This is Info file libc.info, produced by Makeinfo version 1.68 from the
input file libc.texinfo.

INFO-DIR-SECTION GNU libraries
START-INFO-DIR-ENTRY
* Libc: (libc).                 C library.
END-INFO-DIR-ENTRY

   This file documents the GNU C library.

   This is Edition 0.08 DRAFT, last updated 11 Jan 1999, of `The GNU C
Library Reference Manual', for Version 2.1 Beta.

   Copyright (C) 1993, '94, '95, '96, '97, '98, '99 Free Software
Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU Library General Public License" is
included exactly as in the original, and provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the text of the translation of the section
entitled "GNU Library General Public License" must be approved for
accuracy by the Foundation.


File: libc.info,  Node: Receiving Datagrams,  Next: Datagram Example,  Prev: Sending Datagrams,  Up: Datagrams

Receiving Datagrams
-------------------

   The `recvfrom' function reads a packet from a datagram socket and
also tells you where it was sent from.  This function is declared in
`sys/socket.h'.

 - Function: int recvfrom (int SOCKET, void *BUFFER, size_t SIZE, int
          FLAGS, struct sockaddr *ADDR, socklen_t *LENGTH-PTR)
     The `recvfrom' function reads one packet from the socket SOCKET
     into the buffer BUFFER.  The SIZE argument specifies the maximum
     number of bytes to be read.

     If the packet is longer than SIZE bytes, then you get the first
     SIZE bytes of the packet, and the rest of the packet is lost.
     There's no way to read the rest of the packet.  Thus, when you use
     a packet protocol, you must always know how long a packet to
     expect.

     The ADDR and LENGTH-PTR arguments are used to return the address
     where the packet came from.  *Note Socket Addresses::.  For a
     socket in the local domain, the address information won't be
     meaningful, since you can't read the address of such a socket
     (*note Local Namespace::.).  You can specify a null pointer as the
     ADDR argument if you are not interested in this information.

     The FLAGS are interpreted the same way as for `recv' (*note Socket
     Data Options::.).  The return value and error conditions are also
     the same as for `recv'.

     This function is defined as a cancelation point in multi-threaded
     programs.  So one has to be prepared for this and make sure that
     possibly allocated resources (like memory, files descriptors,
     semaphores or whatever) are freed even if the thread is canceled.

   You can use plain `recv' (*note Receiving Data::.) instead of
`recvfrom' if you know don't need to find out who sent the packet
(either because you know where it should come from or because you treat
all possible senders alike).  Even `read' can be used if you don't want
to specify FLAGS (*note I/O Primitives::.).


File: libc.info,  Node: Datagram Example,  Next: Example Receiver,  Prev: Receiving Datagrams,  Up: Datagrams

Datagram Socket Example
-----------------------

   Here is a set of example programs that send messages over a datagram
stream in the local namespace.  Both the client and server programs use
the `make_named_socket' function that was presented in *Note Local
Socket Example::, to create and name their sockets.

   First, here is the server program.  It sits in a loop waiting for
messages to arrive, bouncing each message back to the sender.
Obviously, this isn't a particularly useful program, but it does show
the general ideas involved.

     #include <stdio.h>
     #include <errno.h>
     #include <stdlib.h>
     #include <sys/socket.h>
     #include <sys/un.h>
     
     #define SERVER  "/tmp/serversocket"
     #define MAXMSG  512
     
     int
     main (void)
     {
       int sock;
       char message[MAXMSG];
       struct sockaddr_un name;
       size_t size;
       int nbytes;
     
       /* Remove the filename first, it's ok if the call fails */
       unlink (SERVER);
     
       /* Make the socket, then loop endlessly. */
       sock = make_named_socket (SERVER);
       while (1)
         {
           /* Wait for a datagram. */
           size = sizeof (name);
           nbytes = recvfrom (sock, message, MAXMSG, 0,
                              (struct sockaddr *) & name, &size);
           if (nbytes < 0)
             {
               perror ("recfrom (server)");
               exit (EXIT_FAILURE);
             }
     
           /* Give a diagnostic message. */
           fprintf (stderr, "Server: got message: %s\n", message);
     
           /* Bounce the message back to the sender. */
           nbytes = sendto (sock, message, nbytes, 0,
                            (struct sockaddr *) & name, size);
           if (nbytes < 0)
             {
               perror ("sendto (server)");
               exit (EXIT_FAILURE);
             }
         }
     }


File: libc.info,  Node: Example Receiver,  Prev: Datagram Example,  Up: Datagrams

Example of Reading Datagrams
----------------------------

   Here is the client program corresponding to the server above.

   It sends a datagram to the server and then waits for a reply.  Notice
that the socket for the client (as well as for the server) in this
example has to be given a name.  This is so that the server can direct
a message back to the client.  Since the socket has no associated
connection state, the only way the server can do this is by referencing
the name of the client.

     #include <stdio.h>
     #include <errno.h>
     #include <unistd.h>
     #include <stdlib.h>
     #include <sys/socket.h>
     #include <sys/un.h>
     
     #define SERVER  "/tmp/serversocket"
     #define CLIENT  "/tmp/mysocket"
     #define MAXMSG  512
     #define MESSAGE "Yow!!! Are we having fun yet?!?"
     
     int
     main (void)
     {
       extern int make_named_socket (const char *name);
       int sock;
       char message[MAXMSG];
       struct sockaddr_un name;
       size_t size;
       int nbytes;
     
       /* Make the socket. */
       sock = make_named_socket (CLIENT);
     
       /* Initialize the server socket address. */
       name.sun_family = AF_LOCAL;
       strcpy (name.sun_path, SERVER);
       size = strlen (name.sun_path) + sizeof (name.sun_family);
     
       /* Send the datagram. */
       nbytes = sendto (sock, MESSAGE, strlen (MESSAGE) + 1, 0,
                        (struct sockaddr *) & name, size);
       if (nbytes < 0)
         {
           perror ("sendto (client)");
           exit (EXIT_FAILURE);
         }
     
       /* Wait for a reply. */
       nbytes = recvfrom (sock, message, MAXMSG, 0, NULL, 0);
       if (nbytes < 0)
         {
           perror ("recfrom (client)");
           exit (EXIT_FAILURE);
         }
     
       /* Print a diagnostic message. */
       fprintf (stderr, "Client: got message: %s\n", message);
     
       /* Clean up. */
       remove (CLIENT);
       close (sock);
     }

   Keep in mind that datagram socket communications are unreliable.  In
this example, the client program waits indefinitely if the message
never reaches the server or if the server's response never comes back.
It's up to the user running the program to kill it and restart it, if
desired.  A more automatic solution could be to use `select' (*note
Waiting for I/O::.) to establish a timeout period for the reply, and in
case of timeout either resend the message or shut down the socket and
exit.


File: libc.info,  Node: Inetd,  Next: Socket Options,  Prev: Datagrams,  Up: Sockets

The `inetd' Daemon
==================

   We've explained above how to write a server program that does its own
listening.  Such a server must already be running in order for anyone
to connect to it.

   Another way to provide service for an Internet port is to let the
daemon program `inetd' do the listening.  `inetd' is a program that
runs all the time and waits (using `select') for messages on a
specified set of ports.  When it receives a message, it accepts the
connection (if the socket style calls for connections) and then forks a
child process to run the corresponding server program.  You specify the
ports and their programs in the file `/etc/inetd.conf'.

* Menu:

* Inetd Servers::
* Configuring Inetd::


File: libc.info,  Node: Inetd Servers,  Next: Configuring Inetd,  Up: Inetd

`inetd' Servers
---------------

   Writing a server program to be run by `inetd' is very simple.  Each
time someone requests a connection to the appropriate port, a new server
process starts.  The connection already exists at this time; the socket
is available as the standard input descriptor and as the standard
output descriptor (descriptors 0 and 1) in the server process.  So the
server program can begin reading and writing data right away.  Often
the program needs only the ordinary I/O facilities; in fact, a
general-purpose filter program that knows nothing about sockets can
work as a byte stream server run by `inetd'.

   You can also use `inetd' for servers that use connectionless
communication styles.  For these servers, `inetd' does not try to accept
a connection, since no connection is possible.  It just starts the
server program, which can read the incoming datagram packet from
descriptor 0.  The server program can handle one request and then exit,
or you can choose to write it to keep reading more requests until no
more arrive, and then exit.  You must specify which of these two
techniques the server uses, when you configure `inetd'.


File: libc.info,  Node: Configuring Inetd,  Prev: Inetd Servers,  Up: Inetd

Configuring `inetd'
-------------------

   The file `/etc/inetd.conf' tells `inetd' which ports to listen to
and what server programs to run for them.  Normally each entry in the
file is one line, but you can split it onto multiple lines provided all
but the first line of the entry start with whitespace.  Lines that
start with `#' are comments.

   Here are two standard entries in `/etc/inetd.conf':

     ftp	stream	tcp	nowait	root	/libexec/ftpd	ftpd
     talk	dgram	udp	wait	root	/libexec/talkd	talkd

   An entry has this format:

     SERVICE STYLE PROTOCOL WAIT USERNAME PROGRAM ARGUMENTS

   The SERVICE field says which service this program provides.  It
should be the name of a service defined in `/etc/services'.  `inetd'
uses SERVICE to decide which port to listen on for this entry.

   The fields STYLE and PROTOCOL specify the communication style and
the protocol to use for the listening socket.  The style should be the
name of a communication style, converted to lower case and with `SOCK_'
deleted--for example, `stream' or `dgram'.  PROTOCOL should be one of
the protocols listed in `/etc/protocols'.  The typical protocol names
are `tcp' for byte stream connections and `udp' for unreliable
datagrams.

   The WAIT field should be either `wait' or `nowait'.  Use `wait' if
STYLE is a connectionless style and the server, once started, handles
multiple requests, as many as come in.  Use `nowait' if `inetd' should
start a new process for each message or request that comes in.  If
STYLE uses connections, then WAIT *must* be `nowait'.

   USER is the user name that the server should run as.  `inetd' runs
as root, so it can set the user ID of its children arbitrarily.  It's
best to avoid using `root' for USER if you can; but some servers, such
as Telnet and FTP, read a username and password themselves.  These
servers need to be root initially so they can log in as commanded by
the data coming over the network.

   PROGRAM together with ARGUMENTS specifies the command to run to
start the server.  PROGRAM should be an absolute file name specifying
the executable file to run.  ARGUMENTS consists of any number of
whitespace-separated words, which become the command-line arguments of
PROGRAM.  The first word in ARGUMENTS is argument zero, which should by
convention be the program name itself (sans directories).

   If you edit `/etc/inetd.conf', you can tell `inetd' to reread the
file and obey its new contents by sending the `inetd' process the
`SIGHUP' signal.  You'll have to use `ps' to determine the process ID
of the `inetd' process, as it is not fixed.


File: libc.info,  Node: Socket Options,  Next: Networks Database,  Prev: Inetd,  Up: Sockets

Socket Options
==============

   This section describes how to read or set various options that modify
the behavior of sockets and their underlying communications protocols.

   When you are manipulating a socket option, you must specify which
"level" the option pertains to.  This describes whether the option
applies to the socket interface, or to a lower-level communications
protocol interface.

* Menu:

* Socket Option Functions::     The basic functions for setting and getting
                                 socket options.
* Socket-Level Options::        Details of the options at the socket level.


File: libc.info,  Node: Socket Option Functions,  Next: Socket-Level Options,  Up: Socket Options

Socket Option Functions
-----------------------

   Here are the functions for examining and modifying socket options.
They are declared in `sys/socket.h'.

 - Function: int getsockopt (int SOCKET, int LEVEL, int OPTNAME, void
          *OPTVAL, socklen_t *OPTLEN-PTR)
     The `getsockopt' function gets information about the value of
     option OPTNAME at level LEVEL for socket SOCKET.

     The option value is stored in a buffer that OPTVAL points to.
     Before the call, you should supply in `*OPTLEN-PTR' the size of
     this buffer; on return, it contains the number of bytes of
     information actually stored in the buffer.

     Most options interpret the OPTVAL buffer as a single `int' value.

     The actual return value of `getsockopt' is `0' on success and `-1'
     on failure.  The following `errno' error conditions are defined:

    `EBADF'
          The SOCKET argument is not a valid file descriptor.

    `ENOTSOCK'
          The descriptor SOCKET is not a socket.

    `ENOPROTOOPT'
          The OPTNAME doesn't make sense for the given LEVEL.

 - Function: int setsockopt (int SOCKET, int LEVEL, int OPTNAME, void
          *OPTVAL, socklen_t OPTLEN)
     This function is used to set the socket option OPTNAME at level
     LEVEL for socket SOCKET.  The value of the option is passed in the
     buffer OPTVAL, which has size OPTLEN.

     The return value and error codes for `setsockopt' are the same as
     for `getsockopt'.



File: libc.info,  Node: Socket-Level Options,  Prev: Socket Option Functions,  Up: Socket Options

Socket-Level Options
--------------------

 - Constant: int SOL_SOCKET
     Use this constant as the LEVEL argument to `getsockopt' or
     `setsockopt' to manipulate the socket-level options described in
     this section.

Here is a table of socket-level option names; all are defined in the
header file `sys/socket.h'.

`SO_DEBUG'
     This option toggles recording of debugging information in the
     underlying protocol modules.  The value has type `int'; a nonzero
     value means "yes".

`SO_REUSEADDR'
     This option controls whether `bind' (*note Setting Address::.)
     should permit reuse of local addresses for this socket.  If you
     enable this option, you can actually have two sockets with the
     same Internet port number; but the system won't allow you to use
     the two identically-named sockets in a way that would confuse the
     Internet.  The reason for this option is that some higher-level
     Internet protocols, including FTP, require you to keep reusing the
     same port number.

     The value has type `int'; a nonzero value means "yes".

`SO_KEEPALIVE'
     This option controls whether the underlying protocol should
     periodically transmit messages on a connected socket.  If the peer
     fails to respond to these messages, the connection is considered
     broken.  The value has type `int'; a nonzero value means "yes".

`SO_DONTROUTE'
     This option controls whether outgoing messages bypass the normal
     message routing facilities.  If set, messages are sent directly to
     the network interface instead.  The value has type `int'; a nonzero
     value means "yes".

`SO_LINGER'
     This option specifies what should happen when the socket of a type
     that promises reliable delivery still has untransmitted messages
     when it is closed; see *Note Closing a Socket::.  The value has
     type `struct linger'.

      - Data Type: struct linger
          This structure type has the following members:

         `int l_onoff'
               This field is interpreted as a boolean.  If nonzero,
               `close' blocks until the data is transmitted or the
               timeout period has expired.

         `int l_linger'
               This specifies the timeout period, in seconds.

`SO_BROADCAST'
     This option controls whether datagrams may be broadcast from the
     socket.  The value has type `int'; a nonzero value means "yes".

`SO_OOBINLINE'
     If this option is set, out-of-band data received on the socket is
     placed in the normal input queue.  This permits it to be read using
     `read' or `recv' without specifying the `MSG_OOB' flag.  *Note
     Out-of-Band Data::.  The value has type `int'; a nonzero value
     means "yes".

`SO_SNDBUF'
     This option gets or sets the size of the output buffer.  The value
     is a `size_t', which is the size in bytes.

`SO_RCVBUF'
     This option gets or sets the size of the input buffer.  The value
     is a `size_t', which is the size in bytes.

`SO_STYLE'
`SO_TYPE'
     This option can be used with `getsockopt' only.  It is used to get
     the socket's communication style.  `SO_TYPE' is the historical
     name, and `SO_STYLE' is the preferred name in GNU.  The value has
     type `int' and its value designates a communication style; see
     *Note Communication Styles::.

`SO_ERROR'
     This option can be used with `getsockopt' only.  It is used to
     reset the error status of the socket.  The value is an `int',
     which represents the previous error status.


File: libc.info,  Node: Networks Database,  Prev: Socket Options,  Up: Sockets

Networks Database
=================

   Many systems come with a database that records a list of networks
known to the system developer.  This is usually kept either in the file
`/etc/networks' or in an equivalent from a name server.  This data base
is useful for routing programs such as `route', but it is not useful
for programs that simply communicate over the network.  We provide
functions to access this data base, which are declared in `netdb.h'.

 - Data Type: struct netent
     This data type is used to represent information about entries in
     the networks database.  It has the following members:

    `char *n_name'
          This is the "official" name of the network.

    `char **n_aliases'
          These are alternative names for the network, represented as a
          vector of strings.  A null pointer terminates the array.

    `int n_addrtype'
          This is the type of the network number; this is always equal
          to `AF_INET' for Internet networks.

    `unsigned long int n_net'
          This is the network number.  Network numbers are returned in
          host byte order; see *Note Byte Order::.

   Use the `getnetbyname' or `getnetbyaddr' functions to search the
networks database for information about a specific network.  The
information is returned in a statically-allocated structure; you must
copy the information if you need to save it.

 - Function: struct netent * getnetbyname (const char *NAME)
     The `getnetbyname' function returns information about the network
     named NAME.  It returns a null pointer if there is no such network.

 - Function: struct netent * getnetbyaddr (unsigned long int NET, int
          TYPE)
     The `getnetbyaddr' function returns information about the network
     of type TYPE with number NET.  You should specify a value of
     `AF_INET' for the TYPE argument for Internet networks.

     `getnetbyaddr' returns a null pointer if there is no such network.

   You can also scan the networks database using `setnetent',
`getnetent', and `endnetent'.  Be careful in using these functions,
because they are not reentrant.

 - Function: void setnetent (int STAYOPEN)
     This function opens and rewinds the networks database.

     If the STAYOPEN argument is nonzero, this sets a flag so that
     subsequent calls to `getnetbyname' or `getnetbyaddr' will not
     close the database (as they usually would).  This makes for more
     efficiency if you call those functions several times, by avoiding
     reopening the database for each call.

 - Function: struct netent * getnetent (void)
     This function returns the next entry in the networks database.  It
     returns a null pointer if there are no more entries.

 - Function: void endnetent (void)
     This function closes the networks database.


File: libc.info,  Node: Low-Level Terminal Interface,  Next: Mathematics,  Prev: Sockets,  Up: Top

Low-Level Terminal Interface
****************************

   This chapter describes functions that are specific to terminal
devices.  You can use these functions to do things like turn off input
echoing; set serial line characteristics such as line speed and flow
control; and change which characters are used for end-of-file,
command-line editing, sending signals, and similar control functions.

   Most of the functions in this chapter operate on file descriptors.
*Note Low-Level I/O::, for more information about what a file
descriptor is and how to open a file descriptor for a terminal device.

* Menu:

* Is It a Terminal::            How to determine if a file is a terminal
			         device, and what its name is.
* I/O Queues::                  About flow control and typeahead.
* Canonical or Not::            Two basic styles of input processing.
* Terminal Modes::              How to examine and modify flags controlling
			         details of terminal I/O: echoing,
                                 signals, editing.
* Line Control::                Sending break sequences, clearing
                                 terminal buffers ...
* Noncanon Example::            How to read single characters without echo.
* Pseudo-Terminals::            How to open a pseudo-terminal.


File: libc.info,  Node: Is It a Terminal,  Next: I/O Queues,  Up: Low-Level Terminal Interface

Identifying Terminals
=====================

   The functions described in this chapter only work on files that
correspond to terminal devices.  You can find out whether a file
descriptor is associated with a terminal by using the `isatty' function.

   Prototypes for the functions in this section are declared in the
header file `unistd.h'.

 - Function: int isatty (int FILEDES)
     This function returns `1' if FILEDES is a file descriptor
     associated with an open terminal device, and 0 otherwise.

   If a file descriptor is associated with a terminal, you can get its
associated file name using the `ttyname' function.  See also the
`ctermid' function, described in *Note Identifying the Terminal::.

 - Function: char * ttyname (int FILEDES)
     If the file descriptor FILEDES is associated with a terminal
     device, the `ttyname' function returns a pointer to a
     statically-allocated, null-terminated string containing the file
     name of the terminal file.  The value is a null pointer if the
     file descriptor isn't associated with a terminal, or the file name
     cannot be determined.

 - Function: int ttyname_r (int FILEDES, char *BUF, size_t LEN)
     The `ttyname_r' function is similar to the `ttyname' function
     except that it places its result into the user-specified buffer
     starting at BUF with length LEN.

     The normal return value from `ttyname_r' is 0.  Otherwise an error
     number is returned to indicate the error.  The following `errno'
     error conditions are defined for this function:

    `EBADF'
          The FILEDES argument is not a valid file descriptor.

    `ENOTTY'
          The FILEDES is not associated with a terminal.

    `ERANGE'
          The buffer length LEN is too small to store the string to be
          returned.


File: libc.info,  Node: I/O Queues,  Next: Canonical or Not,  Prev: Is It a Terminal,  Up: Low-Level Terminal Interface

I/O Queues
==========

   Many of the remaining functions in this section refer to the input
and output queues of a terminal device.  These queues implement a form
of buffering *within the kernel* independent of the buffering
implemented by I/O streams (*note I/O on Streams::.).

   The "terminal input queue" is also sometimes referred to as its
"typeahead buffer".  It holds the characters that have been received
from the terminal but not yet read by any process.

   The size of the input queue is described by the `MAX_INPUT' and
`_POSIX_MAX_INPUT' parameters; see *Note Limits for Files::.  You are
guaranteed a queue size of at least `MAX_INPUT', but the queue might be
larger, and might even dynamically change size.  If input flow control
is enabled by setting the `IXOFF' input mode bit (*note Input
Modes::.), the terminal driver transmits STOP and START characters to
the terminal when necessary to prevent the queue from overflowing.
Otherwise, input may be lost if it comes in too fast from the terminal.
In canonical mode, all input stays in the queue until a newline
character is received, so the terminal input queue can fill up when you
type a very long line.  *Note Canonical or Not::.

   The "terminal output queue" is like the input queue, but for output;
it contains characters that have been written by processes, but not yet
transmitted to the terminal.  If output flow control is enabled by
setting the `IXON' input mode bit (*note Input Modes::.), the terminal
driver obeys START and STOP characters sent by the terminal to stop and
restart transmission of output.

   "Clearing" the terminal input queue means discarding any characters
that have been received but not yet read.  Similarly, clearing the
terminal output queue means discarding any characters that have been
written but not yet transmitted.


File: libc.info,  Node: Canonical or Not,  Next: Terminal Modes,  Prev: I/O Queues,  Up: Low-Level Terminal Interface

Two Styles of Input: Canonical or Not
=====================================

   POSIX systems support two basic modes of input: canonical and
noncanonical.

   In "canonical input processing" mode, terminal input is processed in
lines terminated by newline (`'\n''), EOF, or EOL characters.  No input
can be read until an entire line has been typed by the user, and the
`read' function (*note I/O Primitives::.) returns at most a single line
of input, no matter how many bytes are requested.

   In canonical input mode, the operating system provides input editing
facilities: some characters are interpreted specially to perform editing
operations within the current line of text, such as ERASE and KILL.
*Note Editing Characters::.

   The constants `_POSIX_MAX_CANON' and `MAX_CANON' parameterize the
maximum number of bytes which may appear in a single line of canonical
input.  *Note Limits for Files::.  You are guaranteed a maximum line
length of at least `MAX_CANON' bytes, but the maximum might be larger,
and might even dynamically change size.

   In "noncanonical input processing" mode, characters are not grouped
into lines, and ERASE and KILL processing is not performed.  The
granularity with which bytes are read in noncanonical input mode is
controlled by the MIN and TIME settings.  *Note Noncanonical Input::.

   Most programs use canonical input mode, because this gives the user a
way to edit input line by line.  The usual reason to use noncanonical
mode is when the program accepts single-character commands or provides
its own editing facilities.

   The choice of canonical or noncanonical input is controlled by the
`ICANON' flag in the `c_lflag' member of `struct termios'.  *Note Local
Modes::.


File: libc.info,  Node: Terminal Modes,  Next: Line Control,  Prev: Canonical or Not,  Up: Low-Level Terminal Interface

Terminal Modes
==============

   This section describes the various terminal attributes that control
how input and output are done.  The functions, data structures, and
symbolic constants are all declared in the header file `termios.h'.

* Menu:

* Mode Data Types::             The data type `struct termios' and
                                 related types.
* Mode Functions::              Functions to read and set the terminal
                                 attributes.
* Setting Modes::               The right way to set terminal attributes
                                 reliably.
* Input Modes::                 Flags controlling low-level input handling.
* Output Modes::                Flags controlling low-level output handling.
* Control Modes::               Flags controlling serial port behavior.
* Local Modes::                 Flags controlling high-level input handling.
* Line Speed::                  How to read and set the terminal line speed.
* Special Characters::          Characters that have special effects,
			         and how to change them.
* Noncanonical Input::          Controlling how long to wait for input.


File: libc.info,  Node: Mode Data Types,  Next: Mode Functions,  Up: Terminal Modes

Terminal Mode Data Types
------------------------

   The entire collection of attributes of a terminal is stored in a
structure of type `struct termios'.  This structure is used with the
functions `tcgetattr' and `tcsetattr' to read and set the attributes.

 - Data Type: struct termios
     Structure that records all the I/O attributes of a terminal.  The
     structure includes at least the following members:

    `tcflag_t c_iflag'
          A bit mask specifying flags for input modes; see *Note Input
          Modes::.

    `tcflag_t c_oflag'
          A bit mask specifying flags for output modes; see *Note
          Output Modes::.

    `tcflag_t c_cflag'
          A bit mask specifying flags for control modes; see *Note
          Control Modes::.

    `tcflag_t c_lflag'
          A bit mask specifying flags for local modes; see *Note Local
          Modes::.

    `cc_t c_cc[NCCS]'
          An array specifying which characters are associated with
          various control functions; see *Note Special Characters::.

     The `struct termios' structure also contains members which encode
     input and output transmission speeds, but the representation is
     not specified.  *Note Line Speed::, for how to examine and store
     the speed values.

   The following sections describe the details of the members of the
`struct termios' structure.

 - Data Type: tcflag_t
     This is an unsigned integer type used to represent the various bit
     masks for terminal flags.

 - Data Type: cc_t
     This is an unsigned integer type used to represent characters
     associated with various terminal control functions.

 - Macro: int NCCS
     The value of this macro is the number of elements in the `c_cc'
     array.


File: libc.info,  Node: Mode Functions,  Next: Setting Modes,  Prev: Mode Data Types,  Up: Terminal Modes

Terminal Mode Functions
-----------------------

 - Function: int tcgetattr (int FILEDES, struct termios *TERMIOS-P)
     This function is used to examine the attributes of the terminal
     device with file descriptor FILEDES.  The attributes are returned
     in the structure that TERMIOS-P points to.

     If successful, `tcgetattr' returns 0.  A return value of -1
     indicates an error.  The following `errno' error conditions are
     defined for this function:

    `EBADF'
          The FILEDES argument is not a valid file descriptor.

    `ENOTTY'
          The FILEDES is not associated with a terminal.

 - Function: int tcsetattr (int FILEDES, int WHEN, const struct termios
          *TERMIOS-P)
     This function sets the attributes of the terminal device with file
     descriptor FILEDES.  The new attributes are taken from the
     structure that TERMIOS-P points to.

     The WHEN argument specifies how to deal with input and output
     already queued.  It can be one of the following values:

    `TCSANOW'
          Make the change immediately.

    `TCSADRAIN'
          Make the change after waiting until all queued output has
          been written.  You should usually use this option when
          changing parameters that affect output.

    `TCSAFLUSH'
          This is like `TCSADRAIN', but also discards any queued input.

    `TCSASOFT'
          This is a flag bit that you can add to any of the above
          alternatives.  Its meaning is to inhibit alteration of the
          state of the terminal hardware.  It is a BSD extension; it is
          only supported on BSD systems and the GNU system.

          Using `TCSASOFT' is exactly the same as setting the `CIGNORE'
          bit in the `c_cflag' member of the structure TERMIOS-P points
          to.  *Note Control Modes::, for a description of `CIGNORE'.

     If this function is called from a background process on its
     controlling terminal, normally all processes in the process group
     are sent a `SIGTTOU' signal, in the same way as if the process
     were trying to write to the terminal.  The exception is if the
     calling process itself is ignoring or blocking `SIGTTOU' signals,
     in which case the operation is performed and no signal is sent.
     *Note Job Control::.

     If successful, `tcsetattr' returns 0.  A return value of -1
     indicates an error.  The following `errno' error conditions are
     defined for this function:

    `EBADF'
          The FILEDES argument is not a valid file descriptor.

    `ENOTTY'
          The FILEDES is not associated with a terminal.

    `EINVAL'
          Either the value of the `when' argument is not valid, or
          there is something wrong with the data in the TERMIOS-P
          argument.

   Although `tcgetattr' and `tcsetattr' specify the terminal device
with a file descriptor, the attributes are those of the terminal device
itself and not of the file descriptor.  This means that the effects of
changing terminal attributes are persistent; if another process opens
the terminal file later on, it will see the changed attributes even
though it doesn't have anything to do with the open file descriptor you
originally specified in changing the attributes.

   Similarly, if a single process has multiple or duplicated file
descriptors for the same terminal device, changing the terminal
attributes affects input and output to all of these file descriptors.
This means, for example, that you can't open one file descriptor or
stream to read from a terminal in the normal line-buffered, echoed
mode; and simultaneously have another file descriptor for the same
terminal that you use to read from it in single-character, non-echoed
mode.  Instead, you have to explicitly switch the terminal back and
forth between the two modes.


File: libc.info,  Node: Setting Modes,  Next: Input Modes,  Prev: Mode Functions,  Up: Terminal Modes

Setting Terminal Modes Properly
-------------------------------

   When you set terminal modes, you should call `tcgetattr' first to
get the current modes of the particular terminal device, modify only
those modes that you are really interested in, and store the result with
`tcsetattr'.

   It's a bad idea to simply initialize a `struct termios' structure to
a chosen set of attributes and pass it directly to `tcsetattr'.  Your
program may be run years from now, on systems that support members not
documented in this manual.  The way to avoid setting these members to
unreasonable values is to avoid changing them.

   What's more, different terminal devices may require different mode
settings in order to function properly.  So you should avoid blindly
copying attributes from one terminal device to another.

   When a member contains a collection of independent flags, as the
`c_iflag', `c_oflag' and `c_cflag' members do, even setting the entire
member is a bad idea, because particular operating systems have their
own flags.  Instead, you should start with the current value of the
member and alter only the flags whose values matter in your program,
leaving any other flags unchanged.

   Here is an example of how to set one flag (`ISTRIP') in the `struct
termios' structure while properly preserving all the other data in the
structure:

     int
     set_istrip (int desc, int value)
     {
       struct termios settings;
       int result;

     result = tcgetattr (desc, &settings);
       if (result < 0)
         {
           perror ("error in tcgetattr");
           return 0;
         }

     settings.c_iflag &= ~ISTRIP;
       if (value)
         settings.c_iflag |= ISTRIP;

     result = tcsetattr (desc, TCSANOW, &settings);
       if (result < 0)
         {
           perror ("error in tcgetattr");
           return;
        }
       return 1;
     }


File: libc.info,  Node: Input Modes,  Next: Output Modes,  Prev: Setting Modes,  Up: Terminal Modes

Input Modes
-----------

   This section describes the terminal attribute flags that control
fairly low-level aspects of input processing: handling of parity errors,
break signals, flow control, and <RET> and <LFD> characters.

   All of these flags are bits in the `c_iflag' member of the `struct
termios' structure.  The member is an integer, and you change flags
using the operators `&', `|' and `^'.  Don't try to specify the entire
value for `c_iflag'--instead, change only specific flags and leave the
rest untouched (*note Setting Modes::.).

 - Macro: tcflag_t INPCK
     If this bit is set, input parity checking is enabled.  If it is
     not set, no checking at all is done for parity errors on input; the
     characters are simply passed through to the application.

     Parity checking on input processing is independent of whether
     parity detection and generation on the underlying terminal
     hardware is enabled; see *Note Control Modes::.  For example, you
     could clear the `INPCK' input mode flag and set the `PARENB'
     control mode flag to ignore parity errors on input, but still
     generate parity on output.

     If this bit is set, what happens when a parity error is detected
     depends on whether the `IGNPAR' or `PARMRK' bits are set.  If
     neither of these bits are set, a byte with a parity error is
     passed to the application as a `'\0'' character.

 - Macro: tcflag_t IGNPAR
     If this bit is set, any byte with a framing or parity error is
     ignored.  This is only useful if `INPCK' is also set.

 - Macro: tcflag_t PARMRK
     If this bit is set, input bytes with parity or framing errors are
     marked when passed to the program.  This bit is meaningful only
     when `INPCK' is set and `IGNPAR' is not set.

     The way erroneous bytes are marked is with two preceding bytes,
     `377' and `0'.  Thus, the program actually reads three bytes for
     one erroneous byte received from the terminal.

     If a valid byte has the value `0377', and `ISTRIP' (see below) is
     not set, the program might confuse it with the prefix that marks a
     parity error.  So a valid byte `0377' is passed to the program as
     two bytes, `0377' `0377', in this case.

 - Macro: tcflag_t ISTRIP
     If this bit is set, valid input bytes are stripped to seven bits;
     otherwise, all eight bits are available for programs to read.

 - Macro: tcflag_t IGNBRK
     If this bit is set, break conditions are ignored.

     A "break condition" is defined in the context of asynchronous
     serial data transmission as a series of zero-value bits longer
     than a single byte.

 - Macro: tcflag_t BRKINT
     If this bit is set and `IGNBRK' is not set, a break condition
     clears the terminal input and output queues and raises a `SIGINT'
     signal for the foreground process group associated with the
     terminal.

     If neither `BRKINT' nor `IGNBRK' are set, a break condition is
     passed to the application as a single `'\0'' character if `PARMRK'
     is not set, or otherwise as a three-character sequence `'\377'',
     `'\0'', `'\0''.

 - Macro: tcflag_t IGNCR
     If this bit is set, carriage return characters (`'\r'') are
     discarded on input.  Discarding carriage return may be useful on
     terminals that send both carriage return and linefeed when you
     type the <RET> key.

 - Macro: tcflag_t ICRNL
     If this bit is set and `IGNCR' is not set, carriage return
     characters (`'\r'') received as input are passed to the
     application as newline characters (`'\n'').

 - Macro: tcflag_t INLCR
     If this bit is set, newline characters (`'\n'') received as input
     are passed to the application as carriage return characters
     (`'\r'').

 - Macro: tcflag_t IXOFF
     If this bit is set, start/stop control on input is enabled.  In
     other words, the computer sends STOP and START characters as
     necessary to prevent input from coming in faster than programs are
     reading it.  The idea is that the actual terminal hardware that is
     generating the input data responds to a STOP character by
     suspending transmission, and to a START character by resuming
     transmission.  *Note Start/Stop Characters::.

 - Macro: tcflag_t IXON
     If this bit is set, start/stop control on output is enabled.  In
     other words, if the computer receives a STOP character, it
     suspends output until a START character is received.  In this
     case, the STOP and START characters are never passed to the
     application program.  If this bit is not set, then START and STOP
     can be read as ordinary characters.  *Note Start/Stop Characters::.

 - Macro: tcflag_t IXANY
     If this bit is set, any input character restarts output when
     output has been suspended with the STOP character.  Otherwise,
     only the START character restarts output.

     This is a BSD extension; it exists only on BSD systems and the GNU
     system.

 - Macro: tcflag_t IMAXBEL
     If this bit is set, then filling up the terminal input buffer
     sends a BEL character (code `007') to the terminal to ring the
     bell.

     This is a BSD extension.


File: libc.info,  Node: Output Modes,  Next: Control Modes,  Prev: Input Modes,  Up: Terminal Modes

Output Modes
------------

   This section describes the terminal flags and fields that control how
output characters are translated and padded for display.  All of these
are contained in the `c_oflag' member of the `struct termios' structure.

   The `c_oflag' member itself is an integer, and you change the flags
and fields using the operators `&', `|', and `^'.  Don't try to specify
the entire value for `c_oflag'--instead, change only specific flags and
leave the rest untouched (*note Setting Modes::.).

 - Macro: tcflag_t OPOST
     If this bit is set, output data is processed in some unspecified
     way so that it is displayed appropriately on the terminal device.
     This typically includes mapping newline characters (`'\n'') onto
     carriage return and linefeed pairs.

     If this bit isn't set, the characters are transmitted as-is.

   The following three bits are BSD features, and they exist only BSD
systems and the GNU system.  They are effective only if `OPOST' is set.

 - Macro: tcflag_t ONLCR
     If this bit is set, convert the newline character on output into a
     pair of characters, carriage return followed by linefeed.

 - Macro: tcflag_t OXTABS
     If this bit is set, convert tab characters on output into the
     appropriate number of spaces to emulate a tab stop every eight
     columns.

 - Macro: tcflag_t ONOEOT
     If this bit is set, discard `C-d' characters (code `004') on
     output.  These characters cause many dial-up terminals to
     disconnect.


File: libc.info,  Node: Control Modes,  Next: Local Modes,  Prev: Output Modes,  Up: Terminal Modes

Control Modes
-------------

   This section describes the terminal flags and fields that control
parameters usually associated with asynchronous serial data
transmission.  These flags may not make sense for other kinds of
terminal ports (such as a network connection pseudo-terminal).  All of
these are contained in the `c_cflag' member of the `struct termios'
structure.

   The `c_cflag' member itself is an integer, and you change the flags
and fields using the operators `&', `|', and `^'.  Don't try to specify
the entire value for `c_cflag'--instead, change only specific flags and
leave the rest untouched (*note Setting Modes::.).

 - Macro: tcflag_t CLOCAL
     If this bit is set, it indicates that the terminal is connected
     "locally" and that the modem status lines (such as carrier detect)
     should be ignored.

     On many systems if this bit is not set and you call `open' without
     the `O_NONBLOCK' flag set, `open' blocks until a modem connection
     is established.

     If this bit is not set and a modem disconnect is detected, a
     `SIGHUP' signal is sent to the controlling process group for the
     terminal (if it has one).  Normally, this causes the process to
     exit; see *Note Signal Handling::.  Reading from the terminal
     after a disconnect causes an end-of-file condition, and writing
     causes an `EIO' error to be returned.  The terminal device must be
     closed and reopened to clear the condition.

 - Macro: tcflag_t HUPCL
     If this bit is set, a modem disconnect is generated when all
     processes that have the terminal device open have either closed
     the file or exited.

 - Macro: tcflag_t CREAD
     If this bit is set, input can be read from the terminal.
     Otherwise, input is discarded when it arrives.

 - Macro: tcflag_t CSTOPB
     If this bit is set, two stop bits are used.  Otherwise, only one
     stop bit is used.

 - Macro: tcflag_t PARENB
     If this bit is set, generation and detection of a parity bit are
     enabled.  *Note Input Modes::, for information on how input parity
     errors are handled.

     If this bit is not set, no parity bit is added to output
     characters, and input characters are not checked for correct
     parity.

 - Macro: tcflag_t PARODD
     This bit is only useful if `PARENB' is set.  If `PARODD' is set,
     odd parity is used, otherwise even parity is used.

   The control mode flags also includes a field for the number of bits
per character.  You can use the `CSIZE' macro as a mask to extract the
value, like this: `settings.c_cflag & CSIZE'.

 - Macro: tcflag_t CSIZE
     This is a mask for the number of bits per character.

 - Macro: tcflag_t CS5
     This specifies five bits per byte.

 - Macro: tcflag_t CS6
     This specifies six bits per byte.

 - Macro: tcflag_t CS7
     This specifies seven bits per byte.

 - Macro: tcflag_t CS8
     This specifies eight bits per byte.

   The following four bits are BSD extensions; this exist only on BSD
systems and the GNU system.

 - Macro: tcflag_t CCTS_OFLOW
     If this bit is set, enable flow control of output based on the CTS
     wire (RS232 protocol).

 - Macro: tcflag_t CRTS_IFLOW
     If this bit is set, enable flow control of input based on the RTS
     wire (RS232 protocol).

 - Macro: tcflag_t MDMBUF
     If this bit is set, enable carrier-based flow control of output.

 - Macro: tcflag_t CIGNORE
     If this bit is set, it says to ignore the control modes and line
     speed values entirely.  This is only meaningful in a call to
     `tcsetattr'.

     The `c_cflag' member and the line speed values returned by
     `cfgetispeed' and `cfgetospeed' will be unaffected by the call.
     `CIGNORE' is useful if you want to set all the software modes in
     the other members, but leave the hardware details in `c_cflag'
     unchanged.  (This is how the `TCSASOFT' flag to `tcsettattr'
     works.)

     This bit is never set in the structure filled in by `tcgetattr'.

