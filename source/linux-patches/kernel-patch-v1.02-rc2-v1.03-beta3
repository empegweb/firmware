Index: empeg/kernel/Makefile
diff -u empeg/kernel/Makefile:1.36.2.6 empeg/kernel/Makefile:1.36.2.7
--- empeg/kernel/Makefile:1.36.2.6	Tue Jan  9 18:34:38 2001
+++ empeg/kernel/Makefile	Wed Feb 14 20:23:49 2001
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 2
 SUBLEVEL = 14
-EXTRAVERSION = -rmk5-np17-empeg41
+EXTRAVERSION = -rmk5-np17-empeg42
 
 #ARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ -e s/arm.*/arm/ -e s/sa110/arm/)
 ARCH := arm
Index: empeg/kernel/arch/arm/def-configs/empeg-car2
diff -u empeg/kernel/arch/arm/def-configs/empeg-car2:1.1.2.1 empeg/kernel/arch/arm/def-configs/empeg-car2:1.1.2.2
--- empeg/kernel/arch/arm/def-configs/empeg-car2:1.1.2.1	Tue Oct 31 14:23:53 2000
+++ empeg/kernel/arch/arm/def-configs/empeg-car2	Thu May  3 18:06:37 2001
@@ -119,7 +119,7 @@
 # CONFIG_EMPEG_USB9602 is not set
 CONFIG_EMPEG_USBD12=y
 CONFIG_EMPEG_STATE=y
-# CONFIG_EMPEG_RDS is not set
+CONFIG_EMPEG_RDS=y
 # CONFIG_EMPEG_DAC is not set
 CONFIG_EMPEG_DSP=y
 CONFIG_EMPEG_CS4231=y
Index: empeg/kernel/arch/arm/lib/findbit.S
diff -u empeg/kernel/arch/arm/lib/findbit.S:1.1.1.1 empeg/kernel/arch/arm/lib/findbit.S:1.1.1.1.8.1
--- empeg/kernel/arch/arm/lib/findbit.S:1.1.1.1	Sat Mar 18 15:24:13 2000
+++ empeg/kernel/arch/arm/lib/findbit.S	Thu May  3 11:58:21 2001
@@ -1,65 +1,66 @@
 /*
- * linux/arch/arm/lib/bitops.S
+ *  linux/arch/arm/lib/findbit.S
  *
- * Copyright (C) 1995-1996 Russell King
+ *  Copyright (C) 1995-2000 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * 16th March 2001 - John Ripley <jripley@riohome.com>
+ *   Fixed so that "size" is an exclusive not an inclusive quantity.
+ *   All users of these functions expect exclusive sizes, and may
+ *   also call with zero size.
  */
-
 #include <linux/linkage.h>
 #include <asm/assembler.h>
                 .text
 
-@ Purpose  : Find a 'zero' bit
-@ Prototype: int find_first_zero_bit(char *addr,int maxbit);
-
+/*
+ * Purpose  : Find a 'zero' bit
+ * Prototype: int find_first_zero_bit(void *addr, unsigned size);
+ */
 ENTRY(find_first_zero_bit)
-		mov	r2, #0			@ Initialise bit position
-Lfindzbit1lp:	ldrb	r3, [r0, r2, lsr #3]	@ Check byte, if 0xFF, then all bits set
-		teq	r3, #0xFF
-		bne	Lfoundzbit
-		add	r2, r2, #8
-		cmp	r2, r1			@ Check to see if we have come to the end
-		bcc	Lfindzbit1lp
-		add	r0, r1, #1		@ Make sure that we flag an error
-		RETINSTR(mov,pc,lr)
-Lfoundzbit:	tst	r3, #1			@ Check individual bits
-		moveq	r0, r2
-		RETINSTR(moveq,pc,lr)
-		tst	r3, #2
-		addeq	r0, r2, #1
-		RETINSTR(moveq,pc,lr)
-		tst	r3, #4
-		addeq	r0, r2, #2
-		RETINSTR(moveq,pc,lr)
-		tst	r3, #8
-		addeq	r0, r2, #3
-		RETINSTR(moveq,pc,lr)
-		tst	r3, #16
-		addeq	r0, r2, #4
-		RETINSTR(moveq,pc,lr)
-		tst	r3, #32
-		addeq	r0, r2, #5
-		RETINSTR(moveq,pc,lr)
-		tst	r3, #64
-		addeq	r0, r2, #6
-		RETINSTR(moveq,pc,lr)
-		add	r0, r2, #7
+		cmp	r1, #0			@ Check size != 0
+		moveq	r0, r1
+		RETINSTR(moveq,pc,lr)		@ Return 0 if not met
+		mov	r2, #0
+.bytelp:	ldrb	r3, [r0, r2, lsr #3]
+		eors	r3, r3, #0xff		@ invert bits
+		bne	.found			@ any now set - found zero bit
+		add	r2, r2, #8		@ next bit pointer
+.boundscheck:	cmp	r2, r1			@ any more?
+		blt	.bytelp
+		mov	r0, r1			@ no free bits
 		RETINSTR(mov,pc,lr)
 
-@ Purpose  : Find next 'zero' bit
-@ Prototype: int find_next_zero_bit(char *addr,int maxbit,int offset)
-
+/*
+ * Purpose  : Find next 'zero' bit
+ * Prototype: int find_next_zero_bit(void *addr, unsigned size, unsigned offset)
+ */
 ENTRY(find_next_zero_bit)
-		tst	r2, #7
-		beq	Lfindzbit1lp		@ If new byte, goto old routine
-		ldrb	r3, [r0, r2, lsr#3]
-		orr	r3, r3, #0xFF00		@ Set top bits so we wont get confused
-		stmfd	sp!, {r4}
-		and	r4, r2, #7
-		mov	r3, r3, lsr r4		@ Shift right by no. of bits
-		ldmfd	sp!, {r4}
-		and	r3, r3, #0xFF
-		teq	r3, #0xFF
-		orreq	r2, r2, #7
+		cmp	r2, r1			@ Check offset < size
+		movge	r0, r1
+		RETINSTR(movge,pc,lr)		@ Return size if not met
+		ands	ip, r2, #7
+		beq	.bytelp			@ If new byte, goto old routine
+		ldrb	r3, [r0, r2, lsr #3]
+		eor	r3, r3, #0xff		@ now looking for a 1 bit
+		movs	r3, r3, lsr ip		@ shift off unused bits
+		orreq	r2, r2, #7		@ if zero, then no bits here
+		addeq	r2, r2, #1		@ align bit pointer
+		beq	.boundscheck		@ jump to loop check
+
+/*
+ * One or more bits in the LSB of r3 are assumed to be set.
+ */
+.found:		tst	r3, #0x0f
+		addeq	r2, r2, #4
+		movne	r3, r3, lsl #4
+		tst	r3, #0x30
+		addeq	r2, r2, #2
+		movne	r3, r3, lsl #2
+		tst	r3, #0x40
 		addeq	r2, r2, #1
-		beq	Lfindzbit1lp		@ If all bits are set, goto old routine
-		b	Lfoundzbit
+		mov	r0, r2
+		RETINSTR(mov,pc,lr)
Index: empeg/kernel/arch/arm/mm/mm-sa1100.c
diff -u empeg/kernel/arch/arm/mm/mm-sa1100.c:1.4.8.2 empeg/kernel/arch/arm/mm/mm-sa1100.c:1.4.8.3
--- empeg/kernel/arch/arm/mm/mm-sa1100.c:1.4.8.2	Tue Dec 19 19:41:46 2000
+++ empeg/kernel/arch/arm/mm/mm-sa1100.c	Thu May  3 11:58:43 2001
@@ -156,7 +156,7 @@
 #ifdef CONFIG_SA1100_EMPEG
 void empeg_setup_bank_mapping(int hw_rev)
 {
-	unsigned long *virt_mapping, *phys_mapping;
+	const unsigned long *virt_mapping, *phys_mapping;
 	
 	static const unsigned long virt_to_phys_1bank[4] = {
 		0xc0000000,
Index: empeg/kernel/arch/arm/special/Makefile
diff -u empeg/kernel/arch/arm/special/Makefile:1.18 empeg/kernel/arch/arm/special/Makefile:1.18.8.1
--- empeg/kernel/arch/arm/special/Makefile:1.18	Fri May 19 19:31:00 2000
+++ empeg/kernel/arch/arm/special/Makefile	Thu May  3 11:54:49 2001
@@ -86,7 +86,8 @@
 endif
 
 ifdef CONFIG_EMPEG_DSP
-  L_OBJS	+= empeg_audio2.o
+#  L_OBJS	+= empeg_audio2.o
+L_OBJS		+= empeg_audio3.o empeg_dsp.o empeg_dsp_i2c.o empeg_mixer.o
 endif
 
 ifdef CONFIG_EMPEG_DAC
Index: empeg/kernel/arch/arm/special/empeg_audio3.c
diff -u /dev/null empeg/kernel/arch/arm/special/empeg_audio3.c:1.4.2.1
--- /dev/null	Thu May 31 21:42:26 2001
+++ empeg/kernel/arch/arm/special/empeg_audio3.c	Thu May  3 11:52:33 2001
@@ -0,0 +1,911 @@
+/*
+ * SA1100/empeg Audio Device Driver
+ *
+ * (C) 1999/2000 empeg ltd, http://www.empeg.com
+ *
+ * Authors:
+ *   Hugo Fiennes, <hugo@empeg.com>
+ *
+ *
+ * The empeg audio output device has several 'limitations' due to the hardware
+ * implementation:
+ *
+ * - Always in stereo
+ * - Always at 44.1kHz
+ * - Always 16-bit little-endian signed
+ *
+ * Due to the high data rate these parameters dictate, this driver uses the
+ * onboard SA1100 DMA engine to fill the FIFOs. As this is the first DMA
+ * device on the empeg, we use DMA channel 0 for it - only a single channel
+ * is needed as, although the SSP input is connected, this doesn't synchronise
+ * with what we need and so we ignore the input (currently).
+ *
+ * The maximum DMA fill size is 8192 bytes - however, as each MPEG audio frame
+ * decodes to 4608 bytes, this is what we use as it gives the neatest
+ * profiling (well, I think so ;) ). We also emit the corresponding display
+ * buffer at DMA time, which keeps the display locked to the visuals.
+ *
+ * From device initialisation onwards, we always run the DMA: this is because
+ * if we stall the SSP, we get a break in the I2S WS clock which causes some
+ * DACs (eg, the Crystal 4334) to go into powerdown mode, which gives around a
+ * 1.5s glitch in the audio (even though the I2S glitch was much much smaller).
+ * We keep track of the transitions from "good data" clocking to "zero"
+ * clocking (which performs DMA from the SA's internal 'zero page' and so is
+ * very bus-efficient) so we can tell if the driver has ever been starved of
+ * data from userland. Annoyingly, the SSP doesn't appear to have a "transmit
+ * underrun" flag which will tell you when the transmitter has been starved,
+ * so short of taking timer values when you enable DMA and checking them next
+ * time DMA is fed, we can't programmatically work out if the transmit has
+ * been glitched.
+ *
+ * In theory, to get a glitch is very hard. We have to miss a buffer fill
+ * interrupt for one whole buffer period (assuming that the previous interrupt
+ * arrives one transfer before the current one is about to time-out) - and
+ * this is 2.6ms (or so). It still seems to happen sometimes under heavy
+ * IRQ/transfer load (eg, ping flooding the ethernet interface).
+ *
+ * Wishlist:
+ * 
+ * - We could do with manufacturing a tail packet of data when we transition
+ *   from good data to zero clocking which gives a logarithmic falloff from
+ *   the last good data sample to zero (avoids clicks at the end of tracks).
+ * - Software volume control
+ * - Sample rate adjustment with aliasing filters
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/malloc.h>
+#include <linux/sched.h>
+#include <linux/major.h>
+#include <linux/errno.h>
+#include <linux/tqueue.h>
+#include <linux/interrupt.h>
+#include <linux/timer.h>
+#include <linux/init.h>
+#include <linux/vmalloc.h>
+#include <linux/soundcard.h>
+#include <asm/segment.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/SA-1100.h>
+#include <asm/uaccess.h>
+#include <asm/delay.h>
+
+#ifdef	CONFIG_PROC_FS
+#include <linux/stat.h>
+#include <linux/proc_fs.h>
+#endif
+
+#include "empeg_dsp.h"
+#include "empeg_dsp_i2c.h"
+#include "empeg_audio3.h"
+#include "empeg_mixer.h"
+
+#ifdef CONFIG_EMPEG_DAC
+#error empeg DAC driver cannot be coexist with DSP driver
+#endif
+
+/* options */
+#define OPTION_DEBUGHOOK		0
+
+/* debug */
+#define AUDIO_DEBUG			0
+#define AUDIO_DEBUG_VERBOSE		0
+#define AUDIO_DEBUG_STATS		1 //AUDIO_DEBUG | AUDIO_DEBUG_VERBOSE
+
+/* Names */
+#define AUDIO_NAME			"audio-empeg"
+#define AUDIO_NAME_VERBOSE		"empeg dsp audio"
+
+/* interrupt numbers */
+#define AUDIO_IRQ			IRQ_DMA0 /* DMA channel 0 IRQ */
+
+/* Client parameters */
+#define AUDIO_NOOF_BUFFERS		8	/* Number of audio buffers */
+#define AUDIO_BUFFER_SIZE		4608	/* User buffer chunk size */
+
+/* Number of audio buffers that can be in use at any one time. This is
+   two less since the inactive two are actually still being used by
+   DMA while they look like being free. */
+#define MAX_FREE_BUFFERS		(AUDIO_NOOF_BUFFERS - 2)
+
+/* statistics */
+typedef struct
+{
+	ulong samples;
+	ulong interrupts;
+	ulong wakeups;  
+	ulong fifo_err;
+	ulong buffer_hwm;
+	ulong user_underruns;
+	ulong irq_underruns;
+} audio_stats;
+
+typedef struct
+{
+	/* Buffer */
+	unsigned char data[AUDIO_BUFFER_SIZE];
+	
+	/* Number of bytes in buffer */
+	int  count;
+} audio_buf;
+
+typedef struct
+{
+	/* Buffers */
+	audio_buf *buffers;
+	int used,free,head,tail;
+
+	/* Buffer management */
+	struct wait_queue *waitq;
+
+	/* Statistics */
+	audio_stats stats;
+
+	/* beep timeout */
+	struct timer_list beep_timer;
+
+	/* Are we sending "good" data? */
+	int good_data;
+} audio_dev;
+
+/* cosine tables for beep parameters */
+static unsigned long csin_table_44100[];
+static unsigned long csin_table_38000[];
+static unsigned long *csin_table = csin_table_44100;
+/* setup stuff for the beep coefficients (see end of file) */
+static dsp_setup beep_setup[];
+
+/* Devices in the system; just the one channel at the moment */
+static audio_dev 	audio[1];
+
+static struct proc_dir_entry *proc_audio;
+
+/* Lots of function things */
+int __init empeg_audio_init(void);
+static int empeg_audio_write(struct file *file,
+			     const char *buffer, size_t count, loff_t *ppos);
+static int empeg_audio_purge(audio_dev *dev);
+static int empeg_audio_ioctl(struct inode *inode, struct file *file,
+			     uint command, ulong arg);
+
+static void empeg_audio_beep(audio_dev *dev,
+			     int pitch, int length, int volume);
+static void empeg_audio_beep_end(unsigned long);
+static void empeg_audio_beep_end_sched(void *unused);
+static void empeg_audio_interrupt(int irq, void *dev_id, struct pt_regs *regs);
+static void empeg_audio_emit_action(void *);
+#ifdef	CONFIG_PROC_FS
+static int empeg_audio_read_proc(char *buf, char **start, off_t offset,
+				 int length, int *eof, void *private);
+#endif
+
+static struct tq_struct emit_task =
+{
+	routine:	empeg_audio_emit_action
+};
+
+static struct tq_struct i2c_queue =
+{
+	routine:	empeg_audio_beep_end_sched
+};
+
+static struct file_operations audio_fops =
+{
+	write:		empeg_audio_write,
+	ioctl:		empeg_audio_ioctl,
+	open:		empeg_audio_open,
+};
+
+
+int __init empeg_audio_init(void)
+{
+	int i, err;
+	audio_dev *dev = &audio[0];
+	
+#if AUDIO_DEBUG_VERBOSE
+	printk(AUDIO_NAME ": audio_sa1100_init\n");
+#endif
+
+	/* Blank everything to start with */
+	memset(dev, 0, sizeof(audio_dev));
+	
+	/* Allocate buffers */
+	if ((dev->buffers = kmalloc(sizeof(audio_buf) * AUDIO_NOOF_BUFFERS,
+				    GFP_KERNEL)) == NULL) {
+		/* No memory */
+		printk(AUDIO_NAME ": can't get memory for buffers");
+		return -ENOMEM;
+	}
+
+	/* Clear them */
+	for(i = 0; i < AUDIO_NOOF_BUFFERS; i++)
+		dev->buffers[i].count = 0;
+
+	/* Set up queue: note that two buffers could be DMA'ed any any time,
+	   and so we use two fewer marked as "free" */
+	dev->head = dev->tail = dev->used = 0;
+	dev->free = MAX_FREE_BUFFERS;
+
+	/* Request appropriate interrupt line */
+	if((err = request_irq(AUDIO_IRQ, empeg_audio_interrupt, SA_INTERRUPT,
+			      AUDIO_NAME,NULL)) != 0) {
+		/* fail: unable to acquire interrupt */
+		printk(AUDIO_NAME ": request_irq failed: %d\n", err);
+		return err;
+	}
+
+	/* Setup I2S clock on GAFR */
+	GAFR |= GPIO_GPIO19;
+
+	/* Setup SSP */
+	Ser4SSCR0 = 0x8f; //SSCR0_DataSize(16)|SSCR0_Motorola|SSCR0_SSE;
+	Ser4SSCR1 = 0x30; //SSCR1_ECS|SSCR1_SP;
+	Ser4SSSR = SSSR_ROR; /* ...baby one more time */
+
+	/* Start DMA: Clear bits in DCSR0 */
+	ClrDCSR0 = DCSR_DONEA | DCSR_DONEB | DCSR_IE | DCSR_RUN;
+	
+	/* Initialise DDAR0 for SSP */
+	DDAR0 = 0x81c01be8;
+
+	/* Start both buffers off with zeros */
+	DBSA0 = (unsigned char*) _ZeroMem;
+	DBTA0 = AUDIO_BUFFER_SIZE;
+	DBSB0 = (unsigned char*) _ZeroMem;
+	DBTB0 = AUDIO_BUFFER_SIZE;
+	SetDCSR0 = DCSR_STRTA | DCSR_STRTB | DCSR_IE | DCSR_RUN;
+
+#ifdef	CONFIG_PROC_FS
+	/* Register procfs devices */
+	proc_audio = create_proc_entry("audio", 0, 0);
+	if (proc_audio)
+		proc_audio->read_proc = empeg_audio_read_proc;
+#endif	/* CONFIG_PROC_FS */
+	
+	/* Log device registration */
+	printk(AUDIO_NAME_VERBOSE " initialised\n");
+
+	/* beep timeout */
+	init_timer(&dev->beep_timer);
+	dev->beep_timer.data = 0;
+	dev->beep_timer.function = empeg_audio_beep_end;
+
+	/* Everything OK */
+	return 0;
+}
+
+int empeg_audio_open(struct inode *inode, struct file *file)
+{
+	file->f_op = &audio_fops;
+
+#if AUDIO_DEBUG
+	printk(AUDIO_NAME ": audio_open\n");
+#endif
+
+	/* Make sure old EQ settings apply */
+	empeg_mixer_eq_apply();
+
+        return 0;
+}
+
+static int empeg_audio_write(struct file *file,
+			     const char *buffer, size_t count, loff_t *ppos)
+{
+	audio_dev *dev = &audio[0];
+	int total = 0;
+	int ret;
+	
+#if AUDIO_DEBUG_VERBOSE
+	printk(AUDIO_NAME ": audio_write: count=%d\n", count);
+#endif
+
+	/* Check the user isn't trying to murder us */
+	if((ret = verify_area(VERIFY_READ, buffer, count)) != 0)
+		return ret;
+	
+	/* Count must be a multiple of the buffer size */
+	if (count % AUDIO_BUFFER_SIZE) {
+	        printk("non-4608 byte write (%d)\n", count);
+		return -EINVAL;
+	}
+
+	if (count == 0) {
+		printk("zero byte write\n");
+		return 0;
+	}
+
+	/* Any space left? (No need to disable IRQs: we're just checking for a
+	   full buffer condition) */
+	/* This version doesn't have races, see p209 of Linux Device Drivers */
+	if (dev->free == 0) {
+	    struct wait_queue wait = { current, NULL };
+
+	    add_wait_queue(&dev->waitq, &wait);
+	    current->state = TASK_INTERRUPTIBLE;
+	    while (dev->free == 0) {
+		schedule();
+	    }
+	    current->state = TASK_RUNNING;
+	    remove_wait_queue(&dev->waitq, &wait);
+	}
+
+	/* Fill as many buffers as we can */
+	while(count > 0 && dev->free > 0) {
+		unsigned long flags;
+
+		/* Critical sections kept as short as possible to give good
+		   latency for other tasks */
+		save_flags_cli(flags);
+		dev->free--;
+		restore_flags(flags);
+
+		/* Copy chunk of data from user-space. We're safe updating the
+		   head when not in cli() as this is the only place the head
+		   gets twiddled */
+		copy_from_user(dev->buffers[dev->head++].data, buffer,
+			       AUDIO_BUFFER_SIZE);
+		if (dev->head == AUDIO_NOOF_BUFFERS)
+			dev->head = 0;
+		total += AUDIO_BUFFER_SIZE;
+		/* Oops, we missed this in previous versions */
+		buffer += AUDIO_BUFFER_SIZE;
+		dev->stats.samples += AUDIO_BUFFER_SIZE;
+		count -= AUDIO_BUFFER_SIZE;
+		/* Now the buffer is ready, we can tell the IRQ section
+		   there's new data */
+		save_flags_cli(flags);
+		dev->used++;
+		restore_flags(flags);
+	}
+
+	/* Update hwm */
+	if (dev->used > dev->stats.buffer_hwm)
+		dev->stats.buffer_hwm=dev->used;
+
+	/* We have data (houston) */
+	dev->good_data = 1;
+
+	/* Write complete */
+	return total;
+}
+
+/* Throw away all complete blocks waiting to go out to the DAC and return how
+   many bytes that was. */
+static int empeg_audio_purge(audio_dev *dev)
+{
+	unsigned long flags;
+	int bytes;
+
+	/* We don't want to get interrupted here */
+	save_flags_cli(flags);
+
+	/* Work out how many bytes are left to send to the audio device:
+	   we only worry about full buffers */
+	bytes=dev->used*AUDIO_BUFFER_SIZE;
+
+	/* Empty buffers */
+	dev->head=dev->tail=dev->used=0;
+	dev->free=MAX_FREE_BUFFERS;
+	
+	/* Let it run again */
+	restore_flags(flags);
+
+	return bytes;
+}
+
+static int empeg_audio_ioctl(struct inode *inode, struct file *file,
+			     uint command, ulong arg)
+{
+	audio_dev *dev = &audio[0];
+
+	switch (command) {
+	case EMPEG_DSP_BEEP:
+	{
+		int pitch, length, volume;
+		int *ptr = (int *)arg;
+		get_user_ret(pitch, ptr, -EFAULT);
+		get_user_ret(length, ptr + 1, -EFAULT);
+		get_user_ret(volume, ptr + 2, -EFAULT);
+		empeg_audio_beep(dev, pitch, length, volume);
+		return 0;
+	}
+	
+	case EMPEG_DSP_PURGE:
+	{
+		int bytes = empeg_audio_purge(dev);
+		put_user_ret(bytes, (int *)arg, -EFAULT);
+		return 0;		
+	}
+	}
+	
+	/* invalid command */
+	return -EINVAL;
+}
+
+static void empeg_audio_beep(audio_dev *dev, int pitch, int length, int volume)
+{
+	/* Section 9.8 */
+	unsigned long coeff;
+	int low, high, vat, i;
+	unsigned int beep_start_coeffs[4];
+	
+#if AUDIO_DEBUG
+	/* Anyone really need this debug output? */
+	printk(AUDIO_NAME ": BEEP %d, %d\n", length, pitch);
+#endif
+
+	volume = (volume * 0x7ff) / 100;
+	if (volume < 0) volume = 0;
+	if (volume > 0x7ff) volume = 0x7ff;
+	
+	if ((length == 0) || (volume == 0)) {		/* Turn beep off */
+		/* Remove pending timers, this doesn't handle all cases */
+		if (timer_pending(&dev->beep_timer))
+		    del_timer(&dev->beep_timer);
+		    
+		/* Turn beep off */
+		dsp_write(Y_sinusMode, 0x89a);
+	}
+	else {				/* Turn beep on */
+		if((pitch < 48) || (pitch > 96)) {
+			/* Don't handle any other pitches without extending
+			   the table a bit */
+			return;
+		}
+		pitch -= 48;
+
+		/* find value in table */
+		coeff = csin_table[pitch];
+		/* low/high 11 bit values */
+		low = coeff & 2047;
+		high = coeff >> 11;
+
+		/* write coefficients (steal volume from another table) */
+		vat = 0xfff - empeg_mixer_get_vat();
+
+		/* write volume two at a time, slightly faster */
+		beep_start_coeffs[0] = volume;	/* Y_VLsin */
+		beep_start_coeffs[1] = volume;	/* Y_VRsin */
+		if(i2c_write(IICD_DSP, Y_VLsin, beep_start_coeffs, 2)) {
+		    printk("i2c_write for beep failed\n");
+		}
+
+		/* write pitch for first beep */
+		beep_start_coeffs[0] = low;
+		beep_start_coeffs[1] = high;
+		if(i2c_write(IICD_DSP, Y_IcoefAl, beep_start_coeffs, 2)) {
+		    printk("i2c_write for beep failed\n");
+		}
+		/* write pitch for second beep (unused) */
+		beep_start_coeffs[0] = low;
+		beep_start_coeffs[1] = high;
+		if(i2c_write(IICD_DSP, Y_IcoefBL, beep_start_coeffs, 2)) {
+		    printk("i2c_write for beep failed\n");
+		}
+
+		/* Coefficients for channel beep volume */
+		for(i=0; i<4; i++) beep_start_coeffs[i] = vat;
+		if(i2c_write(IICD_DSP, Y_tfnFL, beep_start_coeffs, 4)) {
+		    printk("i2c_write for beep failed\n");
+		}
+
+		{
+			int t;
+			if(csin_table == csin_table_38000)
+				t = (length * 19) / 2;
+			else
+				t = (length * 441) / 40;
+			dsp_write(X_plusmax, 131071);
+			dsp_write(X_minmax, 262144 - t);
+			dsp_write(X_stepSize, 1);
+			dsp_write(X_counterX, 262144 - t);
+		}
+		
+		/* latch new values in synchronously */
+		dsp_write(Y_iSinusWant, 0x82a);
+		/* turn on the oscillator, superposition mode */
+		dsp_write(Y_sinusMode, 0x88d);
+		if (length > 0) {
+			/* schedule a beep off */
+
+			/* minimum duration is 30ms or you get a click */
+			if (timer_pending(&dev->beep_timer))
+				del_timer(&dev->beep_timer);
+			/* 30ms decay */
+			length += 30;
+			dev->beep_timer.expires = jiffies + (length * HZ)/1000;
+			add_timer(&dev->beep_timer);
+		}
+	}
+}
+
+static void empeg_audio_beep_end(unsigned long unused)
+{
+	/* We don't want to be doing this from interrupt time */
+	/* Schedule back to process time -- concurrency safe(ish) */
+	queue_task(&i2c_queue, &tq_scheduler);
+}	
+
+static void empeg_audio_beep_end_sched(void *unused)
+{
+	/* This doesn't handle all cases */
+	/* if another thing timed, we should keep the beep on, really */
+	if(timer_pending(&audio[0]. beep_timer)) return;
+
+	/* Turn beep off */
+#if AUDIO_DEBUG
+	/* This all works now, I'm pretty sure */
+	printk(AUDIO_NAME ": BEEP off.\n");
+#endif
+
+	/* Turn off oscillator */
+	dsp_write(Y_sinusMode, 0x89a);
+}
+
+/*                      
+ * Interrupt processing 
+ */
+static void empeg_audio_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	audio_dev *dev = &audio[0];
+	int status = RdDCSR0, dofirst = -1;
+
+	/* Update statistics */
+#if AUDIO_DEBUG_STATS
+	dev->stats.interrupts++;
+#endif
+
+	/* Work out which DMA buffer we need to attend to first */
+	dofirst = ( ((status & DCSR_BIU) && (status & DCSR_STRTB)) ||
+		    (!(status & DCSR_BIU) && !(status & DCSR_STRTA)))
+		? 0 : 1;
+
+	/* Fill the first buffer */
+        if (dofirst== 0) {
+		ClrDCSR0 = DCSR_DONEB;
+		
+		/* Any data to get? */
+		if (dev->used == 0) {
+			DBSA0 = (unsigned char *) _ZeroMem;
+			DBTA0 = AUDIO_BUFFER_SIZE;
+
+
+			/* If we've underrun, take note */
+			if (dev->good_data) {
+				dev->good_data = 0;
+				dev->stats.user_underruns++;
+			}
+		}
+		else {
+		        DBSA0 =	(unsigned char *)
+				virt_to_phys(dev->buffers[dev->tail].data);
+			DBTA0 = AUDIO_BUFFER_SIZE;
+			if (++dev->tail == AUDIO_NOOF_BUFFERS) dev->tail = 0;
+			dev->used--;
+			dev->free++;
+		}
+		
+		if (!(status & DCSR_STRTB)) {
+			/* Filling both buffers: possible IRQ underrun */
+			dev->stats.irq_underruns++;
+
+			if (dev->used == 0) {
+				DBSB0 = (unsigned char *) _ZeroMem;
+				DBTB0 = AUDIO_BUFFER_SIZE;
+			}
+			else {
+				DBSB0 = (unsigned char *) virt_to_phys(
+					dev->buffers[dev->tail].data);
+				DBTB0 = AUDIO_BUFFER_SIZE;
+				if (++dev->tail == AUDIO_NOOF_BUFFERS)
+					dev->tail = 0;
+				dev->used--;
+				dev->free++;
+			}
+			
+			/* Start both channels */
+			SetDCSR0 =
+				DCSR_STRTA | DCSR_STRTB | DCSR_IE | DCSR_RUN;
+		}
+		else {
+			SetDCSR0 = DCSR_STRTA | DCSR_IE | DCSR_RUN;
+		}
+	}
+	else {
+		ClrDCSR0 = DCSR_DONEA;
+
+		/* Any data to get? */
+		if (dev->used == 0) {
+			DBSB0 = (unsigned char *) _ZeroMem;
+			DBTB0 = AUDIO_BUFFER_SIZE;
+
+			/* If we've underrun, take note */
+			if (dev->good_data) {
+				dev->good_data = 0;
+				dev->stats.user_underruns++;
+			}
+		}
+		else {
+			DBSB0 = (unsigned char *)
+				virt_to_phys(dev->buffers[dev->tail].data);
+			DBTB0 = AUDIO_BUFFER_SIZE;
+			if (++dev->tail == AUDIO_NOOF_BUFFERS)
+				dev->tail=0;
+			dev->used--;
+			dev->free++;
+		}
+		
+		if (!(status & DCSR_STRTA)) {
+			/* Filling both buffers: possible IRQ underrun */
+			dev->stats.irq_underruns++;
+
+			if (dev->used == 0) {
+				DBSA0 = (unsigned char *) _ZeroMem;
+				DBTA0 = AUDIO_BUFFER_SIZE;
+			}
+			else {
+				DBSA0 = (unsigned char*) virt_to_phys(
+					dev->buffers[dev->tail].data);
+				DBTA0 = AUDIO_BUFFER_SIZE;
+				if (++dev->tail == AUDIO_NOOF_BUFFERS)
+					dev->tail=0;
+				dev->used--;
+				dev->free++;
+			}
+
+			/* Start both channels */
+			SetDCSR0 =
+				DCSR_STRTA | DCSR_STRTB | DCSR_IE | DCSR_RUN;
+		}
+		else {
+			SetDCSR0 = DCSR_STRTB | DCSR_IE | DCSR_RUN;
+		}
+	}
+
+	/* Run the audio buffer emmitted action */
+	queue_task(&emit_task, &tq_immediate);
+	mark_bh(IMMEDIATE_BH);
+	
+	/* Wake up waiter */
+	wake_up_interruptible(&dev->waitq);
+}
+
+static void empeg_audio_emit_action(void *p)
+{
+#ifdef CONFIG_EMPEG_DISPLAY
+	audio_emitted_action();
+#endif
+}
+
+void empeg_audio_beep_setup(int rate)
+{
+	/* Page 156 */
+    
+	/* Setup beep coefficients for this sampling frequency */
+	if(rate == 38000) {
+		csin_table = csin_table_38000;
+	    
+		// 6ms rise/fall time, 30ms transient
+		dsp_patchmulti(beep_setup, Y_samAttl, 0x312);
+		dsp_patchmulti(beep_setup, Y_samAtth, 0x7dc);
+		dsp_patchmulti(beep_setup, Y_samDecl, 0x312);
+		dsp_patchmulti(beep_setup, Y_samDech, 0x7dc);
+		dsp_patchmulti(beep_setup, Y_deltaA, 0x10e);
+		dsp_patchmulti(beep_setup, Y_switchA, 0x10e);
+		dsp_patchmulti(beep_setup, Y_deltaD, 0);
+		dsp_patchmulti(beep_setup, Y_switchD, 0);
+	}
+	else if(rate == 44100) {
+		csin_table = csin_table_44100;
+	    
+		// 6 ms rise/fall time, 30ms transient
+		dsp_patchmulti(beep_setup, Y_samAttl, 0x22f);
+		dsp_patchmulti(beep_setup, Y_samAtth, 0x7e1);
+		dsp_patchmulti(beep_setup, Y_samDecl, 0x22f);
+		dsp_patchmulti(beep_setup, Y_samDech, 0x7e1);
+		dsp_patchmulti(beep_setup, Y_deltaA, 0x0fb);
+		dsp_patchmulti(beep_setup, Y_switchA, 0x0fb);
+		dsp_patchmulti(beep_setup, Y_deltaD, 0);
+		dsp_patchmulti(beep_setup, Y_switchD, 0);
+	}
+	else {
+		printk(AUDIO_NAME
+		       ": unsupported rate for beeps: %d\n", rate);
+	}
+
+	dsp_writemulti(beep_setup);
+}
+
+#ifdef	CONFIG_PROC_FS
+static struct proc_dir_entry *proc_audio;
+static int empeg_audio_read_proc(char *buf, char **start, off_t offset,
+				 int length, int *eof, void *private )
+{
+	audio_dev *dev = &audio[0];
+
+	length = 0;
+	length += sprintf(buf + length,
+			  "samples   : %ld\n"
+			  "interrupts: %ld\n"
+			  "wakeups   : %ld\n"
+			  "fifo errs : %ld\n"
+			  "buffer hwm: %ld\n"
+			  "usr undrrn: %ld\n"
+			  "irq undrrn: %ld\n",
+			  dev->stats.samples,
+			  dev->stats.interrupts,
+			  dev->stats.wakeups,
+			  dev->stats.fifo_err,
+			  dev->stats.buffer_hwm,
+			  dev->stats.user_underruns,
+			  dev->stats.irq_underruns);
+	
+	return length;
+}
+#endif	/* CONFIG_PROC_FS */
+
+
+static unsigned long csin_table_44100[] =
+{
+	0x3FF7F3,    // midi note 48, piano note A 4
+	0x3FF6F7,    // midi note 49, piano note A#4
+	0x3FF5DC,    // midi note 50, piano note B 4
+	0x3FF49E,    // midi note 51, piano note C 4
+	0x3FF339,    // midi note 52, piano note C#4
+	0x3FF1A9,    // midi note 53, piano note D 4
+	0x3FEFE7,    // midi note 54, piano note D#4
+	0x3FEDEF,    // midi note 55, piano note E 4
+	0x3FEBB9,    // midi note 56, piano note F 4
+	0x3FE93D,    // midi note 57, piano note F#4
+	0x3FE674,    // midi note 58, piano note G 4
+	0x3FE353,    // midi note 59, piano note G#4
+	0x3FDFD1,    // midi note 60, piano note A 5
+	0x3FDBE0,    // midi note 61, piano note A#5
+	0x3FD774,    // midi note 62, piano note B 5
+	0x3FD27D,    // midi note 63, piano note C 5
+	0x3FCCEC,    // midi note 64, piano note C#5
+	0x3FC6AB,    // midi note 65, piano note D 5
+	0x3FBFA7,    // midi note 66, piano note D#5
+	0x3FB7C7,    // midi note 67, piano note E 5
+	0x3FAEF1,    // midi note 68, piano note F 5
+	0x3FA506,    // midi note 69, piano note F#5
+	0x3F99E5,    // midi note 70, piano note G 5
+	0x3F8D68,    // midi note 71, piano note G#5
+	0x3F7F64,    // midi note 72, piano note A 6
+	0x3F6FAA,    // midi note 73, piano note A#6
+	0x3F5E04,    // midi note 74, piano note B 6
+	0x3F4A38,    // midi note 75, piano note C 6
+	0x3F3401,    // midi note 76, piano note C#6
+	0x3F1B14,    // midi note 77, piano note D 6
+	0x3EFF1E,    // midi note 78, piano note D#6
+	0x3EDFC1,    // midi note 79, piano note E 6
+	0x3EBC92,    // midi note 80, piano note F 6
+	0x3E951C,    // midi note 81, piano note F#6
+	0x3E68DB,    // midi note 82, piano note G 6
+	0x3E373A,    // midi note 83, piano note G#6
+	0x3DFF96,    // midi note 84, piano note A 7
+	0x3DC134,    // midi note 85, piano note A#7
+	0x3D7B47,    // midi note 86, piano note B 7
+	0x3D2CE9,    // midi note 87, piano note C 7
+	0x3CD518,    // midi note 88, piano note C#7
+	0x3C72B8,    // midi note 89, piano note D 7
+	0x3C0489,    // midi note 90, piano note D#7
+	0x3B8929,    // midi note 91, piano note E 7
+	0x3AFF0F,    // midi note 92, piano note F 7
+	0x3A6485,    // midi note 93, piano note F#7
+	0x39B7A9,    // midi note 94, piano note G 7
+	0x38F663,    // midi note 95, piano note G#7
+	0x381E65,    // midi note 96, piano note A 8
+};
+
+static unsigned long csin_table_38000[] =
+{
+	0x3FF529,    // midi note 48, piano note A 4
+	0x3FF3D5,    // midi note 49, piano note A#4
+	0x3FF258,    // midi note 50, piano note B 4
+	0x3FF0AC,    // midi note 51, piano note C 4
+	0x3FEECB,    // midi note 52, piano note C#4
+	0x3FECB0,    // midi note 53, piano note D 4
+	0x3FEA53,    // midi note 54, piano note D#4
+	0x3FE7AB,    // midi note 55, piano note E 4
+	0x3FE4B1,    // midi note 56, piano note F 4
+	0x3FE159,    // midi note 57, piano note F#4
+	0x3FDD99,    // midi note 58, piano note G 4
+	0x3FD962,    // midi note 59, piano note G#4
+	0x3FD4A8,    // midi note 60, piano note A 5
+	0x3FCF5A,    // midi note 61, piano note A#5
+	0x3FC966,    // midi note 62, piano note B 5
+	0x3FC2B7,    // midi note 63, piano note C 5
+	0x3FBB38,    // midi note 64, piano note C#5
+	0x3FB2CD,    // midi note 65, piano note D 5
+	0x3FA95B,    // midi note 66, piano note D#5
+	0x3F9EC1,    // midi note 67, piano note E 5
+	0x3F92DC,    // midi note 68, piano note F 5
+	0x3F8583,    // midi note 69, piano note F#5
+	0x3F7688,    // midi note 70, piano note G 5
+	0x3F65B9,    // midi note 71, piano note G#5
+	0x3F52DD,    // midi note 72, piano note A 6
+	0x3F3DB4,    // midi note 73, piano note A#6
+	0x3F25F7,    // midi note 74, piano note B 6
+	0x3F0B54,    // midi note 75, piano note C 6
+	0x3EED73,    // midi note 76, piano note C#6
+	0x3ECBEF,    // midi note 77, piano note D 6
+	0x3EA658,    // midi note 78, piano note D#6
+	0x3E7C2E,    // midi note 79, piano note E 6
+	0x3E4CE6,    // midi note 80, piano note F 6
+	0x3E17E2,    // midi note 81, piano note F#6
+	0x3DDC71,    // midi note 82, piano note G 6
+	0x3D99CF,    // midi note 83, piano note G#6
+	0x3D4F20,    // midi note 84, piano note A 7
+	0x3CFB6E,    // midi note 85, piano note A#7
+	0x3C9DAA,    // midi note 86, piano note B 7
+	0x3C34A1,    // midi note 87, piano note C 7
+	0x3BBF02,    // midi note 88, piano note C#7
+	0x3B3B54,    // midi note 89, piano note D 7
+	0x3AA7F5,    // midi note 90, piano note D#7
+	0x3A0315,    // midi note 91, piano note E 7
+	0x394AB5,    // midi note 92, piano note F 7
+	0x387C9D,    // midi note 93, piano note F#7
+	0x37965D,    // midi note 94, piano note G 7
+	0x369548,    // midi note 95, piano note G#7
+	0x35766D,    // midi note 96, piano note A 8
+};
+
+static dsp_setup beep_setup[] =
+{
+	/* Timing generator scaling coefficients */
+	{ Y_scalS1_,	0 },		/* 1-a scale = 0 */
+	{ Y_scalS1,	0x7ff },	/* a scale   = 1 */
+
+	/* Timing generator copy locations */
+	{ Y_cpyS1,	0x8f9 },	/* copy a*S1 to c1 */
+	{ Y_cpyS1_,	0x8fb },	/* nothing */
+
+	{ Y_c0sin,	0 },		/* nothing */
+	{ Y_c1sin,	0 },		/* controlled by a*S1 */
+	{ Y_c2sin,	0 },		/* nothing */
+	{ Y_c3sin,	0 },		/* nothing */
+		
+	/* Full volume */
+	{ Y_VLsin,	0x7ff },	/* volume left  = 1 */
+	{ Y_VRsin,	0x7ff },	/* volume right = 1 */
+		
+	{ Y_IClipAmax,	0 },		/* no output */
+	{ Y_IClipAmin,	0 },		/* no output */
+	{ Y_IClipBmax,	0x100 },	/* 50% clipping */
+	{ Y_IClipBmin,	0x100 },	/* 50% clipping */
+		
+	/* Tone frequency */
+	{ Y_IcoefAl,	0 },		/* written as required */
+	{ Y_IcoefAh,	0 },
+	{ Y_IcoefBL,	0 },
+	{ Y_IcoefBH,	0 },
+
+	/* Coefficients for channel beep volume */
+	{ Y_tfnFL,	0x800 },	/* yes the manual says -1 */
+	{ Y_tfnFR,	0x800 },	/* but that only causes */
+	{ Y_tfnBL,	0x800 },	/* the wave to invert */
+	{ Y_tfnBR,	0x800 },	/* which is ok */
+
+	/* Attack / decay */
+	{ Y_samAttl,	0 },		/* written when changing */
+	{ Y_samAtth,	0 },		/* channels */
+	{ Y_deltaA,	0 },
+	{ Y_switchA,	0 },
+	{ Y_samDecl,	0 },
+	{ Y_samDech,	0 },
+	{ Y_deltaD,	0 },
+	{ Y_switchD,	0 },
+
+	/* wave routing select */
+	{ Y_iSinusWant,	0x82a },
+	{ Y_sinusMode,	0x89a },	/* off */
+
+	{ 0,0 }
+};
Index: empeg/kernel/arch/arm/special/empeg_audio3.h
diff -u /dev/null empeg/kernel/arch/arm/special/empeg_audio3.h:1.1.2.1
--- /dev/null	Thu May 31 21:42:26 2001
+++ empeg/kernel/arch/arm/special/empeg_audio3.h	Thu May  3 11:52:33 2001
@@ -0,0 +1,12 @@
+#ifndef EMPEG_AUDIO3_H
+#define EMPEG_AUDIO3_H
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/init.h>
+
+int __init empeg_audio_init(void);
+int empeg_audio_open(struct inode *inode, struct file *file);
+void empeg_audio_beep_setup(int rate);
+
+#endif
Index: empeg/kernel/arch/arm/special/empeg_display.c
diff -u empeg/kernel/arch/arm/special/empeg_display.c:1.33.4.2 empeg/kernel/arch/arm/special/empeg_display.c:1.33.4.3
--- empeg/kernel/arch/arm/special/empeg_display.c:1.33.4.2	Fri Jan  5 15:43:21 2001
+++ empeg/kernel/arch/arm/special/empeg_display.c	Mon Feb 12 15:40:20 2001
@@ -587,8 +587,6 @@
 		logo_type = LOGO_EMPEG;
 	}
 	
-	printk("Logo type is %x\n", logo_type);
-	
 	/* Load splash screen image */
 	if ((logo_type & LOGO_MASK) == LOGO_RIO)
 		display_splash(dev, &rio_logo);
Index: empeg/kernel/arch/arm/special/empeg_dsp.c
diff -u /dev/null empeg/kernel/arch/arm/special/empeg_dsp.c:1.1.2.1
--- /dev/null	Thu May 31 21:42:26 2001
+++ empeg/kernel/arch/arm/special/empeg_dsp.c	Thu May  3 11:52:33 2001
@@ -0,0 +1,85 @@
+/*
+ * SA1100/empeg DSP multiplexor
+ *
+ * (C) 2000 empeg ltd, http://www.empeg.com
+ *
+ * Authors:
+ *   Hugo Fiennes, <hugo@empeg.com>
+ *   John Ripley, <john@empeg.com>
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/empeg.h>
+
+#include "empeg_audio3.h"
+#include "empeg_mixer.h"
+
+#ifdef CONFIG_EMPEG_DAC
+#error empeg DAC driver cannot be coexist with DSP driver
+#endif
+
+#define EMPEG_DSP_NAME			"dspaudio"
+#define EMPEG_DSP_NAME_VERBOSE		"empeg dsp"
+
+/* device numbers */
+#define EMPEG_DSP_MAJOR			245
+
+#define EMPEG_MIXER_MINOR		0
+#define EMPEG_MIC_MINOR			1
+#define EMPEG_DSP_MINOR			3
+#define EMPEG_AUDIO_MINOR		4
+
+int __init empeg_dsp_init(void);
+static int empeg_dsp_major_open(struct inode *inode, struct file *file);
+
+static struct file_operations dsp_fops =
+{
+	open:		empeg_dsp_major_open
+};
+
+int __init empeg_dsp_init(void)
+{
+	int ret;
+
+	if((ret = empeg_audio_init()) != 0)
+		return ret;
+
+	if((ret = empeg_mixer_init()) != 0)
+		return ret;
+
+	if((ret = register_chrdev(EMPEG_DSP_MAJOR,
+				  EMPEG_DSP_NAME,
+				  &dsp_fops)) != 0) {
+		printk(EMPEG_DSP_NAME
+		       ": unable to register major device %d\n",
+		       EMPEG_DSP_MAJOR);
+		
+		return ret;
+	}
+
+	printk(EMPEG_DSP_NAME_VERBOSE " initialised\n");
+
+	return 0;
+}
+
+static int empeg_dsp_major_open(struct inode *inode, struct file *file)
+{
+	
+	switch(MINOR(inode->i_rdev)) {
+	case EMPEG_AUDIO_MINOR:
+	case EMPEG_DSP_MINOR:
+		return empeg_audio_open(inode, file);
+		
+	case EMPEG_MIXER_MINOR:
+		return empeg_mixer_open(inode, file);
+
+	default:
+		return -ENXIO;
+	}
+}
+
Index: empeg/kernel/arch/arm/special/empeg_dsp.h
diff -u /dev/null empeg/kernel/arch/arm/special/empeg_dsp.h:1.1.2.1
--- /dev/null	Thu May 31 21:42:26 2001
+++ empeg/kernel/arch/arm/special/empeg_dsp.h	Thu May  3 11:52:33 2001
@@ -0,0 +1,6 @@
+#ifndef EMPEG_DSP_H
+#define EMPEG_DSP_H 1
+
+#define RADIO_DEBUG			0
+
+#endif
Index: empeg/kernel/arch/arm/special/empeg_dsp_i2c.c
diff -u /dev/null empeg/kernel/arch/arm/special/empeg_dsp_i2c.c:1.1.2.1
--- /dev/null	Thu May 31 21:42:26 2001
+++ empeg/kernel/arch/arm/special/empeg_dsp_i2c.c	Thu May  3 11:52:33 2001
@@ -0,0 +1,408 @@
+/*
+ * SA1100/empeg DSP (Philips) interface via i2c
+ *
+ * (C) 2000 empeg ltd, http://www.empeg.com
+ *
+ * Authors:
+ *   Hugo Fiennes, <hugo@empeg.com>
+ *   John Ripley, <john@empeg.com>
+ *
+ */
+
+#include <linux/kernel.h>
+#include <asm/delay.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/empeg.h>
+
+#include "empeg_dsp_i2c.h"
+
+static void i2c_startseq(void);
+static void i2c_stopseq(void);
+static int i2c_getdatabit(void);
+static void i2c_putdatabit(int bit);
+static int i2c_getbyte(unsigned char *byte, int nak);
+static int i2c_putbyte(int byte);
+
+/*
+ * Delay stuff
+ * These are the minimum delays that the i2c bus can take before
+ * the lines fail to get driven to the correct level.
+ */
+
+static __inline__ void i2c_delay_long(void)
+{
+	udelay(15);	// any lower and the lines don't float
+}
+
+static __inline__ void i2c_delay_short(void)
+{
+	udelay(1);	// any lower and the lines don't float
+}
+
+/* Pulse out the start sequence */
+
+static void i2c_startseq(void)
+{
+	/* Clock low, data high */
+	GPCR = IIC_CLOCK | IIC_DATAOUT;
+	i2c_delay_long();
+
+	/* Put clock high */
+	GPSR = IIC_CLOCK;
+	i2c_delay_short();
+
+	/* Put data low */
+	GPSR = IIC_DATAOUT;
+	i2c_delay_short();
+
+	/* Clock low again */
+	GPCR = IIC_CLOCK;
+	i2c_delay_long();
+}
+
+/* Pulse out the stop sequence */
+
+static void i2c_stopseq(void)
+{
+	/* Data low, clock low */
+	GPCR = IIC_CLOCK;
+	GPSR = IIC_DATAOUT;
+	i2c_delay_long();
+
+	/* Clock high */
+	GPSR = IIC_CLOCK;
+	i2c_delay_short();
+	
+	/* Let data float high */
+	GPCR = IIC_DATAOUT;
+	i2c_delay_long();
+}
+
+/*
+ * Read in a single bit, assumes the current state is clock low
+ * and that the data direction is inbound.
+ */
+
+static int i2c_getdatabit(void)
+{
+	int result;
+
+	/* Trigger the clock */
+	GPSR = IIC_CLOCK;
+	i2c_delay_long();
+	
+	/* Wait for the slave to give me the data */
+	result = !(GPLR & IIC_DATAIN);
+
+	/* Now take the clock low */
+	GPCR = IIC_CLOCK;
+	i2c_delay_long();
+	return result;
+}
+
+/*
+ * Pulse out a single bit, assumes the current state is clock low
+ * and that the data direction is outbound.
+ */
+
+static void i2c_putdatabit(int bit)
+{
+	/* First set the data bit (clock low) */
+	GPCR = IIC_CLOCK;
+	if (bit) {
+	    if (GPLR & IIC_DATAOUT) {
+		GPCR = IIC_DATAOUT;
+		i2c_delay_long();
+	    }
+	}
+	else {
+	    if (!(GPLR & IIC_DATAOUT)) {
+		GPSR = IIC_DATAOUT;
+	    }
+	}
+	i2c_delay_short();
+
+	/* Now trigger the clock */
+	GPSR = IIC_CLOCK;
+	i2c_delay_short();
+	
+	/* Drop the clock */
+	GPCR = IIC_CLOCK;
+	i2c_delay_short();
+}
+
+/*
+ * Read an entire byte and send out acknowledge.
+ * Returns byte read.
+ */
+
+static int i2c_getbyte(unsigned char *byte, int nak)
+{
+	int i;
+
+	/* Let data line float */
+	GPCR = IIC_DATAOUT;
+	i2c_delay_long();
+
+	*byte = 0;
+	/* Clock in the data */
+	for(i = 7; i >= 0; --i)
+		if (i2c_getdatabit())
+			(*byte) |= (1 << i);
+	
+	/* Well, I got it so respond with an ack, or nak */
+	
+	/* Send data low to indicate success */
+	if(!nak) {
+		GPSR = IIC_DATAOUT;
+	}
+	else {
+		GPCR = IIC_DATAOUT;
+	}
+	i2c_delay_long();
+
+	/* Trigger clock since data is ready */
+	GPSR = IIC_CLOCK;
+	i2c_delay_long();
+
+	/* Take clock low */
+
+	GPCR = IIC_CLOCK;
+	i2c_delay_long();
+
+	/* Release data line */
+	GPCR = IIC_DATAOUT;
+	i2c_delay_long();
+
+	return 0; /* success */
+}
+	
+/*
+ * Pulse out a complete byte and receive acknowledge.
+ * Returns 0 on success, non-zero on failure.
+ */
+static int i2c_putbyte(int byte)
+{
+	int i, ack;
+
+	/* Clock/data low */
+	GPCR = IIC_CLOCK;
+	GPSR = IIC_DATAOUT;
+
+	/* Clock out the data */
+	for(i = 7; i >= 0; --i)
+		i2c_putdatabit(byte & (1 << i));
+	
+	/* data high (ie, no drive) */
+	GPCR = IIC_DATAOUT | IIC_CLOCK;
+
+	i2c_delay_long();
+	
+	/* Clock out */
+	GPSR = IIC_CLOCK;
+	
+	/* Wait for ack to arrive */
+	i2c_delay_long();
+
+	ack = !(GPLR & IIC_DATAIN);
+
+	i2c_delay_long();
+	/* Clock low */
+	GPCR = IIC_CLOCK;
+	
+	i2c_delay_long();
+
+	if (ack) {
+		i2c_stopseq();
+		udelay(3000);
+		printk(KERN_ERR "i2c: Failed to receive ACK for data!\n");
+	}
+
+	return ack;
+}	
+
+
+/*
+ * This stuff gets called from empeg_audio2.c and friends
+ */
+
+/* Write to one or more I2C registers */
+
+int i2c_read(unsigned char device, unsigned short address,
+	     unsigned int *data, int count)
+{
+	/* Send start sequence */
+	i2c_startseq();
+
+	/* Set the device */
+	if (i2c_putbyte(device & 0xFE))
+		goto i2c_error;
+
+	/* Set the address (higher then lower) */
+	if (i2c_putbyte(address >> 8) || i2c_putbyte(address & 0xFF))
+		goto i2c_error;
+
+	/* Repeat the start sequence */
+	i2c_startseq();
+	
+	/* Set the device but this time in read mode */
+	if (i2c_putbyte(device | 0x01))
+		goto i2c_error;
+
+	/* Now read in the actual data */
+	while(count--)
+	{
+		unsigned char b1, b2, b3;
+		if(address < 0x200) {
+			if (i2c_getbyte(&b1, 0) ||
+			    i2c_getbyte(&b2, 0) ||
+			    i2c_getbyte(&b3, 1))
+				goto i2c_error;
+			*data++ = (b1 << 16) | (b2 << 8) | b3;
+		} else {
+			/* Receive the 16 bit quantity */
+			if (i2c_getbyte(&b1, 0) ||
+			    i2c_getbyte(&b2, 1))
+				goto i2c_error;
+			*data++ = (b1 << 8) | b2;
+		}
+	}
+
+	/* Now say we don't want any more: NAK (send bit 1) */
+	i2c_putdatabit(1);
+
+	i2c_stopseq();	
+	
+	return 0;
+
+ i2c_error:
+	return -1;
+}
+
+int i2c_read1(unsigned char device, unsigned short address,
+	      unsigned int *data)
+{
+	return i2c_read(device, address, data, 1);
+}
+
+int i2c_write(unsigned char device, unsigned short address,
+	      unsigned int *data, unsigned short count)
+{
+	/* Pulse out the start sequence */
+	i2c_startseq();
+
+	/* Say who we're talking to */
+	if (i2c_putbyte(device & 0xFE)) {
+		printk("i2c_write: device select failed\n");
+		goto i2c_error;
+	}
+
+	/* Set the address (higher then lower) */
+	if (i2c_putbyte(address >> 8) || i2c_putbyte(address & 0xFF)) {
+		printk("i2c_write: address select failed\n");
+		goto i2c_error;
+	}
+
+	/* Now send the actual data */
+	while(count--)
+	{
+		if (address < 0x200) {
+			/* Send out the 24 bit quantity */
+			
+			/* Mask off the top 8 bits in certain situations! */
+			if (i2c_putbyte((*data >> 16) & 0xff)) {
+				printk("i2c_write: write first byte failed"
+				       ", count:%d\n", count);
+				goto i2c_error;
+			}
+			if (i2c_putbyte((*data >> 8) & 0xFF)) {
+				printk("i2c_write: write second byte failed"
+				       ", count:%d\n", count);
+				goto i2c_error;
+			}
+			if (i2c_putbyte(*data & 0xFF)) {
+				printk("i2c_write: write third byte failed"
+				       ", count:%d\n", count);
+				goto i2c_error;
+			}
+		}
+		else {
+			/* Send out 16 bit quantity */
+			/* Mask off the top 8 bits in certain situations! */
+			if (i2c_putbyte(*data >> 8)) {
+				printk("i2c_write: write first byte failed"
+				       ", count:%d\n", count);
+				goto i2c_error;
+			}
+			if (i2c_putbyte(*data & 0xFF)) {
+				printk("i2c_write: write second byte failed"
+				       ", count:%d\n", count);
+				goto i2c_error;
+			}
+		}
+		++data;
+	}
+	
+	i2c_stopseq();
+
+	/* Complete success */
+	return 0;
+
+ i2c_error:
+	/* Complete failure */
+	return -1;
+}
+
+int i2c_write1(unsigned char device, unsigned short address,
+	       unsigned int data)
+{
+	return i2c_write(device, address, &data, 1);
+}
+
+
+int dsp_write(unsigned short address, unsigned int data)
+{
+#if AUDIO_DEBUG
+	printk(AUDIO_NAME ": dsp_write %x=%x\n",address,data);
+#endif
+	return(i2c_write1(IICD_DSP,address,data));
+}  
+
+int dsp_read_yram(unsigned short address, unsigned int *data)
+{
+	return i2c_read1(IICD_DSP, address, data);
+}
+
+int dsp_read_xram(unsigned short address, unsigned int *data)
+{
+	int status;
+	status = i2c_read1(IICD_DSP, address, data);
+	*data &= 0x3FFFF; /* Only eighteen bits of real data */
+	return status;
+}
+
+int dsp_writemulti(dsp_setup *setup)
+{
+	int a;
+	for(a = 0; setup[a].address != 0; a++) {
+		if (dsp_write(setup[a].address, setup[a].data)) {
+			printk(KERN_ERR "I2C write failed (%x, %x)\n",
+			       setup[a].address, setup[a].data);
+			return 1;
+		}
+	}
+	
+	return 0;
+}
+
+int dsp_patchmulti(dsp_setup *setup, int address, int new_data)
+{
+	int a;
+	for(a = 0; setup[a].address != 0;a++) {
+		if (setup[a].address == address) {
+			setup[a].data = new_data;
+			return 0;
+		}
+	}	
+	return 1;
+}	
Index: empeg/kernel/arch/arm/special/empeg_dsp_i2c.h
diff -u /dev/null empeg/kernel/arch/arm/special/empeg_dsp_i2c.h:1.3.2.2
--- /dev/null	Thu May 31 21:42:26 2001
+++ empeg/kernel/arch/arm/special/empeg_dsp_i2c.h	Thu May 31 15:57:27 2001
@@ -0,0 +1,169 @@
+#ifndef EMPEG_DSP_I2C_H
+#define EMPEG_DSP_I2C_H	1
+
+/* DSP memory: incomplete list of locations, but enough for now */
+#define X_modpntr	0x000
+#define X_levn		0x001
+#define X_leva		0x002
+#define X_mlta		0x006
+#define X_mltflim	0x007
+#define X_pltd		0x00e
+#define X_noisflt	0x01c
+#define X_leva_u	0x019
+#define X_stepSize	0x120
+#define X_counterX	0x121
+#define X_plusmax	0x122
+#define X_minmax	0x123
+#define Y_mod00		0x800		/* Filtered FM level */
+#define Y_p1		0x81d
+#define Y_q1		0x81e
+#define Y_c1		0x821
+#define Y_p12		0x837
+#define Y_q12		0x838
+#define Y_p13		0x83d
+#define Y_q13		0x83e
+#define Y_p7		0x840
+#define Y_q7		0x841
+#define Y_minsmtcn	0x842
+#define Y_AMb02		0x845		/* thru 0x853 for AM filter */
+#define Y_p2		0x84d
+#define Y_q2		0x84e
+#define Y_minsmtc	0x84f
+#define Y_compry0st_28	0x856
+#define Y_p3		0x861
+#define Y_q3		0x862
+#define Y_E_strnf_str	0x867
+#define Y_E_mltp_str	0x868
+#define Y_stro		0x869
+#define Y_p5		0x86d
+#define Y_q5		0x86e
+#define Y_E_strnf_rsp	0x872
+#define Y_E_mltp_rsp	0x873
+#define Y_sdr_d_c	0x874
+#define Y_c91		0x87b
+#define Y_c61		0x87d
+#define Y_EMute		0x887
+#define Y_VGA		0x8e0
+#define Y_KLCl		0x8e1
+#define Y_KLCh		0x8e2
+#define Y_KLBl		0x8e3
+#define Y_KLBh		0x8e4
+#define Y_KLA0l		0x8e5
+#define Y_KLA0h		0x8e6
+#define Y_KLA2l		0x8e7
+#define Y_KLA2h		0x8e8
+#define Y_KLtre		0x8e9
+#define Y_KLbas		0x8ea
+#define Y_KLmid		0x8eb
+#define Y_VAT		0x8ec
+#define Y_SAM		0x8ed
+#define Y_OutSwi	0x8ee
+#define Y_SrcScal	0x8f3
+#define Y_samCl		0x8f4
+#define Y_samCh		0x8f5
+#define Y_delta		0x8f6
+#define Y_switch	0x8f7
+#define Y_louSwi	0x8f9
+#define Y_statLou	0x8fa
+#define Y_OFFS		0x8fb
+#define Y_KPDL		0x8fc
+#define Y_KMDL		0x8fd
+#define Y_Cllev		0x8fe
+#define Y_Ctre		0x8ff
+#define Y_EMuteF1	0x90e
+#define Y_scalS1_	0x927
+#define Y_scalS1	0x928
+#define Y_cpyS1		0x92a
+#define Y_cpyS1_	0x92b
+#define Y_c3sin		0x92e
+#define Y_c1sin		0x92f
+#define Y_c0sin		0x931
+#define Y_c2sin		0x932
+#define Y_VLsin		0x933
+#define Y_VRsin		0x934
+#define Y_IClipAmax	0x935
+#define Y_IClipAmin	0x936
+#define Y_IcoefAl	0x937
+#define Y_IcoefAh	0x938
+#define Y_IClipBmax	0x939
+#define Y_IClipBmin	0x93a
+#define Y_IcoefBL	0x93b
+#define Y_IcoefBH	0x93c
+#define Y_samDecl	0x93d
+#define Y_samDech	0x93e
+#define Y_deltaD	0x93f
+#define Y_switchD	0x940
+#define Y_samAttl	0x941
+#define Y_samAtth	0x942
+#define Y_deltaA	0x943
+#define Y_switchA	0x944
+#define Y_iSinusWant	0x946
+#define Y_sinusMode	0x947
+#define Y_tfnFL		0x948
+#define Y_tfnFR		0x949
+#define Y_tfnBL		0x94a
+#define Y_tfnBR		0x94b
+#define Y_BALL0		0x8bc
+#define Y_BALR0		0x8bd
+#define Y_BALL1		0x8ca
+#define Y_BALR1		0x8cb
+#define Y_FLcof		0x8ef
+#define Y_FRcof		0x8f0
+#define Y_RLcof		0x8f1
+#define Y_RRcof		0x8f2
+
+/* THIS SHOULDN'T BE IN HERE, IT'S ONLY VISITING!
+   <altman@empeg.com> */
+
+/* Some DSP defines */
+#define IICD_DSP			0x38
+
+#define IIC_DSP_SEL			0x0FFA
+#define IIC_DSP_SEL_RESERVED0		0x0001
+#define IIC_DSP_SEL_AUX_FM		0x0002
+#define IIC_DSP_SEL_AUX_AM_TAPE		0x0004
+#define IIC_DSP_SEL_AUX_CD_TAPE		0x0008
+#define IIC_DSP_SEL_RESERVED1		0x0010
+#define IIC_DSP_SEL_LEV_AMFM		0x0020
+#define IIC_DSP_SEL_LEV_WIDENARROW	0x0040
+#define IIC_DSP_SEL_LEV_DEF		0x0080
+#define IIC_DSP_SEL_BYPASS_PLL		0x0100
+#define IIC_DSP_SEL_DC_OFFSET		0x0200
+#define IIC_DSP_SEL_RESERVED2		0x0400
+#define IIC_DSP_SEL_ADC_SRC		0x0800
+#define IIC_DSP_SEL_NSDEC		0x1000
+#define IIC_DSP_SEL_INV_HOST_WS		0x2000
+#define IIC_DSP_SEL_RESERVED3		0x4000
+#define IIC_DSP_SEL_ADC_BW_SWITCH	0x8000
+
+/*
+ * Empeg I2C support
+ */
+
+#define IIC_CLOCK			EMPEG_I2CCLOCK
+#define IIC_DATAOUT			EMPEG_I2CDATA
+#define IIC_DATAIN			EMPEG_I2CDATAIN
+
+typedef struct
+{
+	int address;
+	int data;
+} dsp_setup;
+
+int i2c_read(unsigned char device, unsigned short address,
+	     unsigned int *data, int count);
+int i2c_read1(unsigned char device, unsigned short address,
+	      unsigned int *data);
+
+int i2c_write(unsigned char device, unsigned short address,
+	      unsigned int *data, unsigned short count);
+int i2c_write1(unsigned char device, unsigned short address,
+	       unsigned int data);
+
+int dsp_read_yram(unsigned short address, unsigned int *data);
+int dsp_read_xram(unsigned short address, unsigned int *data);
+int dsp_write(unsigned short address, unsigned int data);
+int dsp_patchmulti(dsp_setup *setup, int address, int new_data);
+int dsp_writemulti(dsp_setup *setup);
+
+#endif
Index: empeg/kernel/arch/arm/special/empeg_mixer.c
diff -u /dev/null empeg/kernel/arch/arm/special/empeg_mixer.c:1.4.2.6
--- /dev/null	Thu May 31 21:42:26 2001
+++ empeg/kernel/arch/arm/special/empeg_mixer.c	Thu May 31 15:58:04 2001
@@ -0,0 +1,1441 @@
+/*
+ * SA1100/empeg mixer device driver
+ *
+ * (C) 2000 empeg ltd, http://www.empeg.com
+ *
+ * Authors:
+ *   Hugo Fiennes, <hugo@empeg.com>
+ *   John Ripley, <john@empeg.com>
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/malloc.h>
+#include <linux/sched.h>
+#include <linux/major.h>
+#include <linux/errno.h>
+#include <linux/tqueue.h>
+#include <linux/interrupt.h>
+#include <linux/timer.h>
+#include <linux/init.h>
+#include <linux/vmalloc.h>
+#include <linux/soundcard.h>
+#include <asm/segment.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/SA-1100.h>
+#include <asm/uaccess.h>
+#include <asm/delay.h>
+
+#ifdef	CONFIG_PROC_FS
+#include <linux/stat.h>
+#include <linux/proc_fs.h>
+#endif
+
+#include "empeg_dsp.h"
+#include "empeg_dsp_i2c.h"
+#include "empeg_audio3.h"
+#include "empeg_mixer.h"
+
+#ifdef CONFIG_EMPEG_DAC
+#error empeg DAC driver cannot be coexist with DSP driver
+#endif
+
+#define MIXER_DEBUG			0
+#define RADIO_DEBUG			0
+
+#define MIXER_NAME			"mixer-empeg"
+#define MIXER_NAME_VERBOSE		"empeg dsp mixer"
+
+/* Defaults */
+#define MIXER_DEVMASK			SOUND_MASK_VOLUME
+#define MIXER_STEREODEVS		MIXER_DEVMASK
+
+/* Input channels */
+#define INPUT_RADIO_FM			0
+#define INPUT_PCM			1
+#define INPUT_AUX			2
+#define INPUT_RADIO_AM			3
+
+typedef struct
+{
+	int input;
+	unsigned int flags;
+	int volume;
+	int loudness;
+	int balance;
+	int fade;
+} mixer_dev;
+
+typedef struct
+{
+	u16 vat;
+	u16 vga;
+	int db;
+} volume_entry;
+
+typedef struct
+{
+	u16 Cllev;
+	int db;
+} loudness_entry;
+
+typedef struct
+{
+	u16 ball;
+	u16 balr;
+	int db;
+} balance_entry;
+
+typedef struct
+{
+	u16 Fcof;
+	u16 Rcof;
+	int db;
+} fade_entry;
+
+#define LOUDNESS_TABLE_SIZE		11
+#define BALANCE_TABLE_SIZE		15
+#define BALANCE_ZERO			7
+#define	FADE_TABLE_SIZE			15
+#define FADE_ZERO			7
+
+/* The level that corresponds to 0dB */
+#define VOLUME_ZERO_DB			90
+
+static volume_entry volume_table[101];
+static loudness_entry loudness_table[LOUDNESS_TABLE_SIZE];
+static balance_entry balance_table[BALANCE_TABLE_SIZE];
+static fade_entry fade_table[FADE_TABLE_SIZE];
+static struct empeg_eq_section_t eq_init[20];
+static struct empeg_eq_section_t eq_current[20];
+static int eq_section_order[20];
+static int mixer_compression = 0;
+static unsigned int eq_last[40];
+static unsigned int eq_reg_last = 0;
+static unsigned int radio_sensitivity;
+static int radio_fm_level_p1 = 512, radio_fm_level_q1 = 0;
+static int radio_fm_deemphasis = 50;
+/* stereo detect */
+static unsigned stereo_level = 0;
+
+static mixer_dev	mixer_global;
+
+static int empeg_mixer_release(struct inode *inode, struct file *file);
+static int empeg_mixer_ioctl(struct inode *inode, struct file *file,
+			     uint command, ulong arg);
+
+static void empeg_mixer_select_input(int input);
+static void empeg_mixer_setloudness(mixer_dev *dev, int level);
+static int empeg_mixer_setvolume(mixer_dev *dev, int vol);
+static int empeg_mixer_getdb(mixer_dev *dev);
+static void empeg_mixer_inflict_flags(mixer_dev *dev);
+static void empeg_mixer_setbalance(mixer_dev *dev, int balance);
+static int empeg_mixer_getloudnessdb(mixer_dev *dev);
+static void empeg_mixer_setbalance(mixer_dev *dev, int balance);
+static void empeg_mixer_setfade(mixer_dev *dev, int fade);
+static void empeg_mixer_mute(int on);
+static void empeg_mixer_select_input(int input);
+static void empeg_mixer_eq_reset(void);
+static void empeg_mixer_eq_set(struct empeg_eq_section_t *sections);
+static void empeg_mixer_set_fm_level(unsigned int p1, unsigned int q1);
+static int empeg_mixer_get_fm_noise(void);
+static int empeg_mixer_set_fm_deemphasis(int which);
+
+static struct file_operations mixer_fops =
+{
+	ioctl:		empeg_mixer_ioctl,
+	open:		empeg_mixer_open,
+	release:	empeg_mixer_release
+};
+
+
+int __init empeg_mixer_init(void)
+{
+	mixer_dev *dev = &mixer_global;
+    
+#if MIXER_DEBUG
+	printk(MIXER_NAME ": mixer_init\n");
+#endif
+	memset((void *) dev, 0, sizeof(mixer_dev));
+	
+	if(empeg_hardwarerevision() < 6)
+		radio_sensitivity = 0x1000;
+	else
+/*		radio_sensitivity = 0x1024; */
+		/*
+		 * actually, it seems that:
+		 * stereo detect triggers at 4kHz out of 75kHz stereo pilot
+		 * pilot is normally at 10%
+		 * so triggering mV must mean total deviation is 40kHz
+		 * so you can adjust sensitivity to 40/75 of trigger
+		 *
+		 * pilot triggers between sensitivity 2 and 3
+		 * so between 93mV and 111mV
+		 * worst case is 111mV,
+		 * so lowest sensitivity is 40/75 * 111 = 59mV
+		 * sensitivity 0 is 65mV
+		 */
+		radio_sensitivity = 0x1024;
+
+	dev->input = SOUND_MASK_PCM;
+	dev->flags = 0;
+
+	/* Easy programming mode 1 (needs to be done after reset) */
+	dsp_write(Y_mod00, 0x4ec);
+
+    	/* Ensure the POM is on while booting. */
+	empeg_mixer_mute(1);
+
+	/* Set volume */
+	empeg_mixer_setvolume(dev,90);
+
+	/* try doing this last thing */
+	empeg_mixer_select_input(INPUT_PCM);
+
+	/* setup Soft Audio Mute, and enable */
+	dsp_write(Y_samCl, 0x189);	/* 4ms */
+	dsp_write(Y_samCh, 0x7a5);
+	dsp_write(Y_delta, 0x07d);
+	dsp_write(Y_switch, 0x5d4);
+/*	dsp_write(Y_switch, 0); */
+	
+	/* mixer_select_input(INPUT_AUX); */
+	dsp_write(Y_SrcScal, 0x400);
+	
+	dev->input = SOUND_MASK_PCM;
+	dev->flags = 0;
+	empeg_mixer_setloudness(dev, 0);
+	empeg_mixer_setbalance(dev, BALANCE_ZERO);
+	empeg_mixer_setfade(dev, FADE_ZERO);
+	empeg_mixer_inflict_flags(dev);
+
+	dsp_write(Y_OutSwi, 0xa7c);
+
+	empeg_mixer_eq_reset();	// reset coefficients
+
+	printk(MIXER_NAME_VERBOSE " initialised\n");
+
+	return 0;
+}
+
+int empeg_mixer_open(struct inode *inode, struct file *file)
+{
+	file->f_op = &mixer_fops;
+	
+#if MIXER_DEBUG
+	printk(MIXER_NAME ": mixer_open\n");
+#endif
+	file->private_data = (void *)&mixer_global;
+
+	return 0;
+}
+
+static int empeg_mixer_release(struct inode *inode, struct file *file)
+{
+#if MIXER_DEBUG
+	printk(MIXER_NAME ": mixer_release\n");
+#endif
+	
+	file->private_data = NULL;
+	return 0;
+}
+
+static int empeg_mixer_ioctl(struct inode *inode, struct file *file,
+			     uint command, ulong arg)
+{
+	mixer_dev *dev = file->private_data;
+#if MIXER_DEBUG
+	printk(MIXER_NAME ": mixer_ioctl %08x %08lx\n", command, arg);
+#endif
+	switch(command)
+	{
+	case SOUND_MIXER_READ_DEVMASK:
+		put_user_ret(MIXER_DEVMASK, (int *)arg, -EFAULT);
+#if MIXER_DEBUG
+		printk(MIXER_NAME
+		       ": mixer_ioctl SOUND_MIXER_READ_DEVMASK %08lx\n",
+		       arg);
+#endif	
+		return 0;
+	case SOUND_MIXER_READ_STEREODEVS:
+		put_user_ret(MIXER_STEREODEVS, (int *)arg, -EFAULT);
+#if MIXER_DEBUG
+		printk(MIXER_NAME
+		       ": mixer_ioctl SOUND_MIXER_READ_STEREODEVS %08lx\n",
+		       arg);
+#endif	
+		return 0;
+
+	case EMPEG_MIXER_READ_LOUDNESS:
+		put_user_ret(dev->loudness * 10, (int *)arg, -EFAULT);
+#if MIXER_DEBUG
+		printk(MIXER_NAME
+		       ": mixer_ioctl EMPEG_MIXER_READ_LOUDNESS %d\n",
+		       dev->loudness * 10);
+#endif	
+		return 0;
+	case EMPEG_MIXER_WRITE_LOUDNESS:
+	{
+		int loudness_in, loudness_out;
+		get_user_ret(loudness_in, (int *)arg, -EFAULT);
+		if (loudness_in/10 >= LOUDNESS_TABLE_SIZE)
+			return -EINVAL;
+		if (loudness_in < 0)
+			return -EINVAL;
+		empeg_mixer_setloudness(dev, loudness_in / 10);
+		loudness_out = dev->loudness * 10;
+		put_user_ret(loudness_out, (int *)arg, -EFAULT);
+#if MIXER_DEBUG
+		printk(MIXER_NAME
+		       ": mixer_ioctl EMPEG_MIXER_WRITE_LOUDNESS %d == %d\n",
+		       loudness_in, loudness_out);
+#endif	
+		return 0;
+	}
+	case EMPEG_MIXER_READ_LOUDNESS_DB:
+	{
+		int db;
+		db = empeg_mixer_getloudnessdb(dev);
+		put_user_ret(db, (int *)arg, -EFAULT);
+#if MIXER_DEBUG
+		printk(MIXER_NAME
+		       ": mixer_ioctl EMPEG_MIXER_READ_LOUDNESS_DB == %dx\n",
+		       db);
+#endif	
+		return 0;
+	}
+	case EMPEG_MIXER_WRITE_BALANCE:
+	{
+		int balance_in, balance_out;
+		get_user_ret(balance_in, (int *)arg, -EFAULT);
+		balance_out = balance_in + BALANCE_ZERO;
+		if (balance_out < 0)
+			return -EINVAL;
+		if (balance_out >= BALANCE_TABLE_SIZE)
+			return -EINVAL;
+		empeg_mixer_setbalance(dev, balance_out);
+		balance_out = dev->balance - BALANCE_ZERO;
+		put_user_ret(balance_out, (int *)arg, -EFAULT);
+#if MIXER_DEBUG
+		printk(MIXER_NAME
+		       ": mixer_ioctl EMPEG_MIXER_WRITE_BALANCE %d == %d\n",
+		       balance_in, balance_out);
+#endif
+		return 0;
+	}
+	case EMPEG_MIXER_READ_BALANCE:
+		put_user_ret(dev->balance - BALANCE_ZERO, (int *)arg, -EFAULT);
+#if MIXER_DEBUG
+		printk(MIXER_NAME
+		       ": mixer_ioctl EMPEG_MIXER_READ_BALANCE == %d\n",
+		       dev->balance - BALANCE_ZERO);
+#endif	
+		return 0;
+
+	case EMPEG_MIXER_READ_BALANCE_DB:
+	{
+		int db;
+		db = balance_table[dev->balance].db;
+		put_user_ret(db, (int *)arg, -EFAULT);
+#if MIXER_DEBUG
+		printk(MIXER_NAME
+		       ": mixer_ioctl EMPEG_MIXER_READ_BALANCE_DB == %d\n",
+		       db);
+#endif	
+		return 0;
+	}
+	case EMPEG_MIXER_WRITE_FADE:
+	{
+		int fade_in, fade_out;
+		get_user_ret(fade_in, (int *)arg, -EFAULT);
+		fade_out = fade_in + FADE_ZERO;
+		if (fade_out < 0)
+			return -EINVAL;
+		if (fade_out >= FADE_TABLE_SIZE)
+			return -EINVAL;
+		empeg_mixer_setfade(dev, fade_out);
+		fade_out = dev->fade - FADE_ZERO;
+		put_user_ret(fade_out, (int *)arg, -EFAULT);
+#if MIXER_DEBUG
+		printk(MIXER_NAME
+		       ": mixer_ioctl EMPEG_MIXER_WRITE_FADE %d == %d\n",
+		       fade_in, fade_out);
+#endif	
+		return 0;
+	}
+	case EMPEG_MIXER_READ_FADE:
+		put_user_ret(dev->fade - FADE_ZERO, (int *)arg, -EFAULT);
+#if MIXER_DEBUG
+		printk(MIXER_NAME
+		       ": mixer_ioctl EMPEG_MIXER_READ_FADE %d\n",
+		       dev->fade - FADE_ZERO);
+#endif	
+		return 0;
+	case EMPEG_MIXER_READ_FADE_DB:
+	{
+		int db;
+		db = fade_table[dev->fade].db;
+		put_user_ret(db, (int *)arg, -EFAULT);
+#if MIXER_DEBUG
+		printk(MIXER_NAME
+		       ": mixer_ioctl EMPEG_MIXER_READ_FADE_DB == %d\n",
+		       db);
+#endif	
+		return 0;
+	}
+	case MIXER_WRITE(SOUND_MIXER_VOLUME):
+	{
+		int vol_in, vol_out;
+		get_user_ret(vol_in, (int *)arg, -EFAULT);
+		/* Equalise left and right */
+		vol_out = ((vol_in & 0xFF) + ((vol_in >> 8) & 0xFF))>>1;
+		if (vol_out < 0 || vol_out > 100)
+			return -EINVAL;
+		empeg_mixer_setvolume(dev, vol_out);
+		vol_out = dev->volume;
+		vol_out = (vol_out & 0xFF) + ((vol_out << 8));
+		put_user_ret(vol_out, (int *)arg, -EFAULT);
+#if MIXER_DEBUG
+		printk(MIXER_NAME
+		       ": mixer_ioctl MIXER_WRITE VOLUME %d == %d\n",
+		       vol_in, vol_out);
+#endif	
+		return 0;
+	}
+	case MIXER_READ(SOUND_MIXER_VOLUME):
+	{
+		int vol = dev->volume;
+		vol = (vol & 0xFF) + ((vol << 8));
+		put_user_ret(vol, (int *)arg, -EFAULT);
+#if MIXER_DEBUG
+		printk(MIXER_NAME
+		       ": mixer_ioctl MIXER_READ VOLUME == %d\n",
+		       vol);
+#endif	
+		return 0;
+	}		
+	case EMPEG_MIXER_READ_DB:
+	{
+		int db;
+		db = empeg_mixer_getdb(dev);
+		put_user_ret(db, (int *)arg, -EFAULT);
+#if MIXER_DEBUG
+		printk(MIXER_NAME
+		       ": mixer_ioctl EMPEG_MIXER_READ_DB == %d\n",
+		       db);
+#endif	
+		return 0;
+	}
+
+	case EMPEG_MIXER_READ_ZERO_LEVEL:
+	{
+		int level = VOLUME_ZERO_DB;
+		put_user_ret(level, (int *)arg, -EFAULT);
+#if MIXER_DEBUG
+		printk(MIXER_NAME
+		       ": mixer_ioctl EMPEG_MIXER_READ_ZERO_LEVEL == %d\n",
+		       level);
+#endif	
+		return 0;
+	}
+
+	case EMPEG_MIXER_WRITE_SOURCE:
+	{
+		int source;
+		get_user_ret(source, (int *)arg, -EFAULT);
+#if MIXER_DEBUG
+		printk(MIXER_NAME
+		       ": mixer_ioctl EMPEG_MIXER_WRITE_SOURCE %d\n",
+		       source);
+#endif	
+		if (source & SOUND_MASK_PCM)
+		{
+			empeg_mixer_select_input(INPUT_PCM);
+			dev->input = SOUND_MASK_PCM;
+		}
+		else if (source & SOUND_MASK_RADIO)
+		{
+			empeg_mixer_select_input(INPUT_RADIO_FM);
+			dev->input = SOUND_MASK_RADIO;
+		}
+		else if (source & SOUND_MASK_LINE1)
+		{
+			empeg_mixer_select_input(INPUT_RADIO_AM);
+			dev->input = SOUND_MASK_LINE1;
+		}
+		else if (source & SOUND_MASK_LINE)
+		{
+		        empeg_mixer_select_input(INPUT_AUX);
+			dev->input = SOUND_MASK_LINE;
+		}
+		put_user_ret(dev->input, (int *)arg, -EFAULT);
+		return 0;
+	}
+	case EMPEG_MIXER_READ_SOURCE:
+		dev->input=SOUND_MASK_PCM;
+		put_user_ret(dev->input, (int *)arg, -EFAULT);
+#if MIXER_DEBUG
+		printk(MIXER_NAME
+		       ": mixer_ioctl EMPEG_MIXER_READ_SOURCE == %d\n",
+		       dev->input);
+#endif
+		return 0;
+
+	case EMPEG_MIXER_WRITE_FLAGS:
+	{
+		int flags;
+		get_user_ret(flags, (int *)arg, -EFAULT);
+		dev->flags = flags;
+		empeg_mixer_inflict_flags(dev);
+#if MIXER_DEBUG
+		printk(MIXER_NAME
+		       ": mixer_ioctl EMPEG_MIXER_WRITE_FLAGS %d\n",
+		       flags);
+#endif	
+		return 0;
+	}
+	case EMPEG_MIXER_READ_FLAGS:
+		put_user_ret(dev->flags, (int *)arg, -EFAULT);
+#if MIXER_DEBUG
+		printk(MIXER_NAME
+		       ": mixer_ioctl EMPEG_MIXER_READ_FLAGS == %d\n",
+		       dev->flags);
+#endif	
+		return 0;
+
+	case EMPEG_MIXER_SET_EQ:
+	{
+		struct empeg_eq_section_t sections[20];
+#if MIXER_DEBUG
+		printk(MIXER_NAME
+		       ": mixer_ioctl EMPEG_MIXER_SET_EQ %08lx\n",
+		       arg);
+#endif	
+
+		copy_from_user_ret((void *) sections, (const void *) arg,
+				   sizeof(sections), -EFAULT);
+
+		empeg_mixer_eq_set(sections);
+		empeg_mixer_eq_apply();
+		return 0;
+	}
+	case EMPEG_MIXER_GET_EQ:
+		copy_to_user_ret((void *) arg, (const void *) eq_current,
+				 sizeof(eq_current), -EFAULT);
+		return 0;
+
+	case EMPEG_MIXER_SET_EQ_FOUR_CHANNEL:
+	{
+		int four_chan;
+#if MIXER_DEBUG
+		printk(MIXER_NAME
+		       ": mixer_ioctl EMPEG_MIXER_GET_EQ %08lx\n",
+		       arg);
+#endif
+		
+		copy_from_user_ret((void *) &four_chan, (const void *) arg,
+				   sizeof(int), -EFAULT);
+
+		eq_reg_last &= 0xefff;
+		eq_reg_last |= ((four_chan & 1) ^ 1) << 12;
+		if(four_chan)
+			dsp_write(Y_OutSwi, 0xa85);
+		else
+			dsp_write(Y_OutSwi, 0xa7c);
+		dsp_write(0xffd, eq_reg_last);
+		return 0;
+	}
+	case EMPEG_MIXER_GET_EQ_FOUR_CHANNEL:
+	{
+		int four_chan;
+#if MIXER_DEBUG
+		printk(MIXER_NAME
+		       ": mixer_ioctl EMPEG_MIXER_GET_EQ_FOUR_CHANNEL %08lx\n",
+		       arg);
+#endif
+
+		four_chan = ((eq_reg_last >> 12) & 1) ^ 1;
+		copy_to_user_ret((void *) arg, (const void *) &four_chan,
+				 sizeof(int), -EFAULT);
+		return 0;
+	}
+	case EMPEG_MIXER_GET_COMPRESSION:
+#if MIXER_DEBUG
+		printk(MIXER_NAME
+		       ": mixer_ioctl EMPEG_MIXER_GET_COMPRESSION %08lx\n",
+		       arg);
+#endif
+
+		copy_to_user_ret((void *) arg,
+				 (const void *) &mixer_compression,
+				 sizeof(int), -EFAULT);
+		return 0;
+
+	case EMPEG_MIXER_SET_COMPRESSION:
+	{
+		int onoff;
+
+#if MIXER_DEBUG
+		printk(MIXER_NAME
+		       ": mixer_ioctl EMPEG_MIXER_SET_COMPRESSION %08lx\n",
+		       arg);
+#endif
+
+		copy_from_user_ret((void *) &onoff, (const void *) arg,
+				   sizeof(int), -EFAULT);
+		if(onoff)
+			dsp_write(Y_compry0st_28, 0x7ab);// turn on compression
+		else
+			dsp_write(Y_compry0st_28, 0x5a);// turn off compression
+		mixer_compression = onoff;
+		return 0;
+	}
+	case EMPEG_MIXER_SET_SAM:
+	{
+		int sam;
+
+		copy_from_user_ret((void *) &sam, (const void *) arg,
+				   sizeof(int), -EFAULT);
+
+       		if(sam) dsp_write(Y_switch, 0);
+		else dsp_write(Y_switch, 0x5d4);	// 4.6ms
+		
+#if MIXER_DEBUG
+		printk(MIXER_NAME
+		       ": mixer_ioctl EMPEG_MIXER_SET_SAM %d\n",
+		       sam);
+#endif
+
+		return 0;
+	}
+	case EMPEG_MIXER_RAW_I2C_READ:
+	{
+		int reg, val;
+
+		copy_from_user_ret((void *) &reg, (const void *) arg,
+				   sizeof(int), -EFAULT);
+		if(reg < 0x800)
+			dsp_read_xram(reg, &val);
+		else
+			dsp_read_yram(reg, &val);
+		copy_to_user_ret((void *) arg, (const void *) &val,
+				 sizeof(int), -EFAULT);
+		return 0;
+	}
+	case EMPEG_MIXER_RAW_I2C_WRITE:
+	{
+		int reg, val;
+		int *block = (int *) arg;
+
+		copy_from_user_ret((void *) &reg, (const void *) block,
+				   sizeof(int), -EFAULT);
+		copy_from_user_ret((void *) &val, (const void *) (block+1),
+				   sizeof(int), -EFAULT);
+		
+		dsp_write(reg, val);
+		return 0;
+	}
+	case EMPEG_MIXER_WRITE_SENSITIVITY:
+	{
+		int val;
+
+		copy_from_user_ret((void *) &val, (const void *) arg,
+				   sizeof(int), -EFAULT);
+		if(val < 0 || val > 7)
+			return -EINVAL;
+		radio_sensitivity = (val << 1) | (val << 4) | 0x1000;
+		dsp_write(0xffd, radio_sensitivity);
+		return 0;
+	}
+	case EMPEG_MIXER_READ_SIGNAL_STRENGTH:
+	{
+		int strength = empeg_mixer_get_fm_level();
+		copy_to_user_ret((int *) arg, &strength, sizeof(int),
+				 -EFAULT);
+		return 0;
+	}
+	case EMPEG_MIXER_READ_SIGNAL_STRENGTH_FAST:
+	{
+		int strength = empeg_mixer_get_fm_level_fast();
+		copy_to_user_ret((int *) arg, &strength, sizeof(int),
+				 -EFAULT);
+		return 0;
+	}
+	case EMPEG_MIXER_READ_SIGNAL_STEREO:
+	{
+		int stereo = empeg_mixer_get_stereo();
+		copy_to_user_ret((int *) arg, &stereo, sizeof(int),
+				 -EFAULT);
+		return 0;
+	}
+	case EMPEG_MIXER_READ_SIGNAL_NOISE:
+	{
+		int noise = empeg_mixer_get_fm_noise();
+		copy_to_user_ret((int *) arg, &noise, sizeof(int),
+				 -EFAULT);
+		return 0;
+	}
+	case EMPEG_MIXER_READ_SIGNAL_MULTIPATH:
+	{
+		int multipath = empeg_mixer_get_multipath();
+		copy_to_user_ret((int *) arg, &multipath, sizeof(int),
+				-EFAULT);
+		return 0;
+	}  
+	case EMPEG_MIXER_READ_LEVEL_ADJUST:
+	{
+		int adjust[2];
+		adjust[0] = radio_fm_level_p1;
+		adjust[1] = radio_fm_level_q1;
+		copy_to_user_ret((int *) arg, (int *) &adjust[0],
+				 2 * sizeof(int), -EFAULT);
+		return 0;
+	}
+	case EMPEG_MIXER_WRITE_LEVEL_ADJUST:
+	{
+		int adjust[2];
+		copy_from_user_ret((int *) &adjust[0], (int *) arg,
+				   2 * sizeof(int), -EFAULT);
+		empeg_mixer_set_fm_level(adjust[0], adjust[1]);
+		return 0;
+	}
+#if 0
+	case EMPEG_MIXER_READ_FM_AM_SELECT:
+	{
+		int select = empeg_mixer_get_fm_am_select();
+		copy_to_user_ret((int *) arg, &select, sizeof(int), -EFAULT);
+		return 0;
+	}
+	case EMPEG_MIXER_WRITE_FM_AM_SELECT:
+	{
+		int select;
+		copy_from_user_ret(&select, (int *) arg, sizeof(int), -EFAULT);
+		if(select < 0 || select > 1)
+			return -EINVAL;
+		empeg_mixer_set_fm_am_select(select);
+		return 0;
+	}
+#endif
+	case EMPEG_MIXER_READ_FM_DEEMPHASIS:
+		copy_to_user_ret((int *) arg, &radio_fm_deemphasis,
+				 sizeof(int), -EFAULT);
+		return 0;
+	case EMPEG_MIXER_WRITE_FM_DEEMPHASIS:
+	{
+		int setting;
+		copy_from_user_ret(&setting, (int *) arg, sizeof(int),
+				   -EFAULT);
+		return empeg_mixer_set_fm_deemphasis(setting);
+	}
+	default:
+		return -EINVAL;
+	}
+}
+
+static void empeg_mixer_setloudness(mixer_dev *dev, int level)
+{
+	static dsp_setup dynlou_41[] = {
+		{ Y_KLCl, 0x347 }, /* p79, 100Hz */
+		{ Y_KLCh, 0x7dc },
+		{ Y_KLBl, 0x171 },
+		{ Y_KLBh, 0xc23 },
+		{ Y_KLA0l, 0x347 },
+		{ Y_KLA0h, 0x000 },
+		{ Y_KLA2l, 0x000 },
+		{ Y_KLA2h, 0x000 },
+		{ Y_KLmid,0x200 },
+		{ Y_Cllev,0x400 },
+		{ Y_Ctre, 0x000 },
+		{ Y_OFFS, 0x100 },
+		{ Y_statLou, 0x7ff }, /* p84, 10.5678dB boost */
+		{ Y_louSwi, 0x910 },
+		{ 0,0 }
+	};
+	       
+	static dsp_setup louoff[]= {
+		{ Y_louSwi, 0x90d },
+		{ Y_statLou, 0x7ff },
+		{ 0,0 }
+	};
+
+	if (level < 0)
+		level = 0;
+	if (level >= LOUDNESS_TABLE_SIZE)
+		level = LOUDNESS_TABLE_SIZE - 1;
+		
+	if (level) {
+		dsp_patchmulti(dynlou_41, Y_Cllev,
+			       loudness_table[level].Cllev);
+		dsp_writemulti(dynlou_41);
+	}
+	else {
+		dsp_writemulti(louoff);
+	}
+	dev->loudness = level;
+}
+
+static int empeg_mixer_getloudnessdb(mixer_dev *dev)
+{
+	return loudness_table[dev->loudness].db;
+}
+
+static void empeg_mixer_setbalance(mixer_dev *dev, int balance)
+{
+	dsp_write(Y_BALL0, balance_table[balance].ball/8);
+	dsp_write(Y_BALL1, balance_table[balance].ball/8);
+	dsp_write(Y_BALR0, balance_table[balance].balr/8);
+	dsp_write(Y_BALR1, balance_table[balance].balr/8);
+	dev->balance = balance;
+}
+
+static void empeg_mixer_setfade(mixer_dev *dev, int fade)
+{
+	dsp_setup bal[]	= {
+		{ Y_FLcof, 0x800 },
+		{ Y_FRcof, 0x800 },
+		{ Y_RLcof, 0x800 },
+		{ Y_RRcof, 0x800 },
+		{ 0, 0 }
+	};
+
+	dsp_patchmulti(bal, Y_FLcof, fade_table[fade].Fcof);
+	dsp_patchmulti(bal, Y_FRcof, fade_table[fade].Fcof);
+	dsp_patchmulti(bal, Y_RLcof, fade_table[fade].Rcof);
+	dsp_patchmulti(bal, Y_RRcof, fade_table[fade].Rcof);
+	dsp_writemulti(bal);
+	dev->fade = fade;
+}
+
+static void empeg_mixer_mute(int on)
+{
+	if (on)
+		GPCR = EMPEG_DSPPOM;
+	else
+		GPSR = EMPEG_DSPPOM;
+#if MIXER_DEBUG
+	printk(MIXER_NAME ": mixer_mute %s\n",on?"on":"off");
+#endif
+}
+
+static void empeg_mixer_select_input(int input)
+{
+	static dsp_setup fm_setup[]=
+	{ { 0xfff, 0x5323 },
+	  { 0xffe, 0x28ed },
+	  { 0xffd, 0x1000 }, /* also in case statement */
+	  { 0xffc, 0x0086 }, /* level IAC off=e080 */
+	  { 0xffb, 0x0aed },
+	  { 0xffa, 0x1048 },
+	  { 0xff9, 0x0020 }, /* no I2S out */
+	  { 0xff3, 0x0000 },
+	  { 0,0 } };
+	
+	static dsp_setup am_setup[]=
+	{ { 0xfff, 0xd223 },
+	  { 0xffe, 0x28ed },
+	  { 0xffd, 0x1000 }, /* also in case statement */
+	  { 0xffc, 0x0000 }, /* level IAC off=e080 */
+	  { 0xffb, 0x0aed },
+	  { 0xffa, 0x1044 },
+	  { 0xff9, 0x0000 }, /* no I2S out */
+	  { 0xff3, 0x0000 },
+	  { 0,0 } };
+	
+	static dsp_setup mpeg_setup[]=
+	{ { 0xfff, 0xd223 },
+	  { 0xffe, 0x28ed },
+	  { 0xffd, 0x1000 }, /* also in case statement */
+	  { 0xffc, 0xe086 },
+	  { 0xffb, 0x0aed },
+	  { 0xffa, 0x1048 },
+	  { 0xff9, 0x1240 }, /* I2S input */
+	  { 0xff3, 0x0000 },
+	  { 0,0 } };
+
+	// Auxillary is on CD Analogue input
+	static dsp_setup aux_setup[] =
+	{ { 0xfff, 0xd223 }, /*DCS_ConTRol*/
+	  { 0xffe, 0x28ed }, /*DCS_DIVide*/
+	  { 0xffd, 0x1000 }, /* also in case statement */
+	  { 0xffc, 0x6080 }, /*LEVEL_IAC*/
+	  { 0xffb, 0x0aed }, /*IAC*/
+	  { 0xffa, 0x904a }, /*SEL*/
+	  { 0xff9, 0x0000 }, /*HOST*/ /* no I2S out */
+	  { 0xff3, 0x0000 }, /*RDS_CONTROL*/
+	  { 0,0 } };
+
+	eq_reg_last = radio_sensitivity;
+	dsp_patchmulti(fm_setup, 0xffd, eq_reg_last);
+	dsp_patchmulti(mpeg_setup, 0xffd, eq_reg_last);
+	dsp_patchmulti(aux_setup, 0xffd, eq_reg_last);
+		
+	/* Ensure any beeps playing are off,
+	   because this may block for some time */
+	dsp_write(Y_sinusMode, 0x89a);
+	
+	/* POM low - hardware mute */ 
+	empeg_mixer_mute(1);
+
+	switch(input) {
+	case INPUT_RADIO_FM: /* FM */
+	  /* FM mode: see p64 */
+		dsp_writemulti(fm_setup);
+		
+		/* Easy programming set 2, FM */
+		dsp_write(X_modpntr,0x600);
+		
+		/* Release POM if it wasn't already released*/
+		if (!(mixer_global.flags & EMPEG_MIXER_FLAG_MUTE))
+			empeg_mixer_mute(0);
+		
+		/* Disable DSP_IN1 mute control */
+		dsp_write(Y_EMute,0x000);
+		dsp_write(Y_EMuteF1,0x000);
+		
+		/* Select mode */
+		dsp_write(X_modpntr,0x080);
+		
+		/* signal strength, X:levn, X:leva
+		   X:levn = X:leva (unfiltered) = 4(D:level*Y:p1+Y:q1)
+		*/
+		if(empeg_hardwarerevision() < 6) {
+			/* FM Level adjustment */
+			empeg_mixer_set_fm_level(2047, -84);
+			
+			/* ok let's just turn everything off */
+
+			/* disable Softmute f(level) */
+			dsp_write(Y_p2, 0x000);
+			dsp_write(Y_q2, 0x7ff);
+
+			/* No FM attenuation due to low level */
+			dsp_write(Y_minsmtc, 0x7ff);
+			dsp_write(Y_minsmtcn, 0x7ff);
+
+			// multipath detection, X:mlta
+			//		dsp_write(Y_c1, -974);
+			dsp_write(Y_c1, -2048);
+			// disable Softmute f(noise)
+			dsp_write(Y_p7, 0x000);
+			dsp_write(Y_q7, 0x7ff);
+			// disable Stereo f(level)
+			dsp_write(Y_p3, 0x000);
+			dsp_write(Y_q3, 0x7ff);
+			// disable Stereo f(noise)
+			//		dsp_write(Y_E_strnf_str, 0x7ff);
+			// disable Stereo f(multipath)
+			dsp_write(Y_E_mltp_str, 0x7ff);
+			// disable Response f(level)
+			dsp_write(Y_p5, 0x000);
+			dsp_write(Y_q5, 0x7ff);
+			// disable Response f(noise)
+			dsp_write(Y_E_strnf_rsp, 0x7ff);
+			dsp_write(Y_E_mltp_rsp, 0x7ff);
+		}
+		else {
+			/* FM Level adjustment */
+			empeg_mixer_set_fm_level(1129, -120);
+
+			/* Level -> Softmute */
+			dsp_write(Y_p2, 559);
+			dsp_write(Y_q2, 47);
+
+			/* Level -> Stereo */
+			dsp_write(Y_p3, 1078);
+			dsp_write(Y_q3, -373);
+
+			/* Level -> Response */
+			dsp_write(Y_p5, 904);
+			dsp_write(Y_q5, -135);
+			
+			/* Max attenuation from level */
+			/* Defaults */
+			
+			/* Max attenuation from noise */
+			/* Defaults */
+			
+			/* Noise -> Stereo and Response */
+			dsp_write(Y_E_strnf_str, 0);
+			dsp_write(Y_E_strnf_rsp, 0);
+
+			/* Multipath -> Stereo and Response */
+			dsp_write(Y_E_mltp_str, 0);
+			dsp_write(Y_E_mltp_rsp, 0);
+		}
+
+		/* use str_corr method of de-emphasis/adaptation */
+		dsp_write(Y_sdr_d_c, 0x7ff);
+		/* defaults to -12dB at 10kHz max attenuation */
+
+		/* set for last known de-emphasis */
+		empeg_mixer_set_fm_deemphasis(radio_fm_deemphasis);
+		
+		/* we want the 38kHz tone table */
+		empeg_audio_beep_setup(38000);
+		break;    
+		
+	case INPUT_RADIO_AM: /* AM */
+		/* AM mode: see p64 */
+		dsp_writemulti(am_setup);
+		
+		/* Easy programming set 3, AM */
+		dsp_write(X_modpntr, 0x640);
+		
+		/* Release POM if it wasn't already released*/
+		if (!(mixer_global.flags & EMPEG_MIXER_FLAG_MUTE))
+			empeg_mixer_mute(0);
+		
+		/* Disable DSP_IN1 mute control */
+		dsp_write(Y_EMute, 0x000);
+		dsp_write(Y_EMuteF1, 0x000);
+		
+		/* Select mode */
+		dsp_write(X_modpntr, 0x300);
+		
+		/* FM Level adjustment */
+		empeg_mixer_set_fm_level(1129, -120);
+		
+#if 0
+		dsp_write(Y_AMb02 +  0, 0x000);
+		dsp_write(Y_AMb02 +  1, 0x400);
+		dsp_write(Y_AMb02 +  2, 0x000);
+		dsp_write(Y_AMb02 +  3, 0x000);
+		dsp_write(Y_AMb02 +  4, 0x000);
+		dsp_write(Y_AMb02 +  5, 0x000);
+		dsp_write(Y_AMb02 +  6, 0x400);
+		dsp_write(Y_AMb02 +  7, 0x000);
+		dsp_write(Y_AMb02 +  8, 0x000);
+		dsp_write(Y_AMb02 +  9, 0x000);
+		dsp_write(Y_AMb02 + 10, 0x000);
+		dsp_write(Y_AMb02 + 11, 0x400);
+		dsp_write(Y_AMb02 + 12, 0x000);
+		dsp_write(Y_AMb02 + 13, 0x000);
+		dsp_write(Y_AMb02 + 14, 0x000);
+#else
+		dsp_write(Y_p12, 0x000);
+		dsp_write(Y_q12, 0x7ff);
+		dsp_write(Y_p13, 0x000);
+		dsp_write(Y_p13, 0x7ff);
+#endif
+		
+		// we want the 38kHz tone table
+		empeg_audio_beep_setup(38000);
+		break;    
+		
+	case INPUT_PCM: /* MPEG */
+		/* I2S input mode: see p64 */
+		dsp_writemulti(mpeg_setup);
+
+		/* Easy programming set 4, CD */
+		dsp_write(X_modpntr,0x5c0);
+		
+		/* Release POM */
+		/* Why do we do it now? Why not wait until after we've set the
+		   mode? */
+		if (!(mixer_global.flags & EMPEG_MIXER_FLAG_MUTE))
+			empeg_mixer_mute(0);
+
+		/* Wait for a while so that the I2S being clocked into the
+		   DSP by DMA runs the initialisation code: the DSP is cycle-
+		   locked to the incoming bitstream */
+		{ int a=jiffies+(HZ/20); while(jiffies<a); }
+		
+		/* Select mode */
+		dsp_write(X_modpntr,0x0200);
+
+		// we want the 44.1kHz tone table
+		empeg_audio_beep_setup(44100);
+		break;
+		
+	case INPUT_AUX:
+		/* AUX mode: see p64 */
+		dsp_writemulti(aux_setup);
+		
+		/* Easy programming set 3, AUX - see page 68 */
+		dsp_write(X_modpntr,0x5c0);
+		
+		/* Release POM */
+		GPSR=GPIO_GPIO15;
+		
+		/* Disable DSP_IN1 mute control */
+		dsp_write(Y_EMute,0x000);
+		dsp_write(Y_EMuteF1,0x000);
+
+		/* Select mode */
+		dsp_write(X_modpntr,0x200);
+
+		// we want the 44.1kHz tone table
+		empeg_audio_beep_setup(44100);
+		break;    
+	}
+}
+
+static int empeg_mixer_setvolume(mixer_dev *dev, int vol)
+{
+	dsp_write(Y_VAT, volume_table[vol].vat);
+	dsp_write(Y_VGA, volume_table[vol].vga);
+	dev->volume = vol;
+
+#if MIXER_DEBUG
+	printk(MIXER_NAME ": volume set %d VAT:%03x VGA:%03x\n",vol,
+	       volume_table[vol].vat,volume_table[vol].vga);
+#endif
+	return vol;
+}
+
+static int empeg_mixer_getdb(mixer_dev *dev)
+{
+	return volume_table[dev->volume].db;
+}
+
+static void empeg_mixer_inflict_flags(mixer_dev *dev)
+{
+	unsigned int flags = dev->flags;
+	empeg_mixer_mute(flags & EMPEG_MIXER_FLAG_MUTE);
+}
+
+static void empeg_mixer_eq_set(struct empeg_eq_section_t *sections)
+{
+	int i, order;
+	
+	for(i=0; i<20; i++) {
+		eq_current[i].word1 = sections[i].word1;
+		eq_current[i].word2 = sections[i].word2;
+
+		order = eq_section_order[i];
+		eq_last[i] = sections[order].word1;
+		eq_last[i+20] = sections[order].word2;
+	}
+}
+
+static void empeg_mixer_eq_reset(void)
+{
+	empeg_mixer_eq_set(eq_init);
+}
+
+void empeg_mixer_eq_apply(void)
+{
+	i2c_write(IICD_DSP, 0xf80, eq_last, 40);
+}
+
+int empeg_mixer_get_fm_level_fast(void)
+{
+	unsigned level;
+
+	if (dsp_read_xram(X_levn, &level) < 0) {
+		return -1;
+	}
+
+	level >>= 1;
+	if(level >= 65536) level = 0;	// negative
+	
+	return (int) level;
+}
+
+int empeg_mixer_get_fm_level(void)
+{
+	unsigned level;
+
+	if (dsp_read_xram(X_leva, &level) < 0) {
+		return -1;
+	}
+
+	level >>= 1;
+	if(level >= 65536) level = 0;	// negative
+	
+	return (int) level;
+}
+
+static int empeg_mixer_get_fm_noise(void)
+{
+	unsigned noise;
+
+	if (dsp_read_xram(X_noisflt, &noise) < 0)
+		return -1;
+
+	/* Convert 18 bit signed to 16 bit unsigned abs */
+	noise >>= 1;
+	if(noise >= 65536) noise = (-noise) & 65535;
+
+	return (int) noise;
+}
+
+static void empeg_mixer_set_fm_level(unsigned int p1, unsigned int q1)
+{
+	// sign extend
+	if(p1 & 2048)
+		p1 = - (((~p1) & 2047) + 1);
+	if(q1 & 2048)
+		q1 = - (((~q1) & 2047) + 1);
+
+	radio_fm_level_p1 = p1;
+	radio_fm_level_q1 = q1;
+
+	dsp_write(Y_p1, p1);
+	dsp_write(Y_q1, q1);
+}
+
+void empeg_mixer_clear_stereo(void)
+{
+	stereo_level = 0;
+}
+
+void empeg_mixer_set_stereo(int on)
+{
+	if(on)
+		dsp_write(Y_stro, 0x7ff);
+	else
+		dsp_write(Y_stro, 0);
+}
+
+int empeg_mixer_get_stereo(void)
+{
+	unsigned pltd;
+
+	if (dsp_read_xram(X_pltd, &pltd) < 0)
+		return -1;
+
+	return pltd;
+}
+
+int empeg_mixer_get_multipath(void)
+{
+	unsigned mlta;
+
+	if (dsp_read_xram(X_mlta, &mlta) < 0) {
+		return -1;
+	}
+
+	/* Convert 18 bit signed to 16 bit unsigned abs */
+	mlta >>= 1;
+	if(mlta >= 65536) mlta = (-mlta) & 65535;
+
+	return (int) mlta;
+}
+
+int empeg_mixer_get_vat(void)
+{
+	return volume_table[mixer_global.volume].vat;
+}
+
+static int empeg_mixer_set_fm_deemphasis(int which)
+{
+    unsigned c61, c91;
+    if(which == 50) {
+	c61 = 0x4b8;
+	c91 = 0x347;
+    }
+    else if(which == 75) {
+	c61 = 0x59e;
+	c91 = 0x260;
+    }
+    else
+	return -EINVAL;
+    
+    dsp_write(Y_c61, c61);
+    dsp_write(Y_c91, c91);
+    radio_fm_deemphasis = which;
+    return 0;
+}
+
+static volume_entry volume_table[101] =
+{
+	{ 0x000, 0xf80, -9999 }, /* Zero */
+	{ 0xfff, 0xf80, -6620 }, /* -66.2 dB intensity 0.023988 */
+	{ 0xffe, 0xf80, -6270 }, /* -62.7 dB intensity 0.053703 */
+	{ 0xffd, 0xf80, -5820 }, /* -58.2 dB intensity 0.151356 */
+	{ 0xffc, 0xf80, -5530 }, /* -55.3 dB intensity 0.295121 */
+	{ 0xffb, 0xf80, -5310 }, /* -53.1 dB intensity 0.489779 */
+	{ 0xffa, 0xf80, -5140 }, /* -51.4 dB intensity 0.724436 */
+	{ 0xff9, 0xf80, -4990 }, /* -49.9 dB intensity 1.023293 */
+	{ 0xff8, 0xf80, -4870 }, /* -48.7 dB intensity 1.348963 */
+	{ 0xff7, 0xf80, -4760 }, /* -47.6 dB intensity 1.737801 */
+	{ 0xff6, 0xf80, -4660 }, /* -46.6 dB intensity 2.187762 */
+	{ 0xff5, 0xf80, -4580 }, /* -45.8 dB intensity 2.630268 */
+	{ 0xff4, 0xf80, -4500 }, /* -45.0 dB intensity 3.162278 */
+	{ 0xff3, 0xf80, -4420 }, /* -44.2 dB intensity 3.801894 */
+	{ 0xff2, 0xf80, -4360 }, /* -43.6 dB intensity 4.365158 */
+	{ 0xff1, 0xf80, -4290 }, /* -42.9 dB intensity 5.128614 */
+	{ 0xff0, 0xf80, -4240 }, /* -42.4 dB intensity 5.754399 */
+	{ 0xfef, 0xf80, -4180 }, /* -41.8 dB intensity 6.606934 */
+	{ 0xfed, 0xf80, -4080 }, /* -40.8 dB intensity 8.317638 */
+	{ 0xfeb, 0xf80, -3990 }, /* -39.9 dB intensity 10.232930 */
+	{ 0xfe9, 0xf80, -3910 }, /* -39.1 dB intensity 12.302688 */
+	{ 0xfe7, 0xf80, -3840 }, /* -38.4 dB intensity 14.454398 */
+	{ 0xfe4, 0xf80, -3740 }, /* -37.4 dB intensity 18.197009 */
+	{ 0xfe1, 0xf80, -3650 }, /* -36.5 dB intensity 22.387211 */
+	{ 0xfde, 0xf80, -3570 }, /* -35.7 dB intensity 26.915348 */
+	{ 0xfdb, 0xf80, -3490 }, /* -34.9 dB intensity 32.359366 */
+	{ 0xfd8, 0xf80, -3420 }, /* -34.2 dB intensity 38.018940 */
+	{ 0xfd5, 0xf80, -3360 }, /* -33.6 dB intensity 43.651583 */
+	{ 0xfd2, 0xf80, -3300 }, /* -33.0 dB intensity 50.118723 */
+	{ 0xfcf, 0xf80, -3250 }, /* -32.5 dB intensity 56.234133 */
+	{ 0xfcb, 0xf80, -3180 }, /* -31.8 dB intensity 66.069345 */
+	{ 0xfc7, 0xf80, -3110 }, /* -31.1 dB intensity 77.624712 */
+	{ 0xfc3, 0xf80, -3050 }, /* -30.5 dB intensity 89.125094 */
+	{ 0xfbf, 0xf80, -3000 }, /* -30.0 dB intensity 100.000000 */
+	{ 0xfbb, 0xf80, -2950 }, /* -29.5 dB intensity 112.201845 */
+	{ 0xfb7, 0xf80, -2900 }, /* -29.0 dB intensity 125.892541 */
+	{ 0xfb3, 0xf80, -2850 }, /* -28.5 dB intensity 141.253754 */
+	{ 0xfaf, 0xf80, -2810 }, /* -28.1 dB intensity 154.881662 */
+	{ 0xfab, 0xf80, -2760 }, /* -27.6 dB intensity 173.780083 */
+	{ 0xfa7, 0xf80, -2720 }, /* -27.2 dB intensity 190.546072 */
+	{ 0xfa2, 0xf80, -2680 }, /* -26.8 dB intensity 208.929613 */
+	{ 0xf9e, 0xf80, -2640 }, /* -26.4 dB intensity 229.086765 */
+	{ 0xf99, 0xf80, -2600 }, /* -26.0 dB intensity 251.188643 */
+	{ 0xf93, 0xf80, -2550 }, /* -25.5 dB intensity 281.838293 */
+	{ 0xf8d, 0xf80, -2500 }, /* -25.0 dB intensity 316.227766 */
+	{ 0xf86, 0xf80, -2450 }, /* -24.5 dB intensity 354.813389 */
+	{ 0xf7f, 0xf80, -2400 }, /* -24.0 dB intensity 398.107171 */
+	{ 0xf77, 0xf80, -2350 }, /* -23.5 dB intensity 446.683592 */
+	{ 0xf6f, 0xf80, -2300 }, /* -23.0 dB intensity 501.187234 */
+	{ 0xf66, 0xf80, -2250 }, /* -22.5 dB intensity 562.341325 */
+	{ 0xf5d, 0xf80, -2200 }, /* -22.0 dB intensity 630.957344 */
+	{ 0xf54, 0xf80, -2150 }, /* -21.5 dB intensity 707.945784 */
+	{ 0xf49, 0xf80, -2100 }, /* -21.0 dB intensity 794.328235 */
+	{ 0xf3f, 0xf80, -2050 }, /* -20.5 dB intensity 891.250938 */
+	{ 0xf33, 0xf80, -2000 }, /* -20.0 dB intensity 1000.000000 */
+	{ 0xf27, 0xf80, -1950 }, /* -19.5 dB intensity 1122.018454 */
+	{ 0xf1a, 0xf80, -1900 }, /* -19.0 dB intensity 1258.925412 */
+	{ 0xf0d, 0xf80, -1850 }, /* -18.5 dB intensity 1412.537545 */
+	{ 0xefe, 0xf80, -1800 }, /* -18.0 dB intensity 1584.893192 */
+	{ 0xeef, 0xf80, -1750 }, /* -17.5 dB intensity 1778.279410 */
+	{ 0xedf, 0xf80, -1700 }, /* -17.0 dB intensity 1995.262315 */
+	{ 0xece, 0xf80, -1650 }, /* -16.5 dB intensity 2238.721139 */
+	{ 0xebb, 0xf80, -1600 }, /* -16.0 dB intensity 2511.886432 */
+	{ 0xea8, 0xf80, -1550 }, /* -15.5 dB intensity 2818.382931 */
+	{ 0xe94, 0xf80, -1500 }, /* -15.0 dB intensity 3162.277660 */
+	{ 0xe7e, 0xf80, -1450 }, /* -14.5 dB intensity 3548.133892 */
+	{ 0xe67, 0xf80, -1400 }, /* -14.0 dB intensity 3981.071706 */
+	{ 0xe4f, 0xf80, -1350 }, /* -13.5 dB intensity 4466.835922 */
+	{ 0xe36, 0xf80, -1300 }, /* -13.0 dB intensity 5011.872336 */
+	{ 0xe1a, 0xf80, -1250 }, /* -12.5 dB intensity 5623.413252 */
+	{ 0xdfe, 0xf80, -1200 }, /* -12.0 dB intensity 6309.573445 */
+	{ 0xddf, 0xf80, -1150 }, /* -11.5 dB intensity 7079.457844 */
+	{ 0xdbf, 0xf80, -1100 }, /* -11.0 dB intensity 7943.282347 */
+	{ 0xd9d, 0xf80, -1050 }, /* -10.5 dB intensity 8912.509381 */
+	{ 0xd78, 0xf80, -1000 }, /* -10.0 dB intensity 10000.000000 */
+	{ 0xd52, 0xf80, -950 }, /* -9.5 dB intensity 11220.184543 */
+	{ 0xd29, 0xf80, -900 }, /* -9.0 dB intensity 12589.254118 */
+	{ 0xcfe, 0xf80, -850 }, /* -8.5 dB intensity 14125.375446 */
+	{ 0xcd1, 0xf80, -800 }, /* -8.0 dB intensity 15848.931925 */
+	{ 0xca0, 0xf80, -750 }, /* -7.5 dB intensity 17782.794100 */
+	{ 0xc6d, 0xf80, -700 }, /* -7.0 dB intensity 19952.623150 */
+	{ 0xc37, 0xf80, -650 }, /* -6.5 dB intensity 22387.211386 */
+	{ 0xbfe, 0xf80, -600 }, /* -6.0 dB intensity 25118.864315 */
+	{ 0xbc1, 0xf80, -550 }, /* -5.5 dB intensity 28183.829313 */
+	{ 0xb80, 0xf80, -500 }, /* -5.0 dB intensity 31622.776602 */
+	{ 0xb3c, 0xf80, -450 }, /* -4.5 dB intensity 35481.338923 */
+	{ 0xaf4, 0xf80, -400 }, /* -4.0 dB intensity 39810.717055 */
+	{ 0xa56, 0xf80, -300 }, /* -3.0 dB intensity 50118.723363 */
+	{ 0x9a5, 0xf80, -200 }, /* -2.0 dB intensity 63095.734448 */
+	{ 0x8df, 0xf80, -100 }, /* -1.0 dB intensity 79432.823472 */
+	{ 0x800, 0xf80, 0 }, /* 0.0 dB intensity 100000.000000 */
+	{ 0x800, 0xf70, 100 }, /* 1.0 dB intensity 125892.541179 */
+	{ 0x800, 0xf5f, 200 }, /* 2.0 dB intensity 158489.319246 */
+	{ 0x800, 0xf4b, 300 }, /* 3.0 dB intensity 199526.231497 */
+	{ 0x800, 0xf35, 400 }, /* 4.0 dB intensity 251188.643151 */
+	{ 0x800, 0xf1c, 500 }, /* 5.0 dB intensity 316227.766017 */
+	{ 0x800, 0xf01, 600 }, /* 6.0 dB intensity 398107.170554 */
+	{ 0x800, 0xee1, 700 }, /* 7.0 dB intensity 501187.233627 */
+	{ 0x800, 0xebe, 800 }, /* 8.0 dB intensity 630957.344480 */
+	{ 0x800, 0xe97, 900 }, /* 9.0 dB intensity 794328.234724 */
+	{ 0x800, 0xe6c, 1000 }, /* 10.0 dB intensity 1000000.000000 */
+/*	{ 0x800, 0xe6c, 1000 }, */ /* 10.0 dB intensity 1000000.000000 */
+};
+
+static loudness_entry loudness_table[LOUDNESS_TABLE_SIZE] =
+{
+	{ 0x0, 0 }, /* 0.0 dB */
+        { 0x30, 150 }, /* 1.5 dB */
+        { 0x6a, 300 }, /* 3.0 dB */
+        { 0xae, 450 }, /* 4.5 dB */
+        { 0xff, 600 }, /* 6.0 dB */
+        { 0x15f, 750 }, /* 7.5 dB */
+        { 0x1d2, 900 }, /* 9.0 dB */
+        { 0x25a, 1050 }, /* 10.5 dB */
+        { 0x2fb, 1200 }, /* 12.0 dB */
+        { 0x378, 1300 }, /* 13.0 dB */
+        { 0x400, 1400 }, /* 14.0 dB */
+};
+
+static balance_entry balance_table[BALANCE_TABLE_SIZE] =
+{
+	{ 0x41, 0x7ff, -3000 }, /* -30.0 dB */
+        { 0x102, 0x7ff, -1800 }, /* -18.0 dB */
+        { 0x1ca, 0x7ff, -1300 }, /* -13.0 dB */
+        { 0x393, 0x7ff, -700 }, /* -7.0 dB */
+	
+        { 0x4c4, 0x7ff, -450 }, /* -4.5 dB */
+        { 0x5aa, 0x7ff, -300 }, /* -3.0 dB */	
+        { 0x6bb, 0x7ff, -150 }, /* -1.5 dB */
+	
+	{ 0x7ff, 0x7ff, 0 }, /*  0.0 dB */
+
+        { 0x7ff, 0x6bb, 150 }, /* 1.5 dB */
+        { 0x7ff, 0x5aa, 300 }, /* 3.0 dB */
+        { 0x7ff, 0x4c4, 450 }, /* 4.5 dB */
+
+        { 0x7ff, 0x393, 700 }, /* 7.0 dB */
+        { 0x7ff, 0x1ca, 1300 }, /* 13.0 dB */
+        { 0x7ff, 0x102, 1800 }, /* 18.0 dB */
+        { 0x7ff, 0x41, 3000 }, /* 30.0 dB */
+};	    
+
+static fade_entry fade_table[FADE_TABLE_SIZE] =
+{
+        { 0xfbf, 0x800, -3000 }, /* -30.0 dB */
+        { 0xefe, 0x800, -1800 }, /* -18.0 dB */
+        { 0xe36, 0x800, -1300 }, /* -13.0 dB */
+        { 0xc6d, 0x800, -700 }, /* -7.0 dB */
+
+        { 0xb3c, 0x800, -450 }, /* -4.5 dB */
+        { 0xa56, 0x800, -300 }, /* -3.0 dB */
+        { 0x945, 0x800, -150 }, /* -1.5 dB */
+
+        { 0x800, 0x800, 0 }, /* 0.0 dB */
+	
+        { 0x800, 0x945, 150 }, /* 1.5 dB */
+        { 0x800, 0xa56, 300 }, /* 3.0 dB */
+        { 0x800, 0xb3c, 450 }, /* 4.5 dB */
+
+        { 0x800, 0xc6d, 700 }, /* 7.0 dB */
+        { 0x800, 0xe36, 1300 }, /* 13.0 dB */
+        { 0x800, 0xefe, 1800 }, /* 18.0 dB */
+        { 0x800, 0xfbf, 3000 }, /* 30.0 dB */
+};
+
+static struct empeg_eq_section_t eq_init[20] =
+{
+	{ 0x00a8, 0x6f40 },
+	{ 0x0147, 0x6e40 },
+	{ 0x0276, 0x6540 },
+	{ 0x04f5, 0x6440 },
+	{ 0x09e4, 0x6340 }, 
+	{ 0x13b3, 0x5a40 },
+	{ 0x26f2, 0x5140 },
+	{ 0x4af1, 0x4040 },
+	{ 0x7ff0, 0x5840 },
+	{ 0x8010, 0x0740 },
+	{ 0x00a8, 0x6f40 },
+	{ 0x0147, 0x6e40 },
+	{ 0x0276, 0x6540 },
+	{ 0x04f5, 0x6440 },
+	{ 0x09e4, 0x6340 },
+	{ 0x13b3, 0x5a40 },
+	{ 0x26f2, 0x5140 },
+	{ 0x4af1, 0x4040 },
+	{ 0x7ff0, 0x5840 },
+	{ 0x8010, 0x0740 },
+};
+
+static int eq_section_order[20] =
+{
+	0, 10, 5, 15, 1, 11, 6, 16, 2, 12,
+	7, 17, 3, 13, 8, 18, 4, 14, 9, 19
+};
Index: empeg/kernel/arch/arm/special/empeg_mixer.h
diff -u /dev/null empeg/kernel/arch/arm/special/empeg_mixer.h:1.1.2.2
--- /dev/null	Thu May 31 21:42:26 2001
+++ empeg/kernel/arch/arm/special/empeg_mixer.h	Tue May 29 10:54:31 2001
@@ -0,0 +1,20 @@
+#ifndef EMPEG_MIXER_H
+#define EMPEG_MIXER_H
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/init.h>
+
+int __init empeg_mixer_init(void);
+int empeg_mixer_open(struct inode *inode, struct file *file);
+int empeg_switch_mixer_open(struct inode *inode, struct file *file);
+void empeg_mixer_eq_apply(void);
+int empeg_mixer_get_fm_level_fast(void);
+int empeg_mixer_get_fm_level(void);
+int empeg_mixer_get_stereo(void);
+int empeg_mixer_get_vat(void);
+void empeg_mixer_clear_stereo(void);
+void empeg_mixer_set_stereo(int on);
+int empeg_mixer_get_multipath(void);
+
+#endif
Index: empeg/kernel/arch/arm/special/empeg_power.c
diff -u empeg/kernel/arch/arm/special/empeg_power.c:1.13.4.2 empeg/kernel/arch/arm/special/empeg_power.c:1.13.4.3
--- empeg/kernel/arch/arm/special/empeg_power.c:1.13.4.2	Fri Jan  5 15:43:22 2001
+++ empeg/kernel/arch/arm/special/empeg_power.c	Thu May  3 11:57:00 2001
@@ -1,6 +1,6 @@
 /* empeg power-pic support
  *
- * (C)2000 empeg ltd, http://www.empeg.com
+ * (C)2000-2001 empeg ltd, http://www.empeg.com
  *
  * Author:
  *   Hugo Fiennes, <hugo@empeg.com>
@@ -47,6 +47,7 @@
  * 2000/03/15 HBF First version
  * 2000/05/24 HBF Added ioctls
  * 2000/07/10 HBF Will now run on Mk1's and show levels on I/O
+ * 2001/04/10 HBF Added display state so we know when it comes back on
  * 
  */
 
@@ -156,6 +157,8 @@
 /* Bitset of current power state */
 int getbitset(void)
 {
+	struct power_dev *dev=power_devices;
+
 	/* These bits should be stable for half a second before they are
 	   allowed to change */
 	const int unstable_bits = EMPEG_POWER_FLAG_FAILENABLED
@@ -176,6 +179,7 @@
 		if (gplr&EMPEG_EXTPOWER)  bitset|=EMPEG_POWER_FLAG_DC;
 		if (powerfail_enabled())  bitset|=EMPEG_POWER_FLAG_FAILENABLED;
 		/* Accessory ON */        bitset|=EMPEG_POWER_FLAG_ACCESSORY;
+		if (dev->displaystate)	  bitset|=EMPEG_POWER_FLAG_DISPLAY;
 	} else {
 		/* Mk2 */
 		if (gplr&EMPEG_EXTPOWER)  bitset|=EMPEG_POWER_FLAG_DC;
@@ -184,7 +188,7 @@
 		if (power_firstboot)      bitset|=EMPEG_POWER_FLAG_FIRSTBOOT;
 		if (!(gplr&EMPEG_SERIALDCD)) bitset|=EMPEG_POWER_FLAG_EXTMUTE; /* Tel mute */
 		if (!(gplr&EMPEG_SERIALCTS)) bitset|=EMPEG_POWER_FLAG_LIGHTS; /* Dimmer sense - inverted */
-
+		if (dev->displaystate)	  bitset|=EMPEG_POWER_FLAG_DISPLAY;
 	}
 	
 	if (saved_unstable == (bitset & unstable_bits)) {
@@ -258,6 +262,13 @@
 		else
 			len += sprintf(buf + len, "0 (Lights sense low)\n");
 	}
+
+	/* Both mk1 & mk2 */
+	if (state & EMPEG_POWER_FLAG_DISPLAY)
+		len += sprintf(buf + len, "1 (Display on)\n");
+	else
+		len += sprintf(buf + len, "0 (Display off)\n");
+
 	len += sprintf(buf + len, "All flags: 0x%x\n", state);
 	return len;
 }
@@ -408,6 +419,7 @@
 		   b3 = 0 2nd or later boot, 1 first boot
 		   b4 = 0 tel mute low, 1 tel mute high
 		   b5 = 0 lights off, 1 lights on
+		   b6 = 0 display off, 1 display on
 		*/
 		unsigned long flags;
 		int returnstate;
@@ -429,12 +441,17 @@
 
 extern void empeg_displaypower(int on)
 {
+	struct power_dev *dev=power_devices;
+
 	if (empeg_hardwarerevision()<9) {
-               /* Just twiddle appropriate line */
-               if (on) GPSR=EMPEG_DISPLAYPOWER;
-               else GPCR=EMPEG_DISPLAYPOWER;
-       } else {
-               /* Send actual command */
-               powercontrol(on?3:4);
-       }
+		/* Just twiddle appropriate line */
+		if (on) GPSR=EMPEG_DISPLAYPOWER;
+		else GPCR=EMPEG_DISPLAYPOWER;
+	} else {
+		/* Send actual command */
+		powercontrol(on?3:4);
+	}
+
+	/* Record the state */
+	dev->displaystate=on?1:0;
 }
Index: empeg/kernel/arch/arm/special/empeg_power.h
diff -u empeg/kernel/arch/arm/special/empeg_power.h:1.2 empeg/kernel/arch/arm/special/empeg_power.h:1.2.4.1
--- empeg/kernel/arch/arm/special/empeg_power.h:1.2	Fri Jul 14 13:51:28 2000
+++ empeg/kernel/arch/arm/special/empeg_power.h	Thu May  3 11:57:00 2001
@@ -12,6 +12,7 @@
         struct tq_struct poller;    /* Checks the power state */
 	int laststate;              /* Last power state */
 	int newstate;               /* New power state */
+	int displaystate;	    /* Is display on or off? */
 };
 
 /* Declarations */
Index: empeg/kernel/arch/arm/special/empeg_state.c
diff -u empeg/kernel/arch/arm/special/empeg_state.c:1.23 empeg/kernel/arch/arm/special/empeg_state.c:1.23.4.2
--- empeg/kernel/arch/arm/special/empeg_state.c:1.23	Mon Jul 17 19:37:15 2000
+++ empeg/kernel/arch/arm/special/empeg_state.c	Tue May 29 10:54:50 2001
@@ -74,6 +74,8 @@
 #include <asm/uaccess.h>
 #include <linux/proc_fs.h>
 
+#define DEBUG 0
+
 /* crctab calculated by Mark G. Mendel, Network Systems Corporation */
 unsigned short crctab[256] = {
     0x0000,  0x1021,  0x2042,  0x3063,  0x4084,  0x50a5,  0x60c6,  0x70e7,
@@ -159,7 +161,7 @@
 
 /* Has buffer been modified? */
 static int dirty=0;
-static int enabled=0;
+static int powerfail_disable_count=0;
 static int erroneous_interrupts = 0;
 
 /* Unixtime and elapsed power on time at power-on */
@@ -171,12 +173,24 @@
 
 void enable_powerfail(int enable)
 {
-        enabled = enable;
+	unsigned long flags;
+	save_flags_cli(flags);
+	if (enable)
+		--powerfail_disable_count;
+	else
+		++powerfail_disable_count;
+	restore_flags(flags);
+
+#if DEBUG
+	printk("Powerfail is now %s (%d)\n", (powerfail_disable_count == 0) ? "enabled" : "disabled", powerfail_disable_count);
+	if (powerfail_disable_count < 0)
+		printk("\n\n\n\nBAD! powerfail disable count fallen below zero to %d.\n\n\n\n", powerfail_disable_count);
+#endif
 }
 
-int powerfail_enabled(void)
+inline int powerfail_enabled(void)
 {
-	return enabled;
+	return (powerfail_disable_count == 0);
 }
 
 static inline void state_enablewrite(void)
@@ -376,15 +390,20 @@
 
 /* Forced cleanse routine, usually called just before a software-initiated
    powerdown */
-extern void state_cleanse()
+extern void state_cleanse(void)
 {
 	/* Is the state dirty? Flush it if it is */
-	if (dirty) state_store();
+	if (dirty) {
+		unsigned long flags;
+		save_flags_cli(flags);
+		state_store();
+		restore_flags(flags);
+	}
 }
 
 static void powerfail_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
-	if (enabled) {
+	if (powerfail_enabled()) {
 		/* Power is failing, quickly do things... */
 		struct state_dev *dev = state_devices;
 
@@ -402,9 +421,9 @@
 		
 		/* Something so we can see how close the actual
                    powerfail *is*! */
-		/*
+#if DEBUG
 		  printk("The quick brown fox jumped over the lazy dog.\n");
-		*/
+#endif
 
 		/* Queue up a powerfail timeout call just in case the
 		 * power hasn't really gone away. */
@@ -425,49 +444,71 @@
 
 static void powerfail_disabled_timeout(unsigned long unused)
 {
-	/* If we get here then a powerfail interrupt happened
-	 * but the power didn't actually go away within a
-	 * sensible amount of time. So, we bring everything
-	 * back to life.
-	 */
+	/* If we get here then a powerfail interrupt happened but the
+	 * power didn't actually go away within a sensible amount of
+	 * time. So, if the voltage has gone back up above the
+	 * threshold we reenable the interrupt and wait for a bit
+	 * longer. If the voltage hasn't gone back up enough we just
+	 * reschedule ourselves to take a look at it again in a little
+	 * while.
+         */
+	
 	struct state_dev *dev = state_devices;
 
 	unsigned long dis;
 	save_flags_cli(dis);
-	/*
+#if DEBUG
 	  printk("The power doesn't seem to have gone away after all.\n");
-	*/
+#endif
 
 #ifdef CONFIG_EMPEG_DISPLAY
 	/* Re-enable powerfail processing */
 	display_powerreturn_action();
 #endif
-
 	if (timer_pending(&dev->powerfail_timer))
 		del_timer(&dev->powerfail_timer);
-	dev->powerfail_timer.expires = jiffies + REENABLE_TIMEOUT * HZ;
-	dev->powerfail_timer.function = powerfail_reenabled_timeout;
-	add_timer(&dev->powerfail_timer);
-
-	erroneous_interrupts = 0;
-	enable_powerfail(FALSE);
+	
+	if (GPLR & EMPEG_POWERFAIL) {
+		/* It's high, so we're lower than 10 volts. Just
+		 * reschedule ourselves to take another look at it
+		 *  later.
+		 */
+		dev->powerfail_timer.expires = jiffies + POWERFAIL_TIMEOUT * HZ;
+		dev->powerfail_timer.function = powerfail_disabled_timeout;
+		add_timer(&dev->powerfail_timer);
+#if DEBUG
+		printk("The voltage is still too low, not reenabling powerfail.\n");
+#endif
+	} else {
+#if DEBUG
+		printk("The voltage has gone high enough, reenabling powerfail tentatitively.\n");
+#endif
+		/* It's low, so we've gone back to above 10 volts. Reenable the
+		 *  interrupt and schedule the reenable function so that it can check
+		 * we haven't had any spurious interrupts too often.
+		 */
+		dev->powerfail_timer.expires = jiffies + REENABLE_TIMEOUT * HZ;
+		dev->powerfail_timer.function = powerfail_reenabled_timeout;
+		add_timer(&dev->powerfail_timer);
+		
+		erroneous_interrupts = 0;
+	}
 	restore_flags(dis);
 }
 
 static void powerfail_reenabled_timeout(unsigned long unused)
 {
 	/* If we get here then the power returned a while ago and we reenabled
-	 * stuff.
-	 */
+	 * stuff.  */
 	
 	struct state_dev *dev = state_devices;
 	unsigned long dis;
 	save_flags_cli(dis);
 	
 	if (erroneous_interrupts) {
-		/*
+#if DEBUG
 		  printk("The power interrupt is happening too often. Can't enable it.\n");
-		*/
+#endif
 		if (timer_pending(&dev->powerfail_timer))
 			del_timer(&dev->powerfail_timer);
 		dev->powerfail_timer.expires = jiffies + POWERFAIL_TIMEOUT * HZ;
@@ -475,9 +516,9 @@
 		add_timer(&dev->powerfail_timer);
 		erroneous_interrupts = 0;
 	} else {
-		/*
+#if DEBUG
 		  printk("The power hasn't failed for a while - reenabling actions.\n");
-		*/
+#endif
 
 		if (timer_pending(&dev->powerfail_timer))
 			del_timer(&dev->powerfail_timer);
@@ -646,8 +687,15 @@
 
 	/* Ensure the IRQ is disabled at source */
 	GRER&=~EMPEG_POWERFAIL;
-	GFER&=~EMPEG_POWERFAIL;
 	GEDR=EMPEG_POWERFAIL;
+
+#if DEBUG
+ 	printk("Powerfail is now %s (%d)\n", (powerfail_disable_count == 0) ? "enabled" : "disabled", powerfail_disable_count);
+#endif
+ 	
+#if DEBUG
+	printk("Powerfail line current level is %d\n", GPLR & EMPEG_POWERFAIL);
+#endif
 	result = request_irq(EMPEG_IRQ_POWERFAIL, powerfail_interrupt, SA_INTERRUPT,
 			     "empeg_state", dev);
 	
@@ -671,10 +719,19 @@
 	
 	printk("empeg state support initialised %04x/%04x (save to %p).\n",
 	       flash_manufacturer,flash_product,savebase);
+
+ 	/* Enable powerfail interrupts if the voltage level isn't already too low */
+ 	if (GPLR & EMPEG_POWERFAIL) {
+ 		/* Pretend we've just received a powerfail interrupt */
+ 		powerfail_disable_count = 1;
+ 		dev->powerfail_timer.expires = jiffies + POWERFAIL_TIMEOUT * HZ;
+ 		dev->powerfail_timer.function = powerfail_disabled_timeout;
+ 		add_timer(&dev->powerfail_timer);		
+ 	} else
+ 		powerfail_disable_count = 0;
 
-	/* We want interrupts on rising only */
-	GRER|=EMPEG_POWERFAIL;
-	enable_powerfail(TRUE);
+  	/* We want interrupts on rising only */
+  	GRER|=EMPEG_POWERFAIL;
 }
 
 static inline void empeg_state_cleanup(void)
Index: empeg/kernel/drivers/char/empeg_ir.c
diff -u empeg/kernel/drivers/char/empeg_ir.c:1.30.4.3 empeg/kernel/drivers/char/empeg_ir.c:1.30.4.4
--- empeg/kernel/drivers/char/empeg_ir.c:1.30.4.3	Mon Dec 18 16:26:28 2000
+++ empeg/kernel/drivers/char/empeg_ir.c	Wed May 30 17:42:29 2001
@@ -220,11 +220,14 @@
 
 static inline int ir_code_repeatable(ir_code data)
 {
+#if 1
 	/* Is the code a repeatable one? */
 	data &= 0x7fffffff;
 	
 	if ((data < 0x2000) || (data > 0x2017))
 		return TRUE;
+	else if (data == 0x2007)
+		return TRUE;
 	else if (data < 0x2010)
 		return FALSE;
 	else if (data == 0x2012)
@@ -233,6 +236,9 @@
 		return FALSE;
 	else
 		return TRUE;
+#else
+	return TRUE;
+#endif
 }
 
 /* Append a repetition of the last data. This is only done if the
Index: empeg/kernel/drivers/char/mem.c
diff -u empeg/kernel/drivers/char/mem.c:1.16 empeg/kernel/drivers/char/mem.c:1.16.6.2
--- empeg/kernel/drivers/char/mem.c:1.16	Tue Jun 13 19:10:58 2000
+++ empeg/kernel/drivers/char/mem.c	Fri May  4 18:06:06 2001
@@ -687,6 +687,7 @@
 #endif
 #ifdef CONFIG_SA1100_EMPEG
 	{
+		extern int empeg_dsp_init(void);
 		extern int audio_empeg_init(void);
 		extern int empeg_ir_init(void);
 		extern int empeg_usb_init(void);
@@ -701,7 +702,10 @@
 #ifdef CONFIG_EMPEG_DISPLAY
 		empeg_display_init();
 #endif
-#if defined(CONFIG_EMPEG_DSP) || defined(CONFIG_EMPEG_DAC)
+#if defined(CONFIG_EMPEG_DSP)
+		empeg_dsp_init();
+#endif
+#if defined(CONFIG_EMPEG_DAC)
 		audio_empeg_init();
 #endif
 #ifdef CONFIG_EMPEG_CS4231
Index: empeg/kernel/drivers/char/radio-empeg.c
diff -u empeg/kernel/drivers/char/radio-empeg.c:1.12 empeg/kernel/drivers/char/radio-empeg.c:1.12.4.1
--- empeg/kernel/drivers/char/radio-empeg.c:1.12	Thu Jun 29 12:56:34 2000
+++ empeg/kernel/drivers/char/radio-empeg.c	Thu May  3 17:44:56 2001
@@ -7,8 +7,6 @@
  *   Mike Crowe <mac@empeg.com>
  */
 
-/* This needs updating to support the new Marvin radio */
-
 #include <linux/module.h>	/* Modules 			*/
 #include <linux/init.h>		/* Initdata			*/
 #include <linux/ioport.h>	/* check_region, request_region	*/
@@ -33,8 +31,10 @@
 #define FLAG_SENSITIVITY_VERYLOW ((1<<16)|(1<<17))
 #define FREQUENCY_MASK (0x7fff)
 
-void audio_clear_stereo(void);
-void audio_set_stereo(int on);
+void empeg_mixer_clear_stereo(void);
+void empeg_mixer_set_stereo(int on);
+int empeg_mixer_get_stereo(void);
+int empeg_mixer_get_multipath(void);
 
 static int users = 0;
 
@@ -145,93 +145,14 @@
 	return 0;
 }
 
-static void marvin_radio_writeword(int data)
-{
-	/* All shifted to top end to make PIC code neater */
-	unsigned int frame=(data<<7);
-
-	/* Write 4 byte frame to radio */
-	Ser1UTDR=1; /* SOH */
-	Ser1UTDR=2; /* Tune command */
-	Ser1UTDR=(frame    )&0xff;
-	Ser1UTDR=(frame>> 8)&0xff;
-	Ser1UTDR=(frame>>16)&0xff;
-	Ser1UTDR=(frame>>24)&0xff;
-}
-
-static int empeg_marvin_radio_update(struct empeg_radio_device *dev, int search, int direction)
-{
-	int word = 0;
-	int a, divisor = 102400000;
-        unsigned long freq = dev->freq;
-	if (dev->mono)
-		word |= FLAG_MONO;
-	else
-		word |= FLAG_STEREO;
-
-	if (1 /*dev->dx*/)
-		word |= FLAG_DX;
-	else
-		word |= FLAG_LOCAL;
-
-	switch (dev->sensitivity)
-	{
-	case 0:
-		word |= FLAG_SENSITIVITY_VERYLOW;
-		break;
-	case 1:
-		word |= FLAG_SENSITIVITY_LOW;
-		break;
-	case 2:
-		word |= FLAG_SENSITIVITY_MEDIUM;
-		break;
-	case 3:
-	default:
-		word |= FLAG_SENSITIVITY_HIGH;
-		break;
-	}
-	
-	if (search)
-	{
-		word |= FLAG_SEARCH;
-		if (direction)
-			word |= FLAG_SEARCH_UP;
-		else
-			word |= FLAG_SEARCH_DOWN;
-	}
-	
-	/* Add 10.7Mhz IF */
-	freq+=10700000;
-	
-	/* Set bits */
-	for(a = 13; a >= 0; a--)
-	{
-		if (freq>=divisor)
-		{
-			word|=(1<<a);
-			freq-=divisor;
-		}
-		divisor>>=1;
-	}
-	
-	marvin_radio_writeword(word);
-
-	return 0;
-}
-
 int empeg_philips_radio_getsigstr(struct empeg_radio_device *dev)
 {
-	unsigned signal = audio_get_fm_level();
-	if ((signal < 0) || (signal > 131071)) signal = 0;
-	else {
-		signal >>= 1;	// 18 bits signed -> 16 bits unsigned
-	}
-	return (int) signal;
+	return empeg_mixer_get_fm_level();
 }
 
 int empeg_philips_radio_getstereo(struct empeg_radio_device *dev)
 {
-	return audio_get_stereo();
+	return empeg_mixer_get_stereo();
 }
 
 static int empeg_philips_radio_ioctl(struct video_device *dev, unsigned int cmd, void *arg)
@@ -293,7 +214,7 @@
 		if(copy_from_user(&radio->freq, arg,sizeof(radio->freq)))
 			return -EFAULT;
 		empeg_philips_radio_update(radio, FALSE, 0);
-		audio_clear_stereo(); // reset stereo level to 0
+		empeg_mixer_clear_stereo(); // reset stereo level to 0
 		return 0;
 	case VIDIOCGAUDIO:
 	{	
@@ -358,7 +279,7 @@
 		return 0;
 	}
 	case EMPEG_RADIO_GET_MULTIPATH: {
-		unsigned multi = audio_get_multipath();
+		unsigned multi = empeg_mixer_get_multipath();
 		if(multi == -1) return -EIO;
 		copy_to_user_ret(arg, &multi, sizeof(unsigned), -EFAULT);
 		return 0;
@@ -366,7 +287,7 @@
 	case EMPEG_RADIO_SET_STEREO: {
 		int stereo;
 		copy_from_user_ret(&stereo, arg, sizeof(int), -EFAULT);
-		audio_set_stereo(stereo);
+		empeg_mixer_set_stereo(stereo);
 		return 0;
 	}
 	default:
@@ -389,162 +310,6 @@
 	MOD_DEC_USE_COUNT;
 }
 
-static int empeg_marvin_radio_open(struct video_device *dev, int flags)
-{
-	if (users)
-		return -EBUSY;
-
-	users++;
-	MOD_INC_USE_COUNT;
-	return 0;
-}
-
-static void empeg_marvin_radio_close(struct video_device *dev)
-{
-	users--;
-	MOD_DEC_USE_COUNT;
-}
-
-static int empeg_marvin_radio_ioctl(struct video_device *dev, unsigned int cmd, void *arg)
-{
-	struct empeg_radio_device *radio=dev->priv;
-	
-	/* For now we'll just accept everything */
-	switch(cmd)
-	{
-	case VIDIOCGCAP:
-	{
-		struct video_capability v;
-		v.type=VID_TYPE_TUNER;
-		v.channels=1;
-		v.audios=1;
-		/* No we don't do pictures */
-		v.maxwidth=0;
-		v.maxheight=0;
-		v.minwidth=0;
-		v.minheight=0;
-		strcpy(v.name, "empeg-car radio");
-		if(copy_to_user(arg,&v,sizeof(v)))
-			return -EFAULT;
-		return 0;
-	}
-	case VIDIOCGTUNER:
-	{
-		struct video_tuner v;
-		if(copy_from_user(&v, arg,sizeof(v))!=0) 
-			return -EFAULT;
-		if(v.tuner)	/* Only 1 tuner */ 
-			return -EINVAL;
-		v.rangelow = 87500000;
-		v.rangehigh = 108000000;
-		v.flags = 0;
-		v.mode = VIDEO_MODE_AUTO;
-		v.signal = empeg_philips_radio_getsigstr(radio);
-
-		if(copy_to_user(arg,&v, sizeof(v)))
-			return -EFAULT;
-		return 0;
-	}
-	case VIDIOCSTUNER:
-	{
-		struct video_tuner v;
-		if(copy_from_user(&v, arg, sizeof(v)))
-			return -EFAULT;
-		if(v.tuner!=0)
-			return -EINVAL;
-		/* Only 1 tuner so no setting needed ! */
-		return 0;
-	}
-	case VIDIOCGFREQ:
-		if(copy_to_user(arg, &radio->freq, sizeof(radio->freq)))
-			return -EFAULT;
-		return 0;
-	case VIDIOCSFREQ:
-		if(copy_from_user(&radio->freq, arg,sizeof(radio->freq)))
-			return -EFAULT;
-		empeg_marvin_radio_update(radio, FALSE, 0);
-		audio_clear_stereo(); // reset stereo level to 0
-		return 0;
-	case VIDIOCGAUDIO:
-	{	
-		struct video_audio v;
-		memset(&v,0, sizeof(v));
-		/*v.flags|=VIDEO_AUDIO_MUTABLE|VIDEO_AUDIO_VOLUME; */
-		/*v.volume=radio->curvol * 6554;*/
-		/*v.step=6554;*/
-		strcpy(v.name, "Radio");
-		if(copy_to_user(arg,&v, sizeof(v)))
-			return -EFAULT;
-		return 0;			
-	}
-	case VIDIOCSAUDIO:
-	{
-		struct video_audio v;
-		if(copy_from_user(&v, arg, sizeof(v))) 
-			return -EFAULT;	
-		if(v.audio) 
-			return -EINVAL;
-		
-		/* Check the mode for stereo/mono */
-		if (v.mode == VIDEO_SOUND_MONO)
-			radio->mono = TRUE;
-		else
-			radio->mono = FALSE;
-		empeg_marvin_radio_update(radio, FALSE, 0);
-		return 0;
-	}
-	case EMPEG_RADIO_READ_MONO:
-		copy_to_user_ret(arg, &(radio->mono), sizeof(radio->mono), -EFAULT);
-		return 0;
-
-	case EMPEG_RADIO_WRITE_MONO:
-		copy_from_user_ret(&(radio->mono), arg, sizeof(radio->mono), -EFAULT);
-		return 0;
-
-	case EMPEG_RADIO_READ_DX:
-		copy_to_user_ret(arg, &(radio->dx), sizeof(radio->dx), -EFAULT);
-		return 0;
-
-	case EMPEG_RADIO_WRITE_DX:
-		copy_from_user_ret(&(radio->dx), arg, sizeof(radio->dx), -EFAULT);
-		empeg_marvin_radio_update(radio, FALSE, 0);
-		return 0;
-
-	case EMPEG_RADIO_READ_SENSITIVITY:
-		copy_to_user_ret(arg, (&radio->sensitivity), sizeof(radio->sensitivity), -EFAULT);
-		return 0;
-
-	case EMPEG_RADIO_WRITE_SENSITIVITY:
-		copy_from_user_ret(&(radio->sensitivity), arg, sizeof(radio->sensitivity), -EFAULT);
-		empeg_marvin_radio_update(radio, FALSE, 0);
-		return 0;
-
-	case EMPEG_RADIO_SEARCH:
-	{
-		int direction;
-		copy_from_user_ret(&direction, arg, sizeof(direction), -EFAULT);
-		empeg_marvin_radio_update(radio, TRUE, direction);
-		return 0;
-	}
-	case EMPEG_RADIO_GET_MULTIPATH: {
-		unsigned multi = audio_get_multipath();
-		if(multi == -1) return -EIO;
-		copy_to_user_ret(arg, &multi, sizeof(unsigned), -EFAULT);
-		return 0;
-	}
-	case EMPEG_RADIO_SET_STEREO: {
-		int stereo;
-		copy_from_user_ret(&stereo, arg, sizeof(int), -EFAULT);
-		audio_set_stereo(stereo);
-		return 0;
-	}
-	default:
-		return -ENOIOCTLCMD;
-	}
-	
-	return 0;
-}
-
 static struct empeg_radio_device empeg_unit;
 
 static struct video_device empeg_philips_radio=
@@ -562,21 +327,6 @@
 	NULL
 };
 
-static struct video_device empeg_marvin_radio=
-{
-	"empeg mk2 radio",
-	VID_TYPE_TUNER,
-	VID_HARDWARE_RTRACK,
-	empeg_marvin_radio_open,
-	empeg_marvin_radio_close,
-	NULL,	/* Can't read  (no capture ability) */
-	NULL,	/* Can't write */
-	NULL,	/* No poll */
-	empeg_marvin_radio_ioctl,
-	NULL,
-	NULL
-};
-
 int __init empeg_radio_init(struct video_init *v)
 {
 	if (empeg_hardwarerevision() < 6) {
@@ -593,90 +343,8 @@
 		printk(KERN_INFO "empeg FM radio driver (Philips).\n");
 		
 	} else {
-		int dtimeout,data,state,tries=0;
-		unsigned char packet[5],checksum;
-
-		/* Private word pointer */
-		empeg_marvin_radio.priv = &empeg_unit;
-
-		/* Set up serial port: 8-bit, 4800bps, no IRQs */
-		Ser1UTCR0=UTCR0_DSS;
-		Ser1UTCR1=0;
-		Ser1UTCR2=47;
-		Ser1UTCR3=UTCR3_RXE|UTCR3_TXE;
-
-		while(tries<2) {
-			//printk("probing, try %d\n",tries);
-
-			/* Flush serial RX */
-			while(Ser1UTSR1&UTSR1_RNE) data=Ser1UTDR;
-			
-			/* Check for radio: some padding then an ID command */
-			Ser1UTDR=0;
-			Ser1UTDR=0;
-			Ser1UTDR=0;
-			Ser1UTDR=0;
-			Ser1UTDR=1; /* SOH */
-			Ser1UTDR=1; /* ID yourself */
-			
-			/* Wait for response */
-			dtimeout=jiffies+(HZ/4);
-			state=0;
-			while(jiffies<dtimeout && state!=7) {
-				/* Any data? */
-				if (Ser1UTSR1&UTSR1_RNE) {
-					data=Ser1UTDR;
-					//printk("got %02x, state=%d\n",data,state);
-					switch(state) {
-					case 0:
-						if (data==1) {
-							checksum=0;
-							state++;
-						}
-						break;
-					case 1:
-					case 2:
-					case 3:
-					case 4:
-					case 5:
-						packet[state-1]=data;
-						checksum+=data;
-						state++;
-						break;
-					case 6:
-						if (checksum==data) {
-							/* Got good reply */
-							state++;
-						} else {
-							printk("checksum error from radio (calc=%02x, rx=%02x)\n",checksum,data);		  
-							state=0;
-						}
-						break;
-					}
-				}
-				
-			}
-			
-			if (state==7) break;
-			
-			/* Try again */
-			tries++;
-		}
-
-		if (state==7) {
-			/* Found unit */
-			empeg_unit.freq = 87500000;
-			empeg_unit.dx = 1;
-			empeg_unit.mono = 0;
-			empeg_unit.sensitivity = 10;
-			
-			if(video_register_device(&empeg_marvin_radio, VFL_TYPE_RADIO)==-1)
-				return -EINVAL;
-			
-			printk(KERN_INFO "empeg radio unit found, capabilities %02x\n",packet[0]);
-		} else {
-			printk(KERN_INFO "no empeg radio unit found\n");
-		}
+		printk(KERN_INFO "empeg FM radio not present\n");
+		return -EINVAL;
 	}
 
 	return 0;
Index: empeg/kernel/include/asm-arm/arch-sa1100/empeg.h
diff -u empeg/kernel/include/asm-arm/arch-sa1100/empeg.h:1.37 empeg/kernel/include/asm-arm/arch-sa1100/empeg.h:1.37.4.3
--- empeg/kernel/include/asm-arm/arch-sa1100/empeg.h:1.37	Fri Jul 14 17:20:03 2000
+++ empeg/kernel/include/asm-arm/arch-sa1100/empeg.h	Thu May 31 15:56:47 2001
@@ -160,9 +160,25 @@
 #define EMPEG_MIXER_GET_COMPRESSION _IOR(EMPEG_MIXER_MAGIC, 14, int)
 #define EMPEG_MIXER_SET_COMPRESSION _IOW(EMPEG_MIXER_MAGIC, 14, int)
 #define EMPEG_MIXER_SET_SAM _IOW(EMPEG_MIXER_MAGIC, 15, int)
+#define EMPEG_MIXER_RAW_I2C_READ	_IOR(EMPEG_MIXER_MAGIC, 16, int)
+#define EMPEG_MIXER_RAW_I2C_WRITE	_IOW(EMPEG_MIXER_MAGIC, 16, int)
+#define EMPEG_MIXER_WRITE_SENSITIVITY	_IOW(EMPEG_MIXER_MAGIC, 17, int)
+#define EMPEG_MIXER_READ_SIGNAL_STRENGTH _IOR(EMPEG_MIXER_MAGIC, 18, int)
+#define EMPEG_MIXER_READ_SIGNAL_STEREO	_IOR(EMPEG_MIXER_MAGIC, 19, int)
+#define EMPEG_MIXER_READ_LEVEL_ADJUST	_IOR(EMPEG_MIXER_MAGIC, 20, int)
+#define EMPEG_MIXER_WRITE_LEVEL_ADJUST	_IOW(EMPEG_MIXER_MAGIC, 20, int)
+#define EMPEG_MIXER_READ_SIGNAL_NOISE	_IOR(EMPEG_MIXER_MAGIC, 21, int)
+#define EMPEG_MIXER_READ_SIGNAL_MULTIPATH _IOR(EMPEG_MIXER_MAGIC, 22, int)
+#define EMPEG_MIXER_READ_FM_AM_SELECT	_IOR(EMPEG_MIXER_MAGIC, 23, int)
+#define EMPEG_MIXER_WRITE_FM_AM_SELECT	_IOW(EMPEG_MIXER_MAGIC, 23, int)
+#define EMPEG_MIXER_READ_SIGNAL_STRENGTH_FAST _IOR(EMPEG_MIXER_MAGIC, 24, int)
+#define EMPEG_MIXER_READ_FM_DEEMPHASIS	_IOR(EMPEG_MIXER_MAGIC, 25, int)
+#define EMPEG_MIXER_WRITE_FM_DEEMPHASIS	_IOW(EMPEG_MIXER_MAGIC, 25, int)
 
 /* Retrieve volume level corresponding to 0dB */
 #define EMPEG_MIXER_READ_ZERO_LEVEL _IOR(EMPEG_MIXER_MAGIC, 3, int)
+#define EMPEG_MIXER_SELECT_FM		0
+#define EMPEG_MIXER_SELECT_AM		1
 
 #define EMPEG_MIXER_FLAG_MUTE (1<<0)
 /*#define EMPEG_MIXER_FLAG_LOUDNESS (1<<1)*/
@@ -179,9 +195,11 @@
 #define EMPEG_RADIO_SEARCH _IO(EMPEG_RADIO_MAGIC, 76) /* Pass in direction in *arg */
 #define EMPEG_RADIO_GET_MULTIPATH _IOR(EMPEG_RADIO_MAGIC, 77, int)
 #define EMPEG_RADIO_SET_STEREO _IOW(EMPEG_RADIO_MAGIC, 78, int)
+#define EMPEG_RADIO_READ_RAW		_IOR(EMPEG_RADIO_MAGIC, 79, int)
 
 #define EMPEG_DSP_BEEP _IOW(EMPEG_DSP_MAGIC, 0, int)
 #define EMPEG_DSP_PURGE _IOR(EMPEG_DSP_MAGIC, 1, int)
+#define EMPEG_DSP_GRAB_OUTPUT _IOR(EMPEG_DSP_MAGIC, 2, int)
 
 /* Audio input IOCTLs */
 #define EMPEG_AUDIOIN_MAGIC 'c'
@@ -212,6 +230,7 @@
 #define EMPEG_POWER_FLAG_FIRSTBOOT	0x08
 #define EMPEG_POWER_FLAG_EXTMUTE	0x10
 #define EMPEG_POWER_FLAG_LIGHTS		0x20
+#define EMPEG_POWER_FLAG_DISPLAY       	0x40
 
 /* State storage ioctls */
 /* Shouldn't need either of these in normal use. */
@@ -242,10 +261,12 @@
 #endif /* CONFIG_EMPEG_STATE */
 
 #ifdef CONFIG_EMPEG_DISPLAY
+void empeg_displaypower(int on);
 static inline void display_powerfail_action(void)
 {
 	/* Mute audio & turn off display */
-	GPCR=EMPEG_DSPPOM | EMPEG_DISPLAYPOWER;
+/*	GPCR=EMPEG_DSPPOM | EMPEG_DISPLAYPOWER; */
+	empeg_displaypower(0);
 
 	/* Turn off scan */
 	LCCR0=0;
