Index: empeg/kernel/.cvsignore
diff -u empeg/kernel/.cvsignore:1.1 empeg/kernel/.cvsignore:1.2
--- empeg/kernel/.cvsignore:1.1	Wed Jun  9 13:32:30 1999
+++ empeg/kernel/.cvsignore	Mon Feb 12 16:58:31 2001
@@ -3,3 +3,4 @@
 System.map
 .config
 .menuconfig.log
+kernel.upgrade
Index: empeg/kernel/Makefile
diff -u empeg/kernel/Makefile:1.36.2.8 empeg/kernel/Makefile:1.47
--- empeg/kernel/Makefile:1.36.2.8	Fri Jun 15 16:41:17 2001
+++ empeg/kernel/Makefile	Wed Oct 17 16:00:51 2001
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 2
 SUBLEVEL = 14
-EXTRAVERSION = -rmk5-np17-empeg43
+EXTRAVERSION = -rmk5-np17-empeg49
 
 #ARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ -e s/arm.*/arm/ -e s/sa110/arm/)
 ARCH := arm
@@ -19,7 +19,7 @@
 HOSTCC  	=gcc
 HOSTCFLAGS	=-Wall -Wstrict-prototypes -O2 -fomit-frame-pointer
 
-CROSS_COMPILE 	= arm-linux-
+CROSS_COMPILE 	= arm-empeg-linux-
 
 AS	=$(CROSS_COMPILE)as
 LD	=$(CROSS_COMPILE)ld
Index: empeg/kernel/nku
diff -u /dev/null empeg/kernel/nku:1.3
--- /dev/null	Wed Oct 17 16:36:04 2001
+++ empeg/kernel/nku	Mon Feb 12 18:49:11 2001
@@ -0,0 +1,37 @@
+#!/bin/sh
+
+OK=0
+if [ "$1" = "" ]; then
+    PROCESSORS=`grep -c processor /proc/cpuinfo`
+    echo Using $PROCESSORS processors
+
+    if make -j $PROCESSORS zImage; then
+	OK=1
+    fi
+else
+    OK=1
+fi
+
+if [ "$OK" = "1" ]; then
+    T=nku.$$
+
+    rm -rf $T
+    mkdir -p $T
+
+    cd $T
+
+    echo -n Making upgrade file...
+    echo Kernel Upgrade >> info
+    date >> version
+    ln -s ../arch/arm/boot/zImage kernel.rom
+    
+    cd ..
+    ../pump/makeupgrade $T kernel.upgrade
+    
+    ls -l kernel.upgrade
+    
+    rm -rf $T
+else
+    # We failed.
+    exit 1
+fi
Index: empeg/kernel/Documentation/Configure.help
diff -u empeg/kernel/Documentation/Configure.help:1.1.1.3 empeg/kernel/Documentation/Configure.help:1.2
--- empeg/kernel/Documentation/Configure.help:1.1.1.3	Sat Mar 18 15:24:15 2000
+++ empeg/kernel/Documentation/Configure.help	Fri Oct 20 15:54:48 2000
@@ -7133,6 +7133,71 @@
   called minix.o. Note that the filesystem of your root partition (the
   one containing the directory /) cannot be compiled as a module.
 
+Reiserfs support
+CONFIG_REISERFS_FS
+  New, fast, space saving filesystem, based on a balanced tree algorithm.
+  Uses journaling, and includes a filesystem resizer.
+  You can use reiserfs in all cases where you use the ext2fs file system.
+  It has fewer worst case performance situations than other file systems.
+  It is more easily extended to have features currently found in database
+  and keyword search systems than block allocation based filesystems are.
+  Have fun.
+
+Reiserfs hash function  
+CONFIG_CRYPTO_SECURE_HASH
+  Reiserfs file system uses a hash function plus a generation counter
+  in determining the key used in directory searching.
+
+  We do this for 
+  compatibility with NFS,  which needs to be able to use a 32 (v2) or 
+  64 bit (v3)  integer  to  specify  where  it  last  read  from in a 
+  directory  (the  NFS  cookie)  because  it  stupidly  assumes  that  
+  directories  are  implemented   as  files  with  byte  offsets  and 
+  directories are never shrunk.  (They could just use the  last  name
+  that was read instead of these  cookies,  hint,  hint.)  This  hash  
+  function determines the order of insertions. That can have dramatic 
+  impact on performance for large directories  because it can cause a 
+  random I/O per filename created.  
+  
+  If you want certainty of avoiding hash collisions, which will cause 
+  a false NAME ALREADY EXISTS ERROR if you have more collisions on a 
+  given hash value  than  the m aximum  generation counter (256), you 
+  should  use the CRYPTO_SECURE_HASH.
+ 
+  The  CRYPTO_SECURE_HASH gives guaranteed worst  performance  of all 
+  possible hashing functions because it destroys any order that might 
+  be present in the ordering of the name creation.  Almost  all other 
+  patterns would make the LRU algorithm somewhat effective.  
+   
+  The Rupasov Hash  makes  an  attempt to preserve much of  the order 
+  that will be present in  alphabetically  or numerically consecutive 
+  names.  Note that if it gets the order reversed,  the LRU algorithm 
+  will still work  better than if it randomizes.....
+
+  
+  IMPORTANT ! 
+  Be careful, after changing the hash function 
+  you have to reformat  the reiserfs partition. 
+      
+  CRYPTO_SECURE_HASH - secure cryptographical hash function (tea hash):
+  A solid, reliable, hash function.  This hash  should be used by any 
+  persons  concerned  about  malicious attackers,  or who cannot risk 
+  relying on the RUPASOV_HASH. You can select tea hash  in many cases.
+  In fact, this function was the first used in ReiserFS,  was used in 
+  many of our benchmarks and can be considered the main hash function 
+  of the ReiserFS file system.  
+  
+  RUPASOV_HASH:
+  Invented by  Yuri Rupasove  while studying the problems of creating 
+  directories   too   large  to  fit  into  RAM.  Never  slower  than 
+  CRYPTO_SECURE_HASH, and for some applications involving directories 
+  too large for RAM it can be as much as 30 times faster.  For normal 
+  size  directpries  it  makes  reiserfs works with the same speed or 
+  just a bit faster than tea  hash  function.  This is beta-test code, 
+  we don't yet  know  if  there are any common applications for which 
+  this hash function will fail you.  Probably not, 
+  but.... no guarantees.
+
 Second extended fs support
 CONFIG_EXT2_FS
   This is the de facto standard Linux filesystem (method to organize
Index: empeg/kernel/arch/arm/def-configs/empeg
diff -u empeg/kernel/arch/arm/def-configs/empeg:1.5.8.1 empeg/kernel/arch/arm/def-configs/empeg:removed
--- empeg/kernel/arch/arm/def-configs/empeg:1.5.8.1	Tue Jun  5 19:36:37 2001
+++ empeg/kernel/arch/arm/def-configs/empeg	Wed Oct 17 16:36:04 2001
@@ -1,201 +0,0 @@
-#
-# Automatically generated make config: don't edit
-#
-CONFIG_ARM=y
-
-#
-# System and processor type
-#
-# CONFIG_ARCH_ARC is not set
-# CONFIG_ARCH_A5K is not set
-# CONFIG_ARCH_RPC is not set
-# CONFIG_ARCH_EBSA110 is not set
-# CONFIG_FOOTBRIDGE is not set
-CONFIG_ARCH_SA1100=y
-CONFIG_CPU_SA1100=y
-# CONFIG_SA1100_BRUTUS is not set
-CONFIG_SA1100_EMPEG=y
-# CONFIG_SA1100_ITSY is not set
-# CONFIG_SA1100_LART is not set
-# CONFIG_SA1100_PLEB is not set
-# CONFIG_SA1100_VICTOR is not set
-# CONFIG_SA1100_TIFON is not set
-# CONFIG_ARCH_ACORN is not set
-# CONFIG_ISA_DMA is not set
-CONFIG_CPU_32=y
-# CONFIG_CPU_26 is not set
-# CONFIG_CPU_ARM2 is not set
-# CONFIG_CPU_ARM3 is not set
-# CONFIG_CPU_ARM6 is not set
-# CONFIG_CPU_ARM7 is not set
-CONFIG_CPU_SA110=y
-
-#
-# Code maturity level options
-#
-CONFIG_EXPERIMENTAL=y
-# CONFIG_ALIGNMENT_TRAP is not set
-# CONFIG_TEXT_SECTIONS is not set
-
-#
-# Loadable module support
-#
-# CONFIG_MODULES is not set
-
-#
-# General setup
-#
-# CONFIG_NET is not set
-# CONFIG_SYSVIPC is not set
-# CONFIG_BSD_PROCESS_ACCT is not set
-# CONFIG_SYSCTL is not set
-CONFIG_NWFPE=y
-# CONFIG_BINFMT_AOUT is not set
-CONFIG_BINFMT_ELF=y
-# CONFIG_BINFMT_MISC is not set
-# CONFIG_ARTHUR is not set
-# CONFIG_PARPORT is not set
-CONFIG_CMDLINE=""
-
-#
-# Plug and Play support
-#
-# CONFIG_PNP is not set
-
-#
-# Block devices
-#
-# CONFIG_BLK_DEV_FD is not set
-CONFIG_BLK_DEV_IDE=y
-
-#
-# Please see Documentation/ide.txt for help/info on IDE drives
-#
-# CONFIG_BLK_DEV_HD_IDE is not set
-CONFIG_BLK_DEV_IDEDISK=y
-# CONFIG_BLK_DEV_IDECD is not set
-# CONFIG_BLK_DEV_IDETAPE is not set
-# CONFIG_BLK_DEV_IDEFLOPPY is not set
-# CONFIG_BLK_DEV_IDESCSI is not set
-# CONFIG_BLK_DEV_CMD640 is not set
-# CONFIG_IDE_CHIPSETS is not set
-
-#
-# Additional Block Devices
-#
-# CONFIG_BLK_DEV_LOOP is not set
-# CONFIG_BLK_DEV_MD is not set
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_INITRD=y
-# CONFIG_BLK_DEV_XD is not set
-CONFIG_PARIDE_PARPORT=y
-# CONFIG_PARIDE is not set
-# CONFIG_BLK_CPQ_DA is not set
-# CONFIG_BLK_DEV_HD is not set
-
-#
-# Character devices
-#
-# CONFIG_VT is not set
-CONFIG_SERIAL_SA1100=y
-CONFIG_SERIAL_SA1100_CONSOLE=y
-# CONFIG_SERIAL is not set
-# CONFIG_SERIAL_EXTENDED is not set
-# CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_UNIX98_PTYS is not set
-# CONFIG_MOUSE is not set
-# CONFIG_QIC02_TAPE is not set
-# CONFIG_WATCHDOG is not set
-# CONFIG_NVRAM is not set
-# CONFIG_RTC is not set
-CONFIG_EMPEG_INPUT=y
-CONFIG_EMPEG_USB9602=y
-# CONFIG_EMPEG_USBD12 is not set
-CONFIG_EMPEG_STATE=y
-CONFIG_EMPEG_RDS=y
-# CONFIG_EMPEG_DAC is not set
-CONFIG_EMPEG_DSP=y
-# CONFIG_EMPEG_CS4231 is not set
-CONFIG_EMPEG_SER2IRDA=y
-CONFIG_EMPEG_DISPLAY=y
-# CONFIG_EMPEG_DISPLAY_INVERTED is not set
-
-#
-# Video For Linux
-#
-CONFIG_VIDEO_DEV=y
-# CONFIG_RADIO_RTRACK is not set
-# CONFIG_RADIO_RTRACK2 is not set
-# CONFIG_RADIO_AZTECH is not set
-# CONFIG_RADIO_CADET is not set
-# CONFIG_RADIO_MIROPCM20 is not set
-# CONFIG_RADIO_GEMTEK is not set
-CONFIG_RADIO_EMPEG=y
-# CONFIG_VIDEO_BT848 is not set
-# CONFIG_VIDEO_PMS is not set
-# CONFIG_VIDEO_SAA5249 is not set
-# CONFIG_RADIO_SF16FMI is not set
-# CONFIG_RADIO_TYPHOON is not set
-# CONFIG_RADIO_ZOLTRIX is not set
-# CONFIG_VIDEO_ZORAN is not set
-# CONFIG_VIDEO_BUZ is not set
-
-#
-# Joystick support
-#
-# CONFIG_JOYSTICK is not set
-# CONFIG_DTLK is not set
-
-#
-# Ftape, the floppy tape device driver
-#
-# CONFIG_FTAPE is not set
-
-#
-# SCSI support
-#
-# CONFIG_SCSI is not set
-
-#
-# Filesystems
-#
-# CONFIG_QUOTA is not set
-# CONFIG_AUTOFS_FS is not set
-# CONFIG_ADFS_FS is not set
-# CONFIG_AFFS_FS is not set
-# CONFIG_HFS_FS is not set
-# CONFIG_FAT_FS is not set
-# CONFIG_MSDOS_FS is not set
-# CONFIG_UMSDOS_FS is not set
-# CONFIG_VFAT_FS is not set
-# CONFIG_ISO9660_FS is not set
-# CONFIG_JOLIET is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_NTFS_FS is not set
-# CONFIG_HPFS_FS is not set
-CONFIG_PROC_FS=y
-# CONFIG_QNX4FS_FS is not set
-# CONFIG_ROMFS_FS is not set
-CONFIG_EXT2_FS=y
-# CONFIG_SYSV_FS is not set
-# CONFIG_UFS_FS is not set
-# CONFIG_EFS_FS is not set
-
-#
-# Partition Types
-#
-# CONFIG_PARTITION_ADVANCED is not set
-CONFIG_MSDOS_PARTITION=y
-# CONFIG_SMD_DISKLABEL is not set
-# CONFIG_SGI_DISKLABEL is not set
-# CONFIG_NLS is not set
-
-#
-# Kernel hacking
-#
-# CONFIG_FRAME_POINTER is not set
-# CONFIG_DEBUG_ERRORS is not set
-CONFIG_DEBUG_USER=y
-# CONFIG_DEBUG_INFO is not set
-# CONFIG_MAGIC_SYSRQ is not set
-# CONFIG_DEBUG_LL is not set
Index: empeg/kernel/arch/arm/def-configs/empeg-car1
diff -u empeg/kernel/arch/arm/def-configs/empeg-car1:1.1.2.2 empeg/kernel/arch/arm/def-configs/empeg-car1:1.2
--- empeg/kernel/arch/arm/def-configs/empeg-car1:1.1.2.2	Tue Jun  5 19:36:37 2001
+++ empeg/kernel/arch/arm/def-configs/empeg-car1	Fri Dec 22 17:24:28 2000
@@ -126,6 +126,7 @@
 CONFIG_EMPEG_DISPLAY=y
 # CONFIG_EMPEG_DISPLAY_INVERTED is not set
 CONFIG_EMPEG_POWER=y
+# CONFIG_EMPEG_RAMTEST is not set
 
 #
 # Video For Linux
@@ -182,6 +183,7 @@
 CONFIG_EXT2_FS=y
 # CONFIG_SYSV_FS is not set
 # CONFIG_UFS_FS is not set
+# CONFIG_REISERFS_FS is not set
 # CONFIG_EFS_FS is not set
 
 #
Index: empeg/kernel/arch/arm/def-configs/empeg-car2
diff -u empeg/kernel/arch/arm/def-configs/empeg-car2:1.1.2.3 empeg/kernel/arch/arm/def-configs/empeg-car2:1.3
--- empeg/kernel/arch/arm/def-configs/empeg-car2:1.1.2.3	Tue Jun  5 19:36:37 2001
+++ empeg/kernel/arch/arm/def-configs/empeg-car2	Mon Apr 23 14:23:45 2001
@@ -127,6 +127,7 @@
 CONFIG_EMPEG_DISPLAY=y
 # CONFIG_EMPEG_DISPLAY_INVERTED is not set
 CONFIG_EMPEG_POWER=y
+# CONFIG_EMPEG_RAMTEST is not set
 
 #
 # Video For Linux
@@ -314,6 +315,7 @@
 CONFIG_EXT2_FS=y
 # CONFIG_SYSV_FS is not set
 # CONFIG_UFS_FS is not set
+# CONFIG_REISERFS_FS is not set
 # CONFIG_EFS_FS is not set
 
 #
Index: empeg/kernel/arch/arm/def-configs/mk2-test
diff -u /dev/null empeg/kernel/arch/arm/def-configs/mk2-test:1.1
--- /dev/null	Wed Oct 17 16:36:04 2001
+++ empeg/kernel/arch/arm/def-configs/mk2-test	Fri Jun 22 10:44:23 2001
@@ -0,0 +1,309 @@
+#
+# Automatically generated by make menuconfig: don't edit
+#
+CONFIG_ARM=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+
+#
+# System and processor type
+#
+# CONFIG_ARCH_ARC is not set
+# CONFIG_ARCH_A5K is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_FOOTBRIDGE is not set
+CONFIG_ARCH_SA1100=y
+CONFIG_CPU_SA1100=y
+# CONFIG_SA1100_BRUTUS is not set
+CONFIG_SA1100_EMPEG=y
+# CONFIG_SA1100_ITSY is not set
+# CONFIG_SA1100_LART is not set
+# CONFIG_SA1100_PLEB is not set
+# CONFIG_SA1100_THINCLIENT is not set
+# CONFIG_SA1100_TIFON is not set
+# CONFIG_SA1100_VICTOR is not set
+# CONFIG_ARCH_ACORN is not set
+CONFIG_CPU_32=y
+# CONFIG_CPU_26 is not set
+CONFIG_CPU_32v4=y
+CONFIG_CPU_SA110=y
+# CONFIG_ISA_DMA is not set
+# CONFIG_ALIGNMENT_TRAP is not set
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# General setup
+#
+CONFIG_NET=y
+# CONFIG_SYSVIPC is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+CONFIG_NWFPE=y
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_ARTHUR is not set
+# CONFIG_PARPORT is not set
+CONFIG_CMDLINE="mem=12M"
+
+#
+# Plug and Play support
+#
+# CONFIG_PNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_IDE=y
+# CONFIG_BLK_DEV_HD_IDE is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_BLK_DEV_CMD640 is not set
+# CONFIG_IDE_CHIPSETS is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_BLK_DEV_XD is not set
+CONFIG_PARIDE_PARPORT=y
+# CONFIG_PARIDE is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+CONFIG_SERIAL_SA1100=y
+CONFIG_SERIAL_SA1100_CONSOLE=y
+# CONFIG_SERIAL is not set
+# CONFIG_SERIAL_EXTENDED is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_UNIX98_PTYS is not set
+
+#
+# Mice
+#
+# CONFIG_BUSMOUSE is not set
+# CONFIG_MOUSE is not set
+
+#
+# Joysticks
+#
+# CONFIG_JOYSTICK is not set
+# CONFIG_QIC02_TAPE is not set
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+CONFIG_EMPEG_INPUT=y
+# CONFIG_EMPEG_USB9602 is not set
+CONFIG_EMPEG_USBD12=y
+CONFIG_EMPEG_STATE=y
+CONFIG_EMPEG_RDS=y
+# CONFIG_EMPEG_DAC is not set
+CONFIG_EMPEG_DSP=y
+CONFIG_EMPEG_CS4231=y
+CONFIG_EMPEG_SER2IRDA=y
+CONFIG_EMPEG_DISPLAY=y
+# CONFIG_EMPEG_DISPLAY_INVERTED is not set
+CONFIG_EMPEG_POWER=y
+CONFIG_EMPEG_RAMTEST=y
+
+#
+# Video For Linux
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DTLK is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+
+#
+# Networking options
+#
+# CONFIG_PACKET is not set
+# CONFIG_NETLINK is not set
+# CONFIG_FIREWALL is not set
+# CONFIG_FILTER is not set
+# CONFIG_UNIX is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_FUDGE_DHCPDISCOVER=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_IP_PNP_UPNP is not set
+# CONFIG_IP_PNP_SSDP is not set
+# CONFIG_IP_ROUTER is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_ALIAS is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_RARP is not set
+# CONFIG_SKB_LARGE is not set
+# CONFIG_IPV6 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_LLC is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+# CONFIG_CPU_IS_SLOW is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Amateur Radio support
+#
+# CONFIG_HAMRADIO is not set
+
+#
+# IrDA subsystem support
+#
+# CONFIG_IRDA is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_SB1000 is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_ARM_AM79C961A is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_LANCE is not set
+CONFIG_NET_VENDOR_SMC=y
+# CONFIG_WD80x3 is not set
+# CONFIG_ULTRA is not set
+# CONFIG_ULTRA32 is not set
+# CONFIG_SMC9194 is not set
+CONFIG_SMC9194_TIFON=y
+# CONFIG_NET_VENDOR_RACAL is not set
+# CONFIG_RTL8139 is not set
+# CONFIG_NET_ISA is not set
+# CONFIG_NET_EISA is not set
+# CONFIG_NET_POCKET is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NET_RADIO is not set
+
+#
+# Token ring devices
+#
+# CONFIG_TR is not set
+# CONFIG_NET_FC is not set
+# CONFIG_RCPCI is not set
+# CONFIG_SHAPER is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_HOSTESS_SV11 is not set
+# CONFIG_COSA is not set
+# CONFIG_SEALEVEL_4021 is not set
+# CONFIG_COMX is not set
+# CONFIG_DLCI is not set
+# CONFIG_SBNI is not set
+
+#
+# SCSI support
+#
+# CONFIG_SCSI is not set
+
+#
+# Filesystems
+#
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_FAT_FS is not set
+# CONFIG_MSDOS_FS is not set
+# CONFIG_UMSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_ISO9660_FS is not set
+# CONFIG_JOLIET is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_NTFS_FS is not set
+# CONFIG_HPFS_FS is not set
+CONFIG_PROC_FS=y
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_EXT2_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_EFS_FS is not set
+
+#
+# Network File Systems
+#
+# CONFIG_CODA_FS is not set
+CONFIG_NFS_FS=y
+CONFIG_ROOT_NFS=y
+CONFIG_ROOT_NFS_MOUNTPOINT="/tftpboot/mk2boot"
+# CONFIG_NFSD is not set
+CONFIG_SUNRPC=y
+CONFIG_LOCKD=y
+# CONFIG_SMB_FS is not set
+# CONFIG_NCP_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_SMD_DISKLABEL is not set
+# CONFIG_SGI_DISKLABEL is not set
+# CONFIG_NLS is not set
+
+#
+# Kernel hacking
+#
+CONFIG_FRAME_POINTER=y
+CONFIG_DEBUG_ERRORS=y
+CONFIG_DEBUG_USER=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_DEBUG_LL is not set
Index: empeg/kernel/arch/arm/kernel/entry-armv.S
diff -u empeg/kernel/arch/arm/kernel/entry-armv.S:1.1.1.3 empeg/kernel/arch/arm/kernel/entry-armv.S:1.2
--- empeg/kernel/arch/arm/kernel/entry-armv.S:1.1.1.3	Sat Mar 18 15:24:12 2000
+++ empeg/kernel/arch/arm/kernel/entry-armv.S	Wed Jun 13 11:17:53 2001
@@ -380,7 +380,8 @@
 
 		.macro	restore_user_regs
 		ldr	r0, [sp, #S_PSR]		@ Get calling cpsr
-		msr	cpsr_c, #I_BIT | MODE_SVC	@ disable IRQs
+		mov	ip, #I_BIT | MODE_SVC
+		msr	cpsr_c, ip			@ disable IRQs
 		msr	spsr, r0			@ save in spsr_svc
 		ldmia	sp, {r0 - lr}^			@ Get calling r0 - lr
 		mov	r0, r0
@@ -527,7 +528,8 @@
 		msr	cpsr_c, r9
 		mov	r3, sp
 		bl	SYMBOL_NAME(do_DataAbort)
-		msr	cpsr_c, #I_BIT | MODE_SVC
+		mov	r0, #I_BIT | MODE_SVC
+		msr	cpsr_c, r0
 		ldr	r0, [sp, #S_PSR]
 		msr	spsr, r0
 		ldmia	sp, {r0 - pc}^			@ load r0 - pc, cpsr
@@ -569,7 +571,8 @@
 		mov	r1, sp				@ struct pt_regs *regs
 		bl	SYMBOL_NAME(do_undefinstr)
 
-1:		msr	cpsr_c, #I_BIT | MODE_SVC
+1:		mov	r0, #I_BIT | MODE_SVC
+		msr	cpsr_c, r0
 		ldr	lr, [sp, #S_PSR]		@ Get SVC cpsr
 		msr	spsr, lr
 		ldmia	sp, {r0 - pc}^			@ Restore SVC registers
@@ -602,7 +605,8 @@
 		ldr	r2, .LCprocfns
 		mov	lr, pc
 		ldr	pc, [r2, #8]			@ call processor specific code
-		msr	cpsr_c, #MODE_SVC		@ Enable interrupts
+		mov	r3, #MODE_SVC
+		msr	cpsr_c, r3			@ Enable interrupts
 		mov	r3, sp
 		adrsvc	al, lr, ret_from_sys_call
 		b	SYMBOL_NAME(do_DataAbort)
@@ -647,9 +651,10 @@
 		add	r10, r10, #TSS_FPESAVE		@ r10 = workspace
 		ldr	pc, [r4]			@ Call FP module USR entry point
 
-fpundefinstr:	mov	r0, lr
+fpundefinstr:	mov	r0, #MODE_SVC
+		msr	cpsr_c, r0			@ Enable interrupts
+		mov	r0, lr
 		mov	r1, sp
-		msr	cpsr_c, #MODE_SVC
 		adrsvc	al, lr, ret_from_sys_call
 		b	SYMBOL_NAME(do_undefinstr)
 
@@ -663,7 +668,8 @@
 		stmdb	r8, {sp, lr}^			@ Save sp_usr lr_usr
 		alignment_trap r4, r7, __temp_abt
 		mov	fp, #0
-		msr	cpsr_c, #MODE_SVC		@ Enable interrupts
+		mov	r0, #MODE_SVC
+		msr	cpsr_c, r0			@ Enable interrupts
 		mov	r0, r5				@ address (pc)
 		mov	r1, sp				@ regs
 		bl	SYMBOL_NAME(do_PrefetchAbort)	@ call abort handler
@@ -726,7 +732,8 @@
 		@
 		@ now branch to the relevent MODE handling routine
 		@
-		msr	spsr_c, #I_BIT | MODE_SVC	@ switch to SVC_32 mode
+		mov	r13, #I_BIT | MODE_SVC
+		msr	spsr_c, r13			@ switch to SVC_32 mode
 
 		and	lr, lr, #15
 		ldr	lr, [pc, lr, lsl #2]
@@ -766,7 +773,8 @@
 		@
 		@ now branch to the relevent MODE handling routine
 		@
-		msr	spsr_c, #I_BIT | MODE_SVC	@ switch to SVC_32 mode
+		mov	r13, #I_BIT | MODE_SVC
+		msr	spsr_c, r13			@ switch to SVC_32 mode
 
 		and	lr, lr, #15
 		ldr	lr, [pc, lr, lsl #2]
@@ -807,7 +815,8 @@
 		@
 		@ now branch to the relevent MODE handling routine
 		@
-		msr	spsr_c, #I_BIT | MODE_SVC	@ switch to SVC_32 mode
+		mov	r13, #I_BIT | MODE_SVC
+		msr	spsr_c, r13			@ switch to SVC_32 mode
 
 		ands	lr, lr, #15
 		ldreq	lr, .LCtab_pabt
@@ -834,7 +843,8 @@
 		@
 		@ now branch to the relevent MODE handling routine
 		@
-		msr	spsr_c, #I_BIT | MODE_SVC	@ switch to SVC_32 mode
+		mov	r13, #I_BIT | MODE_SVC
+		msr	spsr_c, r13			@ switch to SVC_32 mode
 
 		and	lr, lr, #15
 		ldr	lr, [pc, lr, lsl #2]
Index: empeg/kernel/arch/arm/kernel/setup.c
diff -u empeg/kernel/arch/arm/kernel/setup.c:1.11.4.2 empeg/kernel/arch/arm/kernel/setup.c:1.14
--- empeg/kernel/arch/arm/kernel/setup.c:1.11.4.2	Tue Dec 19 19:41:31 2000
+++ empeg/kernel/arch/arm/kernel/setup.c	Mon Feb 19 17:56:48 2001
@@ -550,7 +550,10 @@
 
 	/* Botch revision number */
 	/* Setup the virt/phys mapping tables */
-	empeg_setup_bank_mapping(mem_end < PAGE_OFFSET + 16*1024*1024 ? 7 : 9);
+	if(mem_end < (PAGE_OFFSET + 16*1024*1024))
+		empeg_setup_bank_mapping(7);
+	else
+		empeg_setup_bank_mapping(9);
 	
 	init_task.mm->start_code = (unsigned long) &_text;
 	init_task.mm->end_code	 = (unsigned long) &_etext;
Index: empeg/kernel/arch/arm/mm/fault-armv.c
diff -u empeg/kernel/arch/arm/mm/fault-armv.c:1.6 empeg/kernel/arch/arm/mm/fault-armv.c:1.7
--- empeg/kernel/arch/arm/mm/fault-armv.c:1.6	Sat Mar 18 15:56:19 2000
+++ empeg/kernel/arch/arm/mm/fault-armv.c	Thu Aug 23 16:28:14 2001
@@ -386,7 +386,7 @@
   "Please read http://www.arm.linux.org.uk/state.html for more information"
 #else
 #define BUG_PROC_MSG \
-  "(You ain't seen me roight)\n"
+  "(You ain't seen me roight - %08X)\n"
 #endif
 
 asmlinkage void
Index: empeg/kernel/arch/arm/mm/fault-common.c
diff -u empeg/kernel/arch/arm/mm/fault-common.c:1.8 empeg/kernel/arch/arm/mm/fault-common.c:1.10
--- empeg/kernel/arch/arm/mm/fault-common.c:1.8	Sat Mar 18 15:56:30 2000
+++ empeg/kernel/arch/arm/mm/fault-common.c	Tue Feb  6 18:03:13 2001
@@ -5,6 +5,8 @@
  *  Modifications for ARM processor (c) 1995-1999 Russell King
  */
 #include <linux/config.h>
+#include <linux/pagemap.h>
+#include <linux/swap.h>
 
 extern void die(char *msg, struct pt_regs *regs, unsigned int err);
 
@@ -165,8 +167,9 @@
 		tsk->tss.error_code = mode;
 		tsk->tss.trap_no = 14;
 #ifdef CONFIG_DEBUG_USER
-		printk("%s: memory violation at pc=0x%08lx, lr=0x%08lx (bad address=0x%08lx, code %d)\n",
-			tsk->comm, regs->ARM_pc, regs->ARM_lr, addr, mode);
+		printk("%s(%d): memory violation at pc=0x%08lx, lr=0x%08lx (bad address=0x%08lx, code %d)\n",
+		       tsk->comm, tsk->pid,
+		       regs->ARM_pc, regs->ARM_lr, addr, mode);
 		show_regs(regs);
 		c_backtrace(regs->ARM_fp, regs->ARM_cpsr);
 #endif
@@ -178,8 +181,8 @@
 	/* Are we prepared to handle this kernel fault?  */
 	if ((fixup = search_exception_table(instruction_pointer(regs))) != 0) {
 #ifdef DEBUG
-		printk(KERN_DEBUG "%s: Exception at [<%lx>] addr=%lx (fixup: %lx)\n",
-			tsk->comm, regs->ARM_pc, addr, fixup);
+		printk(KERN_DEBUG "%s(%d): Exception at [<%lx>] addr=%lx (fixup: %lx)\n",
+		       tsk->comm, tsk->pid, regs->ARM_pc, addr, fixup);
 #endif
 		regs->ARM_pc = fixup;
 		return;
@@ -201,6 +204,14 @@
 	up(&mm->mmap_sem);
 	if (user_mode(regs)) {
 		printk("VM: killing process %s\n", tsk->comm);
+		printk("buffermem       : %ld\n"
+		       "page_cache_size : %ld\n"
+		       "nr_free_pages   : %d\n"
+		       "num_physpages   : %ld\n",
+		       buffermem,
+		       page_cache_size,
+		       nr_free_pages,
+		       num_physpages);
 		do_exit(SIGKILL);
 	}
 	goto no_context;
@@ -219,8 +230,9 @@
 	tsk->tss.error_code = mode;
 	tsk->tss.trap_no = 14;
 #ifdef CONFIG_DEBUG_USER
-		printk("%s: memory violation at pc=0x%08lx, lr=0x%08lx (bad address=0x%08lx, code %d)\n",
-			tsk->comm, regs->ARM_pc, regs->ARM_lr, addr, mode);
+		printk("%s(%d): memory violation at pc=0x%08lx, lr=0x%08lx (bad address=0x%08lx, code %d)\n",
+		       tsk->comm, tsk->pid,
+		       regs->ARM_pc, regs->ARM_lr, addr, mode);
 		show_regs(regs);
 		c_backtrace(regs->ARM_fp, regs->ARM_cpsr);
 #endif
Index: empeg/kernel/arch/arm/special/Makefile
diff -u empeg/kernel/arch/arm/special/Makefile:1.18.8.2 empeg/kernel/arch/arm/special/Makefile:1.21
--- empeg/kernel/arch/arm/special/Makefile:1.18.8.2	Tue Jun  5 19:35:38 2001
+++ empeg/kernel/arch/arm/special/Makefile	Tue Oct 17 12:41:36 2000
@@ -90,8 +90,7 @@
 endif
 
 ifdef CONFIG_EMPEG_DSP
-#  L_OBJS	+= empeg_audio2.o
-L_OBJS		+= empeg_audio3.o empeg_dsp.o empeg_dsp_i2c.o empeg_mixer.o
+  L_OBJS	+= empeg_dsp.o empeg_dsp_i2c.o empeg_audio3.o empeg_mixer.o
 endif
 
 ifdef CONFIG_EMPEG_DAC
@@ -116,6 +115,10 @@
 
 ifdef CONFIG_EMPEG_POWER
   L_OBJS        += empeg_power.o
+endif
+
+ifdef CONFIG_EMPEG_RAMTEST
+  L_OBJS	+= empeg_ramtest.o empeg_ramtest_asm.o
 endif
 
 ifdef CONFIG_SA1100_CITYGO
Index: empeg/kernel/arch/arm/special/empeg_ani.h
diff -u /dev/null empeg/kernel/arch/arm/special/empeg_ani.h:1.4
--- /dev/null	Wed Oct 17 16:36:04 2001
+++ empeg/kernel/arch/arm/special/empeg_ani.h	Fri Oct  5 15:56:38 2001
@@ -0,0 +1,842 @@
+/* This file is autogenerated by the rules in kernel-logos/ - do not edit */
+static unsigned char empeg_ani[] = {
+    0x70, 0x00, 0x00, 0x00, 0x70, 0x04, 0x00, 0x00, 0x70, 0x08, 0x00, 0x00, 0x70, 0x0c, 0x00, 0x00,
+    0x70, 0x10, 0x00, 0x00, 0x70, 0x14, 0x00, 0x00, 0x70, 0x18, 0x00, 0x00, 0x70, 0x1c, 0x00, 0x00,
+    0x70, 0x1c, 0x00, 0x00, 0x70, 0x1c, 0x00, 0x00, 0x70, 0x20, 0x00, 0x00, 0x70, 0x20, 0x00, 0x00,
+    0x70, 0x20, 0x00, 0x00, 0x70, 0x20, 0x00, 0x00, 0x70, 0x24, 0x00, 0x00, 0x70, 0x28, 0x00, 0x00,
+    0x70, 0x2c, 0x00, 0x00, 0x70, 0x30, 0x00, 0x00, 0x70, 0x2c, 0x00, 0x00, 0x70, 0x30, 0x00, 0x00,
+    0x70, 0x2c, 0x00, 0x00, 0x70, 0x30, 0x00, 0x00, 0x70, 0x2c, 0x00, 0x00, 0x70, 0x28, 0x00, 0x00,
+    0x70, 0x24, 0x00, 0x00, 0x70, 0x20, 0x00, 0x00, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x9f, 0xb6, 0x04, 0xa1, 0x00, 0x96, 0x00, 0x09, 0x60, 0x5a, 0xa1, 0x4e, 0xfb, 0x00,
+    0x00, 0x9f, 0xb6, 0x00, 0x00, 0x4a, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x0e, 0xfa, 0xef, 0x7f, 0xff, 0x6e, 0xff, 0xb0, 0xef, 0xfb, 0xff, 0xfb, 0xeb, 0xae, 0xb0,
+    0x0e, 0xfa, 0xef, 0x70, 0x04, 0xff, 0xfe, 0xff, 0xf3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xcb, 0x10, 0x08, 0xf7, 0x09, 0x7b, 0x14, 0xe5, 0xb1, 0x4e, 0xb0, 0x0e, 0x70, 0x04, 0xe2,
+    0x8b, 0x10, 0x08, 0xf2, 0x4f, 0xa5, 0x9f, 0xa5, 0x93, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x04, 0xb1, 0x00, 0x00, 0xcb, 0x00, 0xe0, 0x00, 0x4f, 0x10, 0x00, 0xe2, 0x08, 0x10, 0x00, 0x8b,
+    0xf1, 0x00, 0x00, 0x8b, 0xe6, 0x00, 0x0d, 0x10, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0x20, 0x04, 0x10, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x0e,
+    0x70, 0x04, 0x10, 0x0e, 0xb0, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0b, 0x00, 0x8f, 0xf1, 0x0c, 0x20, 0x05, 0x00, 0x00, 0x41, 0x00, 0x0b, 0x00, 0x4a, 0x00, 0x08,
+    0x30, 0x8f, 0xf1, 0x0c, 0x30, 0x09, 0x20, 0x00, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x87, 0x00, 0xe6, 0xa3, 0x08, 0x30, 0xcf, 0x30, 0x00, 0xff, 0x00, 0x0b, 0x04, 0xef, 0xb0, 0x08,
+    0x30, 0xe6, 0xa3, 0x08, 0x30, 0x9f, 0xf2, 0x00, 0xc2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0xc2, 0x08, 0x70, 0xdb, 0x04, 0xb0, 0xba, 0xb0, 0x0c, 0xae, 0x20, 0x0b, 0x08, 0x74, 0xe1, 0x04,
+    0x78, 0x70, 0xdb, 0x04, 0xb0, 0xe1, 0x97, 0x00, 0xc2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0xe1, 0x0c, 0xaf, 0xb6, 0x00, 0xf0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0e, 0x10, 0xc2, 0x00,
+    0xbc, 0xaf, 0xb6, 0x00, 0xf8, 0x70, 0x0b, 0x00, 0xc2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0xe0, 0x0d, 0xfa, 0x10, 0x04, 0xf0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x00,
+    0xbe, 0xfa, 0x10, 0x04, 0xfc, 0x20, 0x0e, 0x00, 0xd1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0xb0, 0x08, 0x10, 0x04, 0xaf, 0xb0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x00,
+    0xb8, 0x10, 0x04, 0xaf, 0xbc, 0x20, 0x0e, 0x00, 0xd1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0xb0, 0x00, 0x00, 0xaf, 0xfb, 0x04, 0x70, 0xe0, 0x0d, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x04,
+    0x70, 0x00, 0xaf, 0xfb, 0x0c, 0x20, 0x0e, 0x00, 0xd1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0xb0, 0x00, 0x9e, 0xfa, 0xe2, 0x04, 0x70, 0xe0, 0x0d, 0x18, 0x30, 0x4b, 0x0b, 0x00, 0xc2, 0x08,
+    0x30, 0x9e, 0xfa, 0xe2, 0x0c, 0x20, 0x0b, 0x00, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0xb0, 0x08, 0xeb, 0x9f, 0xfb, 0x04, 0x70, 0xe0, 0x0d, 0x18, 0x30, 0x47, 0x0b, 0x00, 0xe1, 0x08,
+    0x38, 0xeb, 0x9f, 0xfb, 0x0c, 0x20, 0x87, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0xe0, 0x08, 0xb5, 0xe3, 0x9f, 0x78, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x47, 0x0d, 0xaa, 0xb0, 0x0d,
+    0x28, 0xb5, 0xe3, 0x9f, 0x74, 0xba, 0xe2, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0xd1, 0x00, 0xef, 0xb0, 0x0c, 0x38, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x87, 0x04, 0xff, 0x10, 0x0e,
+    0x00, 0xef, 0xb0, 0x0c, 0x30, 0xdf, 0x70, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0xc2, 0x00, 0x05, 0x00, 0x0e, 0x18, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x83, 0x00, 0x00, 0x00, 0x8b,
+    0x00, 0x05, 0x00, 0x0e, 0x10, 0x0a, 0x10, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x4b, 0x00, 0x00, 0x00, 0x8b, 0x08, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x83, 0x00, 0x00, 0x00, 0xdb,
+    0x00, 0x00, 0x00, 0x8b, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0e, 0x20, 0x00, 0x00, 0xe2, 0x08, 0x34, 0xb0, 0x0e, 0x0d, 0x20, 0x83, 0x42, 0x00, 0x08, 0xbe,
+    0x20, 0x00, 0x00, 0xef, 0x10, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x08, 0xb2, 0x00, 0x4e, 0xf1, 0x08, 0x34, 0xb0, 0x0e, 0x0d, 0x20, 0x83, 0x8f, 0x60, 0x9e, 0x28,
+    0xb2, 0x00, 0x4e, 0xbc, 0xb1, 0x00, 0xd3, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xdf, 0xaa, 0xeb, 0xef, 0xff, 0x24, 0xff, 0xfb, 0x0d, 0xff, 0xf2, 0xca, 0xff, 0xf7, 0x00,
+    0xdf, 0xaa, 0xeb, 0x20, 0xeb, 0xae, 0xb3, 0x04, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x09, 0xff, 0xb0, 0x8a, 0xaa, 0x10, 0xaa, 0xa6, 0x04, 0xae, 0xa1, 0xc2, 0x5a, 0x10, 0x00,
+    0x09, 0xff, 0xb0, 0x00, 0x0e, 0xfb, 0xe2, 0x04, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x10, 0xd2, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xe1, 0x08, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0xd2, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xcf, 0xae, 0x70, 0x08, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xd1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xca, 0xfb, 0x00, 0x0d, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc2, 0x00, 0x00, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc1, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc1, 0x00, 0x09, 0xf1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc6, 0x5a, 0xef, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xcf, 0xff, 0xb1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x9f, 0xb6, 0x04, 0xa1, 0x00, 0x96, 0x00, 0x09, 0x60, 0x5a, 0xa1, 0x4e, 0xfb, 0x00,
+    0x00, 0x9f, 0xb6, 0x00, 0x00, 0x4a, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c,
+    0x00, 0x0e, 0xfa, 0xef, 0x7f, 0xff, 0x6e, 0xff, 0xb0, 0xef, 0xfb, 0xff, 0xfb, 0xeb, 0xae, 0xb0,
+    0x0e, 0xfa, 0xef, 0x70, 0x04, 0xff, 0xfe, 0xff, 0xf3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b,
+    0x00, 0xcb, 0x10, 0x08, 0xf7, 0x09, 0x7b, 0x14, 0xe5, 0xb1, 0x4e, 0xb0, 0x0e, 0x70, 0x04, 0xe2,
+    0x8b, 0x10, 0x08, 0xf2, 0x4f, 0xa5, 0x9f, 0xa5, 0x93, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
+    0x04, 0xb1, 0x00, 0x00, 0xcb, 0x00, 0xe0, 0x00, 0x4f, 0x10, 0x00, 0xe2, 0x08, 0x10, 0x00, 0x8b,
+    0xf1, 0x00, 0x00, 0x8b, 0xe6, 0x00, 0x0d, 0x10, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
+    0x0d, 0x20, 0x04, 0x10, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x0e,
+    0x70, 0x04, 0x10, 0x0e, 0xb0, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,
+    0x0b, 0x00, 0x8f, 0xf1, 0x0c, 0x20, 0x05, 0x00, 0x00, 0x41, 0x00, 0x0b, 0x00, 0x4a, 0x00, 0x08,
+    0x30, 0x8f, 0xf1, 0x0c, 0x30, 0x09, 0x20, 0x00, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43,
+    0x87, 0x00, 0xe6, 0xa3, 0x08, 0x30, 0xcf, 0x30, 0x00, 0xff, 0x00, 0x0b, 0x04, 0xef, 0xb0, 0x08,
+    0x30, 0xe6, 0xa3, 0x08, 0x30, 0x9f, 0xf2, 0x00, 0xc2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xde,
+    0xc2, 0x08, 0x70, 0xdb, 0x04, 0xb0, 0xba, 0xb0, 0x0c, 0xae, 0x20, 0x0b, 0x08, 0x74, 0xe1, 0x04,
+    0x78, 0x70, 0xdb, 0x04, 0xb0, 0xe1, 0x97, 0x00, 0xc2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xba,
+    0xe1, 0x0c, 0xaf, 0xb6, 0x00, 0xf0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0e, 0x10, 0xc2, 0x00,
+    0xbc, 0xaf, 0xb6, 0x00, 0xf8, 0x70, 0x0b, 0x00, 0xc2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0xaa,
+    0xe0, 0x0d, 0xfa, 0x10, 0x04, 0xf0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x00,
+    0xbe, 0xfa, 0x10, 0x04, 0xfc, 0x20, 0x0e, 0x00, 0xd1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfb,
+    0xb0, 0x08, 0x10, 0x04, 0xaf, 0xb0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x00,
+    0xb8, 0x10, 0x04, 0xaf, 0xbc, 0x20, 0x0e, 0x00, 0xd1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,
+    0xb0, 0x00, 0x00, 0xaf, 0xfb, 0x04, 0x70, 0xe0, 0x0d, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x04,
+    0x70, 0x00, 0xaf, 0xfb, 0x0c, 0x20, 0x0e, 0x00, 0xd1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4f,
+    0xb0, 0x00, 0x9e, 0xfa, 0xe2, 0x04, 0x70, 0xe0, 0x0d, 0x18, 0x30, 0x4b, 0x0b, 0x00, 0xc2, 0x08,
+    0x30, 0x9e, 0xfa, 0xe2, 0x0c, 0x20, 0x0b, 0x00, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f,
+    0xb0, 0x08, 0xeb, 0x9f, 0xfb, 0x04, 0x70, 0xe0, 0x0d, 0x18, 0x30, 0x47, 0x0b, 0x00, 0xe1, 0x08,
+    0x38, 0xeb, 0x9f, 0xfb, 0x0c, 0x20, 0x87, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdf,
+    0xe0, 0x08, 0xb5, 0xe3, 0x9f, 0x78, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x47, 0x0d, 0xaa, 0xb0, 0x0d,
+    0x28, 0xb5, 0xe3, 0x9f, 0x74, 0xba, 0xe2, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xef,
+    0xd1, 0x00, 0xef, 0xb0, 0x0c, 0x38, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x87, 0x04, 0xff, 0x10, 0x0e,
+    0x00, 0xef, 0xb0, 0x0c, 0x30, 0xdf, 0x70, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xff,
+    0xc2, 0x00, 0x05, 0x00, 0x0e, 0x18, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x83, 0x00, 0x00, 0x00, 0x8b,
+    0x00, 0x05, 0x00, 0x0e, 0x10, 0x0a, 0x10, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xfb,
+    0x4b, 0x00, 0x00, 0x00, 0x8b, 0x08, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x83, 0x00, 0x00, 0x00, 0xdb,
+    0x00, 0x00, 0x00, 0x8b, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0xfb,
+    0x0e, 0x20, 0x00, 0x00, 0xe2, 0x08, 0x34, 0xb0, 0x0e, 0x0d, 0x20, 0x83, 0x42, 0x00, 0x08, 0xbe,
+    0x20, 0x00, 0x00, 0xef, 0x10, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0xf7,
+    0x08, 0xb2, 0x00, 0x4e, 0xf1, 0x08, 0x34, 0xb0, 0x0e, 0x0d, 0x20, 0x83, 0x8f, 0x60, 0x9e, 0x28,
+    0xb2, 0x00, 0x4e, 0xbc, 0xb1, 0x00, 0xd3, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf2,
+    0x00, 0xdf, 0xaa, 0xeb, 0xef, 0xff, 0x24, 0xff, 0xfb, 0x0d, 0xff, 0xf2, 0xca, 0xff, 0xf7, 0x00,
+    0xdf, 0xaa, 0xeb, 0x20, 0xeb, 0xae, 0xb3, 0x04, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf1,
+    0x00, 0x09, 0xff, 0xb0, 0x8a, 0xaa, 0x10, 0xaa, 0xa6, 0x04, 0xae, 0xa1, 0xc2, 0x5a, 0x10, 0x00,
+    0x09, 0xff, 0xb0, 0x00, 0x0e, 0xfb, 0xe2, 0x04, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xb0,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x10, 0xd2, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xe1, 0x08, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x70,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0xd2, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xcf, 0xae, 0x70, 0x08, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0xf6,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xd1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xca, 0xfb, 0x00, 0x0d, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xff,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc2, 0x00, 0x00, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xef,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc1, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xeb, 0x9f,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc1, 0x00, 0x09, 0xf1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xba, 0x65,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc6, 0x5a, 0xef, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xef, 0xaa,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xcf, 0xff, 0xb1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xff,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
+    0x00, 0x00, 0x9f, 0xb6, 0x04, 0xa1, 0x00, 0x96, 0x00, 0x09, 0x60, 0x5a, 0xa1, 0x4e, 0xfb, 0x00,
+    0x00, 0x9f, 0xb6, 0x00, 0x00, 0x4a, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x20,
+    0x00, 0x0e, 0xfa, 0xef, 0x7f, 0xff, 0x6e, 0xff, 0xb0, 0xef, 0xfb, 0xff, 0xfb, 0xeb, 0xae, 0xb0,
+    0x0e, 0xfa, 0xef, 0x70, 0x04, 0xff, 0xfe, 0xff, 0xf3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00,
+    0x00, 0xcb, 0x10, 0x08, 0xf7, 0x09, 0x7b, 0x14, 0xe5, 0xb1, 0x4e, 0xb0, 0x0e, 0x70, 0x04, 0xe2,
+    0x8b, 0x10, 0x08, 0xf2, 0x4f, 0xa5, 0x9f, 0xa5, 0x93, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00,
+    0x04, 0xb1, 0x00, 0x00, 0xcb, 0x00, 0xe0, 0x00, 0x4f, 0x10, 0x00, 0xe2, 0x08, 0x10, 0x00, 0x8b,
+    0xf1, 0x00, 0x00, 0x8b, 0xe6, 0x00, 0x0d, 0x10, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00,
+    0x0d, 0x20, 0x04, 0x10, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x0e,
+    0x70, 0x04, 0x10, 0x0e, 0xb0, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x20,
+    0x0b, 0x00, 0x8f, 0xf1, 0x0c, 0x20, 0x05, 0x00, 0x00, 0x41, 0x00, 0x0b, 0x00, 0x4a, 0x00, 0x08,
+    0x30, 0x8f, 0xf1, 0x0c, 0x30, 0x09, 0x20, 0x00, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x30,
+    0x87, 0x00, 0xe6, 0xa3, 0x08, 0x30, 0xcf, 0x30, 0x00, 0xff, 0x00, 0x0b, 0x04, 0xef, 0xb0, 0x08,
+    0x30, 0xe6, 0xa3, 0x08, 0x30, 0x9f, 0xf2, 0x00, 0xc2, 0x00, 0x00, 0x00, 0x00, 0x00, 0xde, 0x20,
+    0xc2, 0x08, 0x70, 0xdb, 0x04, 0xb0, 0xba, 0xb0, 0x0c, 0xae, 0x20, 0x0b, 0x08, 0x74, 0xe1, 0x04,
+    0x78, 0x70, 0xdb, 0x04, 0xb0, 0xe1, 0x97, 0x00, 0xc2, 0x00, 0x00, 0x00, 0x00, 0x04, 0xba, 0xa0,
+    0xe1, 0x0c, 0xaf, 0xb6, 0x00, 0xf0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0e, 0x10, 0xc2, 0x00,
+    0xbc, 0xaf, 0xb6, 0x00, 0xf8, 0x70, 0x0b, 0x00, 0xc2, 0x00, 0x00, 0x00, 0x00, 0x0d, 0xaa, 0xa0,
+    0xe0, 0x0d, 0xfa, 0x10, 0x04, 0xf0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x00,
+    0xbe, 0xfa, 0x10, 0x04, 0xfc, 0x20, 0x0e, 0x00, 0xd1, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfb, 0x20,
+    0xb0, 0x08, 0x10, 0x04, 0xaf, 0xb0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x00,
+    0xb8, 0x10, 0x04, 0xaf, 0xbc, 0x20, 0x0e, 0x00, 0xd1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x10,
+    0xb0, 0x00, 0x00, 0xaf, 0xfb, 0x04, 0x70, 0xe0, 0x0d, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x04,
+    0x70, 0x00, 0xaf, 0xfb, 0x0c, 0x20, 0x0e, 0x00, 0xd1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4f, 0x20,
+    0xb0, 0x00, 0x9e, 0xfa, 0xe2, 0x04, 0x70, 0xe0, 0x0d, 0x18, 0x30, 0x4b, 0x0b, 0x00, 0xc2, 0x08,
+    0x30, 0x9e, 0xfa, 0xe2, 0x0c, 0x20, 0x0b, 0x00, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x30,
+    0xb0, 0x08, 0xeb, 0x9f, 0xfb, 0x04, 0x70, 0xe0, 0x0d, 0x18, 0x30, 0x47, 0x0b, 0x00, 0xe1, 0x08,
+    0x38, 0xeb, 0x9f, 0xfb, 0x0c, 0x20, 0x87, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdf, 0xb0,
+    0xe0, 0x08, 0xb5, 0xe3, 0x9f, 0x78, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x47, 0x0d, 0xaa, 0xb0, 0x0d,
+    0x28, 0xb5, 0xe3, 0x9f, 0x74, 0xba, 0xe2, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xef, 0x70,
+    0xd1, 0x00, 0xef, 0xb0, 0x0c, 0x38, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x87, 0x04, 0xff, 0x10, 0x0e,
+    0x00, 0xef, 0xb0, 0x0c, 0x30, 0xdf, 0x70, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x04, 0xff, 0x20,
+    0xc2, 0x00, 0x05, 0x00, 0x0e, 0x18, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x83, 0x00, 0x00, 0x00, 0x8b,
+    0x00, 0x05, 0x00, 0x0e, 0x10, 0x0a, 0x10, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x08, 0xff, 0x20,
+    0x4b, 0x00, 0x00, 0x00, 0x8b, 0x08, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x83, 0x00, 0x00, 0x00, 0xdb,
+    0x00, 0x00, 0x00, 0x8b, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x0d, 0xff, 0x10,
+    0x0e, 0x20, 0x00, 0x00, 0xe2, 0x08, 0x34, 0xb0, 0x0e, 0x0d, 0x20, 0x83, 0x42, 0x00, 0x08, 0xbe,
+    0x20, 0x00, 0x00, 0xef, 0x10, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x0e, 0xfb, 0x00,
+    0x08, 0xb2, 0x00, 0x4e, 0xf1, 0x08, 0x34, 0xb0, 0x0e, 0x0d, 0x20, 0x83, 0x8f, 0x60, 0x9e, 0x28,
+    0xb2, 0x00, 0x4e, 0xbc, 0xb1, 0x00, 0xd3, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf7, 0x00,
+    0x00, 0xdf, 0xaa, 0xeb, 0xef, 0xff, 0x24, 0xff, 0xfb, 0x0d, 0xff, 0xf2, 0xca, 0xff, 0xf7, 0x00,
+    0xdf, 0xaa, 0xeb, 0x20, 0xeb, 0xae, 0xb3, 0x04, 0x70, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf2, 0x04,
+    0x00, 0x09, 0xff, 0xb0, 0x8a, 0xaa, 0x10, 0xaa, 0xa6, 0x04, 0xae, 0xa1, 0xc2, 0x5a, 0x10, 0x00,
+    0x09, 0xff, 0xb0, 0x00, 0x0e, 0xfb, 0xe2, 0x04, 0x70, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf1, 0x0d,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x10, 0xd2, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xe1, 0x08, 0x30, 0x00, 0x00, 0x00, 0x00, 0x0e, 0xfb, 0x9f,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0xd2, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xcf, 0xae, 0x70, 0x08, 0x30, 0x00, 0x00, 0x00, 0x00, 0x0d, 0xff, 0xff,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xd1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xca, 0xfb, 0x00, 0x0d, 0x20, 0x00, 0x00, 0x00, 0x00, 0x08, 0xff, 0xfb,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc2, 0x00, 0x00, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xef, 0xf2,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc1, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9f, 0xb0,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc1, 0x00, 0x09, 0xf1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x65, 0x50,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc6, 0x5a, 0xef, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xba, 0xab,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xcf, 0xff, 0xb1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xef, 0xfd,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x30,
+    0x00, 0x00, 0x9f, 0xb6, 0x04, 0xa1, 0x00, 0x96, 0x00, 0x09, 0x60, 0x5a, 0xa1, 0x4e, 0xfb, 0x00,
+    0x00, 0x9f, 0xb6, 0x00, 0x00, 0x4a, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x20, 0xe0,
+    0x00, 0x0e, 0xfa, 0xef, 0x7f, 0xff, 0x6e, 0xff, 0xb0, 0xef, 0xfb, 0xff, 0xfb, 0xeb, 0xae, 0xb0,
+    0x0e, 0xfa, 0xef, 0x70, 0x04, 0xff, 0xfe, 0xff, 0xf3, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x83,
+    0x00, 0xcb, 0x10, 0x08, 0xf7, 0x09, 0x7b, 0x14, 0xe5, 0xb1, 0x4e, 0xb0, 0x0e, 0x70, 0x04, 0xe2,
+    0x8b, 0x10, 0x08, 0xf2, 0x4f, 0xa5, 0x9f, 0xa5, 0x93, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03,
+    0x04, 0xb1, 0x00, 0x00, 0xcb, 0x00, 0xe0, 0x00, 0x4f, 0x10, 0x00, 0xe2, 0x08, 0x10, 0x00, 0x8b,
+    0xf1, 0x00, 0x00, 0x8b, 0xe6, 0x00, 0x0d, 0x10, 0x43, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03,
+    0x0d, 0x20, 0x04, 0x10, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x0e,
+    0x70, 0x04, 0x10, 0x0e, 0xb0, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x20, 0x07,
+    0x0b, 0x00, 0x8f, 0xf1, 0x0c, 0x20, 0x05, 0x00, 0x00, 0x41, 0x00, 0x0b, 0x00, 0x4a, 0x00, 0x08,
+    0x30, 0x8f, 0xf1, 0x0c, 0x30, 0x09, 0x20, 0x00, 0x83, 0x00, 0x00, 0x00, 0x00, 0x43, 0x30, 0x0b,
+    0x87, 0x00, 0xe6, 0xa3, 0x08, 0x30, 0xcf, 0x30, 0x00, 0xff, 0x00, 0x0b, 0x04, 0xef, 0xb0, 0x08,
+    0x30, 0xe6, 0xa3, 0x08, 0x30, 0x9f, 0xf2, 0x00, 0xc2, 0x00, 0x00, 0x00, 0x00, 0xde, 0x20, 0x0e,
+    0xc2, 0x08, 0x70, 0xdb, 0x04, 0xb0, 0xba, 0xb0, 0x0c, 0xae, 0x20, 0x0b, 0x08, 0x74, 0xe1, 0x04,
+    0x78, 0x70, 0xdb, 0x04, 0xb0, 0xe1, 0x97, 0x00, 0xc2, 0x00, 0x00, 0x00, 0x04, 0xba, 0xa0, 0x0c,
+    0xe1, 0x0c, 0xaf, 0xb6, 0x00, 0xf0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0e, 0x10, 0xc2, 0x00,
+    0xbc, 0xaf, 0xb6, 0x00, 0xf8, 0x70, 0x0b, 0x00, 0xc2, 0x00, 0x00, 0x00, 0x0d, 0xaa, 0xa0, 0x0c,
+    0xe0, 0x0d, 0xfa, 0x10, 0x04, 0xf0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x00,
+    0xbe, 0xfa, 0x10, 0x04, 0xfc, 0x20, 0x0e, 0x00, 0xd1, 0x00, 0x00, 0x00, 0x04, 0xfb, 0x20, 0x08,
+    0xb0, 0x08, 0x10, 0x04, 0xaf, 0xb0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x00,
+    0xb8, 0x10, 0x04, 0xaf, 0xbc, 0x20, 0x0e, 0x00, 0xd1, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x10, 0x00,
+    0xb0, 0x00, 0x00, 0xaf, 0xfb, 0x04, 0x70, 0xe0, 0x0d, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x04,
+    0x70, 0x00, 0xaf, 0xfb, 0x0c, 0x20, 0x0e, 0x00, 0xd1, 0x00, 0x00, 0x00, 0x00, 0x4f, 0x20, 0x00,
+    0xb0, 0x00, 0x9e, 0xfa, 0xe2, 0x04, 0x70, 0xe0, 0x0d, 0x18, 0x30, 0x4b, 0x0b, 0x00, 0xc2, 0x08,
+    0x30, 0x9e, 0xfa, 0xe2, 0x0c, 0x20, 0x0b, 0x00, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x40, 0x00,
+    0xb0, 0x08, 0xeb, 0x9f, 0xfb, 0x04, 0x70, 0xe0, 0x0d, 0x18, 0x30, 0x47, 0x0b, 0x00, 0xe1, 0x08,
+    0x38, 0xeb, 0x9f, 0xfb, 0x0c, 0x20, 0x87, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0xdf, 0xf0, 0x00,
+    0xe0, 0x08, 0xb5, 0xe3, 0x9f, 0x78, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x47, 0x0d, 0xaa, 0xb0, 0x0d,
+    0x28, 0xb5, 0xe3, 0x9f, 0x74, 0xba, 0xe2, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0xef, 0xb0, 0x00,
+    0xd1, 0x00, 0xef, 0xb0, 0x0c, 0x38, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x87, 0x04, 0xff, 0x10, 0x0e,
+    0x00, 0xef, 0xb0, 0x0c, 0x30, 0xdf, 0x70, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x04, 0xff, 0xb0, 0x00,
+    0xc2, 0x00, 0x05, 0x00, 0x0e, 0x18, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x83, 0x00, 0x00, 0x00, 0x8b,
+    0x00, 0x05, 0x00, 0x0e, 0x10, 0x0a, 0x10, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x08, 0xff, 0x70, 0x00,
+    0x4b, 0x00, 0x00, 0x00, 0x8b, 0x08, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x83, 0x00, 0x00, 0x00, 0xdb,
+    0x00, 0x00, 0x00, 0x8b, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x00, 0x00, 0x0d, 0xff, 0x20, 0x00,
+    0x0e, 0x20, 0x00, 0x00, 0xe2, 0x08, 0x34, 0xb0, 0x0e, 0x0d, 0x20, 0x83, 0x42, 0x00, 0x08, 0xbe,
+    0x20, 0x00, 0x00, 0xef, 0x10, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x00, 0x00, 0x0e, 0xff, 0x10, 0x00,
+    0x08, 0xb2, 0x00, 0x4e, 0xf1, 0x08, 0x34, 0xb0, 0x0e, 0x0d, 0x20, 0x83, 0x8f, 0x60, 0x9e, 0x28,
+    0xb2, 0x00, 0x4e, 0xbc, 0xb1, 0x00, 0xd3, 0x00, 0x70, 0x00, 0x00, 0x00, 0x0f, 0xfb, 0x00, 0x10,
+    0x00, 0xdf, 0xaa, 0xeb, 0xef, 0xff, 0x24, 0xff, 0xfb, 0x0d, 0xff, 0xf2, 0xca, 0xff, 0xf7, 0x00,
+    0xdf, 0xaa, 0xeb, 0x20, 0xeb, 0xae, 0xb3, 0x04, 0x70, 0x00, 0x00, 0x00, 0x0f, 0xf7, 0x04, 0x10,
+    0x00, 0x09, 0xff, 0xb0, 0x8a, 0xaa, 0x10, 0xaa, 0xa6, 0x04, 0xae, 0xa1, 0xc2, 0x5a, 0x10, 0x00,
+    0x09, 0xff, 0xb0, 0x00, 0x0e, 0xfb, 0xe2, 0x04, 0x70, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x6e, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x10, 0xd2, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xe1, 0x08, 0x30, 0x00, 0x00, 0x00, 0x0e, 0xff, 0xff, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0xd2, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xcf, 0xae, 0x70, 0x08, 0x30, 0x00, 0x00, 0x00, 0x0d, 0xff, 0xff, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xd1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xca, 0xfb, 0x00, 0x0d, 0x20, 0x00, 0x00, 0x00, 0x08, 0xff, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc2, 0x00, 0x00, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0xef, 0xf2, 0x04,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc1, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9f, 0xb0, 0x0d,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc1, 0x00, 0x09, 0xf1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x50, 0x4b,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc6, 0x5a, 0xef, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0xaa, 0xd2,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xcf, 0xff, 0xb1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0xff, 0xf0,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x30, 0x00,
+    0x00, 0x00, 0x9f, 0xb6, 0x04, 0xa1, 0x00, 0x96, 0x00, 0x09, 0x60, 0x5a, 0xa1, 0x4e, 0xfb, 0x00,
+    0x00, 0x9f, 0xb6, 0x00, 0x00, 0x4a, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x20, 0xe0, 0x00,
+    0x00, 0x0e, 0xfa, 0xef, 0x7f, 0xff, 0x6e, 0xff, 0xb0, 0xef, 0xfb, 0xff, 0xfb, 0xeb, 0xae, 0xb0,
+    0x0e, 0xfa, 0xef, 0x70, 0x04, 0xff, 0xfe, 0xff, 0xf3, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x83, 0x00,
+    0x00, 0xcb, 0x10, 0x08, 0xf7, 0x09, 0x7b, 0x14, 0xe5, 0xb1, 0x4e, 0xb0, 0x0e, 0x70, 0x04, 0xe2,
+    0x8b, 0x10, 0x08, 0xf2, 0x4f, 0xa5, 0x9f, 0xa5, 0x93, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00,
+    0x04, 0xb1, 0x00, 0x00, 0xcb, 0x00, 0xe0, 0x00, 0x4f, 0x10, 0x00, 0xe2, 0x08, 0x10, 0x00, 0x8b,
+    0xf1, 0x00, 0x00, 0x8b, 0xe6, 0x00, 0x0d, 0x10, 0x43, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00,
+    0x0d, 0x20, 0x04, 0x10, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x0e,
+    0x70, 0x04, 0x10, 0x0e, 0xb0, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00, 0x0e, 0x20, 0x07, 0x00,
+    0x0b, 0x00, 0x8f, 0xf1, 0x0c, 0x20, 0x05, 0x00, 0x00, 0x41, 0x00, 0x0b, 0x00, 0x4a, 0x00, 0x08,
+    0x30, 0x8f, 0xf1, 0x0c, 0x30, 0x09, 0x20, 0x00, 0x83, 0x00, 0x00, 0x00, 0x43, 0x30, 0x0b, 0x00,
+    0x87, 0x00, 0xe6, 0xa3, 0x08, 0x30, 0xcf, 0x30, 0x00, 0xff, 0x00, 0x0b, 0x04, 0xef, 0xb0, 0x08,
+    0x30, 0xe6, 0xa3, 0x08, 0x30, 0x9f, 0xf2, 0x00, 0xc2, 0x00, 0x00, 0x00, 0xde, 0x20, 0x0e, 0x00,
+    0xc2, 0x08, 0x70, 0xdb, 0x04, 0xb0, 0xba, 0xb0, 0x0c, 0xae, 0x20, 0x0b, 0x08, 0x74, 0xe1, 0x04,
+    0x78, 0x70, 0xdb, 0x04, 0xb0, 0xe1, 0x97, 0x00, 0xc2, 0x00, 0x00, 0x04, 0xba, 0xa0, 0x0c, 0x10,
+    0xe1, 0x0c, 0xaf, 0xb6, 0x00, 0xf0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0e, 0x10, 0xc2, 0x00,
+    0xbc, 0xaf, 0xb6, 0x00, 0xf8, 0x70, 0x0b, 0x00, 0xc2, 0x00, 0x00, 0x0d, 0xaa, 0xa0, 0x0c, 0x20,
+    0xe0, 0x0d, 0xfa, 0x10, 0x04, 0xf0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x00,
+    0xbe, 0xfa, 0x10, 0x04, 0xfc, 0x20, 0x0e, 0x00, 0xd1, 0x00, 0x00, 0x04, 0xfb, 0x20, 0x08, 0x30,
+    0xb0, 0x08, 0x10, 0x04, 0xaf, 0xb0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x00,
+    0xb8, 0x10, 0x04, 0xaf, 0xbc, 0x20, 0x0e, 0x00, 0xd1, 0x00, 0x00, 0x00, 0x0e, 0x10, 0x00, 0x30,
+    0xb0, 0x00, 0x00, 0xaf, 0xfb, 0x04, 0x70, 0xe0, 0x0d, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x04,
+    0x70, 0x00, 0xaf, 0xfb, 0x0c, 0x20, 0x0e, 0x00, 0xd1, 0x00, 0x00, 0x00, 0x4f, 0x20, 0x00, 0xb0,
+    0xb0, 0x00, 0x9e, 0xfa, 0xe2, 0x04, 0x70, 0xe0, 0x0d, 0x18, 0x30, 0x4b, 0x0b, 0x00, 0xc2, 0x08,
+    0x30, 0x9e, 0xfa, 0xe2, 0x0c, 0x20, 0x0b, 0x00, 0xd0, 0x00, 0x00, 0x00, 0x8f, 0x30, 0x00, 0xe1,
+    0xb0, 0x08, 0xeb, 0x9f, 0xfb, 0x04, 0x70, 0xe0, 0x0d, 0x18, 0x30, 0x47, 0x0b, 0x00, 0xe1, 0x08,
+    0x38, 0xeb, 0x9f, 0xfb, 0x0c, 0x20, 0x87, 0x00, 0xe0, 0x00, 0x00, 0x00, 0xdf, 0xb0, 0x00, 0xc1,
+    0xe0, 0x08, 0xb5, 0xe3, 0x9f, 0x78, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x47, 0x0d, 0xaa, 0xb0, 0x0d,
+    0x28, 0xb5, 0xe3, 0x9f, 0x74, 0xba, 0xe2, 0x00, 0xe0, 0x00, 0x00, 0x00, 0xef, 0x70, 0x00, 0xc2,
+    0xd1, 0x00, 0xef, 0xb0, 0x0c, 0x38, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x87, 0x04, 0xff, 0x10, 0x0e,
+    0x00, 0xef, 0xb0, 0x0c, 0x30, 0xdf, 0x70, 0x00, 0xe0, 0x00, 0x00, 0x04, 0xff, 0x20, 0x00, 0x83,
+    0xc2, 0x00, 0x05, 0x00, 0x0e, 0x18, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x83, 0x00, 0x00, 0x00, 0x8b,
+    0x00, 0x05, 0x00, 0x0e, 0x10, 0x0a, 0x10, 0x00, 0xe0, 0x00, 0x00, 0x08, 0xff, 0x20, 0x00, 0x43,
+    0x4b, 0x00, 0x00, 0x00, 0x8b, 0x08, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x83, 0x00, 0x00, 0x00, 0xdb,
+    0x00, 0x00, 0x00, 0x8b, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x00, 0x0d, 0xff, 0x10, 0x00, 0x43,
+    0x0e, 0x20, 0x00, 0x00, 0xe2, 0x08, 0x34, 0xb0, 0x0e, 0x0d, 0x20, 0x83, 0x42, 0x00, 0x08, 0xbe,
+    0x20, 0x00, 0x00, 0xef, 0x10, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x00, 0x0e, 0xfb, 0x00, 0x00, 0x03,
+    0x08, 0xb2, 0x00, 0x4e, 0xf1, 0x08, 0x34, 0xb0, 0x0e, 0x0d, 0x20, 0x83, 0x8f, 0x60, 0x9e, 0x28,
+    0xb2, 0x00, 0x4e, 0xbc, 0xb1, 0x00, 0xd3, 0x00, 0x70, 0x00, 0x00, 0x0f, 0xf7, 0x00, 0x00, 0x43,
+    0x00, 0xdf, 0xaa, 0xeb, 0xef, 0xff, 0x24, 0xff, 0xfb, 0x0d, 0xff, 0xf2, 0xca, 0xff, 0xf7, 0x00,
+    0xdf, 0xaa, 0xeb, 0x20, 0xeb, 0xae, 0xb3, 0x04, 0x70, 0x00, 0x00, 0x0f, 0xf2, 0x04, 0x10, 0x83,
+    0x00, 0x09, 0xff, 0xb0, 0x8a, 0xaa, 0x10, 0xaa, 0xa6, 0x04, 0xae, 0xa1, 0xc2, 0x5a, 0x10, 0x00,
+    0x09, 0xff, 0xb0, 0x00, 0x0e, 0xfb, 0xe2, 0x04, 0x70, 0x00, 0x00, 0x0f, 0xf1, 0x0d, 0x10, 0x83,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x10, 0xd2, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xe1, 0x08, 0x30, 0x00, 0x00, 0x0e, 0xfb, 0x9f, 0x10, 0xc2,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0xd2, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xcf, 0xae, 0x70, 0x08, 0x30, 0x00, 0x00, 0x0d, 0xff, 0xff, 0x10, 0xc1,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xd1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xca, 0xfb, 0x00, 0x0d, 0x20, 0x00, 0x00, 0x08, 0xff, 0xfb, 0x00, 0xd2,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc2, 0x00, 0x00, 0x4e, 0x00, 0x00, 0x00, 0x00, 0xef, 0xf2, 0x04, 0xb0,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc1, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 0x00, 0x9f, 0xb0, 0x0d, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc1, 0x00, 0x09, 0xf1, 0x00, 0x00, 0x00, 0x04, 0x65, 0x50, 0x4b, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc6, 0x5a, 0xef, 0x20, 0x00, 0x00, 0x00, 0x08, 0xba, 0xab, 0x9a, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xcf, 0xff, 0xb1, 0x00, 0x00, 0x00, 0x00, 0x04, 0xef, 0xfd, 0xff, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcf, 0xf0, 0x00, 0x00,
+    0x00, 0x00, 0x9f, 0xb6, 0x04, 0xa1, 0x00, 0x96, 0x00, 0x09, 0x60, 0x5a, 0xa1, 0x4e, 0xfb, 0x00,
+    0x00, 0x9f, 0xb6, 0x00, 0x00, 0x4a, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x83, 0x00, 0x00,
+    0x00, 0x0e, 0xfa, 0xef, 0x7f, 0xff, 0x6e, 0xff, 0xb0, 0xef, 0xfb, 0xff, 0xfb, 0xeb, 0xae, 0xb0,
+    0x0e, 0xfa, 0xef, 0x70, 0x04, 0xff, 0xfe, 0xff, 0xf3, 0x00, 0x00, 0x0c, 0x20, 0x0e, 0x00, 0x00,
+    0x00, 0xcb, 0x10, 0x08, 0xf7, 0x09, 0x7b, 0x14, 0xe5, 0xb1, 0x4e, 0xb0, 0x0e, 0x70, 0x04, 0xe2,
+    0x8b, 0x10, 0x08, 0xf2, 0x4f, 0xa5, 0x9f, 0xa5, 0x93, 0x00, 0x00, 0x0c, 0x00, 0x0c, 0x00, 0x00,
+    0x04, 0xb1, 0x00, 0x00, 0xcb, 0x00, 0xe0, 0x00, 0x4f, 0x10, 0x00, 0xe2, 0x08, 0x10, 0x00, 0x8b,
+    0xf1, 0x00, 0x00, 0x8b, 0xe6, 0x00, 0x0d, 0x10, 0x43, 0x00, 0x00, 0x0c, 0x00, 0x0c, 0x00, 0x00,
+    0x0d, 0x20, 0x04, 0x10, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x0e,
+    0x70, 0x04, 0x10, 0x0e, 0xb0, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x08, 0xb0, 0x0c, 0x10, 0x00,
+    0x0b, 0x00, 0x8f, 0xf1, 0x0c, 0x20, 0x05, 0x00, 0x00, 0x41, 0x00, 0x0b, 0x00, 0x4a, 0x00, 0x08,
+    0x30, 0x8f, 0xf1, 0x0c, 0x30, 0x09, 0x20, 0x00, 0x83, 0x00, 0x00, 0x0d, 0xc0, 0x0c, 0x20, 0x00,
+    0x87, 0x00, 0xe6, 0xa3, 0x08, 0x30, 0xcf, 0x30, 0x00, 0xff, 0x00, 0x0b, 0x04, 0xef, 0xb0, 0x08,
+    0x30, 0xe6, 0xa3, 0x08, 0x30, 0x9f, 0xf2, 0x00, 0xc2, 0x00, 0x00, 0x4b, 0xb0, 0x08, 0x30, 0x00,
+    0xc2, 0x08, 0x70, 0xdb, 0x04, 0xb0, 0xba, 0xb0, 0x0c, 0xae, 0x20, 0x0b, 0x08, 0x74, 0xe1, 0x04,
+    0x78, 0x70, 0xdb, 0x04, 0xb0, 0xe1, 0x97, 0x00, 0xc2, 0x00, 0x00, 0xda, 0xa2, 0x00, 0x70, 0x00,
+    0xe1, 0x0c, 0xaf, 0xb6, 0x00, 0xf0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0e, 0x10, 0xc2, 0x00,
+    0xbc, 0xaf, 0xb6, 0x00, 0xf8, 0x70, 0x0b, 0x00, 0xc2, 0x00, 0x04, 0xba, 0xa2, 0x00, 0xb0, 0x00,
+    0xe0, 0x0d, 0xfa, 0x10, 0x04, 0xf0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x00,
+    0xbe, 0xfa, 0x10, 0x04, 0xfc, 0x20, 0x0e, 0x00, 0xd1, 0x00, 0x00, 0xdf, 0xa0, 0x00, 0xe0, 0x00,
+    0xb0, 0x08, 0x10, 0x04, 0xaf, 0xb0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x00,
+    0xb8, 0x10, 0x04, 0xaf, 0xbc, 0x20, 0x0e, 0x00, 0xd1, 0x00, 0x00, 0x08, 0x70, 0x00, 0xc0, 0x00,
+    0xb0, 0x00, 0x00, 0xaf, 0xfb, 0x04, 0x70, 0xe0, 0x0d, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x04,
+    0x70, 0x00, 0xaf, 0xfb, 0x0c, 0x20, 0x0e, 0x00, 0xd1, 0x00, 0x00, 0x0d, 0xb0, 0x00, 0xc2, 0x00,
+    0xb0, 0x00, 0x9e, 0xfa, 0xe2, 0x04, 0x70, 0xe0, 0x0d, 0x18, 0x30, 0x4b, 0x0b, 0x00, 0xc2, 0x08,
+    0x30, 0x9e, 0xfa, 0xe2, 0x0c, 0x20, 0x0b, 0x00, 0xd0, 0x00, 0x00, 0x0e, 0xf0, 0x00, 0x87, 0x00,
+    0xb0, 0x08, 0xeb, 0x9f, 0xfb, 0x04, 0x70, 0xe0, 0x0d, 0x18, 0x30, 0x47, 0x0b, 0x00, 0xe1, 0x08,
+    0x38, 0xeb, 0x9f, 0xfb, 0x0c, 0x20, 0x87, 0x00, 0xe0, 0x00, 0x00, 0x4f, 0xf0, 0x00, 0x07, 0x00,
+    0xe0, 0x08, 0xb5, 0xe3, 0x9f, 0x78, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x47, 0x0d, 0xaa, 0xb0, 0x0d,
+    0x28, 0xb5, 0xe3, 0x9f, 0x74, 0xba, 0xe2, 0x00, 0xe0, 0x00, 0x00, 0x8f, 0xb0, 0x00, 0x0b, 0x00,
+    0xd1, 0x00, 0xef, 0xb0, 0x0c, 0x38, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x87, 0x04, 0xff, 0x10, 0x0e,
+    0x00, 0xef, 0xb0, 0x0c, 0x30, 0xdf, 0x70, 0x00, 0xe0, 0x00, 0x00, 0xdf, 0x70, 0x00, 0x0e, 0x00,
+    0xc2, 0x00, 0x05, 0x00, 0x0e, 0x18, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x83, 0x00, 0x00, 0x00, 0x8b,
+    0x00, 0x05, 0x00, 0x0e, 0x10, 0x0a, 0x10, 0x00, 0xe0, 0x00, 0x00, 0xef, 0x20, 0x00, 0x0d, 0x00,
+    0x4b, 0x00, 0x00, 0x00, 0x8b, 0x08, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x83, 0x00, 0x00, 0x00, 0xdb,
+    0x00, 0x00, 0x00, 0x8b, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x04, 0xff, 0x20, 0x00, 0x0d, 0x00,
+    0x0e, 0x20, 0x00, 0x00, 0xe2, 0x08, 0x34, 0xb0, 0x0e, 0x0d, 0x20, 0x83, 0x42, 0x00, 0x08, 0xbe,
+    0x20, 0x00, 0x00, 0xef, 0x10, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x08, 0xff, 0x10, 0x00, 0x0c, 0x00,
+    0x08, 0xb2, 0x00, 0x4e, 0xf1, 0x08, 0x34, 0xb0, 0x0e, 0x0d, 0x20, 0x83, 0x8f, 0x60, 0x9e, 0x28,
+    0xb2, 0x00, 0x4e, 0xbc, 0xb1, 0x00, 0xd3, 0x00, 0x70, 0x00, 0x0c, 0xfb, 0x00, 0x00, 0x0d, 0x00,
+    0x00, 0xdf, 0xaa, 0xeb, 0xef, 0xff, 0x24, 0xff, 0xfb, 0x0d, 0xff, 0xf2, 0xca, 0xff, 0xf7, 0x00,
+    0xdf, 0xaa, 0xeb, 0x20, 0xeb, 0xae, 0xb3, 0x04, 0x70, 0x00, 0x0c, 0xf7, 0x00, 0x10, 0x0e, 0x00,
+    0x00, 0x09, 0xff, 0xb0, 0x8a, 0xaa, 0x10, 0xaa, 0xa6, 0x04, 0xae, 0xa1, 0xc2, 0x5a, 0x10, 0x00,
+    0x09, 0xff, 0xb0, 0x00, 0x0e, 0xfb, 0xe2, 0x04, 0x70, 0x00, 0x0c, 0xf2, 0x04, 0x70, 0x0e, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x10, 0xd2, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xe1, 0x08, 0x30, 0x00, 0x08, 0xf1, 0x0d, 0x70, 0x0b, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0xd2, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xcf, 0xae, 0x70, 0x08, 0x30, 0x00, 0x04, 0xfb, 0x9f, 0x70, 0x07, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xd1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xca, 0xfb, 0x00, 0x0d, 0x20, 0x00, 0x00, 0xef, 0xff, 0x20, 0x4b, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc2, 0x00, 0x00, 0x4e, 0x00, 0x00, 0x00, 0xbf, 0xfb, 0x00, 0xde, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc1, 0x00, 0x00, 0x97, 0x00, 0x00, 0x8f, 0x6e, 0xf2, 0x04, 0xbe, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc1, 0x00, 0x09, 0xf1, 0x00, 0x00, 0xca, 0xa5, 0x51, 0x0d, 0xab, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc6, 0x5a, 0xef, 0x20, 0x00, 0x00, 0x8f, 0xba, 0xac, 0x7b, 0xe2, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xcf, 0xff, 0xb1, 0x00, 0x00, 0x00, 0x00, 0xef, 0xf7, 0xdf, 0xb0, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x20, 0x00, 0x00,
+    0x00, 0x00, 0x9f, 0xb6, 0x04, 0xa1, 0x00, 0x96, 0x00, 0x09, 0x60, 0x5a, 0xa1, 0x4e, 0xfb, 0x00,
+    0x00, 0x9f, 0xb6, 0x00, 0x00, 0x4a, 0x10, 0x00, 0x00, 0x00, 0x00, 0xc2, 0x00, 0x30, 0x00, 0x00,
+    0x00, 0x0e, 0xfa, 0xef, 0x7f, 0xff, 0x6e, 0xff, 0xb0, 0xef, 0xfb, 0xff, 0xfb, 0xeb, 0xae, 0xb0,
+    0x0e, 0xfa, 0xef, 0x70, 0x04, 0xff, 0xfe, 0xff, 0xf3, 0x00, 0x00, 0xb0, 0x00, 0xe0, 0x00, 0x00,
+    0x00, 0xcb, 0x10, 0x08, 0xf7, 0x09, 0x7b, 0x14, 0xe5, 0xb1, 0x4e, 0xb0, 0x0e, 0x70, 0x04, 0xe2,
+    0x8b, 0x10, 0x08, 0xf2, 0x4f, 0xa5, 0x9f, 0xa5, 0x93, 0x00, 0x00, 0x30, 0x00, 0xc0, 0x00, 0x00,
+    0x04, 0xb1, 0x00, 0x00, 0xcb, 0x00, 0xe0, 0x00, 0x4f, 0x10, 0x00, 0xe2, 0x08, 0x10, 0x00, 0x8b,
+    0xf1, 0x00, 0x00, 0x8b, 0xe6, 0x00, 0x0d, 0x10, 0x43, 0x00, 0x00, 0x30, 0x00, 0xc0, 0x00, 0x00,
+    0x0d, 0x20, 0x04, 0x10, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x0e,
+    0x70, 0x04, 0x10, 0x0e, 0xb0, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0xea, 0xb0, 0xc1, 0x00, 0x00,
+    0x0b, 0x00, 0x8f, 0xf1, 0x0c, 0x20, 0x05, 0x00, 0x00, 0x41, 0x00, 0x0b, 0x00, 0x4a, 0x00, 0x08,
+    0x30, 0x8f, 0xf1, 0x0c, 0x30, 0x09, 0x20, 0x00, 0x83, 0x00, 0x00, 0x3f, 0xc0, 0xc2, 0x00, 0x00,
+    0x87, 0x00, 0xe6, 0xa3, 0x08, 0x30, 0xcf, 0x30, 0x00, 0xff, 0x00, 0x0b, 0x04, 0xef, 0xb0, 0x08,
+    0x30, 0xe6, 0xa3, 0x08, 0x30, 0x9f, 0xf2, 0x00, 0xc2, 0x00, 0x00, 0xea, 0xb0, 0x83, 0x00, 0x00,
+    0xc2, 0x08, 0x70, 0xdb, 0x04, 0xb0, 0xba, 0xb0, 0x0c, 0xae, 0x20, 0x0b, 0x08, 0x74, 0xe1, 0x04,
+    0x78, 0x70, 0xdb, 0x04, 0xb0, 0xe1, 0x97, 0x00, 0xc2, 0x00, 0x04, 0xba, 0x10, 0x07, 0x00, 0x00,
+    0xe1, 0x0c, 0xaf, 0xb6, 0x00, 0xf0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0e, 0x10, 0xc2, 0x00,
+    0xbc, 0xaf, 0xb6, 0x00, 0xf8, 0x70, 0x0b, 0x00, 0xc2, 0x00, 0x04, 0xba, 0xa0, 0x0b, 0x00, 0x00,
+    0xe0, 0x0d, 0xfa, 0x10, 0x04, 0xf0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x00,
+    0xbe, 0xfa, 0x10, 0x04, 0xfc, 0x20, 0x0e, 0x00, 0xd1, 0x00, 0x0c, 0xaa, 0xa0, 0x0e, 0x00, 0x00,
+    0xb0, 0x08, 0x10, 0x04, 0xaf, 0xb0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x00,
+    0xb8, 0x10, 0x04, 0xaf, 0xbc, 0x20, 0x0e, 0x00, 0xd1, 0x00, 0x0c, 0xaa, 0xa0, 0x0c, 0x00, 0x00,
+    0xb0, 0x00, 0x00, 0xaf, 0xfb, 0x04, 0x70, 0xe0, 0x0d, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x04,
+    0x70, 0x00, 0xaf, 0xfb, 0x0c, 0x20, 0x0e, 0x00, 0xd1, 0x00, 0x0e, 0xba, 0xd0, 0x0c, 0x20, 0x00,
+    0xb0, 0x00, 0x9e, 0xfa, 0xe2, 0x04, 0x70, 0xe0, 0x0d, 0x18, 0x30, 0x4b, 0x0b, 0x00, 0xc2, 0x08,
+    0x30, 0x9e, 0xfa, 0xe2, 0x0c, 0x20, 0x0b, 0x00, 0xd0, 0x00, 0x0b, 0x8f, 0xf3, 0x10, 0xb0, 0x00,
+    0xb0, 0x08, 0xeb, 0x9f, 0xfb, 0x04, 0x70, 0xe0, 0x0d, 0x18, 0x30, 0x47, 0x0b, 0x00, 0xe1, 0x08,
+    0x38, 0xeb, 0x9f, 0xfb, 0x0c, 0x20, 0x87, 0x00, 0xe0, 0x00, 0x83, 0xdf, 0xff, 0x20, 0xc2, 0x00,
+    0xe0, 0x08, 0xb5, 0xe3, 0x9f, 0x78, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x47, 0x0d, 0xaa, 0xb0, 0x0d,
+    0x28, 0xb5, 0xe3, 0x9f, 0x74, 0xba, 0xe2, 0x00, 0xe0, 0x00, 0xc2, 0xef, 0xff, 0x70, 0x83, 0x00,
+    0xd1, 0x00, 0xef, 0xb0, 0x0c, 0x38, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x87, 0x04, 0xff, 0x10, 0x0e,
+    0x00, 0xef, 0xb0, 0x0c, 0x30, 0xdf, 0x70, 0x00, 0xe0, 0x00, 0xc4, 0xff, 0xff, 0xb0, 0x03, 0x00,
+    0xc2, 0x00, 0x05, 0x00, 0x0e, 0x18, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x83, 0x00, 0x00, 0x00, 0x8b,
+    0x00, 0x05, 0x00, 0x0e, 0x10, 0x0a, 0x10, 0x00, 0xe0, 0x00, 0xe8, 0xff, 0xff, 0xf1, 0x0b, 0x00,
+    0x4b, 0x00, 0x00, 0x00, 0x8b, 0x08, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x83, 0x00, 0x00, 0x00, 0xdb,
+    0x00, 0x00, 0x00, 0x8b, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x00, 0xbd, 0xff, 0xff, 0xf2, 0x0e, 0x00,
+    0x0e, 0x20, 0x00, 0x00, 0xe2, 0x08, 0x34, 0xb0, 0x0e, 0x0d, 0x20, 0x83, 0x42, 0x00, 0x08, 0xbe,
+    0x20, 0x00, 0x00, 0xef, 0x10, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x3f, 0xff, 0xff, 0xf3, 0x0c, 0x00,
+    0x08, 0xb2, 0x00, 0x4e, 0xf1, 0x08, 0x34, 0xb0, 0x0e, 0x0d, 0x20, 0x83, 0x8f, 0x60, 0x9e, 0x28,
+    0xb2, 0x00, 0x4e, 0xbc, 0xb1, 0x00, 0xd3, 0x00, 0x70, 0x00, 0x3f, 0xff, 0xff, 0xf3, 0x0c, 0x00,
+    0x00, 0xdf, 0xaa, 0xeb, 0xef, 0xff, 0x24, 0xff, 0xfb, 0x0d, 0xff, 0xf2, 0xca, 0xff, 0xf7, 0x00,
+    0xdf, 0xaa, 0xeb, 0x20, 0xeb, 0xae, 0xb3, 0x04, 0x70, 0x00, 0x3f, 0xff, 0xff, 0xf3, 0x0c, 0x00,
+    0x00, 0x09, 0xff, 0xb0, 0x8a, 0xaa, 0x10, 0xaa, 0xa6, 0x04, 0xae, 0xa1, 0xc2, 0x5a, 0x10, 0x00,
+    0x09, 0xff, 0xb0, 0x00, 0x0e, 0xfb, 0xe2, 0x04, 0x70, 0x00, 0x3f, 0xff, 0xff, 0xf3, 0x0c, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x10, 0xd2, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xe1, 0x08, 0x30, 0x00, 0x3e, 0xff, 0xff, 0xf3, 0x0c, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0xd2, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xcf, 0xae, 0x70, 0x08, 0x30, 0x00, 0x3d, 0xff, 0xff, 0xf2, 0x0e, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xd1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xca, 0xfb, 0x00, 0x0d, 0x20, 0x00, 0xc4, 0xff, 0xff, 0xb1, 0x83, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc2, 0x00, 0x00, 0x4e, 0x00, 0x00, 0x07, 0xa6, 0xeb, 0xa6, 0x30, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc1, 0x00, 0x00, 0x97, 0x00, 0x00, 0x0b, 0xaa, 0x00, 0xaa, 0x30, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc1, 0x00, 0x09, 0xf1, 0x00, 0x00, 0xca, 0xaa, 0x23, 0xaa, 0xe0, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc6, 0x5a, 0xef, 0x20, 0x00, 0x00, 0x8f, 0xff, 0xfe, 0xff, 0xb0, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xcf, 0xff, 0xb1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x30, 0x00, 0x00,
+    0x00, 0x00, 0x9f, 0xb6, 0x04, 0xa1, 0x00, 0x96, 0x00, 0x09, 0x60, 0x5a, 0xa1, 0x4e, 0xfb, 0x00,
+    0x00, 0x9f, 0xb6, 0x00, 0x00, 0x4a, 0x10, 0x00, 0x00, 0x00, 0x00, 0xc2, 0x00, 0xe0, 0x00, 0x00,
+    0x00, 0x0e, 0xfa, 0xef, 0x7f, 0xff, 0x6e, 0xff, 0xb0, 0xef, 0xfb, 0xff, 0xfb, 0xeb, 0xae, 0xb0,
+    0x0e, 0xfa, 0xef, 0x70, 0x04, 0xff, 0xfe, 0xff, 0xf3, 0x00, 0x00, 0xb0, 0x00, 0x83, 0x00, 0x00,
+    0x00, 0xcb, 0x10, 0x08, 0xf7, 0x09, 0x7b, 0x14, 0xe5, 0xb1, 0x4e, 0xb0, 0x0e, 0x70, 0x04, 0xe2,
+    0x8b, 0x10, 0x08, 0xf2, 0x4f, 0xa5, 0x9f, 0xa5, 0x93, 0x00, 0x00, 0x30, 0x00, 0x03, 0x00, 0x00,
+    0x04, 0xb1, 0x00, 0x00, 0xcb, 0x00, 0xe0, 0x00, 0x4f, 0x10, 0x00, 0xe2, 0x08, 0x10, 0x00, 0x8b,
+    0xf1, 0x00, 0x00, 0x8b, 0xe6, 0x00, 0x0d, 0x10, 0x43, 0x00, 0x00, 0x30, 0x00, 0x03, 0x00, 0x00,
+    0x0d, 0x20, 0x04, 0x10, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x0e,
+    0x70, 0x04, 0x10, 0x0e, 0xb0, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x3e, 0xab, 0x07, 0x00, 0x00,
+    0x0b, 0x00, 0x8f, 0xf1, 0x0c, 0x20, 0x05, 0x00, 0x00, 0x41, 0x00, 0x0b, 0x00, 0x4a, 0x00, 0x08,
+    0x30, 0x8f, 0xf1, 0x0c, 0x30, 0x09, 0x20, 0x00, 0x83, 0x00, 0x00, 0x73, 0xfc, 0x0b, 0x00, 0x00,
+    0x87, 0x00, 0xe6, 0xa3, 0x08, 0x30, 0xcf, 0x30, 0x00, 0xff, 0x00, 0x0b, 0x04, 0xef, 0xb0, 0x08,
+    0x30, 0xe6, 0xa3, 0x08, 0x30, 0x9f, 0xf2, 0x00, 0xc2, 0x00, 0x00, 0x7e, 0xab, 0x0e, 0x00, 0x00,
+    0xc2, 0x08, 0x70, 0xdb, 0x04, 0xb0, 0xba, 0xb0, 0x0c, 0xae, 0x20, 0x0b, 0x08, 0x74, 0xe1, 0x04,
+    0x78, 0x70, 0xdb, 0x04, 0xb0, 0xe1, 0x97, 0x00, 0xc2, 0x00, 0x04, 0x79, 0xa1, 0x0c, 0x10, 0x00,
+    0xe1, 0x0c, 0xaf, 0xb6, 0x00, 0xf0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0e, 0x10, 0xc2, 0x00,
+    0xbc, 0xaf, 0xb6, 0x00, 0xf8, 0x70, 0x0b, 0x00, 0xc2, 0x00, 0x04, 0x3a, 0xaa, 0x0c, 0x20, 0x00,
+    0xe0, 0x0d, 0xfa, 0x10, 0x04, 0xf0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x00,
+    0xbe, 0xfa, 0x10, 0x04, 0xfc, 0x20, 0x0e, 0x00, 0xd1, 0x00, 0x08, 0x3a, 0xaa, 0x08, 0x30, 0x00,
+    0xb0, 0x08, 0x10, 0x04, 0xaf, 0xb0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x00,
+    0xb8, 0x10, 0x04, 0xaf, 0xbc, 0x20, 0x0e, 0x00, 0xd1, 0x00, 0x0c, 0x2a, 0xaa, 0x00, 0x30, 0x00,
+    0xb0, 0x00, 0x00, 0xaf, 0xfb, 0x04, 0x70, 0xe0, 0x0d, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x04,
+    0x70, 0x00, 0xaf, 0xfb, 0x0c, 0x20, 0x0e, 0x00, 0xd1, 0x00, 0x0e, 0x4b, 0xad, 0x00, 0xb0, 0x00,
+    0xb0, 0x00, 0x9e, 0xfa, 0xe2, 0x04, 0x70, 0xe0, 0x0d, 0x18, 0x30, 0x4b, 0x0b, 0x00, 0xc2, 0x08,
+    0x30, 0x9e, 0xfa, 0xe2, 0x0c, 0x20, 0x0b, 0x00, 0xd0, 0x00, 0x0b, 0x8f, 0xff, 0x10, 0xe2, 0x00,
+    0xb0, 0x08, 0xeb, 0x9f, 0xfb, 0x04, 0x70, 0xe0, 0x0d, 0x18, 0x30, 0x47, 0x0b, 0x00, 0xe1, 0x08,
+    0x38, 0xeb, 0x9f, 0xfb, 0x0c, 0x20, 0x87, 0x00, 0xe0, 0x00, 0x83, 0xdf, 0xff, 0x20, 0x0b, 0x00,
+    0xe0, 0x08, 0xb5, 0xe3, 0x9f, 0x78, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x47, 0x0d, 0xaa, 0xb0, 0x0d,
+    0x28, 0xb5, 0xe3, 0x9f, 0x74, 0xba, 0xe2, 0x00, 0xe0, 0x00, 0xc2, 0xef, 0xff, 0x70, 0x0e, 0x00,
+    0xd1, 0x00, 0xef, 0xb0, 0x0c, 0x38, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x87, 0x04, 0xff, 0x10, 0x0e,
+    0x00, 0xef, 0xb0, 0x0c, 0x30, 0xdf, 0x70, 0x00, 0xe0, 0x00, 0xc4, 0xff, 0xff, 0xb0, 0x0c, 0x00,
+    0xc2, 0x00, 0x05, 0x00, 0x0e, 0x18, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x83, 0x00, 0x00, 0x00, 0x8b,
+    0x00, 0x05, 0x00, 0x0e, 0x10, 0x0a, 0x10, 0x00, 0xe0, 0x00, 0xe8, 0xff, 0xff, 0xf1, 0x0c, 0x20,
+    0x4b, 0x00, 0x00, 0x00, 0x8b, 0x08, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x83, 0x00, 0x00, 0x00, 0xdb,
+    0x00, 0x00, 0x00, 0x8b, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x00, 0xbd, 0xff, 0xff, 0xf2, 0x08, 0x30,
+    0x0e, 0x20, 0x00, 0x00, 0xe2, 0x08, 0x34, 0xb0, 0x0e, 0x0d, 0x20, 0x83, 0x42, 0x00, 0x08, 0xbe,
+    0x20, 0x00, 0x00, 0xef, 0x10, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x3f, 0xff, 0xff, 0xf3, 0x00, 0x30,
+    0x08, 0xb2, 0x00, 0x4e, 0xf1, 0x08, 0x34, 0xb0, 0x0e, 0x0d, 0x20, 0x83, 0x8f, 0x60, 0x9e, 0x28,
+    0xb2, 0x00, 0x4e, 0xbc, 0xb1, 0x00, 0xd3, 0x00, 0x70, 0x00, 0x3f, 0xff, 0xff, 0xf3, 0x00, 0x30,
+    0x00, 0xdf, 0xaa, 0xeb, 0xef, 0xff, 0x24, 0xff, 0xfb, 0x0d, 0xff, 0xf2, 0xca, 0xff, 0xf7, 0x00,
+    0xdf, 0xaa, 0xeb, 0x20, 0xeb, 0xae, 0xb3, 0x04, 0x70, 0x00, 0x3f, 0xff, 0xff, 0xf3, 0x00, 0x30,
+    0x00, 0x09, 0xff, 0xb0, 0x8a, 0xaa, 0x10, 0xaa, 0xa6, 0x04, 0xae, 0xa1, 0xc2, 0x5a, 0x10, 0x00,
+    0x09, 0xff, 0xb0, 0x00, 0x0e, 0xfb, 0xe2, 0x04, 0x70, 0x00, 0x3f, 0xff, 0xff, 0xf3, 0x00, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x10, 0xd2, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xe1, 0x08, 0x30, 0x00, 0x3e, 0xff, 0xff, 0xf3, 0x00, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0xd2, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xcf, 0xae, 0x70, 0x08, 0x30, 0x00, 0x3d, 0xff, 0xff, 0xf2, 0x08, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xd1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xca, 0xfb, 0x00, 0x0d, 0x20, 0x00, 0xc4, 0xff, 0xff, 0xb1, 0x0e, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc2, 0x00, 0x00, 0x4e, 0x00, 0x00, 0x7a, 0x6e, 0xfb, 0x9a, 0x63, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc1, 0x00, 0x00, 0x97, 0x00, 0x00, 0xba, 0xa0, 0x00, 0x9a, 0xa3, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc1, 0x00, 0x09, 0xf1, 0x00, 0x0c, 0xaa, 0xa2, 0xf3, 0xaa, 0xae, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc6, 0x5a, 0xef, 0x20, 0x00, 0x08, 0xff, 0xff, 0x2e, 0xff, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xcf, 0xff, 0xb1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x9f, 0xb6, 0x04, 0xa1, 0x00, 0x96, 0x00, 0x09, 0x60, 0x5a, 0xa1, 0x4e, 0xfb, 0x00,
+    0x00, 0x9f, 0xb6, 0x00, 0x00, 0x4a, 0x10, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xff, 0xf0, 0x00, 0x00,
+    0x00, 0x0e, 0xfa, 0xef, 0x7f, 0xff, 0x6e, 0xff, 0xb0, 0xef, 0xfb, 0xff, 0xfb, 0xeb, 0xae, 0xb0,
+    0x0e, 0xfa, 0xef, 0x70, 0x04, 0xff, 0xfe, 0xff, 0xf3, 0x00, 0x00, 0x0b, 0x00, 0x83, 0x00, 0x00,
+    0x00, 0xcb, 0x10, 0x08, 0xf7, 0x09, 0x7b, 0x14, 0xe5, 0xb1, 0x4e, 0xb0, 0x0e, 0x70, 0x04, 0xe2,
+    0x8b, 0x10, 0x08, 0xf2, 0x4f, 0xa5, 0x9f, 0xa5, 0x93, 0x00, 0x00, 0xc2, 0x00, 0x0e, 0x00, 0x00,
+    0x04, 0xb1, 0x00, 0x00, 0xcb, 0x00, 0xe0, 0x00, 0x4f, 0x10, 0x00, 0xe2, 0x08, 0x10, 0x00, 0x8b,
+    0xf1, 0x00, 0x00, 0x8b, 0xe6, 0x00, 0x0d, 0x10, 0x43, 0x00, 0x00, 0xc0, 0x00, 0x0c, 0x00, 0x00,
+    0x0d, 0x20, 0x04, 0x10, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x0e,
+    0x70, 0x04, 0x10, 0x0e, 0xb0, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0xc0, 0x00, 0x0c, 0x00, 0x00,
+    0x0b, 0x00, 0x8f, 0xf1, 0x0c, 0x20, 0x05, 0x00, 0x00, 0x41, 0x00, 0x0b, 0x00, 0x4a, 0x00, 0x08,
+    0x30, 0x8f, 0xf1, 0x0c, 0x30, 0x09, 0x20, 0x00, 0x83, 0x00, 0x00, 0xc8, 0xbe, 0x2c, 0x10, 0x00,
+    0x87, 0x00, 0xe6, 0xa3, 0x08, 0x30, 0xcf, 0x30, 0x00, 0xff, 0x00, 0x0b, 0x04, 0xef, 0xb0, 0x08,
+    0x30, 0xe6, 0xa3, 0x08, 0x30, 0x9f, 0xf2, 0x00, 0xc2, 0x00, 0x00, 0xcd, 0xc3, 0x3c, 0x20, 0x00,
+    0xc2, 0x08, 0x70, 0xdb, 0x04, 0xb0, 0xba, 0xb0, 0x0c, 0xae, 0x20, 0x0b, 0x08, 0x74, 0xe1, 0x04,
+    0x78, 0x70, 0xdb, 0x04, 0xb0, 0xe1, 0x97, 0x00, 0xc2, 0x00, 0x00, 0xc9, 0xbe, 0x28, 0x30, 0x00,
+    0xe1, 0x0c, 0xaf, 0xb6, 0x00, 0xf0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0e, 0x10, 0xc2, 0x00,
+    0xbc, 0xaf, 0xb6, 0x00, 0xf8, 0x70, 0x0b, 0x00, 0xc2, 0x00, 0x00, 0xd5, 0xa6, 0x00, 0x70, 0x00,
+    0xe0, 0x0d, 0xfa, 0x10, 0x04, 0xf0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x00,
+    0xbe, 0xfa, 0x10, 0x04, 0xfc, 0x20, 0x0e, 0x00, 0xd1, 0x00, 0x00, 0xd8, 0xaa, 0x20, 0xb0, 0x00,
+    0xb0, 0x08, 0x10, 0x04, 0xaf, 0xb0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x00,
+    0xb8, 0x10, 0x04, 0xaf, 0xbc, 0x20, 0x0e, 0x00, 0xd1, 0x00, 0x00, 0xe8, 0xaa, 0x20, 0xe0, 0x00,
+    0xb0, 0x00, 0x00, 0xaf, 0xfb, 0x04, 0x70, 0xe0, 0x0d, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x04,
+    0x70, 0x00, 0xaf, 0xfb, 0x0c, 0x20, 0x0e, 0x00, 0xd1, 0x00, 0x00, 0xb8, 0xaa, 0x20, 0xc0, 0x00,
+    0xb0, 0x00, 0x9e, 0xfa, 0xe2, 0x04, 0x70, 0xe0, 0x0d, 0x18, 0x30, 0x4b, 0x0b, 0x00, 0xc2, 0x08,
+    0x30, 0x9e, 0xfa, 0xe2, 0x0c, 0x20, 0x0b, 0x00, 0xd0, 0x00, 0x08, 0x3d, 0xa6, 0xb0, 0xc2, 0x00,
+    0xb0, 0x08, 0xeb, 0x9f, 0xfb, 0x04, 0x70, 0xe0, 0x0d, 0x18, 0x30, 0x47, 0x0b, 0x00, 0xe1, 0x08,
+    0x38, 0xeb, 0x9f, 0xfb, 0x0c, 0x20, 0x87, 0x00, 0xe0, 0x00, 0x0c, 0x2e, 0xff, 0xf1, 0x8b, 0x00,
+    0xe0, 0x08, 0xb5, 0xe3, 0x9f, 0x78, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x47, 0x0d, 0xaa, 0xb0, 0x0d,
+    0x28, 0xb5, 0xe3, 0x9f, 0x74, 0xba, 0xe2, 0x00, 0xe0, 0x00, 0x0e, 0x4f, 0xff, 0xf2, 0x0c, 0x20,
+    0xd1, 0x00, 0xef, 0xb0, 0x0c, 0x38, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x87, 0x04, 0xff, 0x10, 0x0e,
+    0x00, 0xef, 0xb0, 0x0c, 0x30, 0xdf, 0x70, 0x00, 0xe0, 0x00, 0x0b, 0x8f, 0xff, 0xf7, 0x08, 0x30,
+    0xc2, 0x00, 0x05, 0x00, 0x0e, 0x18, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x83, 0x00, 0x00, 0x00, 0x8b,
+    0x00, 0x05, 0x00, 0x0e, 0x10, 0x0a, 0x10, 0x00, 0xe0, 0x00, 0x83, 0xdf, 0xff, 0xfb, 0x00, 0x30,
+    0x4b, 0x00, 0x00, 0x00, 0x8b, 0x08, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x83, 0x00, 0x00, 0x00, 0xdb,
+    0x00, 0x00, 0x00, 0x8b, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x00, 0xc2, 0xef, 0xff, 0xff, 0x10, 0xb0,
+    0x0e, 0x20, 0x00, 0x00, 0xe2, 0x08, 0x34, 0xb0, 0x0e, 0x0d, 0x20, 0x83, 0x42, 0x00, 0x08, 0xbe,
+    0x20, 0x00, 0x00, 0xef, 0x10, 0x00, 0x00, 0x00, 0xb0, 0x00, 0xe4, 0xff, 0xff, 0xff, 0x20, 0xe0,
+    0x08, 0xb2, 0x00, 0x4e, 0xf1, 0x08, 0x34, 0xb0, 0x0e, 0x0d, 0x20, 0x83, 0x8f, 0x60, 0x9e, 0x28,
+    0xb2, 0x00, 0x4e, 0xbc, 0xb1, 0x00, 0xd3, 0x00, 0x70, 0x00, 0xb8, 0xff, 0xff, 0xff, 0x20, 0xc0,
+    0x00, 0xdf, 0xaa, 0xeb, 0xef, 0xff, 0x24, 0xff, 0xfb, 0x0d, 0xff, 0xf2, 0xca, 0xff, 0xf7, 0x00,
+    0xdf, 0xaa, 0xeb, 0x20, 0xeb, 0xae, 0xb3, 0x04, 0x70, 0x00, 0x38, 0xff, 0xff, 0xff, 0x20, 0xc0,
+    0x00, 0x09, 0xff, 0xb0, 0x8a, 0xaa, 0x10, 0xaa, 0xa6, 0x04, 0xae, 0xa1, 0xc2, 0x5a, 0x10, 0x00,
+    0x09, 0xff, 0xb0, 0x00, 0x0e, 0xfb, 0xe2, 0x04, 0x70, 0x08, 0x38, 0xff, 0xff, 0xff, 0x20, 0xc0,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x10, 0xd2, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xe1, 0x08, 0x30, 0x0e, 0x96, 0xff, 0xff, 0xff, 0x20, 0xc2,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0xd2, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xcf, 0xae, 0x70, 0x08, 0x30, 0x87, 0xaa, 0xdf, 0xff, 0xff, 0x9a, 0xe3,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xd1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xca, 0xfb, 0x00, 0x0d, 0x20, 0xc9, 0xaa, 0x6f, 0xff, 0xff, 0xaa, 0xab,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc2, 0x00, 0x00, 0x4e, 0x00, 0xca, 0xaa, 0xad, 0xff, 0xf7, 0xaa, 0xae,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc1, 0x00, 0x00, 0x97, 0x00, 0xca, 0xaa, 0xa6, 0xff, 0xf9, 0xaa, 0xae,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc1, 0x00, 0x09, 0xf1, 0x00, 0xca, 0xaa, 0xaa, 0x55, 0x5a, 0xaa, 0xab,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc6, 0x5a, 0xef, 0x20, 0x00, 0x8f, 0xaa, 0xaa, 0x00, 0x0a, 0xaa, 0xf2,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xcf, 0xff, 0xb1, 0x00, 0x00, 0x08, 0xfb, 0xae, 0xff, 0xfa, 0xae, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0xfb, 0x00, 0x8f, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x9f, 0xb6, 0x04, 0xa1, 0x00, 0x96, 0x00, 0x09, 0x60, 0x5a, 0xa1, 0x4e, 0xfb, 0x00,
+    0x00, 0x9f, 0xb6, 0x00, 0x00, 0x4a, 0x10, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xff, 0xf0, 0x00, 0x00,
+    0x00, 0x0e, 0xfa, 0xef, 0x7f, 0xff, 0x6e, 0xff, 0xb0, 0xef, 0xfb, 0xff, 0xfb, 0xeb, 0xae, 0xb0,
+    0x0e, 0xfa, 0xef, 0x70, 0x04, 0xff, 0xfe, 0xff, 0xf3, 0x00, 0x00, 0x0b, 0x00, 0x83, 0x00, 0x00,
+    0x00, 0xcb, 0x10, 0x08, 0xf7, 0x09, 0x7b, 0x14, 0xe5, 0xb1, 0x4e, 0xb0, 0x0e, 0x70, 0x04, 0xe2,
+    0x8b, 0x10, 0x08, 0xf2, 0x4f, 0xa5, 0x9f, 0xa5, 0x93, 0x00, 0x00, 0xc2, 0x00, 0x0e, 0x00, 0x00,
+    0x04, 0xb1, 0x00, 0x00, 0xcb, 0x00, 0xe0, 0x00, 0x4f, 0x10, 0x00, 0xe2, 0x08, 0x10, 0x00, 0x8b,
+    0xf1, 0x00, 0x00, 0x8b, 0xe6, 0x00, 0x0d, 0x10, 0x43, 0x00, 0x00, 0xc0, 0x00, 0x0c, 0x00, 0x00,
+    0x0d, 0x20, 0x04, 0x10, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x0e,
+    0x70, 0x04, 0x10, 0x0e, 0xb0, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0xc0, 0x00, 0x0c, 0x00, 0x00,
+    0x0b, 0x00, 0x8f, 0xf1, 0x0c, 0x20, 0x05, 0x00, 0x00, 0x41, 0x00, 0x0b, 0x00, 0x4a, 0x00, 0x08,
+    0x30, 0x8f, 0xf1, 0x0c, 0x30, 0x09, 0x20, 0x00, 0x83, 0x00, 0x00, 0xc8, 0xbe, 0x2c, 0x10, 0x00,
+    0x87, 0x00, 0xe6, 0xa3, 0x08, 0x30, 0xcf, 0x30, 0x00, 0xff, 0x00, 0x0b, 0x04, 0xef, 0xb0, 0x08,
+    0x30, 0xe6, 0xa3, 0x08, 0x30, 0x9f, 0xf2, 0x00, 0xc2, 0x00, 0x00, 0xcd, 0xc3, 0x3c, 0x20, 0x00,
+    0xc2, 0x08, 0x70, 0xdb, 0x04, 0xb0, 0xba, 0xb0, 0x0c, 0xae, 0x20, 0x0b, 0x08, 0x74, 0xe1, 0x04,
+    0x78, 0x70, 0xdb, 0x04, 0xb0, 0xe1, 0x97, 0x00, 0xc2, 0x00, 0x00, 0xc9, 0xbe, 0x28, 0x30, 0x00,
+    0xe1, 0x0c, 0xaf, 0xb6, 0x00, 0xf0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0e, 0x10, 0xc2, 0x00,
+    0xbc, 0xaf, 0xb6, 0x00, 0xf8, 0x70, 0x0b, 0x00, 0xc2, 0x00, 0x00, 0xd5, 0xa6, 0x00, 0x70, 0x00,
+    0xe0, 0x0d, 0xfa, 0x10, 0x04, 0xf0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x00,
+    0xbe, 0xfa, 0x10, 0x04, 0xfc, 0x20, 0x0e, 0x00, 0xd1, 0x00, 0x00, 0xd8, 0xaa, 0x20, 0xb0, 0x00,
+    0xb0, 0x08, 0x10, 0x04, 0xaf, 0xb0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x00,
+    0xb8, 0x10, 0x04, 0xaf, 0xbc, 0x20, 0x0e, 0x00, 0xd1, 0x00, 0x00, 0xe8, 0xaa, 0x20, 0xe0, 0x00,
+    0xb0, 0x00, 0x00, 0xaf, 0xfb, 0x04, 0x70, 0xe0, 0x0d, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x04,
+    0x70, 0x00, 0xaf, 0xfb, 0x0c, 0x20, 0x0e, 0x00, 0xd1, 0x00, 0x00, 0xb8, 0xaa, 0x20, 0xc0, 0x00,
+    0xb0, 0x00, 0x9e, 0xfa, 0xe2, 0x04, 0x70, 0xe0, 0x0d, 0x18, 0x30, 0x4b, 0x0b, 0x00, 0xc2, 0x08,
+    0x30, 0x9e, 0xfa, 0xe2, 0x0c, 0x20, 0x0b, 0x00, 0xd0, 0x00, 0x08, 0x3d, 0xa6, 0xb0, 0xc2, 0x00,
+    0xb0, 0x08, 0xeb, 0x9f, 0xfb, 0x04, 0x70, 0xe0, 0x0d, 0x18, 0x30, 0x47, 0x0b, 0x00, 0xe1, 0x08,
+    0x38, 0xeb, 0x9f, 0xfb, 0x0c, 0x20, 0x87, 0x00, 0xe0, 0x00, 0x0c, 0x2e, 0xff, 0xf1, 0x8b, 0x00,
+    0xe0, 0x08, 0xb5, 0xe3, 0x9f, 0x78, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x47, 0x0d, 0xaa, 0xb0, 0x0d,
+    0x28, 0xb5, 0xe3, 0x9f, 0x74, 0xba, 0xe2, 0x00, 0xe0, 0x00, 0x8e, 0x4f, 0xff, 0xf2, 0x0c, 0x20,
+    0xd1, 0x00, 0xef, 0xb0, 0x0c, 0x38, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x87, 0x04, 0xff, 0x10, 0x0e,
+    0x00, 0xef, 0xb0, 0x0c, 0x30, 0xdf, 0x70, 0x00, 0xe0, 0x00, 0xeb, 0x8f, 0xff, 0xf7, 0x08, 0x30,
+    0xc2, 0x00, 0x05, 0x00, 0x0e, 0x18, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x83, 0x00, 0x00, 0x00, 0x8b,
+    0x00, 0x05, 0x00, 0x0e, 0x10, 0x0a, 0x10, 0x00, 0xe0, 0x00, 0xb0, 0xdf, 0xff, 0xfb, 0x00, 0x30,
+    0x4b, 0x00, 0x00, 0x00, 0x8b, 0x08, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x83, 0x00, 0x00, 0x00, 0xdb,
+    0x00, 0x00, 0x00, 0x8b, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x30, 0xef, 0xff, 0xff, 0x10, 0xb0,
+    0x0e, 0x20, 0x00, 0x00, 0xe2, 0x08, 0x34, 0xb0, 0x0e, 0x0d, 0x20, 0x83, 0x42, 0x00, 0x08, 0xbe,
+    0x20, 0x00, 0x00, 0xef, 0x10, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x30, 0xff, 0xff, 0xff, 0x20, 0xe0,
+    0x08, 0xb2, 0x00, 0x4e, 0xf1, 0x08, 0x34, 0xb0, 0x0e, 0x0d, 0x20, 0x83, 0x8f, 0x60, 0x9e, 0x28,
+    0xb2, 0x00, 0x4e, 0xbc, 0xb1, 0x00, 0xd3, 0x00, 0x70, 0x00, 0x30, 0xff, 0xff, 0xff, 0x20, 0xc0,
+    0x00, 0xdf, 0xaa, 0xeb, 0xef, 0xff, 0x24, 0xff, 0xfb, 0x0d, 0xff, 0xf2, 0xca, 0xff, 0xf7, 0x00,
+    0xdf, 0xaa, 0xeb, 0x20, 0xeb, 0xae, 0xb3, 0x04, 0x70, 0x00, 0x70, 0xdf, 0xff, 0xff, 0x20, 0xc0,
+    0x00, 0x09, 0xff, 0xb0, 0x8a, 0xaa, 0x10, 0xaa, 0xa6, 0x04, 0xae, 0xa1, 0xc2, 0x5a, 0x10, 0x00,
+    0x09, 0xff, 0xb0, 0x00, 0x0e, 0xfb, 0xe2, 0x04, 0x70, 0x08, 0x70, 0xdf, 0xff, 0xff, 0x20, 0xc0,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x10, 0xd2, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xe1, 0x08, 0x30, 0x0e, 0x96, 0xdf, 0xff, 0xff, 0x20, 0xc2,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0xd2, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xcf, 0xae, 0x70, 0x08, 0x30, 0x87, 0xaa, 0xdf, 0xff, 0xff, 0x9a, 0xe3,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xd1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xca, 0xfb, 0x00, 0x0d, 0x20, 0xc9, 0xaa, 0x6f, 0xff, 0xff, 0xaa, 0xab,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc2, 0x00, 0x00, 0x4e, 0x00, 0xca, 0xaa, 0xad, 0xff, 0xf7, 0xaa, 0xae,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc1, 0x00, 0x00, 0x97, 0x00, 0xca, 0xaa, 0xa6, 0xff, 0xf9, 0xaa, 0xae,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc1, 0x00, 0x09, 0xf1, 0x00, 0xca, 0xaa, 0xaa, 0x55, 0x5a, 0xaa, 0xab,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc6, 0x5a, 0xef, 0x20, 0x00, 0x8f, 0xaa, 0xaa, 0x00, 0x0a, 0xaa, 0xf2,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xcf, 0xff, 0xb1, 0x00, 0x00, 0x08, 0xfb, 0xae, 0xff, 0xfa, 0xae, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0xfb, 0x00, 0x8f, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x9f, 0xb6, 0x04, 0xa1, 0x00, 0x96, 0x00, 0x09, 0x60, 0x5a, 0xa1, 0x4e, 0xfb, 0x00,
+    0x00, 0x9f, 0xb6, 0x00, 0x00, 0x4a, 0x10, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xff, 0xf0, 0x00, 0x00,
+    0x00, 0x0e, 0xfa, 0xef, 0x7f, 0xff, 0x6e, 0xff, 0xb0, 0xef, 0xfb, 0xff, 0xfb, 0xeb, 0xae, 0xb0,
+    0x0e, 0xfa, 0xef, 0x70, 0x04, 0xff, 0xfe, 0xff, 0xf3, 0x00, 0x00, 0x0b, 0x00, 0x83, 0x00, 0x00,
+    0x00, 0xcb, 0x10, 0x08, 0xf7, 0x09, 0x7b, 0x14, 0xe5, 0xb1, 0x4e, 0xb0, 0x0e, 0x70, 0x04, 0xe2,
+    0x8b, 0x10, 0x08, 0xf2, 0x4f, 0xa5, 0x9f, 0xa5, 0x93, 0x00, 0x00, 0xc2, 0x00, 0x0e, 0x00, 0x00,
+    0x04, 0xb1, 0x00, 0x00, 0xcb, 0x00, 0xe0, 0x00, 0x4f, 0x10, 0x00, 0xe2, 0x08, 0x10, 0x00, 0x8b,
+    0xf1, 0x00, 0x00, 0x8b, 0xe6, 0x00, 0x0d, 0x10, 0x43, 0x00, 0x00, 0xc0, 0x00, 0x0c, 0x00, 0x00,
+    0x0d, 0x20, 0x04, 0x10, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x0e,
+    0x70, 0x04, 0x10, 0x0e, 0xb0, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0xc0, 0x00, 0x0c, 0x00, 0x00,
+    0x0b, 0x00, 0x8f, 0xf1, 0x0c, 0x20, 0x05, 0x00, 0x00, 0x41, 0x00, 0x0b, 0x00, 0x4a, 0x00, 0x08,
+    0x30, 0x8f, 0xf1, 0x0c, 0x30, 0x09, 0x20, 0x00, 0x83, 0x00, 0x00, 0xc8, 0xbe, 0x2c, 0x10, 0x00,
+    0x87, 0x00, 0xe6, 0xa3, 0x08, 0x30, 0xcf, 0x30, 0x00, 0xff, 0x00, 0x0b, 0x04, 0xef, 0xb0, 0x08,
+    0x30, 0xe6, 0xa3, 0x08, 0x30, 0x9f, 0xf2, 0x00, 0xc2, 0x00, 0x00, 0xcd, 0xc3, 0x3c, 0x20, 0x00,
+    0xc2, 0x08, 0x70, 0xdb, 0x04, 0xb0, 0xba, 0xb0, 0x0c, 0xae, 0x20, 0x0b, 0x08, 0x74, 0xe1, 0x04,
+    0x78, 0x70, 0xdb, 0x04, 0xb0, 0xe1, 0x97, 0x00, 0xc2, 0x00, 0x00, 0xc9, 0xbe, 0x28, 0x30, 0x00,
+    0xe1, 0x0c, 0xaf, 0xb6, 0x00, 0xf0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0e, 0x10, 0xc2, 0x00,
+    0xbc, 0xaf, 0xb6, 0x00, 0xf8, 0x70, 0x0b, 0x00, 0xc2, 0x00, 0x00, 0xd5, 0xa6, 0x00, 0x70, 0x00,
+    0xe0, 0x0d, 0xfa, 0x10, 0x04, 0xf0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x00,
+    0xbe, 0xfa, 0x10, 0x04, 0xfc, 0x20, 0x0e, 0x00, 0xd1, 0x00, 0x00, 0xd8, 0xaa, 0x20, 0xb0, 0x00,
+    0xb0, 0x08, 0x10, 0x04, 0xaf, 0xb0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x00,
+    0xb8, 0x10, 0x04, 0xaf, 0xbc, 0x20, 0x0e, 0x00, 0xd1, 0x00, 0x00, 0xe8, 0xaa, 0x20, 0xe0, 0x00,
+    0xb0, 0x00, 0x00, 0xaf, 0xfb, 0x04, 0x70, 0xe0, 0x0d, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x04,
+    0x70, 0x00, 0xaf, 0xfb, 0x0c, 0x20, 0x0e, 0x00, 0xd1, 0x00, 0x00, 0xb8, 0xaa, 0x20, 0xc0, 0x00,
+    0xb0, 0x00, 0x9e, 0xfa, 0xe2, 0x04, 0x70, 0xe0, 0x0d, 0x18, 0x30, 0x4b, 0x0b, 0x00, 0xc2, 0x08,
+    0x30, 0x9e, 0xfa, 0xe2, 0x0c, 0x20, 0x0b, 0x00, 0xd0, 0x0c, 0xfb, 0x3d, 0xa6, 0xb0, 0xc2, 0x00,
+    0xb0, 0x08, 0xeb, 0x9f, 0xfb, 0x04, 0x70, 0xe0, 0x0d, 0x18, 0x30, 0x47, 0x0b, 0x00, 0xe1, 0x08,
+    0x38, 0xeb, 0x9f, 0xfb, 0x0c, 0x20, 0x87, 0x00, 0xe0, 0x0b, 0x0e, 0x2e, 0xff, 0xf1, 0x8b, 0x00,
+    0xe0, 0x08, 0xb5, 0xe3, 0x9f, 0x78, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x47, 0x0d, 0xaa, 0xb0, 0x0d,
+    0x28, 0xb5, 0xe3, 0x9f, 0x74, 0xba, 0xe2, 0x00, 0xe0, 0x03, 0x0d, 0x4f, 0xff, 0xf2, 0x0c, 0x20,
+    0xd1, 0x00, 0xef, 0xb0, 0x0c, 0x38, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x87, 0x04, 0xff, 0x10, 0x0e,
+    0x00, 0xef, 0xb0, 0x0c, 0x30, 0xdf, 0x70, 0x00, 0xe0, 0x03, 0x00, 0x8f, 0xff, 0xf7, 0x08, 0x30,
+    0xc2, 0x00, 0x05, 0x00, 0x0e, 0x18, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x83, 0x00, 0x00, 0x00, 0x8b,
+    0x00, 0x05, 0x00, 0x0e, 0x10, 0x0a, 0x10, 0x00, 0xe0, 0x03, 0x00, 0xdf, 0xff, 0xfb, 0x00, 0x30,
+    0x4b, 0x00, 0x00, 0x00, 0x8b, 0x08, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x83, 0x00, 0x00, 0x00, 0xdb,
+    0x00, 0x00, 0x00, 0x8b, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x03, 0x00, 0xef, 0xff, 0xff, 0x10, 0xb0,
+    0x0e, 0x20, 0x00, 0x00, 0xe2, 0x08, 0x34, 0xb0, 0x0e, 0x0d, 0x20, 0x83, 0x42, 0x00, 0x08, 0xbe,
+    0x20, 0x00, 0x00, 0xef, 0x10, 0x00, 0x00, 0x00, 0xb0, 0x03, 0x04, 0xff, 0xff, 0xff, 0x20, 0xe0,
+    0x08, 0xb2, 0x00, 0x4e, 0xf1, 0x08, 0x34, 0xb0, 0x0e, 0x0d, 0x20, 0x83, 0x8f, 0x60, 0x9e, 0x28,
+    0xb2, 0x00, 0x4e, 0xbc, 0xb1, 0x00, 0xd3, 0x00, 0x70, 0x0e, 0x28, 0xff, 0xff, 0xff, 0x20, 0xc0,
+    0x00, 0xdf, 0xaa, 0xeb, 0xef, 0xff, 0x24, 0xff, 0xfb, 0x0d, 0xff, 0xf2, 0xca, 0xff, 0xf7, 0x00,
+    0xdf, 0xaa, 0xeb, 0x20, 0xeb, 0xae, 0xb3, 0x04, 0x70, 0x00, 0x78, 0xff, 0xff, 0xff, 0x20, 0xc0,
+    0x00, 0x09, 0xff, 0xb0, 0x8a, 0xaa, 0x10, 0xaa, 0xa6, 0x04, 0xae, 0xa1, 0xc2, 0x5a, 0x10, 0x00,
+    0x09, 0xff, 0xb0, 0x00, 0x0e, 0xfb, 0xe2, 0x04, 0x70, 0x08, 0x78, 0xff, 0xff, 0xff, 0x20, 0xc0,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x10, 0xd2, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xe1, 0x08, 0x30, 0x0e, 0x96, 0xff, 0xff, 0xff, 0x20, 0xc2,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0xd2, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xcf, 0xae, 0x70, 0x08, 0x30, 0x87, 0xaa, 0xdf, 0xff, 0xff, 0x9a, 0xe3,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xd1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xca, 0xfb, 0x00, 0x0d, 0x20, 0xc9, 0xaa, 0x6f, 0xff, 0xff, 0xaa, 0xab,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc2, 0x00, 0x00, 0x4e, 0x00, 0xca, 0xaa, 0xad, 0xff, 0xf7, 0xaa, 0xae,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc1, 0x00, 0x00, 0x97, 0x00, 0xca, 0xaa, 0xa6, 0xff, 0xf9, 0xaa, 0xae,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc1, 0x00, 0x09, 0xf1, 0x00, 0xca, 0xaa, 0xaa, 0x55, 0x5a, 0xaa, 0xab,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc6, 0x5a, 0xef, 0x20, 0x00, 0x8f, 0xaa, 0xaa, 0x00, 0x0a, 0xaa, 0xf2,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xcf, 0xff, 0xb1, 0x00, 0x00, 0x08, 0xfb, 0xae, 0xff, 0xfa, 0xae, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0xfb, 0x00, 0x8f, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x9f, 0xb6, 0x04, 0xa1, 0x00, 0x96, 0x00, 0x09, 0x60, 0x5a, 0xa1, 0x4e, 0xfb, 0x00,
+    0x00, 0x9f, 0xb6, 0x00, 0x00, 0x4a, 0x10, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xff, 0xf0, 0x00, 0x00,
+    0x00, 0x0e, 0xfa, 0xef, 0x7f, 0xff, 0x6e, 0xff, 0xb0, 0xef, 0xfb, 0xff, 0xfb, 0xeb, 0xae, 0xb0,
+    0x0e, 0xfa, 0xef, 0x70, 0x04, 0xff, 0xfe, 0xff, 0xf3, 0x00, 0x00, 0x0b, 0x00, 0x83, 0x00, 0x00,
+    0x00, 0xcb, 0x10, 0x08, 0xf7, 0x09, 0x7b, 0x14, 0xe5, 0xb1, 0x4e, 0xb0, 0x0e, 0x70, 0x04, 0xe2,
+    0x8b, 0x10, 0x08, 0xf2, 0x4f, 0xa5, 0x9f, 0xa5, 0x93, 0x00, 0x00, 0xc2, 0x00, 0x0e, 0x00, 0x00,
+    0x04, 0xb1, 0x00, 0x00, 0xcb, 0x00, 0xe0, 0x00, 0x4f, 0x10, 0x00, 0xe2, 0x08, 0x10, 0x00, 0x8b,
+    0xf1, 0x00, 0x00, 0x8b, 0xe6, 0x00, 0x0d, 0x10, 0x43, 0x00, 0x00, 0xc0, 0x00, 0x0c, 0x00, 0x00,
+    0x0d, 0x20, 0x04, 0x10, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x0e,
+    0x70, 0x04, 0x10, 0x0e, 0xb0, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0xc0, 0x00, 0x0c, 0x00, 0x00,
+    0x0b, 0x00, 0x8f, 0xf1, 0x0c, 0x20, 0x05, 0x00, 0x00, 0x41, 0x00, 0x0b, 0x00, 0x4a, 0x00, 0x08,
+    0x30, 0x8f, 0xf1, 0x0c, 0x30, 0x09, 0x20, 0x00, 0x83, 0x04, 0x00, 0xc8, 0xbe, 0x2c, 0x10, 0x00,
+    0x87, 0x00, 0xe6, 0xa3, 0x08, 0x30, 0xcf, 0x30, 0x00, 0xff, 0x00, 0x0b, 0x04, 0xef, 0xb0, 0x08,
+    0x30, 0xe6, 0xa3, 0x08, 0x30, 0x9f, 0xf2, 0x00, 0xc2, 0x0d, 0x10, 0xcd, 0xc3, 0x3c, 0x20, 0x00,
+    0xc2, 0x08, 0x70, 0xdb, 0x04, 0xb0, 0xba, 0xb0, 0x0c, 0xae, 0x20, 0x0b, 0x08, 0x74, 0xe1, 0x04,
+    0x78, 0x70, 0xdb, 0x04, 0xb0, 0xe1, 0x97, 0x00, 0xc2, 0x4b, 0x70, 0xc9, 0xbe, 0x28, 0x30, 0x00,
+    0xe1, 0x0c, 0xaf, 0xb6, 0x00, 0xf0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0e, 0x10, 0xc2, 0x00,
+    0xbc, 0xaf, 0xb6, 0x00, 0xf8, 0x70, 0x0b, 0x00, 0xc2, 0xc2, 0xe0, 0xd5, 0xa6, 0x00, 0x70, 0x00,
+    0xe0, 0x0d, 0xfa, 0x10, 0x04, 0xf0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x00,
+    0xbe, 0xfa, 0x10, 0x04, 0xfc, 0x20, 0x0e, 0x00, 0xd1, 0xc1, 0xd0, 0xd8, 0xaa, 0x20, 0xb0, 0x00,
+    0xb0, 0x08, 0x10, 0x04, 0xaf, 0xb0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x00,
+    0xb8, 0x10, 0x04, 0xaf, 0xbc, 0x20, 0x0e, 0x00, 0xd1, 0xc0, 0xc0, 0xe8, 0xaa, 0x20, 0xe0, 0x00,
+    0xb0, 0x00, 0x00, 0xaf, 0xfb, 0x04, 0x70, 0xe0, 0x0d, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x04,
+    0x70, 0x00, 0xaf, 0xfb, 0x0c, 0x20, 0x0e, 0x00, 0xd1, 0xc0, 0x03, 0xb8, 0xaa, 0x20, 0xc0, 0x00,
+    0xb0, 0x00, 0x9e, 0xfa, 0xe2, 0x04, 0x70, 0xe0, 0x0d, 0x18, 0x30, 0x4b, 0x0b, 0x00, 0xc2, 0x08,
+    0x30, 0x9e, 0xfa, 0xe2, 0x0c, 0x20, 0x0b, 0x00, 0xd0, 0xc0, 0x0b, 0x3d, 0xa6, 0xb0, 0xc2, 0x00,
+    0xb0, 0x08, 0xeb, 0x9f, 0xfb, 0x04, 0x70, 0xe0, 0x0d, 0x18, 0x30, 0x47, 0x0b, 0x00, 0xe1, 0x08,
+    0x38, 0xeb, 0x9f, 0xfb, 0x0c, 0x20, 0x87, 0x00, 0xe0, 0xc2, 0x0c, 0x2e, 0xff, 0xf1, 0x8b, 0x00,
+    0xe0, 0x08, 0xb5, 0xe3, 0x9f, 0x78, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x47, 0x0d, 0xaa, 0xb0, 0x0d,
+    0x28, 0xb5, 0xe3, 0x9f, 0x74, 0xba, 0xe2, 0x00, 0xe0, 0x83, 0x0c, 0x4f, 0xff, 0xf2, 0x0c, 0x20,
+    0xd1, 0x00, 0xef, 0xb0, 0x0c, 0x38, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x87, 0x04, 0xff, 0x10, 0x0e,
+    0x00, 0xef, 0xb0, 0x0c, 0x30, 0xdf, 0x70, 0x00, 0xe0, 0x03, 0x00, 0x8f, 0xff, 0xf7, 0x08, 0x30,
+    0xc2, 0x00, 0x05, 0x00, 0x0e, 0x18, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x83, 0x00, 0x00, 0x00, 0x8b,
+    0x00, 0x05, 0x00, 0x0e, 0x10, 0x0a, 0x10, 0x00, 0xe0, 0x0b, 0x00, 0xcf, 0xff, 0xfb, 0x00, 0x30,
+    0x4b, 0x00, 0x00, 0x00, 0x8b, 0x08, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x83, 0x00, 0x00, 0x00, 0xdb,
+    0x00, 0x00, 0x00, 0x8b, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x0c, 0x00, 0xef, 0xff, 0xff, 0x10, 0xb0,
+    0x0e, 0x20, 0x00, 0x00, 0xe2, 0x08, 0x34, 0xb0, 0x0e, 0x0d, 0x20, 0x83, 0x42, 0x00, 0x08, 0xbe,
+    0x20, 0x00, 0x00, 0xef, 0x10, 0x00, 0x00, 0x00, 0xb0, 0x0c, 0x24, 0xff, 0xff, 0xff, 0x20, 0xe0,
+    0x08, 0xb2, 0x00, 0x4e, 0xf1, 0x08, 0x34, 0xb0, 0x0e, 0x0d, 0x20, 0x83, 0x8f, 0x60, 0x9e, 0x28,
+    0xb2, 0x00, 0x4e, 0xbc, 0xb1, 0x00, 0xd3, 0x00, 0x70, 0x00, 0xb8, 0xff, 0xff, 0xff, 0x20, 0xc0,
+    0x00, 0xdf, 0xaa, 0xeb, 0xef, 0xff, 0x24, 0xff, 0xfb, 0x0d, 0xff, 0xf2, 0xca, 0xff, 0xf7, 0x00,
+    0xdf, 0xaa, 0xeb, 0x20, 0xeb, 0xae, 0xb3, 0x04, 0x70, 0x00, 0x38, 0xff, 0xff, 0xff, 0x20, 0xc0,
+    0x00, 0x09, 0xff, 0xb0, 0x8a, 0xaa, 0x10, 0xaa, 0xa6, 0x04, 0xae, 0xa1, 0xc2, 0x5a, 0x10, 0x00,
+    0x09, 0xff, 0xb0, 0x00, 0x0e, 0xfb, 0xe2, 0x04, 0x70, 0x08, 0x38, 0xff, 0xff, 0xff, 0x20, 0xc0,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x10, 0xd2, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xe1, 0x08, 0x30, 0x0e, 0x96, 0xff, 0xff, 0xff, 0x20, 0xc2,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0xd2, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xcf, 0xae, 0x70, 0x08, 0x30, 0x87, 0xaa, 0xdf, 0xff, 0xff, 0x9a, 0xe3,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xd1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xca, 0xfb, 0x00, 0x0d, 0x20, 0xc9, 0xaa, 0x6f, 0xff, 0xff, 0xaa, 0xab,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc2, 0x00, 0x00, 0x4e, 0x00, 0xca, 0xaa, 0xad, 0xff, 0xf7, 0xaa, 0xae,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc1, 0x00, 0x00, 0x97, 0x00, 0xca, 0xaa, 0xa6, 0xff, 0xf9, 0xaa, 0xae,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc1, 0x00, 0x09, 0xf1, 0x00, 0xca, 0xaa, 0xaa, 0x55, 0x5a, 0xaa, 0xab,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc6, 0x5a, 0xef, 0x20, 0x00, 0x8f, 0xaa, 0xaa, 0x00, 0x0a, 0xaa, 0xf2,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xcf, 0xff, 0xb1, 0x00, 0x00, 0x08, 0xfb, 0xae, 0xff, 0xfa, 0xae, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0xfb, 0x00, 0x8f, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x9f, 0xb6, 0x04, 0xa1, 0x00, 0x96, 0x00, 0x09, 0x60, 0x5a, 0xa1, 0x4e, 0xfb, 0x00,
+    0x00, 0x9f, 0xb6, 0x00, 0x00, 0x4a, 0x10, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xff, 0xf0, 0x00, 0x00,
+    0x00, 0x0e, 0xfa, 0xef, 0x7f, 0xff, 0x6e, 0xff, 0xb0, 0xef, 0xfb, 0xff, 0xfb, 0xeb, 0xae, 0xb0,
+    0x0e, 0xfa, 0xef, 0x70, 0x04, 0xff, 0xfe, 0xff, 0xf3, 0x00, 0x00, 0x0b, 0x00, 0x83, 0x00, 0x00,
+    0x00, 0xcb, 0x10, 0x08, 0xf7, 0x09, 0x7b, 0x14, 0xe5, 0xb1, 0x4e, 0xb0, 0x0e, 0x70, 0x04, 0xe2,
+    0x8b, 0x10, 0x08, 0xf2, 0x4f, 0xa5, 0x9f, 0xa5, 0x93, 0x00, 0x00, 0xc2, 0x00, 0x0e, 0x00, 0x00,
+    0x04, 0xb1, 0x00, 0x00, 0xcb, 0x00, 0xe0, 0x00, 0x4f, 0x10, 0x00, 0xe2, 0x08, 0x10, 0x00, 0x8b,
+    0xf1, 0x00, 0x00, 0x8b, 0xe6, 0x00, 0x0d, 0x10, 0x43, 0x00, 0x00, 0xc0, 0x00, 0x0c, 0x00, 0x00,
+    0x0d, 0x20, 0x04, 0x10, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x0e,
+    0x70, 0x04, 0x10, 0x0e, 0xb0, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0xc0, 0x00, 0x0c, 0x00, 0x00,
+    0x0b, 0x00, 0x8f, 0xf1, 0x0c, 0x20, 0x05, 0x00, 0x00, 0x41, 0x00, 0x0b, 0x00, 0x4a, 0x00, 0x08,
+    0x30, 0x8f, 0xf1, 0x0c, 0x30, 0x09, 0x20, 0x00, 0x83, 0x00, 0x40, 0xc8, 0xbe, 0x2c, 0x10, 0x00,
+    0x87, 0x00, 0xe6, 0xa3, 0x08, 0x30, 0xcf, 0x30, 0x00, 0xff, 0x00, 0x0b, 0x04, 0xef, 0xb0, 0x08,
+    0x30, 0xe6, 0xa3, 0x08, 0x30, 0x9f, 0xf2, 0x00, 0xc2, 0x00, 0xd1, 0xcd, 0xc3, 0x3c, 0x20, 0x00,
+    0xc2, 0x08, 0x70, 0xdb, 0x04, 0xb0, 0xba, 0xb0, 0x0c, 0xae, 0x20, 0x0b, 0x08, 0x74, 0xe1, 0x04,
+    0x78, 0x70, 0xdb, 0x04, 0xb0, 0xe1, 0x97, 0x00, 0xc2, 0x04, 0xb3, 0xc9, 0xbe, 0x28, 0x30, 0x00,
+    0xe1, 0x0c, 0xaf, 0xb6, 0x00, 0xf0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0e, 0x10, 0xc2, 0x00,
+    0xbc, 0xaf, 0xb6, 0x00, 0xf8, 0x70, 0x0b, 0x00, 0xc2, 0x0d, 0x23, 0xc5, 0xa6, 0x00, 0x70, 0x00,
+    0xe0, 0x0d, 0xfa, 0x10, 0x04, 0xf0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x00,
+    0xbe, 0xfa, 0x10, 0x04, 0xfc, 0x20, 0x0e, 0x00, 0xd1, 0x0b, 0x13, 0xd8, 0xaa, 0x20, 0xb0, 0x00,
+    0xb0, 0x08, 0x10, 0x04, 0xaf, 0xb0, 0xb0, 0xe0, 0x0c, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x00,
+    0xb8, 0x10, 0x04, 0xaf, 0xbc, 0x20, 0x0e, 0x00, 0xd1, 0x07, 0x03, 0xe8, 0xaa, 0x20, 0xe0, 0x00,
+    0xb0, 0x00, 0x00, 0xaf, 0xfb, 0x04, 0x70, 0xe0, 0x0d, 0x28, 0x30, 0x0b, 0x0b, 0x00, 0x83, 0x04,
+    0x70, 0x00, 0xaf, 0xfb, 0x0c, 0x20, 0x0e, 0x00, 0xd1, 0x03, 0x03, 0xb8, 0xaa, 0x20, 0xc0, 0x00,
+    0xb0, 0x00, 0x9e, 0xfa, 0xe2, 0x04, 0x70, 0xe0, 0x0d, 0x18, 0x30, 0x4b, 0x0b, 0x00, 0xc2, 0x08,
+    0x30, 0x9e, 0xfa, 0xe2, 0x0c, 0x20, 0x0b, 0x00, 0xd0, 0x03, 0x0b, 0x3d, 0xa6, 0xb0, 0xc2, 0x00,
+    0xb0, 0x08, 0xeb, 0x9f, 0xfb, 0x04, 0x70, 0xe0, 0x0d, 0x18, 0x30, 0x47, 0x0b, 0x00, 0xe1, 0x08,
+    0x38, 0xeb, 0x9f, 0xfb, 0x0c, 0x20, 0x87, 0x00, 0xe0, 0x03, 0x0c, 0x2e, 0xff, 0xf1, 0x8b, 0x00,
+    0xe0, 0x08, 0xb5, 0xe3, 0x9f, 0x78, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x47, 0x0d, 0xaa, 0xb0, 0x0d,
+    0x28, 0xb5, 0xe3, 0x9f, 0x74, 0xba, 0xe2, 0x00, 0xe0, 0x03, 0x0c, 0x4f, 0xff, 0xf2, 0x0c, 0x20,
+    0xd1, 0x00, 0xef, 0xb0, 0x0c, 0x38, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x87, 0x04, 0xff, 0x10, 0x0e,
+    0x00, 0xef, 0xb0, 0x0c, 0x30, 0xdf, 0x70, 0x00, 0xe0, 0x03, 0x00, 0x8f, 0xff, 0xf7, 0x08, 0x30,
+    0xc2, 0x00, 0x05, 0x00, 0x0e, 0x18, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x83, 0x00, 0x00, 0x00, 0x8b,
+    0x00, 0x05, 0x00, 0x0e, 0x10, 0x0a, 0x10, 0x00, 0xe0, 0x0b, 0x00, 0xcf, 0xff, 0xfb, 0x00, 0x30,
+    0x4b, 0x00, 0x00, 0x00, 0x8b, 0x08, 0x30, 0xb0, 0x0e, 0x0c, 0x20, 0x83, 0x00, 0x00, 0x00, 0xdb,
+    0x00, 0x00, 0x00, 0x8b, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x0c, 0x00, 0xef, 0xff, 0xff, 0x10, 0xb0,
+    0x0e, 0x20, 0x00, 0x00, 0xe2, 0x08, 0x34, 0xb0, 0x0e, 0x0d, 0x20, 0x83, 0x42, 0x00, 0x08, 0xbe,
+    0x20, 0x00, 0x00, 0xef, 0x10, 0x00, 0x00, 0x00, 0xb0, 0x0c, 0x24, 0xff, 0xff, 0xff, 0x20, 0xe0,
+    0x08, 0xb2, 0x00, 0x4e, 0xf1, 0x08, 0x34, 0xb0, 0x0e, 0x0d, 0x20, 0x83, 0x8f, 0x60, 0x9e, 0x28,
+    0xb2, 0x00, 0x4e, 0xbc, 0xb1, 0x00, 0xd3, 0x00, 0x70, 0x00, 0xb8, 0xff, 0xff, 0xff, 0x20, 0xc0,
+    0x00, 0xdf, 0xaa, 0xeb, 0xef, 0xff, 0x24, 0xff, 0xfb, 0x0d, 0xff, 0xf2, 0xca, 0xff, 0xf7, 0x00,
+    0xdf, 0xaa, 0xeb, 0x20, 0xeb, 0xae, 0xb3, 0x04, 0x70, 0x00, 0x38, 0xff, 0xff, 0xff, 0x20, 0xc0,
+    0x00, 0x09, 0xff, 0xb0, 0x8a, 0xaa, 0x10, 0xaa, 0xa6, 0x04, 0xae, 0xa1, 0xc2, 0x5a, 0x10, 0x00,
+    0x09, 0xff, 0xb0, 0x00, 0x0e, 0xfb, 0xe2, 0x04, 0x70, 0x08, 0x38, 0xff, 0xff, 0xff, 0x20, 0xc0,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x10, 0xd2, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xe1, 0x08, 0x30, 0x0e, 0x96, 0xff, 0xff, 0xff, 0x20, 0xc2,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0xd2, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xcf, 0xae, 0x70, 0x08, 0x30, 0x87, 0xaa, 0xdf, 0xff, 0xff, 0x9a, 0xe3,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xd1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xca, 0xfb, 0x00, 0x0d, 0x20, 0xc9, 0xaa, 0x6f, 0xff, 0xff, 0xaa, 0xab,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc2, 0x00, 0x00, 0x4e, 0x00, 0xca, 0xaa, 0xad, 0xff, 0xf7, 0xaa, 0xae,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc1, 0x00, 0x00, 0x97, 0x00, 0xca, 0xaa, 0xa6, 0xff, 0xf9, 0xaa, 0xae,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0xe1, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc1, 0x00, 0x09, 0xf1, 0x00, 0xca, 0xaa, 0xaa, 0x55, 0x5a, 0xaa, 0xab,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xc6, 0x5a, 0xef, 0x20, 0x00, 0x8f, 0xaa, 0xaa, 0x00, 0x0a, 0xaa, 0xf2,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xcf, 0xff, 0xb1, 0x00, 0x00, 0x08, 0xfb, 0xae, 0xff, 0xfa, 0xae, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0xfb, 0x00, 0x8f, 0xfb, 0x00,
+};
Index: empeg/kernel/arch/arm/special/empeg_audio.h
diff -u empeg/kernel/arch/arm/special/empeg_audio.h:1.16 empeg/kernel/arch/arm/special/empeg_audio.h:removed
--- empeg/kernel/arch/arm/special/empeg_audio.h:1.16	Wed Jan  5 16:58:57 2000
+++ empeg/kernel/arch/arm/special/empeg_audio.h	Wed Oct 17 16:36:04 2001
@@ -1,503 +0,0 @@
-#ifndef EMPEG_AUDIO_H
-#define EMPEG_AUDIO_H 1
-
-/* DSP memory: incomplete list of locations, but enough for now */
-#define X_modpntr    0x000
-#define X_levn	     0x001
-#define X_leva	     0x002
-#define X_mlta       0x006
-#define X_mltflim    0x007
-#define X_pltd	     0x00e
-#define X_leva_u     0x019
-#define X_stepSize   0x120
-#define X_counterX   0x121
-#define X_plusmax    0x122
-#define X_minmax     0x123
-#define Y_mod00      0x800 /* Filtered FM level */
-#define Y_p1	     0x81d
-#define Y_q1	     0x81e
-#define Y_c1	     0x821
-#define Y_p7	     0x840
-#define Y_q7	     0x841
-#define Y_minsmtcn   0x842
-#define Y_p2	     0x84d
-#define Y_q2	     0x84e
-#define Y_minsmtc    0x84f
-#define Y_compry0st_28	0x856
-#define Y_p3	     0x861
-#define Y_q3	     0x862
-#define Y_E_strnf_str 0x867
-#define Y_E_mltp_str 0x868
-#define Y_stro	     0x869
-#define Y_p5	     0x86d
-#define Y_q5	     0x86e
-#define Y_E_strnf_rsp 0x872
-#define Y_E_mltp_rsp 0x873
-#define Y_EMute      0x887
-#define Y_VGA        0x8e0
-#define Y_KLCl       0x8e1
-#define Y_KLCh       0x8e2
-#define Y_KLBl       0x8e3
-#define Y_KLBh       0x8e4
-#define Y_KLA0l      0x8e5
-#define Y_KLA0h      0x8e6
-#define Y_KLA2l      0x8e7
-#define Y_KLA2h      0x8e8
-#define Y_KLtre      0x8e9
-#define Y_KLbas      0x8ea
-#define Y_KLmid      0x8eb
-#define Y_VAT        0x8ec
-#define Y_SAM	     0x8ed
-#define Y_OutSwi     0x8ee
-#define Y_SrcScal    0x8f3
-#define Y_samCl      0x8f4
-#define Y_samCh      0x8f5
-#define Y_delta      0x8f6
-#define Y_switch     0x8f7
-#define Y_louSwi     0x8f9
-#define Y_statLou    0x8fa
-#define Y_OFFS       0x8fb
-#define Y_KPDL       0x8fc
-#define Y_KMDL       0x8fd
-#define Y_Cllev      0x8fe
-#define Y_Ctre       0x8ff
-#define Y_EMuteF1    0x90e
-#define Y_scalS1_    0x927
-#define Y_scalS1     0x928
-#define Y_cpyS1      0x92a
-#define Y_cpyS1_     0x92b
-#define Y_c3sin      0x92e
-#define Y_c1sin      0x92f
-#define Y_c0sin      0x931
-#define Y_c2sin      0x932
-#define Y_VLsin      0x933
-#define Y_VRsin      0x934
-#define Y_IClipAmax  0x935
-#define Y_IClipAmin  0x936
-#define Y_IcoefAl    0x937
-#define Y_IcoefAh    0x938
-#define Y_IClipBmax  0x939
-#define Y_IClipBmin  0x93a
-#define Y_IcoefBL    0x93b
-#define Y_IcoefBH    0x93c
-#define Y_samDecl    0x93d
-#define Y_samDech    0x93e
-#define Y_deltaD     0x93f
-#define Y_switchD    0x940
-#define Y_samAttl    0x941
-#define Y_samAtth    0x942
-#define Y_deltaA     0x943
-#define Y_switchA    0x944
-#define Y_iSinusWant 0x946
-#define Y_sinusMode  0x947
-#define Y_tfnFL	     0x948
-#define Y_tfnFR	     0x949
-#define Y_tfnBL	     0x94a
-#define Y_tfnBR	     0x94b
-#define Y_BALL0	     0x8bc
-#define Y_BALR0	     0x8bd
-#define Y_BALL1      0x8ca
-#define Y_BALR1      0x8cb
-#define Y_FLcof      0x8ef
-#define Y_FRcof      0x8f0
-#define Y_RLcof      0x8f1
-#define Y_RRcof      0x8f2
-
-
-/*
- * Empeg I2C support
- */
-
-#define IIC_CLOCK  	EMPEG_I2CCLOCK
-#define IIC_DATAOUT	EMPEG_I2CDATA
-#define IIC_DATAIN 	EMPEG_I2CDATAIN
-
-static __inline__ void i2c_delay(void)
-{
-	udelay(15); // as low as revision 4 will go
-//	schedule();
-}
-
-/*
- * Pulse out a single bit, assumes the current state is clock low
- * and that the data direction is outbound.
- */
-
-static __inline__ void i2c_putdatabit(int bit)
-{
-	/* First set the data bit (clock low) */
-	GPCR=IIC_CLOCK;
-	if (bit) {
-	    if (GPLR&IIC_DATAOUT) {
-		GPCR = IIC_DATAOUT;
-		udelay(14);
-	    }
-	}
-	else {
-	    if (!(GPLR&IIC_DATAOUT)) {
-		GPSR = IIC_DATAOUT;
-	    }
-	}
-	udelay(1);
-
-	/* Now trigger the clock */
-	GPSR=IIC_CLOCK;
-	udelay(1);
-	
-	/* Drop the clock */
-	GPCR=IIC_CLOCK;
-	udelay(1);
-}
-
-/*
- * Read in a single bit, assumes the current state is clock low
- * and that the data direction is inbound.
- */
-
-static __inline__ int i2c_getdatabit(void)
-{
-	int result;
-
-	/* Trigger the clock */
-	GPSR=IIC_CLOCK;
-	udelay(15);
-	
-	/* Wait for the slave to give me the data */
-	result = !(GPLR & IIC_DATAIN);
-//	udelay(1);
-
-	/* Now take the clock low */
-	GPCR = IIC_CLOCK;
-	udelay(15);
-	return result;
-}
-
-/* Pulse out the start sequence */
-
-static __inline__ void i2c_startseq(void)
-{
-	/* Clock low, data high */
-	GPCR=IIC_CLOCK|IIC_DATAOUT;
-	udelay(15);
-
-	/* Put clock high */
-	GPSR=IIC_CLOCK;
-	udelay(1);
-
-	/* Put data low */
-	GPSR=IIC_DATAOUT;
-	udelay(1);
-
-	/* Clock low again */
-	GPCR=IIC_CLOCK;
-	udelay(15);
-}
-
-/* Pulse out the stop sequence */
-
-static __inline__ void i2c_stopseq(void)
-{
-	/* Data low, clock low */
-	GPCR=IIC_CLOCK;
-	GPSR=IIC_DATAOUT;
-	udelay(15);
-
-	/* Clock high */
-	GPSR=IIC_CLOCK;
-	udelay(1);
-	
-	/* Let data float high */
-	GPCR=IIC_DATAOUT;
-	udelay(15);
-}
-
-/*
- * Pulse out a complete byte and receive acknowledge.
- * Returns 0 on success, non-zero on failure.
- */
-static __inline__ int i2c_putbyte(int byte)
-{
-	int i, ack;
-#ifdef I2C_LOCK
-	unsigned long flags;
-	save_flags_cli(flags);
-#endif
-
-	/* Clock/data low */
-	GPCR=IIC_CLOCK;
-	GPSR=IIC_DATAOUT;
-
-	/* Clock out the data */
-	for(i = 7; i >= 0; --i)
-		i2c_putdatabit(byte & (1 << i));
-	
-	/* data high (ie, no drive) */
-	GPCR = IIC_DATAOUT | IIC_CLOCK;
-
-	i2c_delay();
-	
-	/* Clock out */
-	GPSR = IIC_CLOCK;
-	
-	/* Wait for ack to arrive */
-	i2c_delay();
-
-	ack = !(GPLR & IIC_DATAIN);
-
-	i2c_delay();
-	/* Clock low */
-	GPCR = IIC_CLOCK;
-	
-	i2c_delay();
-
-	if (ack) {
-		i2c_stopseq();
-		{ int a,b=0; for(a=0;a<100000;a++) b+=a; }
-		printk(KERN_ERR "i2c: Failed to receive ACK for data!\n");
-	}
-
-#ifdef I2C_LOCK
-	restore_flags(flags);
-#endif
-
-	return ack;
-}
-
-/*
- * Read an entire byte and send out acknowledge.
- * Returns byte read.
- */
-
-static __inline__ int i2c_getbyte(unsigned char *byte, int nak)
-{
-	int i;
-#ifdef I2C_LOCK
-	unsigned long flags;	
-	save_flags_cli(flags);
-#endif
-
-	/* Let data line float */
-	GPCR = IIC_DATAOUT;
-	i2c_delay();
-
-	*byte = 0;
-	/* Clock in the data */
-	for(i = 7; i >= 0; --i)
-		if (i2c_getdatabit())
-			(*byte) |= (1 << i);
-	
-	/* Well, I got it so respond with an ack, or nak */
-	
-	/* Send data low to indicate success */
-	if(!nak) {
-		GPSR = IIC_DATAOUT;
-	}
-	else {
-		GPCR = IIC_DATAOUT;
-	}
-	i2c_delay();
-
-	/* Trigger clock since data is ready */
-	GPSR = IIC_CLOCK;
-	i2c_delay();
-
-	/* Take clock low */
-
-	GPCR = IIC_CLOCK;
-	i2c_delay();
-
-	/* Release data line */
-	GPCR = IIC_DATAOUT;
-	i2c_delay();
-
-#ifdef I2C_LOCK
-	restore_flags(flags);
-#endif
-
-	return 0; /* success */
-}
-	
-	
-
-/* Write to one or more I2C registers */
-
-static __inline__ int i2c_write(unsigned char device, unsigned short address,
-					 unsigned int *data, unsigned short count)
-{
-#ifdef I2C_LOCK
-	unsigned long flags;
-	save_flags_cli(flags);
-#endif
-
-	/* Pulse out the start sequence */
-	i2c_startseq();
-
-	/* Say who we're talking to */
-	if (i2c_putbyte(device & 0xFE)) {
-		printk("i2c_write: device select failed\n");
-		goto i2c_error;
-	}
-
-	/* Set the address (higher then lower) */
-	if (i2c_putbyte(address >> 8) || i2c_putbyte(address & 0xFF)) {
-		printk("i2c_write: address select failed\n");
-		goto i2c_error;
-	}
-
-	/* Now send the actual data */
-	while(count--)
-	{
-		if (address<0x200) {
-			/* Send out the 24 bit quantity */
-			
-			/* Mask off the top eight bits in certain situations! */
-			if (i2c_putbyte((*data>>16)&0xff)) {
-				printk("i2c_write: write first byte failed"
-				       ", count:%d\n", count);
-				goto i2c_error;
-			}
-			if (i2c_putbyte((*data >> 8) & 0xFF)) {
-				printk("i2c_write: write second byte failed"
-				       ", count:%d\n", count);
-				goto i2c_error;
-			}
-			if (i2c_putbyte(*data & 0xFF)) {
-				printk("i2c_write: write third byte failed"
-				       ", count:%d\n", count);
-				goto i2c_error;
-			}
-		}
-		else {
-			/* Send out 16 bit quantity */
-			/* Mask off the top eight bits in certain situations! */
-			if (i2c_putbyte(*data >> 8)) {
-				printk("i2c_write: write first byte failed"
-				       ", count:%d\n", count);
-				goto i2c_error;
-			}
-			if (i2c_putbyte(*data & 0xFF)) {
-				printk("i2c_write: write second byte failed"
-				       ", count:%d\n", count);
-				goto i2c_error;
-			}
-		}
-		++data;
-	}
-	
-	i2c_stopseq();
-
-#ifdef I2C_LOCK
-	restore_flags(flags);
-#endif
-
-	/* Complete success */
-	return 0;
-
- i2c_error:
-#ifdef I2C_LOCK
-	restore_flags(flags);
-#endif
-
-	/* Complete failure */
-	return -1;
-}
-
-
-static __inline__ int i2c_read(unsigned char device, unsigned short address, unsigned int *data, int count)
-{
-#ifdef I2C_LOCK
-	unsigned long flags;
-	save_flags_cli(flags);
-#endif
-
-	/* Send start sequence */
-	i2c_startseq();
-
-	/* Set the device */
-	if (i2c_putbyte(device & 0xFE))
-		goto i2c_error;
-
-	/* Set the address (higher then lower) */
-	if (i2c_putbyte(address >> 8) || i2c_putbyte(address & 0xFF))
-		goto i2c_error;
-
-	/* Repeat the start sequence */
-	i2c_startseq();
-	
-	/* Set the device but this time in read mode */
-	if (i2c_putbyte(device | 0x01))
-		goto i2c_error;
-
-	/* Now read in the actual data */
-	while(count--)
-	{
-		unsigned char b1, b2, b3;
-		if(address < 0x200) {
-			if (i2c_getbyte(&b1, 0) ||
-			    i2c_getbyte(&b2, 0) ||
-			    i2c_getbyte(&b3, 1))
-				goto i2c_error;
-			*data++ = (b1 << 16) | (b2 << 8) | b3;
-		} else {
-			/* Receive the 16 bit quantity */
-			if (i2c_getbyte(&b1, 0) ||
-			    i2c_getbyte(&b2, 1))
-				goto i2c_error;
-			*data++ = (b1 << 8) | b2;
-		}
-	}
-
-	/* Now say we don't want any more: NAK (send bit 1) */
-	i2c_putdatabit(1);
-
-	i2c_stopseq();	
-	
-#ifdef I2C_LOCK
-	restore_flags(flags);
-#endif
-
-	return 0;
-
- i2c_error:
-#ifdef I2C_LOCK
-	restore_flags(flags);
-#endif
-
-	return -1;
-}
-
-static __inline__ int i2c_write1(unsigned char device, unsigned short address, unsigned int data)
-{
-	return i2c_write(device, address, &data, 1);
-}
-
-static __inline__ int i2c_read1(unsigned char device, unsigned short address, unsigned int *data)
-{
-	return i2c_read(device, address, data, 1);
-}
-
-/* THIS SHOULDN'T BE IN HERE, IT'S ONLY VISITING!
-   <altman@empeg.com> */
-
-/* Some DSP defines */
-#define IICD_DSP 0x38
-
-#define IIC_DSP_SEL 0x0FFA
-#define IIC_DSP_SEL_RESERVED0 0x01
-#define IIC_DSP_SEL_AUX_FM 0x02
-#define IIC_DSP_SEL_AUX_AM_TAPE 0x04
-#define IIC_DSP_SEL_AUX_CD_TAPE 0x08
-#define IIC_DSP_SEL_RESERVED1 0x10
-#define IIC_DSP_SEL_LEV_AMFM 0x20
-#define IIC_DSP_SEL_LEV_WIDENARROW 0x40
-#define IIC_DSP_SEL_LEV_DEF 0x80
-#define IIC_DSP_SEL_BYPASS_PLL 0x100
-#define IIC_DSP_SEL_DC_OFFSET 0x200
-#define IIC_DSP_SEL_RESERVED2 0x400
-#define IIC_DSP_SEL_ADC_SRC 0x800
-#define IIC_DSP_SEL_NSDEC 0x1000
-#define IIC_DSP_SEL_INV_HOST_WS 0x2000
-#define IIC_DSP_SEL_RESERVED3 0x4000
-#define IIC_DSP_SEL_ADC_BW_SWITCH 0x8000
-
-#endif
Index: empeg/kernel/arch/arm/special/empeg_audio2.c
diff -u empeg/kernel/arch/arm/special/empeg_audio2.c:1.10.2.1 empeg/kernel/arch/arm/special/empeg_audio2.c:1.14
--- empeg/kernel/arch/arm/special/empeg_audio2.c:1.10.2.1	Mon Aug 28 15:17:22 2000
+++ empeg/kernel/arch/arm/special/empeg_audio2.c	Wed Oct  4 17:37:21 2000
@@ -132,6 +132,11 @@
 #define AUDIO_NOOF_BUFFERS		(8)   /* Number of audio buffers */
 #define AUDIO_BUFFER_SIZE		(4608) /* Size of user buffer chunks */
 
+/* Number of audio buffers that can be in use at any one time. This is
+   two less since the inactive two are actually still being used by
+   DMA while they look like being free. */
+#define MAX_FREE_BUFFERS		(AUDIO_NOOF_BUFFERS - 2)
+
 /* Input channels */
 #define INPUT_PCM (1)
 #define INPUT_RADIO (0)
@@ -260,6 +265,7 @@
 static void mixer_eq_apply(void);
 static unsigned int eq_last[40];
 static unsigned int eq_reg_last = 0;
+static unsigned int radio_sensitivity = 0x1048;	// for marvin, 0x1000 for <6
 
 /* Devices in the system; just the one channel at the moment */
 static audio_dev 	audio[1];
@@ -540,6 +546,30 @@
 	return(total);
 }
 
+/* Throw away all complete blocks waiting to go out to the DAC and return how
+   many bytes that was. */
+static int audio_purge(audio_dev *dev)
+{
+	unsigned long flags;
+	int bytes;
+
+	/* We don't want to get interrupted here */
+	save_flags_cli(flags);
+
+	/* Work out how many bytes are left to send to the audio device:
+	   we only worry about full buffers */
+	bytes=dev->used*AUDIO_BUFFER_SIZE;
+
+	/* Empty buffers */
+	dev->head=dev->tail=dev->used=0;
+	dev->free=MAX_FREE_BUFFERS;
+	
+	/* Let it run again */
+	restore_flags(flags);
+
+	return bytes;
+}
+
 static int audio_ioctl( struct inode *inode, struct file *file, uint command, ulong arg )
 {
 	audio_dev *dev = &audio[0];
@@ -555,6 +585,12 @@
 		audio_beep(dev, pitch, length, volume);
 		return 0;
 	}
+
+	case EMPEG_DSP_PURGE: {
+		int bytes = audio_purge(dev);
+		put_user_ret(bytes, (int *)arg, -EFAULT);
+		return 0;		
+	}
 	}
 	
 	/* invalid command */
@@ -969,6 +1005,43 @@
 
 		return 0;
 	}
+	case EMPEG_MIXER_RAW_I2C_READ:
+	{
+		int err, reg, val;
+		if((err = verify_area(VERIFY_WRITE, (void *) arg, sizeof(int))) != 0)
+			return err;
+		copy_from_user((void *) &reg, (const void *) arg, sizeof(int));
+		
+		dsp_read_yram(reg, &val);
+		copy_to_user((void *) arg, (const void *) &val, sizeof(int));
+		return 0;
+	}
+	case EMPEG_MIXER_RAW_I2C_WRITE:
+	{
+		int err;
+		int reg, val;
+		int *block = (int *) arg;
+		if((err = verify_area(VERIFY_READ, (void *) block, 2 * sizeof(int))) != 0)
+			return err;
+		copy_from_user((void *) &reg, (const void *) block, sizeof(int));
+		copy_from_user((void *) &val, (const void *) (block+1), sizeof(int));
+		
+		dsp_write(reg, val);
+		return 0;
+	}
+	case EMPEG_MIXER_WRITE_SENSITIVITY:
+	{
+		int err;
+		int val;
+		if((err = verify_area(VERIFY_READ, (void *) arg, sizeof(int))) != 0)
+			return err;
+		copy_from_user((void *) &val, (const void *) arg, sizeof(int));
+		if(val < 0 || val > 7)
+			return -EINVAL;
+		radio_sensitivity = (val << 1) | (val << 4) | 0x1000;
+		dsp_write(0xffd, radio_sensitivity);
+		return 0;
+	}
 	default:
 		return -EINVAL;
 	}
@@ -1089,6 +1162,11 @@
 	printk(AUDIO_NAME ": audio_sa1100_init\n");
 #endif
 
+	if(empeg_hardwarerevision() < 6)
+		radio_sensitivity = 0x1000;
+	else
+		radio_sensitivity = 0x1048;
+
 	/* Blank everything to start with */
 	memset(dev,0,sizeof(audio_dev));
 	
@@ -1106,7 +1184,7 @@
 	/* Set up queue: note that two buffers could be DMA'ed any any time,
 	   and so we use two fewer marked as "free" */
 	dev->head=dev->tail=dev->used=0;
-	dev->free=(AUDIO_NOOF_BUFFERS-2);
+	dev->free=MAX_FREE_BUFFERS;
 
 	/* Request appropriate interrupt line */
 	if((err=request_irq(AUDIO_IRQ,audio_interrupt,SA_INTERRUPT,AUDIO_NAME,NULL))!= 0) {
@@ -1427,8 +1505,9 @@
 	  { 0xffe, 0x28ed },
 	  // flat eric
 	  //	  { 0xffd, 0x102a }, /* 2-ch eq, 65mV tuner */
-	  { 0xffd, 0x100a }, /* 2-ch eq, 65mV tuner */	// also in case statement
-	  { 0xffc, 0xe086 }, /* level IAC off=e080 */
+	  { 0xffd, 0x1000 }, /* 2-ch eq, 65mV tuner */	// also in case statement
+	  //	  { 0xffc, 0xe086 }, /* level IAC off=e080 */
+	  { 0xffc, 0x0086 }, /* level IAC off=e080 */
 	  { 0xffb, 0x0aed },
 	  { 0xffa, 0x1048 },
 	  { 0xff9, 0x0020 }, /* no I2S out */
@@ -1439,7 +1518,7 @@
 	{ { 0xfff, 0xd223 },
 	  { 0xffe, 0x28ed },
 	  //	  { 0xffd, 0x006c },
-	  { 0xffd, 0x106c },	/* 2 ch too */		// also in case statement
+	  { 0xffd, 0x1000 },	/* 2 ch too */		// also in case statement
 	  { 0xffc, 0xe086 },
 	  { 0xffb, 0x0aed },
 	  { 0xffa, 0x1048 },
@@ -1452,7 +1531,7 @@
 	{ { 0xfff, 0xd223 }, /*DCS_ConTRol*/
 	  { 0xffe, 0x28ed }, /*DCS_DIVide*/
 	  //	  { 0xffd, 0x006c }, /*AD*/
-	  { 0xffd, 0x106c }, /*AD - 2 ch */		// also in case statement
+	  { 0xffd, 0x1000 }, /*AD - 2 ch */		// also in case statement
 	  { 0xffc, 0x6080 }, /*LEVEL_IAC*/
 	  { 0xffb, 0x0aed }, /*IAC*/
 	  { 0xffa, 0x904a }, /*SEL*/
@@ -1460,6 +1539,11 @@
 	  { 0xff3, 0x0000 }, /*RDS_CONTROL*/
 	  { 0,0 } };
 
+	eq_reg_last = radio_sensitivity;
+	dsp_patchmulti(fm_setup, 0xffd, eq_reg_last);
+	dsp_patchmulti(mpeg_setup, 0xffd, eq_reg_last);
+	dsp_patchmulti(aux_setup, 0xffd, eq_reg_last);
+		
 	/* Ensure any beeps playing are off, because this may block for some time */
 	dsp_write(Y_sinusMode, 0x89a);
 	
@@ -1468,9 +1552,8 @@
 
 	switch(input) {
 	case INPUT_RADIO: /* FM */
-		/* FM mode: see p64 */
+	  /* FM mode: see p64 */
 		dsp_writemulti(fm_setup);
-		eq_reg_last = 0x100a;
 		
 		/* Easy programming set 2, FM */
 		dsp_write(X_modpntr,0x600);
@@ -1499,6 +1582,7 @@
 		//dsp_write(Y_q1, 3380 /* 3438 */);
 
 		// To work out required p and q values, use #define RADIO_DEBUG 1
+		// use Y_p1 = 256 (0.25), Y_q1 = 0
 		// record low and high levels printed:
 
 		// l_low = (lowest reading) / 131072
@@ -1515,6 +1599,10 @@
 
 		//    0 <= p <= 2047
 		// 2048 <= q <= 4095
+		// dsp_write(Y_p1, 512);
+		// dsp_write(Y_q1, 0);
+		dsp_write(Y_p1, 2047);
+		dsp_write(Y_q1, 4030);
 #else
 		dsp_write(Y_p1, 2047);	// coefficients
 		//		dsp_write(Y_q1, 3987);
@@ -1553,7 +1641,6 @@
 	case INPUT_PCM: /* MPEG */
 		/* I2S input mode: see p64 */
 		dsp_writemulti(mpeg_setup);
-		eq_reg_last = 0x106c;
 
 		/* Easy programming set 4, CD */
 		dsp_write(X_modpntr,0x5c0);
@@ -1579,7 +1666,6 @@
 	case INPUT_AUX:
 		/* AUX mode: see p64 */
 		dsp_writemulti(aux_setup);
-		eq_reg_last = 0x106c;
 		
 		/* Easy programming set 3, AUX - see page 68 */
 		dsp_write(X_modpntr,0x5c0);
@@ -1680,12 +1766,17 @@
 int audio_get_fm_level(void)
 {
 	unsigned level;
+#if RADIO_DEBUG > 0
+	static unsigned min = 131071, max = 0;
+#endif
 
 	if (dsp_read_xram(X_leva, &level) < 0) {
 		return -1;
 	}
 #if RADIO_DEBUG > 0
-	printk("X_leva: %u\n", level);
+	if(level < min) min = level;
+	if(level > max) max = level;
+	//	printk("X_leva: %6u (%6u .. %6u)\n", level, min, max);
 #endif
 	
 	return (int) level;
Index: empeg/kernel/arch/arm/special/empeg_audio3.c
diff -u empeg/kernel/arch/arm/special/empeg_audio3.c:1.4.2.1 empeg/kernel/arch/arm/special/empeg_audio3.c:1.6
--- empeg/kernel/arch/arm/special/empeg_audio3.c:1.4.2.1	Thu May  3 11:52:33 2001
+++ empeg/kernel/arch/arm/special/empeg_audio3.c	Mon Sep 17 15:19:21 2001
@@ -81,6 +81,9 @@
 #include <linux/proc_fs.h>
 #endif
 
+/* For the userspace interface */
+#include <asm/arch/empeg.h>
+
 #include "empeg_dsp.h"
 #include "empeg_dsp_i2c.h"
 #include "empeg_audio3.h"
@@ -422,6 +425,16 @@
 		put_user_ret(bytes, (int *)arg, -EFAULT);
 		return 0;		
 	}
+	case EMPEG_DSP_GRAB_OUTPUT:
+	{
+	        int pretail = dev->tail - 1;
+	        if( pretail < 0 )
+	            pretail += AUDIO_NOOF_BUFFERS;
+
+		return copy_to_user((char *) arg,
+		                    dev->buffers[pretail].data,
+				    AUDIO_BUFFER_SIZE);
+        }	
 	}
 	
 	/* invalid command */
Index: empeg/kernel/arch/arm/special/empeg_cs4231a.c
diff -u empeg/kernel/arch/arm/special/empeg_cs4231a.c:1.11 empeg/kernel/arch/arm/special/empeg_cs4231a.c:1.15
--- empeg/kernel/arch/arm/special/empeg_cs4231a.c:1.11	Tue Jun 13 13:43:03 2000
+++ empeg/kernel/arch/arm/special/empeg_cs4231a.c	Tue Sep 25 12:22:37 2001
@@ -49,6 +49,9 @@
 #include <linux/proc_fs.h>
 #include <linux/poll.h>
 
+/* For the userspace interface */
+#include <asm/arch/empeg.h>
+
 #include "empeg_cs4231a.h"
 
 /* Only one audio channel */
@@ -170,10 +173,15 @@
 		   int gain)
 {
 	int a=0,timeout=jiffies+HZ;
+	int stopped = 0;
 
-	/* Stop the sampling */
-	INDEX(INTERFACE_CONFIG);
-	WRITEDATA(0x00);
+	if (stereo >= 0 || rate >= 0)
+	{
+		stopped = 1;
+		/* Stop the sampling */
+		INDEX(INTERFACE_CONFIG);
+		WRITEDATA(0x00);
+	}
 
 	if (channel>=0) {
 		/* Select channel */
@@ -259,7 +267,7 @@
 	}
 
 	/* Reset capture if device is open */
-	if (dev->open) {
+	if (stopped && dev->open) {
 		unsigned long flags;
 		struct pt_regs regs;
 		int a;
@@ -326,8 +334,15 @@
 
 	/* Read version */
 	INDEX(VERSION);
-	version=READDATA();
+	version=(READDATA()&0xe7);
 
+	/* Check version */
+	if (version!=0xa0) {
+		printk(KERN_WARNING "Could not find CS4231A (version=%02x)\n",
+		       version);
+		return;
+	}
+		
 	/* Set SDC bit (single DMA channel) */
 	INDEX(INTERFACE_CONFIG|INDEX_MCE);
 	WRITEDATA(0x00);
@@ -346,7 +361,7 @@
 	/* Allocate buffers */
 	dev->rx_buffer=vmalloc(CS4231_BUFFER_SIZE);
 	if (!dev->rx_buffer) {
-		printk(KERN_WARNING "Could not allocate memory for USB receive buffer\n");
+		printk(KERN_WARNING "Could not allocate memory for audio input buffer\n");
 		return;
 	}
 
@@ -524,39 +539,43 @@
 
 	switch(cmd) {
 	case EMPEG_AUDIOIN_READ_SAMPLERATE:
+		/* Read samplerate */
 		put_user_ret(dev->samplerate, (int*)arg, -EFAULT);
+		return 0;
 
 	case EMPEG_AUDIOIN_WRITE_SAMPLERATE:
-		get_user_ret(parm, (int*)arg, -EFAULT);
-
 		/* Set samplerate */
+		get_user_ret(parm, (int*)arg, -EFAULT);
 		return setmode(dev,-1,parm,-1,-1);
 
 	case EMPEG_AUDIOIN_READ_CHANNEL:
+		/* Read channel */
 		put_user_ret(dev->channel, (int*)arg, -EFAULT);
+		return 0;
 
 	case EMPEG_AUDIOIN_WRITE_CHANNEL:
-		get_user_ret(parm, (int*)arg, -EFAULT);
-
 		/* Set samplerate */
+		get_user_ret(parm, (int*)arg, -EFAULT);
 		return setmode(dev,parm,-1,-1,-1);
 
 	case EMPEG_AUDIOIN_READ_STEREO:
+		/* Read stereoness */
 		put_user_ret(dev->stereo, (int*)arg, -EFAULT);
+		return 0;
 
 	case EMPEG_AUDIOIN_WRITE_STEREO:
-		get_user_ret(parm, (int*)arg, -EFAULT);
-
 		/* Set stereoness */
+		get_user_ret(parm, (int*)arg, -EFAULT);
 		return setmode(dev,-1,-1,parm,-1);
 
 	case EMPEG_AUDIOIN_READ_GAIN:
+		/* Read gain */
 		put_user_ret(dev->gain, (int*)arg, -EFAULT);
+		return 0;
 
 	case EMPEG_AUDIOIN_WRITE_GAIN:
-		get_user_ret(parm, (int*)arg, -EFAULT);
-
 		/* Set gain */
+		get_user_ret(parm, (int*)arg, -EFAULT);
 		return setmode(dev,-1,-1,-1,parm);
 	}
 
Index: empeg/kernel/arch/arm/special/empeg_dac.c
diff -u empeg/kernel/arch/arm/special/empeg_dac.c:1.11.8.1 empeg/kernel/arch/arm/special/empeg_dac.c:1.15
--- empeg/kernel/arch/arm/special/empeg_dac.c:1.11.8.1	Thu Sep 28 12:00:02 2000
+++ empeg/kernel/arch/arm/special/empeg_dac.c	Fri Aug 24 11:28:32 2001
@@ -83,6 +83,9 @@
 #include <asm/arch/SA-1100.h>
 #include <asm/uaccess.h>
 
+/* For the userspace interface */
+#include <asm/arch/empeg.h>
+
 #ifdef	CONFIG_PROC_FS
 #include <linux/stat.h>
 #include <linux/proc_fs.h>
@@ -123,9 +126,14 @@
 /* Client parameters */
 #define AUDIO_NOOF_BUFFERS		(8)   /* Number of audio buffers */
 #define AUDIO_BUFFER_SIZE		(4608) /* Size of user buffer chunks */
+
+/* Number of audio buffers that can be in use at any one time. This is
+   two less since the inactive two are actually still being used by
+   DMA while they look like being free. */
+#define AUDIO_MAX_FREE_BUFFERS		(AUDIO_NOOF_BUFFERS - 2)
 
-#if AUDIO_NOOF_BUFFERS < 4
-#error Whoops
+#if AUDIO_MAX_FREE_BUFFERS < 2
+#error Insufficient buffer size.
 #endif
 
 /* Input channels */
@@ -621,7 +629,7 @@
 
 	/* Set up queue */
 	dev->head=dev->tail=dev->used=0;
-	dev->free=AUDIO_NOOF_BUFFERS - 2;
+	dev->free=AUDIO_MAX_FREE_BUFFERS;
 
 	/* Request appropriate interrupt line */
 	if((err=request_irq(AUDIO_IRQ,audio_interrupt,0,AUDIO_NAME,NULL))!=0) {
Index: empeg/kernel/arch/arm/special/empeg_display.c
diff -u empeg/kernel/arch/arm/special/empeg_display.c:1.33.4.3 empeg/kernel/arch/arm/special/empeg_display.c:1.48
--- empeg/kernel/arch/arm/special/empeg_display.c:1.33.4.3	Mon Feb 12 15:40:20 2001
+++ empeg/kernel/arch/arm/special/empeg_display.c	Wed Oct 17 15:52:25 2001
@@ -63,8 +63,9 @@
  *                vanished because of this (probably something to do with
  *                the minimum start porch). Some tidying.
  *
- * 2001/01/05 MAC Ported Hugo's empeg_power changes from the trunk back
- *                so we support rev9 players.
+ * 2000/10/27 HBF Display power on/off now uses empeg_displaypower() -
+ *                (in the empeg_power driver) as issue 9 boards no longer
+ *                use a GPIO to control this.
  *
  * This is the very basic console mapping code: we only provide a mmap()able
  * area at the moment - there is no linkup with the VT code.
@@ -134,11 +135,22 @@
 #include <asm/arch/empeg.h>
 #include <asm/uaccess.h>
 
+#ifdef NO_ANIMATION
+/* The Rio logo for the splash screen */
+#include "rio_logo.h"
 /* The empeg logo for the splash screen: includes tux :) */
 #include "empeg_logo.h"
+#else
+/* Animations for both empeg and rio players. */
+#include "empeg_ani.h"
+#include "rio_ani.h"
 
-/* The Rio logo for the splash screen */
-#include "rio_logo.h"
+/* Animation speed (in fps) */
+#define ANIMATION_FPS		12
+#endif
+
+/* No hard disk found image */
+#include "nohd_img.h"
 
 inline void donothing(const char *s, ...)
 {
@@ -149,6 +161,11 @@
 #define BUFFER_COUNT_ORDER     (3) /* Eight buffers */
 #define BUFFER_COUNT	       (1<<BUFFER_COUNT_ORDER)
 
+/* Since we need to parallel the number of audio buffers there are
+   actually two less due to DMA stuff. See the audio driver for
+   details. */
+#define MAX_FREE_BUFFERS	(BUFFER_COUNT - 2)
+
 /* We run in a 4bpp mode */
 #define EMPEG_SCREEN_BPP       4
 #define EMPEG_PALETTE_SIZE     (1<<EMPEG_SCREEN_BPP)
@@ -245,6 +262,9 @@
 
 static struct display_dev devices[1];
 
+/* Timer to display boot animation */
+static struct timer_list animation_timer;
+
 /* Timer to display user's splash screen */
 static struct timer_list display_timer;
 
@@ -553,6 +573,58 @@
 	display_splash(dev, image);
 }
 
+/* Boot failure */
+void display_bootfail(void)
+{
+	/* Display the no hard disks found image */
+	display_user_splash((unsigned long)nohd_img);
+}
+
+/* Deal with next animation frame */
+static void display_animation(unsigned long animation_base)
+{
+	struct display_dev *dev = devices;
+	unsigned int *frameptr=(unsigned int*)animation_base;
+
+	/* Used once only, so this can be static */
+	static int framenr=-1;
+
+	/* Called once to initialise */
+	if (framenr>=0) {
+		unsigned char *d,*s;
+		int a;
+
+		/* Find applicable frame to display */
+		s=(unsigned char*)(animation_base+frameptr[framenr]);
+
+		/* End of animation? */
+		if (!frameptr[framenr]) return;
+
+		/* Decompress and display */
+		d=dev->software_buffer;
+		for(a=0;a<2048;a+=2) {
+			*d++=((*s&0xc0)>>2)|((*s&0x30)>>4);
+			*d++=((*s&0x0c)<<2)|((*s&0x03));
+			s++;
+		}
+
+		/* Blat it: well, add it to the refresh buffer, otherwise when
+		   the audio DMA starts it all goes blank... */
+		display_refresh(dev);
+	}
+		
+	/* Re-queue ourselves at ANIMATION_FPS (0.5 seconds for the first
+	   frame) */
+	init_timer(&animation_timer);
+	animation_timer.data=animation_base;
+	animation_timer.expires=(jiffies+((framenr==0)?(HZ/2):(HZ/ANIMATION_FPS)));
+	animation_timer.function=display_animation;
+	add_timer(&animation_timer);
+
+	/* Next frame */
+	framenr++;
+}
+
 #define CHARS_TO_ULONG(A, B, C, D) ((A) | ((B) << 8) | ((C) << 16) | ((D) << 24))
 	
 static void handle_splash(struct display_dev *dev)
@@ -563,10 +635,12 @@
 	const int LOGO_CUSTOM = 0x10;	
 	int logo_type;
 	unsigned char *user_splash=(unsigned char*)(EMPEG_FLASHBASE+0xa000);
+	int animation_time=(3*HZ);
+	unsigned long *ani_ptr;
 
 	unsigned long splash_signature = *((unsigned long *)user_splash);
 
-	printk("Signature is %08x '%c%c%c%c'\n", splash_signature,
+	printk("Signature is %08lx '%c%c%c%c'\n", splash_signature,
 	       user_splash[0], user_splash[1], user_splash[2], user_splash[3]);
 	
 	switch (splash_signature)
@@ -587,17 +661,32 @@
 		logo_type = LOGO_EMPEG;
 	}
 	
+#ifdef NO_ANIMATION
 	/* Load splash screen image */
 	if ((logo_type & LOGO_MASK) == LOGO_RIO)
 		display_splash(dev, &rio_logo);
 	else
 		display_splash(dev, &empeg_logo);
+#else
+	/* Display splash screen animation */
+	if ((logo_type & LOGO_MASK) == LOGO_RIO) {
+		display_animation((unsigned long)rio_ani);
+		ani_ptr=(unsigned long*)rio_ani;
+	} else {
+		display_animation((unsigned long)empeg_ani);
+		ani_ptr=(unsigned long*)empeg_ani;
+	}
 
-	/* Setup timer to display user's image (if present) in 3 seconds */
+	/* Work out time to play animation: 1s (0.5 start & end) + frames */
+	animation_time=HZ;
+	while(*ani_ptr++) animation_time+=(HZ/ANIMATION_FPS);
+#endif
+
+	/* Setup timer to display user's image (if present) in 4 seconds */
 	if (logo_type & LOGO_CUSTOM) {
 		printk("Scheduling custom logo.\n");
 		init_timer(&display_timer);
-		display_timer.expires=(jiffies+(HZ*3));
+		display_timer.expires=(jiffies+animation_time);
 
 		/* On AC or DC power? AC is first image, DC is second */
 		display_timer.data=(unsigned long)(user_splash+4);
@@ -761,18 +850,18 @@
 				/* Lcd control register 0; everything off */
 				LCSR = LCSR_LDD;
 				LCCR0 = 0;
-				
+
 				/* Wait for controller off */
 				while((LCSR&LCSR_LDD)==0);
 			}
-			
+
 			/* Clear error flags */
 			LCSR = 0xfff;
-			
+
 			/* Set up the DMA controller's base address for the
 			   screen */
 			DBAR1 = (unsigned char*)virt_to_phys((int)dev->hardware_buffer);
-			
+
 			/* Now enable the screen */
 			LCCR0 = LCCR0_SETUP;
 			LCCR0 |= LCCR0_LEN;
@@ -1049,8 +1138,7 @@
 		LCCR0_4PixMono+       /* 4-pixels-per-clock mono display */
 		LCCR0_DMADel(0);      /* No DMA delay */
 
-	/* Turn off POM */
-	GPSR=EMPEG_DSPPOM;
+	/* Display on again */
 	empeg_displaypower(1);
 #else
 	struct display_dev *dev = devices;
@@ -1107,6 +1195,5 @@
 		empeg_displaypower(1);
 		udelay(POWERFAIL_DISABLED_DELAY);
 	}
-	GPSR=EMPEG_DSPPOM;
 #endif
 }
Index: empeg/kernel/arch/arm/special/empeg_dsp_i2c.c
diff -u empeg/kernel/arch/arm/special/empeg_dsp_i2c.c:1.1.2.1 empeg/kernel/arch/arm/special/empeg_dsp_i2c.c:1.2
--- empeg/kernel/arch/arm/special/empeg_dsp_i2c.c:1.1.2.1	Thu May  3 11:52:33 2001
+++ empeg/kernel/arch/arm/special/empeg_dsp_i2c.c	Thu Aug 23 16:27:50 2001
@@ -9,10 +9,11 @@
  *
  */
 
+#include <linux/config.h>
 #include <linux/kernel.h>
 #include <asm/delay.h>
 #include <asm/arch/hardware.h>
-#include <asm/arch/empeg.h>
+#include <asm/arch/hardware.h>
 
 #include "empeg_dsp_i2c.h"
 
Index: empeg/kernel/arch/arm/special/empeg_input.c
diff -u empeg/kernel/arch/arm/special/empeg_input.c:1.2.2.1 empeg/kernel/arch/arm/special/empeg_input.c:1.3
--- empeg/kernel/arch/arm/special/empeg_input.c:1.2.2.1	Tue Jun  5 19:35:13 2001
+++ empeg/kernel/arch/arm/special/empeg_input.c	Mon Oct  1 18:22:29 2001
@@ -128,7 +128,7 @@
  */   
 //#define REQUEST_IRQ_ON_OPEN 0
 
-#define REMOTE_BUTTON_UP_TIMEOUT MS_TO_JIFFIES(100) /* .1 seconds */
+#define REMOTE_BUTTON_UP_TIMEOUT MS_TO_JIFFIES(150) /* .15 seconds */
 
 /* Each button press when in one of the control specific modes
  * generates a 4 byte code. When in capture mode each transition
Index: empeg/kernel/arch/arm/special/empeg_input_fiq.S
diff -u empeg/kernel/arch/arm/special/empeg_input_fiq.S:1.2.2.1 empeg/kernel/arch/arm/special/empeg_input_fiq.S:1.3
--- empeg/kernel/arch/arm/special/empeg_input_fiq.S:1.2.2.1	Tue Jun  5 19:35:13 2001
+++ empeg/kernel/arch/arm/special/empeg_input_fiq.S	Thu Aug 23 16:27:50 2001
@@ -9,9 +9,10 @@
  *
  */
 
+#include <linux/config.h>
 #include <linux/linkage.h>
 #include <asm/assembler.h>
-#include <asm/arch/empeg.h>
+#include <asm/arch/hardware.h>
 #include "empeg_input.h"
 		.text
 	
Index: empeg/kernel/arch/arm/special/empeg_mixer.c
diff -u empeg/kernel/arch/arm/special/empeg_mixer.c:1.4.2.9 empeg/kernel/arch/arm/special/empeg_mixer.c:1.6
--- empeg/kernel/arch/arm/special/empeg_mixer.c:1.4.2.9	Fri Jun 15 16:18:10 2001
+++ empeg/kernel/arch/arm/special/empeg_mixer.c	Wed Sep 12 18:05:32 2001
@@ -31,6 +31,8 @@
 #include <asm/uaccess.h>
 #include <asm/delay.h>
 
+#include <asm/arch/empeg.h>
+
 #ifdef	CONFIG_PROC_FS
 #include <linux/stat.h>
 #include <linux/proc_fs.h>
Index: empeg/kernel/arch/arm/special/empeg_pdiusb12.c
diff -u empeg/kernel/arch/arm/special/empeg_pdiusb12.c:1.8.6.5 empeg/kernel/arch/arm/special/empeg_pdiusb12.c:1.14
--- empeg/kernel/arch/arm/special/empeg_pdiusb12.c:1.8.6.5	Tue Oct 31 14:30:04 2000
+++ empeg/kernel/arch/arm/special/empeg_pdiusb12.c	Fri Oct  5 09:57:07 2001
@@ -197,9 +197,17 @@
 
 /* Unicode descriptors for our device description */
 unsigned char UNICODE_AVAILABLE[]={ 0x04,0x00,0x09,0x04 };        /* We offer only one language: 0409, US English */
-unsigned char UNICODE_MANUFACTURER[]={12,0,'e',0,'m',0,'p',0,'e',0,'g',0};
-unsigned char UNICODE_PRODUCT[]={20,0,'e',0,'m',0,'p',0,'e',0,'g',0,'-',0,
-                             'c',0,'a',0,'r',0};
+unsigned char UNICODE_MANUFACTURER[]={8,0,'R',0,'i',0,'o',0};
+unsigned char UNICODE_PRODUCT[]={
+	16,0,
+	'R',0,
+	'i',0,
+	'o',0,
+	' ',0,
+	'C',0,
+	'a',0,
+	'r',0
+};
 
 /* Predeclarations */
 static void tx_data(int kick);
@@ -231,14 +239,14 @@
 {
 	unsigned char d;
 	d=*usb_data;
-	{ int a; for(a=0;a<8;a++); }
+	{ int a; for(a=0;a<10;a++); }
 	return(d);
 }
 
 static __inline__ void usb_cwrite(unsigned char dta)  
 {
 	*usb_data=dta;
-	{ int a; for(a=0;a<41;a++); }
+	{ int a; for(a=0;a<43;a++); }
 }
 
 /* Check to see if endpoint is full */
@@ -551,7 +559,7 @@
 		usb_command(CMD_CLEARBUFFER);
 
 		/* Packet rx ok */
-		dev->stats_rxok[1]++;
+		dev->stats_ok[1]++;
 
 #ifdef DEBUG_USB_1
 		LOG('r');
@@ -628,7 +636,7 @@
 		printk("tx(%02x)\n",txstat);
 #endif
 		/* Successfully sent some stuff: bump counts & reset buffer */
-		dev->stats_txok[1]++;
+		dev->stats_ok[1]++;
 
 		/* If last packet was short, and there's nothing in the buffer
 		   to send, then just stop here with TX disabled */
@@ -721,7 +729,7 @@
 	eplast=usb_cread();
 	
 	/* Bump stats */
-	dev->stats_rxok[0]++;
+	dev->stats_ok[0]++;
 
 	/* Is this a setup packet? */  
 	if(eplast&LASTTRANS_SETUP) {
@@ -776,7 +784,10 @@
 					/* Find endpoint */
 					int ep=((command[4]&0x80)?1:0)+((command[4]&3)*2);
 					int stall=(command[1]==SET_FEATURE)?SETEPSTATUS_STALLED:0;
-					/* Set/clear stall flag */
+#ifdef DEBUG_USB_1
+					printk("endpoint stall(%d)\n",ep);
+#endif
+					/* Set/clear endpoint stall flag */
 					usb_command(CMD_SETEPSTATUS0+ep);
 					usb_cwrite(stall);
 
@@ -853,7 +864,7 @@
 	usb_cread();
 
 	/* Bump stats */
-	dev->stats_txok[0]++;
+	dev->stats_ok[0]++;
 
 	LOGS("tx_command ");
 
@@ -944,25 +955,19 @@
 	len = 0;
 
 	len+=sprintf(buf+len,"Control endpoint 0\n");
-	len+=sprintf(buf+len,"  %9d RX ok\n",dev->stats_rxok[0]);
-	len+=sprintf(buf+len,"  %9d RX error\n",dev->stats_rxerr[0]);
-	len+=sprintf(buf+len,"  %9d RX nak\n",dev->stats_rxnak[0]);
-	len+=sprintf(buf+len,"  %9d TX ok\n",dev->stats_txok[0]);
-	len+=sprintf(buf+len,"  %9d TX error\n\n",dev->stats_txerr[0]);
+	len+=sprintf(buf+len,"  %9d RX ok\n",dev->stats_ok[0]);
+	len+=sprintf(buf+len,"  %9d TX ok\n\n",dev->stats_ok[1]);
 	
 	len+=sprintf(buf+len,"Overall stats\n");
 	len+=sprintf(buf+len,"  %9d RX bytes\n",dev->rx_count);
 	len+=sprintf(buf+len,"  %9d TX bytes\n\n",dev->tx_count);
 	len+=sprintf(buf+len,"  %9d RX buffered\n",dev->rx_used);
 	len+=sprintf(buf+len,"  %9d TX buffered\n\n",dev->tx_used);
-
-	len+=sprintf(buf+len,"Endpoint\n");
-	len+=sprintf(buf+len,"  %9d RX ok\n",dev->stats_rxok[1]);
-	len+=sprintf(buf+len,"  %9d RX error\n",dev->stats_rxerr[1]);
-	len+=sprintf(buf+len,"  %9d RX nak\n",dev->stats_rxnak[1]);
-	len+=sprintf(buf+len,"  %9d RX overruns\n",dev->stats_rxoverrun[1]);
-	len+=sprintf(buf+len,"  %9d TX ok\n",dev->stats_txok[1]);
-	len+=sprintf(buf+len,"  %9d TX error\n\n",dev->stats_txerr[1]);
+	
+	len+=sprintf(buf+len,"Data endpoints\n");
+	len+=sprintf(buf+len,"  %9d RX ok\n",dev->stats_ok[2]);
+	len+=sprintf(buf+len,"  %9d TX ok\n\n",dev->stats_ok[3]);
+	
 
 	{
 		unsigned long flags;
@@ -972,7 +977,6 @@
 		usb_command(CMD_SELECTEP4);
 		if (usb_cread() & SELECTEP_STALL)
 			len += sprintf(buf+len, "Endpoint 4 is stalled.\n");
-
 		usb_command(CMD_SELECTEP5);
 		if (usb_cread() & SELECTEP_STALL)
 			len += sprintf(buf+len, "Endpoint 5 is stalled.\n");		
Index: empeg/kernel/arch/arm/special/empeg_power.c
diff -u empeg/kernel/arch/arm/special/empeg_power.c:1.13.4.3 empeg/kernel/arch/arm/special/empeg_power.c:1.19
--- empeg/kernel/arch/arm/special/empeg_power.c:1.13.4.3	Thu May  3 11:57:00 2001
+++ empeg/kernel/arch/arm/special/empeg_power.c	Thu Aug 23 16:27:50 2001
@@ -76,6 +76,9 @@
 #include <linux/proc_fs.h>
 #include <linux/poll.h>
 
+/* For the userspace interface */
+#include <asm/arch/empeg.h>
+
 #include "empeg_power.h"
 
 /* Only one power pic */
Index: empeg/kernel/arch/arm/special/empeg_ramtest.c
diff -u /dev/null empeg/kernel/arch/arm/special/empeg_ramtest.c:1.7
--- /dev/null	Wed Oct 17 16:36:04 2001
+++ empeg/kernel/arch/arm/special/empeg_ramtest.c	Fri Dec  8 15:32:48 2000
@@ -0,0 +1,296 @@
+/* empeg ram test haxory
+ *
+ * (C) 1999/2000 empeg ltd, http://www.empeg.com
+ *
+ * Authors:
+ *   John Ripley <john@empeg.com>
+ *
+ * Disable everything and test a page of RAM extensively.
+ * Satan waz ere.
+ *
+ * Version 0.01 20000920 john@empeg.com
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/major.h>
+#include <linux/errno.h>
+#include <linux/malloc.h>
+#include <linux/vmalloc.h>
+#include <linux/init.h>
+
+#include <asm/byteorder.h>
+#include <asm/irq.h>
+#include <asm/fiq.h>
+#include <asm/segment.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <linux/proc_fs.h>
+#include <linux/poll.h>
+
+#define RAMTEST_DEBUG		0
+
+#define RAMTEST_MAJOR		251
+#define RAMTEST_NAME		"ramtest"
+
+/* evil asm calls */
+void empeg_ramtest_critical_start(void);	/* don't wipe from here... */
+void empeg_ramtest_critical_end(void);		/* ... to here */
+int empeg_ramtest_preserve(unsigned long safe_page,
+			   unsigned long test_page, int half);
+int empeg_ramtest_destructive(unsigned long safe_page, int half);
+
+struct empeg_ramtest_dev
+{
+	int use_count;
+	unsigned long safe_page;
+};
+
+static struct empeg_ramtest_dev ramtest_device;
+
+int __init empeg_ramtest_init(void);
+static int empeg_ramtest_open(struct inode *inode, struct file *flip);
+static int empeg_ramtest_release(struct inode *inode, struct file *flip);
+static int empeg_ramtest_ioctl(struct inode *inode, struct file *filp,
+			       unsigned int cmd, unsigned long arg);
+static int empeg_ramtest_test_page(unsigned long safe_page,
+				   unsigned long test_page);
+static void empeg_ramtest_fault(unsigned long page, int half, int code);
+
+static struct file_operations empeg_ramtest_fops = {
+	NULL, /* lseek */
+	NULL,
+	NULL,
+	NULL, /* readdir */
+	NULL,
+	empeg_ramtest_ioctl,
+	NULL, /* mmap */
+	empeg_ramtest_open,
+	NULL, /* flush */
+	empeg_ramtest_release,
+};
+
+static unsigned long critical_start, critical_end;
+
+int __init empeg_ramtest_init(void)
+{
+	int err;
+
+	critical_start = (unsigned long) empeg_ramtest_critical_start;
+	critical_end = (unsigned long) empeg_ramtest_critical_end;
+
+	critical_start &= ~(PAGE_SIZE - 1);
+	critical_end += PAGE_SIZE - 1;
+	critical_end &= ~(PAGE_SIZE - 1);
+
+	critical_start = virt_to_phys(critical_start);
+	critical_end = virt_to_phys(critical_end);
+
+	if((err = register_chrdev(RAMTEST_MAJOR,
+				  RAMTEST_NAME,
+				  &empeg_ramtest_fops)) != 0) {
+		printk(RAMTEST_NAME ": unable to register major device %d\n",
+		       RAMTEST_MAJOR);
+		return err;
+	}
+
+	printk(RAMTEST_NAME ": initialised, critical at %08lx-%08lx\n",
+	       critical_start, critical_end);
+
+	return 0;
+}
+
+static int empeg_ramtest_open(struct inode *inode, struct file *filp)
+{
+	struct empeg_ramtest_dev *dev = &ramtest_device;
+
+	if(dev->use_count > 0) return -EBUSY;
+
+	dev->safe_page = get_free_page(GFP_KERNEL);
+	if(!dev->safe_page)
+		return -ENOMEM;
+
+	dev->use_count++;
+
+	/* Ho-kay */
+	return 0;
+}
+
+static int empeg_ramtest_release(struct inode *inode, struct file *filp)
+{
+	struct empeg_ramtest_dev *dev = &ramtest_device;
+
+	free_page(dev->safe_page);
+	dev->use_count--;
+
+	/* Yippee */
+	return 0;
+}
+
+static int empeg_ramtest_ioctl(struct inode *inode, struct file *filp,
+			       unsigned int cmd, unsigned long arg)
+{
+	int err;
+	struct empeg_ramtest_dev *dev = &ramtest_device;
+	unsigned long mem_size;
+
+	switch(cmd) {
+	case EMPEG_RAMTEST_TEST_PAGE: {
+		struct empeg_ramtest_args_t args;
+		
+		if((err =
+		    verify_area(VERIFY_WRITE, (void *) arg,
+				sizeof(struct empeg_ramtest_args_t))) != 0)
+			return -EFAULT;
+		   
+		/* Get page requested */
+		copy_from_user(&args, (void *) arg,
+			       sizeof(struct empeg_ramtest_args_t));
+
+		if(empeg_hardwarerevision() < 6)
+		    mem_size = 8 * 1024 * 1024;
+		else if(empeg_hardwarerevision() < 9)
+		    mem_size = 12 * 1024 * 1024;
+		else
+		    mem_size = 16 * 1024 * 1024;
+
+		if((args.addr & (PAGE_SIZE - 1)) ||
+		   (args.addr >= mem_size))
+			return -EINVAL;
+
+		/* Test it */
+		err = empeg_ramtest_test_page(dev->safe_page, args.addr);
+		args.ret = (unsigned) err;
+
+		copy_to_user((void *) arg, &args,
+			     sizeof(struct empeg_ramtest_args_t));
+
+		/* success, or error not caused by RAM */
+		if(err <= 0)
+			return err;
+
+		/* RAM fault
+		 * args.addr points to faulty page
+		 * args.len updated
+		 * args.ret contains error number
+		 */
+		return -EIO;
+	}
+
+	default:
+#if RAMTEST_DEBUG
+		printk("ramtest: bad command: %d\n", cmd);
+#endif
+		return -EINVAL;
+	}
+}
+
+static int empeg_ramtest_test_page(unsigned long safe_page,
+				   unsigned long test_page)
+{
+	struct empeg_ramtest_dev *dev = &ramtest_device;
+	int ret = 0, half;
+	unsigned long display_start, display_end;
+
+	safe_page = virt_to_phys(safe_page);
+	test_page += 0xc0000000;
+	test_page = virt_to_phys(test_page);
+
+	display_start = (unsigned long) DBAR1;
+	display_start &= ~(PAGE_SIZE - 1);
+	display_end = display_start + 3 * PAGE_SIZE;
+
+	/* Just fake an OK for display memory */
+	if((test_page >= display_start &&
+	    test_page < display_end) ||
+	   (test_page >= critical_start &&
+	    test_page < critical_end))
+		return 0;
+
+#if RAMTEST_DEBUG
+	printk("Testing safe_page\n");
+#endif
+	for(half = 0; half < 2; half++) {
+#if RAMTEST_DEBUG
+		printk("Testing safe_page, half %d\n", half);
+#endif
+		ret = empeg_ramtest_destructive(safe_page, half);
+
+		if(ret != 0) {
+#if RAMTEST_DEBUG
+			printk("safe_page page failed\n");
+#endif
+			empeg_ramtest_fault(safe_page, half, ret);
+			return (ret << 1) | half;
+		}
+	}
+#if RAMTEST_DEBUG
+	printk("Ok\n");
+#endif
+
+	for(half = 0; half < 2; half++) {
+		ret = empeg_ramtest_preserve(safe_page, test_page, half);
+
+		if(ret != 0) {
+			empeg_ramtest_fault(test_page, half, ret);
+			return (ret << 1) | half;
+		}
+	}
+
+#if RAMTEST_DEBUG
+	printk("Done\n");
+#endif
+
+	return 0;
+}
+
+static void empeg_ramtest_fault(unsigned long page, int half, int code)
+{
+	static const char *codes[] = {
+		"Success",	/* hmm... */
+		"Zero pattern failed",
+		"All 1's failed",
+		"0x55 bit pattern failed",
+		"0xaa bit pattern failed",
+		"0x5555/0xaaaa bit pattern failed",
+		"0xaaaa/0x5555 bit pattern failed",
+		"Rom copy test failed"
+	};
+	static const int ics[] = {
+		1, 2, 3, 4, 19, 32
+	};
+	int chip;
+	unsigned long max_page;
+
+	if(empeg_hardwarerevision() < 6)
+		max_page = 0xd0000000;
+	else
+		max_page = 0xd8000000;
+
+	if(page < 0xc0000000 || page >= max_page ||
+	   (page & 0x07c00000) != 0) {
+		printk("Not a RAM address: %08lx (half %d code %d)\n",
+		       page, half, code);
+		return;
+	}
+
+	page -= 0xc0000000;
+	chip = (page >> 27) * 2 + half;
+	if(chip < 0 || chip > 5) {
+		printk("Wrong ic somehow, address: %08lx (half %d code %d)\n",
+		       page, half, code);
+	}
+
+	if(code < 0 || code > 7) {
+		printk("RAM fault: ic %d, bad code %d\n",
+		       ics[chip], code);
+	}
+	else {
+		printk("RAM fault: ic %d: %s\n",
+		       ics[chip], codes[code]);
+	}
+}
Index: empeg/kernel/arch/arm/special/empeg_ramtest_asm.S
diff -u /dev/null empeg/kernel/arch/arm/special/empeg_ramtest_asm.S:1.11
--- /dev/null	Wed Oct 17 16:36:04 2001
+++ empeg/kernel/arch/arm/special/empeg_ramtest_asm.S	Thu Sep 28 18:45:06 2000
@@ -0,0 +1,465 @@
+	.globl	empeg_ramtest_critical_start
+	.globl	empeg_ramtest_critical_end
+	.globl	empeg_ramtest_preserve
+	.globl	empeg_ramtest_destructive
+
+#define PAGESIZE		4096
+#define FLASHBASE		0x00000000
+
+#define FLUSH_BASE		0xdf000000
+#define FLUSH_BASE_MINICACHE	0xdf800000
+#define MAIN_DCACHE_SIZE	16384
+#define FLUSH_OFFSET		32768
+
+#define UTDR			0x14
+#define UTSR1			0x20
+	
+	.text
+
+empeg_ramtest_critical_start:
+	/* Don't wipe me */
+
+Lclean_switch:
+	.long	0
+
+regs_save_preserve:
+	.long	0	@ r4
+	.long	0	@ r5
+	.long	0	@ r6
+	.long	0	@ r7
+	.long	0	@ r8
+	.long	0	@ r9
+	.long	0	@ r10
+	.long	0	@ r11
+	.long	0	@ r12
+	.long	0	@ lr
+
+regs_save_destructive:
+	.long	0	@ r4
+	.long	0	@ r5
+	.long	0	@ r6
+	.long	0	@ r7
+	.long	0	@ r8
+	.long	0	@ r9
+	.long	0	@ r10
+	.long	0	@ r11
+	.long	0	@ r12
+	.long	0	@ lr
+
+regs_save_wrapper:	
+	.long	0	@ r4
+	.long	0	@ r5
+	.long	0	@ r6
+	.long	0	@ lr
+	
+irqstate_save:
+	.long	0
+
+tablebase_save:	
+	.long	0
+	
+domain_save:	
+	.long	0
+
+	
+	/* on entry, r0 = test_page
+		     r1 = 0 for low 16 bits
+			  1 for high 16 bits
+	   on exit,  r0 = failure code */
+empeg_ramtest_destructive:
+	adr	r3, regs_save_wrapper
+	stmia	r3, {r4-r5, lr}
+
+	mov	r4, r0
+	mov	r5, r1
+	bl	empeg_ramtest_mmu_off
+	mov	r0, r4
+	mov	r1, r5
+	bl	empeg_ramtest_destructive_no_mmu
+	mov	r4, r0
+	bl	empeg_ramtest_mmu_on
+	mov	r0, r4
+
+	adr	r3, regs_save_wrapper
+	ldmia	r3, {r4-r5, pc}
+
+	
+	/* on entry, r0 = safe_page (assumed)
+		     r1 = test_page
+		     r2 = 0 for low 16 bits
+			  1 for high 16 bits
+	   on exit,  r0 = failure code */
+empeg_ramtest_preserve:
+	adr	r3, regs_save_wrapper
+	stmia	r3, {r4-r6, lr}
+	
+	mov	r4, r0
+	mov	r5, r1
+	mov	r6, r2
+	bl	empeg_ramtest_mmu_off
+	
+	mov	r0, r4
+	mov	r1, r5
+	mov	r2, r6
+	bl	empeg_ramtest_preserve_no_mmu
+	mov	r4, r0
+
+	bl	empeg_ramtest_mmu_on
+	mov	r0, r4
+
+	adr	r3, regs_save_wrapper
+	ldmia	r3, {r4-r6, pc}
+
+		
+empeg_ramtest_mmu_off:
+	@ Turn FIQ/IRQ off
+	mrs	r0, cpsr
+	and	r1, r0, #192
+	str	r1, irqstate_save
+	orr	r0, r0, #192
+	msr	cpsr, r0
+
+	@ Save domain and table base
+	mrc	p15, 0, r1, c2, c0, 0	@ Get table base
+	bic	r1,r1,#0x00003f00
+	bic	r1,r1,#0x000000ff
+	str	r1,tablebase_save
+	mrc	p15, 0, r1, c3, c0, 0	@ Get domain register
+	str	r1,domain_save
+
+	@ main dcache
+	mov	r2, #FLUSH_BASE
+	add	r1, r2, #MAIN_DCACHE_SIZE
+1:	ldr	r3, [r2], #32
+	teq	r1, r2
+	bne	1b
+
+	@ mini dcache
+	add	r2, r2, #(FLUSH_BASE_MINICACHE - FLUSH_BASE)
+	add	r1, r2, #512	@ 512 bytes minicache
+1:	ldr	r3, [r2], #32
+	teq	r1, r2
+	bne	1b
+
+	mov	r1, #0
+	mcr	p15, 0, r1, c7, c10, 4	@ drain WB
+	mcr	p15, 0, r1, c7, c7, 0	@ flush I & D
+	mcr	p15, 0, r1, c8, c7, 0   @ flush I & D tlbs
+	
+	mrc	p15, 0, r1, c1, c0, 0	@ Get control register
+	bic	r1,r1,#0x000d		@ Turn off D-cache & MMU
+	mcr	p15, 0, r1, c1, c0, 0
+	mov	r0,r0
+	mov	r0,r0
+	mov	r0,r0	
+	mov	pc,lr
+
+	
+empeg_ramtest_mmu_on:
+	@ Load domain and table base
+	ldr	r1,tablebase_save
+	mcr	p15, 0, r1, c2, c0, 0	@ Get table base
+	ldr	r1,domain_save
+	mcr	p15, 0, r1, c3, c0, 0	@ Get domain register
+
+	mov	r1, #0
+	mcr	p15, 0, r1, c7, c7, 0	@ flush I & D caches
+	mcr	p15, 0, r1, c7, c10, 4	@ drain WB
+	mcr	p15, 0, r1, c8, c7, 0	@ flush I & D TLBs
+	
+	mrc	p15, 0, r1, c1, c0, 0	@ Get control register
+	orr	r1, r1, #0x000d
+	mcr	p15, 0, r1, c1, c0, 0	@ Turn on D-cache & MMU
+	mov	r0, r0
+	mov	r0, r0
+	
+	@ Turn FIQ/IRQ on again
+	mrs	r0, cpsr
+	bic	r0, r0, #192
+	ldr	r1, irqstate_save
+	orr	r0, r0, r1
+	msr	cpsr, r0
+		
+	mov	pc,lr		
+
+	@ corrupts r1
+empeg_ramtest_putchar:
+1:	mov	r1, #0x80000000
+	orr	r1, r1, #0x50000
+	ldrb	r1, [r1, #UTSR1]
+	tst	r1, #4
+	beq	1b
+	mov	r1, #0x80000000
+	orr	r1, r1, #0x50000
+	strb	r0, [r1, #UTDR]
+	mov	pc, lr
+	
+	/* failure codes:
+		0 - success
+		1 - zero test failed
+		2 - all 1's test failed
+		3 - 0x55 bit pattern failed
+		4 - 0xaa bit pattern failed
+		5 - 0x5555/0xaaaa bit pattern failed
+		6 - 0xaaaa/0x5555 bit pattern failed
+		7 - romcopy test failed
+	*/
+	
+	/* on entry, r0 = safe_page (assumed)
+		     r1 = test_page
+		     r2 = 0 for low 16 bits
+			  1 for high 16 bits
+	   on exit,  r0 = failure code */
+
+
+empeg_ramtest_preserve_no_mmu:
+	adr	r3, regs_save_preserve
+	stmia	r3, {r4-r12, lr}
+
+	mov	r11, r0			@ safe_page
+	mov	r12, r1			@ test_page
+	mov	r10, r2			@ half
+
+	/* loop through blat_page array */
+	mov	r7, #PAGESIZE
+1:	
+	/* copy test_page to safe_page */
+	mov	r3, r11
+	mov	r4, r12
+	mov	r5, #PAGESIZE
+2:	ldr	r6, [r4], #4
+	str	r6, [r3], #4
+	subs	r5, r5, #4
+	bne	2b
+
+	mov	r0, r12
+	mov	r1, r10
+	bl	empeg_ramtest_destructive_no_mmu
+	/* r0 is error code */
+
+	/* copy r11 (safe_page) to r12 (test_page), 4096 bytes */
+	mov	r3, r11
+	mov	r4, r12
+	mov	r5, #PAGESIZE
+3:	ldr	r6, [r3], #4
+	str	r6, [r4], #4
+	subs	r5, r5, #4
+	bne	3b
+
+	/* r0 still contains error code */
+	adr	r3, regs_save_preserve
+	ldmia	r3, {r4-r12, pc}
+	
+	
+	/* on entry, r0 = test_page
+		     r1 = 0 for low 16 bits
+			  1 for high 16 bits
+	   on exit,  r0 = failure code */
+
+empeg_ramtest_destructive_no_mmu:
+	@ can't use stack, hmm...
+	adr	r3, regs_save_destructive
+	stmia	r3, {r4-r12, lr}
+
+	mov	r10, r0			@ r10 = address of test_page
+	tst	r1, #1
+	moveq	r11, #0x000000ff
+	movne	r11, #0x00ff0000
+	orr	r11, r11, r11, lsl#8	@ make bank mask
+
+	@ First, zero test
+	mov	r0, #0
+	bl	testram_fill
+	mov	r0, #0
+	bl	testram_check
+	cmp	r0, #0
+	movne	r0, #1
+	bne	1f
+
+	@ Now 0xff test
+	mvn	r0, #0
+	bl	testram_fill
+	mvn	r0, #0
+	bl	testram_check
+	cmp	r0, #0
+	movne	r0, #2
+	bne	1f
+	
+	@ 0x55 alternate bit pattern
+	ldr	r0,test_55
+	bl	testram_fill
+	ldr	r0,test_55
+	bl	testram_check
+	cmp	r0, #0
+	movne	r0, #3
+	bne	1f
+
+	@ 0xaa alternate bit pattern
+	ldr	r0,test_aa
+	bl	testram_fill
+	ldr	r0,test_aa
+	bl	testram_check
+	cmp	r0, #0
+	movne	r0, #4
+	bne	1f
+
+	@ 0x5555/0xaaaa alternate words
+	ldr	r0,test_55
+	ldr	r1,test_aa
+	bl	testram_fillalt
+	ldr	r0,test_55
+	ldr	r1,test_aa
+	bl	testram_checkalt
+	cmp	r0, #0
+	movne	r0, #5
+	bne	1f
+
+	@ 0xaaaa/0x5555 alternate words
+	ldr	r0,test_aa
+	ldr	r1,test_55
+	bl	testram_fillalt
+	ldr	r0,test_aa
+	ldr	r1,test_55
+	bl	testram_checkalt
+	cmp	r0, #0
+	movne	r0, #6
+	bne	1f
+
+	@ romcopy test
+	bl	testram_fillrom
+	bl	testram_checkrom
+	cmp	r0, #0
+	movne	r0, #7
+	bne	1f
+
+	@mov	r0, r10
+	@bl	sendhex32
+	@mov	r0, #'\r'
+	@bl	empeg_ramtest_putchar
+	@mov	r0, #'\n'
+	@bl	empeg_ramtest_putchar
+	
+	@ Pass
+	mov	r0, #0
+1:	/* failure jumps here with r0 set */
+
+	adr	r3, regs_save_destructive
+	ldmia	r3, {r4-r12, pc}
+	
+test_55:
+	.word	0x55555555
+test_aa:
+	.word	0xaaaaaaaa
+
+	
+testram_fill:
+	mov	r4,r0
+	mov	r5,r0
+	mov	r6,r0
+	mov	r7,r0
+	mov	r8,r10
+	mov	r9,#PAGESIZE
+1:	stmia	r8!,{r4-r7}
+	subs	r9,r9,#16
+	bne	1b
+	mov	pc,lr
+
+testram_check:
+	and	r5,r0,r11
+	mov	r0,#0
+	mov	r8,r10
+	mov	r9,#PAGESIZE
+1:	ldr	r4,[r8],#4
+	and	r4,r4,r11
+	teq	r4,r5
+	movne	r0,#1
+	subs	r9,r9,#4
+	bne	1b
+	mov	pc,lr
+
+testram_fillalt:
+	mov	r4,r0
+	mov	r5,r1
+	mov	r6,r0
+	mov	r7,r1
+	mov	r8,r10
+	mov	r9,#PAGESIZE
+1:	stmia	r8!,{r4-r7}
+	subs	r9,r9,#16
+	bne	1b
+	mov	pc,lr
+
+testram_checkalt:
+	and	r5,r0,r11
+	mov	r0,#0
+	and	r6,r1,r11	
+	mov	r8,r10
+	mov	r9,#PAGESIZE
+1:	ldr	r4,[r8],#4
+	and	r4,r4,r11
+	teq	r4,r5
+	movne	r0,#1
+	ldr	r4,[r8],#4
+	and	r4,r4,r11
+	teq	r4,r6
+	movne	r0,#1
+	subs	r9,r9,#8
+	bne	1b
+	mov	pc,lr
+
+testram_fillrom:
+	mov	r8,r10
+	mov	r9,#PAGESIZE
+	mov	r6,#FLASHBASE
+1:	ldr	r0,[r6],#4
+	str	r0,[r8],#4
+	subs	r9,r9,#4
+	bne	1b
+	mov	pc,lr
+
+testram_checkrom:
+	mov	r2,#0
+	mov	r8,r10
+	mov	r9,#PAGESIZE
+	mov	r6,#FLASHBASE
+1:	ldr	r0,[r6],#4
+	and	r0,r0,r11
+	ldr	r1,[r8],#4
+	and	r1,r1,r11
+	teq	r0,r1
+	movne	r2,#1
+	subs	r9,r9,#4
+	bne	1b
+	mov	r0,r2
+	mov	pc,lr
+
+	
+sendhex32:
+        mov     r3, #8
+sendhexg:       
+	mov	r2, #0x80000000
+	orr	r2, r2, #0x50000
+1:      ldrb    r1, [r2, #UTSR1]
+        tst     r1, #4
+        beq     1b
+        and     r1, r0, #0xf0000000
+        adr     r2, hextable
+        ldrb    r1, [r2, r1, lsr#28]
+	mov	r2, #0x80000000
+	orr	r2, r2, #0x50000
+        strb    r1, [r2, #UTDR]
+        mov     r0, r0, lsl#4
+        subs    r3, r3, #1
+        bne     1b
+        mov     pc, lr
+
+hextable:
+        .ascii  "0123456789abcdef"
+        .align  0
+
+
+empeg_ramtest_critical_end:
+	/* You can wipe this lot though */
+
+
+
Index: empeg/kernel/arch/arm/special/empeg_rds.c
diff -u empeg/kernel/arch/arm/special/empeg_rds.c:1.14 empeg/kernel/arch/arm/special/empeg_rds.c:1.16
--- empeg/kernel/arch/arm/special/empeg_rds.c:1.14	Thu Apr 20 17:03:53 2000
+++ empeg/kernel/arch/arm/special/empeg_rds.c	Thu Aug 23 16:27:50 2001
@@ -53,6 +53,9 @@
 #include <linux/proc_fs.h>
 #include <linux/poll.h>
 
+/* For the userspace interface */
+#include <asm/arch/empeg.h>
+
 #include "empeg_rds.h"
 
 /* Only one RDS channel */
@@ -61,7 +64,7 @@
 /* Logging for proc */
 static char log[1024];
 static int log_size=0;
-#define LOG(x) { if (log_size<sizeof(log)) log[log_size++]=(x); }
+#define LOG(x) { if (log_size<1023) log[log_size++]=(x); }
 #define LOGS(x) { char *p=(x); while(*p) { LOG(*p); p++; } }
 
 static struct file_operations rds_fops = {
@@ -388,7 +391,7 @@
 	return result;
 }
 
-static __inline__ void rds_processbit(struct rds_dev *dev, int rdsbit)
+static __inline__ void rds_processbit_cooked(struct rds_dev *dev, int rdsbit)
 {
 	static char tmp[256];
 	unsigned int rdsdata,rdscrc,b,correct,correct2;
@@ -545,6 +548,26 @@
 	LOGS(tmp);
 }
 
+static __inline__ void rds_processbit_raw(struct rds_dev *dev, int rdsbit)
+{
+	dev->buffer[dev->bitsinfifo >> 3] |= rdsbit << (dev->bitsinfifo & 7);
+
+	if(++dev->bitsinfifo < 64) return;
+	dev->bitsinfifo = 0;
+	rds_processpacket(dev);
+	memset(dev->buffer, 0, sizeof(dev->buffer));
+}
+
+static __inline__ void rds_processbit(struct rds_dev *dev, int rdsbit)
+{
+	if(!dev->in_use) return;
+
+	if(dev->interface == EMPEG_RDS_INTERFACE_COOKED)
+		rds_processbit_cooked(dev, rdsbit);
+	else if(dev->interface == EMPEG_RDS_INTERFACE_RAW)
+		rds_processbit_raw(dev, rdsbit);
+}
+
 void rds_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
 	struct rds_dev *dev=rds_devices;
@@ -559,6 +582,7 @@
 	len = 0;
 
 	LOG(0);
+	log[1023] = 0;
 	len+=sprintf(buf+len,"Log: %s\n",log);
 	log_size=0;
 	
@@ -602,19 +626,20 @@
 	result=request_irq(3,rds_interrupt,0,"empeg_rdsirq",dev);
 
 	/* Got it ok? */
-	if (result==0) {
-		/* Initialise state machine */
-		dev->state=0;
-		dev->bitsinfifo=0;
-
-		/* Dad's home! */
-		printk("empeg RDS driver initialised\n");
-	}
-	else {
+	if (result!=0) {
 		printk(KERN_ERR "Can't get empeg RDSIRQ IRQ 3.\n");
 		return;
 	}
 
+	/* Initialise state machine */
+	dev->interface = EMPEG_RDS_INTERFACE_COOKED;
+	dev->state=0;
+	dev->bitsinfifo=0;
+	dev->in_use=0;
+
+	/* Dad's home! */
+	printk("empeg RDS driver initialised\n");
+
 	/* Get the device */
 	result=register_chrdev(EMPEG_RDS_MAJOR,"empeg_rds",&rds_fops);
 	if (result<0) {
@@ -639,12 +664,16 @@
 	dev->recovered_packets=0;
 	dev->bad_packets=0;
 	dev->sync_lost_packets = 0;
+	dev->in_use++;
 
 	return 0;
 }
 
 static int rds_release(struct inode *inode, struct file *flip)
 {
+	struct rds_dev *dev=rds_devices;
+	dev->in_use--;
+	
 	MOD_DEC_USE_COUNT;
 	return 0;
 }
@@ -711,27 +740,34 @@
 
 static int rds_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)
 {
-#if 0
 	struct rds_dev *dev = filp->private_data;
-	if (_IOC_TYPE(cmd) != IR_IOC_MAGIC)
+	if (_IOC_TYPE(cmd) != EMPEG_RDS_MAGIC)
 		return -EINVAL;
 	
 	switch(cmd) {
-	case IR_IOCSTYPE:
-		/* arg is the type we want */
-		if (arg >= IR_TYPE_COUNT)
-			return -EINVAL;
-		dev->ir_type = arg;
-		break;
-	case IR_IOCTTYPE:
-		/* arg is the location to put the type in */
-		((int *)arg) = dev->ir_type;
-		break;
+	case EMPEG_RDS_GET_INTERFACE:
+		copy_to_user_ret((void *) arg, &dev->interface, sizeof(int),
+				 -EFAULT);
+		return 0;
+
+	case EMPEG_RDS_SET_INTERFACE:
+		{
+			int val;
+			copy_from_user_ret(&val, (void *) arg, sizeof(int),
+					   -EFAULT);
+			if(val != EMPEG_RDS_INTERFACE_COOKED &&
+			   val != EMPEG_RDS_INTERFACE_RAW)
+				return -EINVAL;
+
+			dev->interface = val;
+			dev->state = 0;
+			dev->bitsinfifo = 0;
+		}
+		return 0;
+
 	default:
 		return -EINVAL;
 	}
-#endif
-	return 0;
 }
 
 #ifdef ALICE_IN_USERLAND
Index: empeg/kernel/arch/arm/special/empeg_rds.h
diff -u empeg/kernel/arch/arm/special/empeg_rds.h:1.3 empeg/kernel/arch/arm/special/empeg_rds.h:1.4
--- empeg/kernel/arch/arm/special/empeg_rds.h:1.3	Wed Aug 18 16:59:33 1999
+++ empeg/kernel/arch/arm/special/empeg_rds.h	Mon Sep 11 18:03:11 2000
@@ -19,6 +19,7 @@
 	struct wait_queue *rx_wq;
 
 	/* RDS decoder state information */
+	int interface;
 	int state;
 	unsigned int rdsstream;
         int bitsinfifo;
@@ -30,6 +31,7 @@
 	int recovered_packets;
 	int bad_packets;
 	int sync_lost_packets;
+	int in_use;
 };
 
 /* Buffer size */
Index: empeg/kernel/arch/arm/special/empeg_state.c
diff -u empeg/kernel/arch/arm/special/empeg_state.c:1.23.4.2 empeg/kernel/arch/arm/special/empeg_state.c:1.28
--- empeg/kernel/arch/arm/special/empeg_state.c:1.23.4.2	Tue May 29 10:54:50 2001
+++ empeg/kernel/arch/arm/special/empeg_state.c	Fri Jul  6 16:27:17 2001
@@ -50,6 +50,7 @@
  *                real time clocks (see include/asm/arch/time.h)
  * 2000/05/20 HBF Support for C3 flash (unlock block before write/erase,
  *                lock afterwards)
+ * 2001/01/22 JHR Added reboot notifier for soft reboot.
  */
 
 #include <linux/config.h>
@@ -73,6 +74,8 @@
 #include <asm/arch/empeg.h>
 #include <asm/uaccess.h>
 #include <linux/proc_fs.h>
+#include <linux/reboot.h>
+#include <linux/notifier.h>
 
 #define DEBUG 0
 
@@ -407,6 +410,18 @@
 		/* Power is failing, quickly do things... */
 		struct state_dev *dev = state_devices;
 
+		/* Mute audio */
+		GPCR=EMPEG_DSPPOM;
+
+		/* Store state if it's changed, or if we've been
+                   powered on for 30+ seconds */
+		if (dirty || ((unsigned int)xtime.tv_sec-unixtime)>=30) state_store();
+
+		/* NOTE! This used to be BEFORE the dirty save, but on the
+		   issue9 and later players, turning the display off involves
+		   sending a command serially to the power PIC, which can take
+		   time. Doing it here is probably ok */
+
 #if CONFIG_EMPEG_DISPLAY
 		/* Turn display off: this will buy us a little time
 		   due to decreased power drain. We also disable the
@@ -415,10 +430,6 @@
 		display_powerfail_action();
 #endif
 		
-		/* Store state if it's changed, or if we've been
-                   powered on for 30+ seconds */
-		if (dirty || ((unsigned int)xtime.tv_sec-unixtime)>=30) state_store();
-		
 		/* Something so we can see how close the actual
                    powerfail *is*! */
 #if DEBUG
@@ -465,6 +476,10 @@
 	/* Re-enable powerfail processing */
 	display_powerreturn_action();
 #endif
+
+	/* Reenable DACs */
+	GPSR=EMPEG_DSPPOM;
+
 	if (timer_pending(&dev->powerfail_timer))
 		del_timer(&dev->powerfail_timer);
 	
@@ -647,7 +662,7 @@
 	return len;
 }
 
-struct proc_dir_entry state_proc_entry = {
+static struct proc_dir_entry state_proc_entry = {
 	0,			/* inode (dynamic) */
 	11, "empeg_state",  	/* length and name */
 	S_IFREG | S_IRUGO, 	/* mode */
@@ -657,6 +672,16 @@
 	&state_read_procmem, 	/* function used to read data */
 };
 
+static int empeg_state_reboot_notifier(struct notifier_block *block,
+				       unsigned long event,
+				       void *buffer);
+
+static struct notifier_block empeg_state_notifier_block = {
+	empeg_state_reboot_notifier,
+	NULL,
+	0
+};
+
 void __init empeg_state_init(void)
 {
 	struct state_dev *dev = state_devices;
@@ -691,9 +716,6 @@
 
 #if DEBUG
  	printk("Powerfail is now %s (%d)\n", (powerfail_disable_count == 0) ? "enabled" : "disabled", powerfail_disable_count);
-#endif
- 	
-#if DEBUG
 	printk("Powerfail line current level is %d\n", GPLR & EMPEG_POWERFAIL);
 #endif
 	result = request_irq(EMPEG_IRQ_POWERFAIL, powerfail_interrupt, SA_INTERRUPT,
@@ -720,18 +742,23 @@
 	printk("empeg state support initialised %04x/%04x (save to %p).\n",
 	       flash_manufacturer,flash_product,savebase);
 
- 	/* Enable powerfail interrupts if the voltage level isn't already too low */
- 	if (GPLR & EMPEG_POWERFAIL) {
- 		/* Pretend we've just received a powerfail interrupt */
- 		powerfail_disable_count = 1;
- 		dev->powerfail_timer.expires = jiffies + POWERFAIL_TIMEOUT * HZ;
- 		dev->powerfail_timer.function = powerfail_disabled_timeout;
- 		add_timer(&dev->powerfail_timer);		
- 	} else
- 		powerfail_disable_count = 0;
+	/* Enable powerfail interrupts if the voltage level isn't already too low */
+	if (GPLR & EMPEG_POWERFAIL) {
+		/* Pretend we've just received a powerfail interrupt */
+		powerfail_disable_count = 1;
+		dev->powerfail_timer.expires = jiffies + POWERFAIL_TIMEOUT * HZ;
+		dev->powerfail_timer.function = powerfail_disabled_timeout;
+		add_timer(&dev->powerfail_timer);		
+	} else
+		powerfail_disable_count = 0;
+#if DEBUG
+	printk("Powerfail is now %s (%d)\n", (powerfail_disable_count == 0) ? "enabled" : "disabled", powerfail_disable_count);
+#endif
+	
+	/* We want interrupts on rising only */
+	GRER|=EMPEG_POWERFAIL;
 
-  	/* We want interrupts on rising only */
-  	GRER|=EMPEG_POWERFAIL;
+	register_reboot_notifier(&empeg_state_notifier_block);
 }
 
 static inline void empeg_state_cleanup(void)
@@ -739,6 +766,9 @@
 	int result;
 	struct state_dev *dev = state_devices;
 
+	unregister_reboot_notifier(&empeg_state_notifier_block);
+	state_cleanse();
+	
 	free_irq(EMPEG_IRQ_POWERFAIL, dev);
 
 	/* No longer require interrupts */
@@ -746,7 +776,16 @@
 	result = unregister_chrdev(EMPEG_STATE_MAJOR, "empeg_state");
 	if (result < 0)
 		printk(KERN_WARNING "empeg state: Unable to unregister device.\n");
+
 	printk("empeg state cleanup complete.\n");
+}
+
+static int empeg_state_reboot_notifier(struct notifier_block *block,
+				       unsigned long event,
+				       void *buffer)
+{
+	state_cleanse();
+	return NOTIFY_OK;
 }
 
 #ifdef MODULE
Index: empeg/kernel/arch/arm/special/empeg_usb.c
diff -u empeg/kernel/arch/arm/special/empeg_usb.c:1.18.8.2 empeg/kernel/arch/arm/special/empeg_usb.c:1.25
--- empeg/kernel/arch/arm/special/empeg_usb.c:1.18.8.2	Mon Oct 30 19:20:22 2000
+++ empeg/kernel/arch/arm/special/empeg_usb.c	Fri Dec 22 18:42:41 2000
@@ -1,5 +1,7 @@
 #undef DEBUG_USB
-#define DEBUG_USB_6 /* Stall debug */
+#undef DEBUG_USB_1
+#undef DEBUG_USB_2
+#undef DEBUG_USB_6 /* Stall debug */
 #define NO_ZERO_TERM
 
 #ifdef CONFIG_EMPEG_USBD12
@@ -71,6 +73,8 @@
  * direction) we get an IRQ asking us for more data - we can then do a bulk
  * transfer to fill/empty the fifo in a hurry and let it get on with life.
  *
+ * 20000812 hugo@empeg.com - Better NAK handling on data EP's
+ *
  */
 
 /**********************************************************************/
@@ -158,21 +162,36 @@
 #endif
 
 /* Logging for proc */
-static char log[256];
-static int log_size=0;
+static char log[2048];
+static int log_head=0;
 
 static inline void LOG(char x)
 {
-	if (log_size < sizeof(log))
-		log[log_size++]=x;
+	log[log_head++]=x;
+	if (log_head==sizeof(log)) log_head=0;
 }
 
-static inline void LOGS(const char *x)
+static inline void LOGS(const char *x, ...)
 {
-	while (*x) {
-		LOG(*x);
-		x++;
+    	static char buffer[1024];
+	char *p = buffer;
+    	va_list va;
+	va_start(va, x);
+	
+	vsprintf(buffer, x, va);
+
+	while (*p) {
+		LOG(*p);
+		p++;
 	}
+
+	va_end(va);
+}
+
+static inline void RESETLOG(void)
+{
+	memset(log,0,sizeof(log));
+	log_head=0;
 }
 
 /* ...for the Natsemi code */
@@ -761,11 +780,13 @@
 	/* Get receiver status */    
 	struct usb_dev *dev=usb_devices;
 	int rxstat=read_usb(RXS0);
-#ifdef DEBUG_USB_2
+#ifdef DEBUG_USB_3
 	printk("  rx_0(RXS0=%02x)\n",rxstat);
 #endif
+	LOGS("  rx_0(RXS0=%02x)\n",rxstat);
+	
 	/* Bump stats */
-	dev->stats_rxok[0]++;
+	dev->stats_ok[0]++;
 
 	/* Is this a setup packet? */  
 	if(rxstat & SETUP_R) {
@@ -799,7 +820,7 @@
 				
 			case GET_DESCRIPTOR: 
 				getdescriptor();                   
-#ifdef DEBUG_USB_1
+#ifdef DEBUG_USB_3
 				printk("USB: Get_Descriptor(%x)\n",usb_buf[3]);
 #endif
 				break;
@@ -812,7 +833,7 @@
 				break;
 
 			case SET_ADDRESS:
-#ifdef DEBUG_USB_1
+#ifdef DEBUG_USB_3
 				printk("USB: Set_Address(%d)\n",usb_buf[2]);
 #endif
 				/* Set and enable new address for endpoint 0,
@@ -824,14 +845,14 @@
 				
 			case SET_CONFIGURATION:
 				setconfiguration(); 
-#ifdef DEBUG_USB_1
+#ifdef DEBUG_USB_3
 				printk("USB: Set_Configuration(%d)\n",usb_buf[2]);
 #endif
 				break;
 				
 			case SET_FEATURE: 
 				setfeature();  
-#ifdef DEBUG_USB_1
+#ifdef DEBUG_USB_3
 				printk("USB: Set_Feature\n");
 #endif
 				break;
@@ -887,9 +908,11 @@
 {
 	struct usb_dev *dev=usb_devices;
       	int txstat=read_usb(TXS0);
-#ifdef DEBUG_USB_2
+#ifdef DEBUG_USB_3
 	printk("  tx_0(%02x)\n",txstat);
 #endif
+	LOGS("  tx_0(%02x)\n",txstat);
+	
 	/* If a transmission has completed successfully, check to see if
 	   we have anything else that needs to go out, otherwise turn the 
 	   receiver back on */  
@@ -917,7 +940,7 @@
 
 				/* All done, reenable RX */
 				write_usb(RXC0,RX_EN);
-#ifdef DEBUG_USB_2
+#ifdef DEBUG_USB_3
 				printk("Wrote %d bytes out of endpoint 0\n",desc_idx);
 #endif
 			}
@@ -928,7 +951,7 @@
 		}
 
 		/* Bump stats */
-		dev->stats_txok[0]++;
+		dev->stats_ok[1]++;
 	} else {	
 		/* Otherwise something must have gone wrong with the previous
 		   transmission, or we got here somehow we shouldn't have */ 
@@ -937,7 +960,7 @@
 #endif
 
 		/* Bump stats */
-		dev->stats_txerr[0]++;
+		dev->stats_err[1]++;
 	}
   
 	/* We do this stuff for all tx_0 events */  
@@ -968,7 +991,7 @@
 		write_usb(usb_rxcontrol[fifo],FLUSH|WLEVEL);
 		
 		/* Bump stats */
-		dev->stats_rxerr[fifo+1]++;
+		dev->stats_err[2]++;
 	} else {
 		/* While there's stuff in the buffer... (it saturates at 15
 		   bytes, so we need to read, empty buffer, and read again
@@ -1011,7 +1034,7 @@
 		wake_up_interruptible(&dev->rx_wq);
 		
 		/* Bump stats */
-		dev->stats_rxok[fifo+1]++;
+		dev->stats_ok[2]++;
 	}
 }
 
@@ -1026,9 +1049,10 @@
 
 	/* Force load of buffer? */
 	if (force) txstat=ACK_STAT|TX_DONE;
-#ifdef DEBUG_USB_1
+#ifdef DEBUG_USB_3
 	printk("tx event stat=%x\n",txstat);
 #endif
+	LOGS("tx event stat=%x\n", txstat);
 	
 	/* If a transmission has completed successfully, update the data
 	   toggle and queue up a dummy packet */ 
@@ -1039,7 +1063,7 @@
 
 		/* Sucessfully sent some stuff: bump counts & reset buffer */
 		dev->tx_count+=usb_txsize;
-		dev->stats_txok[2]++;
+		dev->stats_ok[3]++;
 
 		/* If last packet was short, and there's nothing in the buffer to send,
 		   then just stop here with TX disabled */
@@ -1080,17 +1104,19 @@
 		/* Wake up anyone that's waiting on write when we've got a decent amount of free space */
 		if (dev->tx_free>(USB_TX_BUFFER_SIZE/4)) wake_up_interruptible(&dev->tx_wq);
 
-#ifdef DEBUG_USB_1
+#ifdef DEBUG_USB_3
 		printk("tx_d() queued %d byte packet with PID %d\n",
 		       usb_txsize,dtapid.TGL3PID);
 #endif
+		LOGS("Q(len=%d,pid=%d)\n", usb_txsize, dtapid.TGL3PID);
 	} else {
 		/* Didn't get an ACK? */
 		if (txstat & TX_DONE) {
-			dev->stats_txerr[2]++;
+			dev->stats_err[3]++;
 #ifdef DEBUG_USB
 			printk("tx_d() no ACK, requeueing with PID %d\n",dtapid.TGL3PID);
 #endif
+			LOGS("tx_d() no ACK, requeing with PID %d\n", dtapid.TGL3PID);
 			/* Empty buffer */
 			FLUSHTX3;
 
@@ -1105,7 +1131,8 @@
 			/* TX_DONE not set. Eh?! */
 #ifdef DEBUG_USB
 			printk("tx_d() tx_done not set\n");
-#endif		       
+#endif
+			LOGS("*TXDNS*");
 		}
 	}
 }
@@ -1137,7 +1164,7 @@
 	}
   
 	/* We do this stuff for all nak0 events */   
-	dev->stats_rxnak[0]++;
+	dev->stats_nak[0]++;
 }
 
 void usb_interrupt(int irq, void *dev_id, struct pt_regs *regs)
@@ -1155,7 +1182,7 @@
 
 		/* Check for overruns */
 		if (evnt2&RXOVRN2) {
-			dev->stats_rxoverrun[1]++;
+			dev->stats_overrun[2]++;
 			usb_rxoverruns++;
 			LOG('o');
 		}
@@ -1181,9 +1208,8 @@
 		evnt2=read_usb(NAKEV); 
 
 		if (evnt2&NAK_O0) nak_0();
-		if (evnt2&NAK_O2) dev->stats_rxnak[1]++;
-		if (evnt2&NAK_O3) dev->stats_rxnak[2]++;
-
+		if (evnt2&NAK_O2) dev->stats_nak[2]++;
+		if (evnt2&NAK_O3) dev->stats_nak[2]++;
 	} else if (evnt&ALT) {
 		LOG('A');
 
@@ -1214,44 +1240,39 @@
 static int usb_read_procmem(char *buf, char **start, off_t offset, int len, int unused)
 {
 	struct usb_dev *dev = usb_devices;
-	int a;
+	int a,b;
 	len = 0;
 
 	len+=sprintf(buf+len,"Control endpoint 0\n");
-	len+=sprintf(buf+len,"  %9d RX ok\n",dev->stats_rxok[0]);
-	len+=sprintf(buf+len,"  %9d RX error\n",dev->stats_rxerr[0]);
-	len+=sprintf(buf+len,"  %9d RX nak\n",dev->stats_rxnak[0]);
-	len+=sprintf(buf+len,"  %9d TX ok\n",dev->stats_txok[0]);
-	len+=sprintf(buf+len,"  %9d TX error\n\n",dev->stats_txerr[0]);
+	len+=sprintf(buf+len,"  %9d RX ok\n",dev->stats_ok[0]);
+	len+=sprintf(buf+len,"  %9d RX error\n",dev->stats_err[0]);
+	len+=sprintf(buf+len,"  %9d RX nak\n",dev->stats_nak[0]);
+	len+=sprintf(buf+len,"  %9d TX ok\n",dev->stats_ok[1]);
+	len+=sprintf(buf+len,"  %9d TX error\n\n",dev->stats_err[1]);
 	
 	len+=sprintf(buf+len,"Overall stats\n");
 	len+=sprintf(buf+len,"  %9d RX bytes\n",dev->rx_count);
 	len+=sprintf(buf+len,"  %9d TX bytes\n\n",dev->tx_count);
-
-	for(a=1;a<3;a++) {
-		len+=sprintf(buf+len,"Endpoint %d\n",a);
-		len+=sprintf(buf+len,"  %9d RX ok\n",dev->stats_rxok[a]);
-		len+=sprintf(buf+len,"  %9d RX error\n",dev->stats_rxerr[a]);
-		len+=sprintf(buf+len,"  %9d RX nak\n",dev->stats_rxnak[a]);
-		len+=sprintf(buf+len,"  %9d RX overruns\n",dev->stats_rxoverrun[a]);
-		len+=sprintf(buf+len,"  %9d TX ok\n",dev->stats_txok[a]);
-		len+=sprintf(buf+len,"  %9d TX error\n\n",dev->stats_txerr[a]);
-	}
-
-	{
-		unsigned long flags;
 
-		save_flags_cli(flags);
-		if (get_endpoint_stall(1))
-			len+=sprintf(buf+len, "Endpoint 1 stalled\n");
-		if (get_endpoint_stall(5))
-			len+=sprintf(buf+len, "Endpoint 5 stalled\n");
-		restore_flags(flags);
+	len+=sprintf(buf+len,"RX stats\n");
+	len+=sprintf(buf+len,"  %9d RX ok\n",dev->stats_ok[2]);
+	len+=sprintf(buf+len,"  %9d RX error\n",dev->stats_err[2]);
+	len+=sprintf(buf+len,"  %9d RX overruns\n",dev->stats_overrun[2]);
+	len+=sprintf(buf+len,"  %9d RX nak\n",dev->stats_nak[2]);
+
+	len+=sprintf(buf+len,"TX stats\n");
+	len+=sprintf(buf+len,"  %9d TX ok\n",dev->stats_ok[3]);
+	len+=sprintf(buf+len,"  %9d TX error\n\n",dev->stats_err[3]);
+	len+=sprintf(buf+len,"  %9d TX nak\n",dev->stats_nak[3]);
+
+	len+=sprintf(buf+len,"Log: ");
+	b=log_head;
+	for(a=0;a<sizeof(log);a++) {
+		if (++b==sizeof(log)) b=0;
+		if (log[b]) buf[len++]=log[b];
 	}
-		
-	LOG(0);
-	len+=sprintf(buf+len,"Log: %s",log);
-	log_size=0;
+	len+=sprintf(buf+len,"\n");	
+	RESETLOG();
 	
 	return len;
 }
@@ -1271,7 +1292,10 @@
 {
         struct usb_dev *dev=usb_devices;
 	int result; unsigned long flags;
-	
+
+	/* Reset the log */
+	RESETLOG();
+
 	/* Do chip setup */
 	init_usb();
 	
Index: empeg/kernel/arch/arm/special/empeg_usb.h
diff -u empeg/kernel/arch/arm/special/empeg_usb.h:1.5 empeg/kernel/arch/arm/special/empeg_usb.h:1.6
--- empeg/kernel/arch/arm/special/empeg_usb.h:1.5	Mon Apr  3 19:43:06 2000
+++ empeg/kernel/arch/arm/special/empeg_usb.h	Sat Aug 12 16:17:49 2000
@@ -26,8 +26,7 @@
 	struct wait_queue *tx_wq;
 	
 	/* Stats */
-	int stats_rxok[4],stats_rxerr[4],stats_rxnak[4],stats_rxwarn[4],stats_rxoverrun[4];
-	int stats_txok[4],stats_txerr[4];
+	int stats_ok[4],stats_err[4],stats_nak[4],stats_warn[4],stats_overrun[4];
 };
 
 /* Buffer sizes */
Index: empeg/kernel/arch/arm/special/nohd_img.h
diff -u /dev/null empeg/kernel/arch/arm/special/nohd_img.h:1.1
--- /dev/null	Wed Oct 17 16:36:04 2001
+++ empeg/kernel/arch/arm/special/nohd_img.h	Wed Oct 17 15:52:05 2001
@@ -0,0 +1,131 @@
+/* This file is autogenerated by the rules in kernel-logos/ - do not edit */
+static unsigned char nohd_img[] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x20, 0x03, 0x00, 0x00, 0x00, 0x00,
+    0x30, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00,
+    0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x02, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00,
+    0x30, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00,
+    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00,
+    0x30, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00,
+    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00,
+    0x30, 0x30, 0x00, 0x03, 0x00, 0x33, 0x03, 0x00, 0x00, 0x03, 0x33, 0x00, 0x30, 0x33, 0x00, 0x33,
+    0x00, 0x33, 0x33, 0x00, 0x00, 0x30, 0x33, 0x03, 0x03, 0x30, 0x03, 0x30, 0x00, 0x03, 0x00, 0x00,
+    0x33, 0x00, 0x33, 0x03, 0x30, 0x00, 0x30, 0x30, 0x30, 0x03, 0x00, 0x33, 0x33, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x01, 0x00, 0x00, 0x00,
+    0x30, 0x30, 0x00, 0x03, 0x30, 0x00, 0x30, 0x00, 0x00, 0x33, 0x00, 0x03, 0x00, 0x00, 0x03, 0x03,
+    0x30, 0x00, 0x30, 0x00, 0x00, 0x03, 0x00, 0x03, 0x03, 0x03, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00,
+    0x03, 0x30, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x03, 0x30, 0x30, 0x00, 0x30, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x01, 0x03, 0x00, 0x03, 0x30, 0x02, 0x00, 0x00, 0x00,
+    0x30, 0x00, 0x03, 0x03, 0x30, 0x00, 0x30, 0x00, 0x00, 0x03, 0x00, 0x03, 0x30, 0x33, 0x03, 0x03,
+    0x30, 0x00, 0x30, 0x00, 0x00, 0x03, 0x00, 0x03, 0x03, 0x30, 0x00, 0x30, 0x03, 0x00, 0x00, 0x00,
+    0x03, 0x30, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x00, 0x30, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x31, 0x30, 0x30, 0x30, 0x20, 0x03, 0x00, 0x00, 0x00,
+    0x30, 0x00, 0x30, 0x03, 0x30, 0x00, 0x30, 0x00, 0x00, 0x03, 0x00, 0x03, 0x03, 0x00, 0x03, 0x03,
+    0x30, 0x00, 0x30, 0x00, 0x00, 0x03, 0x00, 0x03, 0x03, 0x00, 0x03, 0x30, 0x30, 0x00, 0x00, 0x00,
+    0x03, 0x30, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x00, 0x30, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x11, 0x22, 0x12, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
+    0x30, 0x00, 0x30, 0x03, 0x30, 0x00, 0x30, 0x00, 0x00, 0x03, 0x00, 0x03, 0x03, 0x00, 0x03, 0x03,
+    0x30, 0x00, 0x30, 0x00, 0x00, 0x03, 0x00, 0x03, 0x03, 0x03, 0x30, 0x30, 0x00, 0x03, 0x00, 0x00,
+    0x03, 0x30, 0x00, 0x30, 0x30, 0x00, 0x33, 0x30, 0x00, 0x30, 0x30, 0x00, 0x30, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x20, 0x22, 0x22, 0x02, 0x00, 0x23, 0x00, 0x00, 0x00,
+    0x30, 0x00, 0x00, 0x03, 0x00, 0x33, 0x03, 0x00, 0x00, 0x03, 0x00, 0x03, 0x30, 0x33, 0x03, 0x03,
+    0x00, 0x33, 0x33, 0x00, 0x00, 0x30, 0x33, 0x03, 0x03, 0x30, 0x03, 0x30, 0x00, 0x30, 0x00, 0x00,
+    0x03, 0x00, 0x33, 0x03, 0x00, 0x33, 0x30, 0x30, 0x00, 0x30, 0x00, 0x33, 0x33, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x20, 0x22, 0x22, 0x02, 0x00, 0x32, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x20, 0x22, 0x22, 0x02, 0x00, 0x30, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x03, 0x31, 0x22, 0x12, 0x23, 0x00, 0x30, 0x02, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x02, 0x32, 0x33, 0x33, 0x33, 0x01, 0x20, 0x23, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x10, 0x33, 0x33, 0x33, 0x33, 0x02, 0x00, 0x30, 0x02, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x20, 0x33, 0x33, 0x33, 0x33, 0x13, 0x00, 0x20, 0x03, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x30, 0x33, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x20, 0x03, 0x31, 0x33, 0x33, 0x33, 0x33, 0x23, 0x00, 0x00, 0x03, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x30, 0x02, 0x32, 0x33, 0x33, 0x33, 0x33, 0x33, 0x01, 0x00, 0x23, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x32, 0x10, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x02, 0x00, 0x32, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x33, 0x03, 0x30, 0x30, 0x03, 0x30, 0x03, 0x30,
+    0x33, 0x00, 0x30, 0x33, 0x00, 0x33, 0x00, 0x00, 0x30, 0x03, 0x30, 0x00, 0x30, 0x30, 0x33, 0x03,
+    0x30, 0x33, 0x03, 0x00, 0x33, 0x03, 0x30, 0x03, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x23, 0x20, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x02, 0x00, 0x30, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x30, 0x00, 0x30, 0x30, 0x03, 0x30, 0x30, 0x00, 0x00,
+    0x00, 0x03, 0x03, 0x00, 0x03, 0x03, 0x00, 0x00, 0x03, 0x30, 0x30, 0x00, 0x30, 0x30, 0x00, 0x30,
+    0x30, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x20, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x02, 0x00, 0x30, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x30, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x00, 0x30,
+    0x33, 0x03, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x30, 0x00, 0x30,
+    0x30, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x20, 0x03, 0x20, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x02, 0x00, 0x30, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x30, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x00, 0x03,
+    0x00, 0x03, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x30, 0x00, 0x30, 0x30, 0x00, 0x30,
+    0x30, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x32, 0x21, 0x12, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x02, 0x00, 0x30, 0x02,
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x00, 0x03,
+    0x00, 0x03, 0x03, 0x00, 0x03, 0x03, 0x00, 0x00, 0x03, 0x30, 0x30, 0x00, 0x33, 0x30, 0x00, 0x30,
+    0x30, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x20, 0x13, 0x22, 0x22, 0x31, 0x33, 0x33, 0x33, 0x33, 0x33, 0x21, 0x22, 0x32, 0x03,
+    0x00, 0x00, 0x00, 0x00, 0x30, 0x33, 0x03, 0x00, 0x33, 0x03, 0x30, 0x00, 0x30, 0x00, 0x03, 0x30,
+    0x33, 0x03, 0x30, 0x33, 0x00, 0x30, 0x00, 0x00, 0x30, 0x03, 0x00, 0x33, 0x30, 0x30, 0x33, 0x03,
+    0x30, 0x33, 0x03, 0x00, 0x33, 0x03, 0x30, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x30, 0x21, 0x22, 0x22, 0x12, 0x33, 0x33, 0x33, 0x33, 0x33, 0x22, 0x22, 0x22, 0x23,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00,
+    0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x30, 0x22, 0x22, 0x22, 0x22, 0x31, 0x33, 0x33, 0x33, 0x13, 0x22, 0x22, 0x22, 0x32,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00,
+    0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x30, 0x22, 0x22, 0x22, 0x22, 0x12, 0x33, 0x33, 0x33, 0x21, 0x22, 0x22, 0x22, 0x32,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x30, 0x22, 0x22, 0x22, 0x22, 0x22, 0x11, 0x11, 0x11, 0x22, 0x22, 0x22, 0x22, 0x23,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x20, 0x33, 0x22, 0x22, 0x22, 0x22, 0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0x33, 0x02,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x20, 0x33, 0x23, 0x22, 0x32, 0x33, 0x33, 0x33, 0x22, 0x22, 0x32, 0x02, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x33, 0x23, 0x00, 0x00, 0x20, 0x33, 0x33, 0x23, 0x00, 0x00,
+};
Index: empeg/kernel/arch/arm/special/rio_ani.h
diff -u /dev/null empeg/kernel/arch/arm/special/rio_ani.h:1.3
--- /dev/null	Wed Oct 17 16:36:04 2001
+++ empeg/kernel/arch/arm/special/rio_ani.h	Tue Oct  2 16:54:40 2001
@@ -0,0 +1,1418 @@
+/* This file is autogenerated by the rules in kernel-logos/ - do not edit */
+static unsigned char rio_ani[] = {
+    0x68, 0x00, 0x00, 0x00, 0x68, 0x04, 0x00, 0x00, 0x68, 0x08, 0x00, 0x00, 0x68, 0x0c, 0x00, 0x00,
+    0x68, 0x10, 0x00, 0x00, 0x68, 0x14, 0x00, 0x00, 0x68, 0x18, 0x00, 0x00, 0x68, 0x1c, 0x00, 0x00,
+    0x68, 0x1c, 0x00, 0x00, 0x68, 0x1c, 0x00, 0x00, 0x68, 0x20, 0x00, 0x00, 0x68, 0x24, 0x00, 0x00,
+    0x68, 0x28, 0x00, 0x00, 0x68, 0x2c, 0x00, 0x00, 0x68, 0x30, 0x00, 0x00, 0x68, 0x34, 0x00, 0x00,
+    0x68, 0x38, 0x00, 0x00, 0x68, 0x3c, 0x00, 0x00, 0x68, 0x40, 0x00, 0x00, 0x68, 0x44, 0x00, 0x00,
+    0x68, 0x48, 0x00, 0x00, 0x68, 0x4c, 0x00, 0x00, 0x68, 0x50, 0x00, 0x00, 0x68, 0x54, 0x00, 0x00,
+    0x68, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf7, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbc, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x0f, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x02, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x1f, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x1f, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x0e, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbc, 0x0d, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x04, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x04, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x04, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x04, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x0d, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x0e, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x0f, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x0f, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x02, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xef, 0x10, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x3c, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0xbd, 0x3c, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x28, 0x7c, 0x0f, 0x70,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x10, 0xfc, 0x00, 0x70,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0xf0, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0xfd, 0x0d, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0xfd, 0x07, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x10, 0xfd, 0xc3, 0xf0,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x20, 0xfc, 0xc3, 0xe0,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x38, 0x7c, 0xc2, 0xc0,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xbd, 0x3c, 0xc1, 0xc0,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xff, 0x3c, 0xc1, 0xc0,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xcb, 0x0c, 0xc1, 0xc0,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x8f, 0x0c, 0xc1, 0xc0,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x0f, 0x0c, 0xc2, 0xc0,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x0f, 0x0c, 0xc3, 0xe0,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x0e, 0x3c, 0xc3, 0xf0,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x0c, 0x3c, 0x07, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x08, 0x7c, 0x0d, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xfd, 0x30, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xff, 0xff, 0x30,
+    0xe2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xff, 0x6f, 0x70,
+    0xf3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xfb, 0x0c, 0xf0,
+    0xf3, 0xcf, 0xf1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf3, 0x08, 0xf1,
+    0xc1, 0xcf, 0xf1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf3, 0x04, 0xf2,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf1, 0x00, 0xf3,
+    0xd0, 0x0e, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf1, 0x00, 0xf3,
+    0xf2, 0xcf, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf2, 0x00, 0xf3,
+    0xf3, 0xc7, 0xf3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf3, 0x04, 0xf2,
+    0xe3, 0xf3, 0xe3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf3, 0x08, 0xf1,
+    0xc3, 0xf1, 0xc3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfb, 0x0c, 0xf0,
+    0xc7, 0xf0, 0x87, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x6f, 0xf0,
+    0xcb, 0xf0, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x70,
+    0xcf, 0xf0, 0x4f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf3, 0xfb, 0x00,
+    0xcf, 0xf0, 0x4f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf3, 0xe7, 0x00,
+    0xcb, 0xf0, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf3, 0xcf, 0x00,
+    0xc7, 0xf0, 0x87, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf3, 0x8f, 0x10,
+    0xc3, 0xf1, 0xc3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf3, 0x0f, 0x30,
+    0xc3, 0xf3, 0xe3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf3, 0x0f, 0x70,
+    0xc3, 0xc7, 0xf3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf3, 0x0c, 0xf0,
+    0xc3, 0xcf, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf3, 0x00, 0x00,
+    0x00, 0x0e, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xdf,
+    0xff, 0x30, 0x8f, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
+    0xff, 0x70, 0xcf, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xef, 0xf7,
+    0x9f, 0xf0, 0xcf, 0x30, 0xef, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x30,
+    0x0e, 0xf1, 0x8f, 0x10, 0xef, 0xfb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x30,
+    0x08, 0xf7, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x20,
+    0x00, 0xfb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x10,
+    0x00, 0xff, 0xcf, 0x00, 0x4f, 0xb1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x10,
+    0x00, 0xff, 0xcf, 0x30, 0xef, 0xfb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x20,
+    0x00, 0xff, 0xcf, 0x3c, 0xf2, 0xcf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x30,
+    0x04, 0xfb, 0x8f, 0x3e, 0xf0, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x30,
+    0x08, 0xf7, 0x0e, 0x3f, 0xf0, 0x4f, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0xb0,
+    0x0e, 0xf1, 0x0e, 0x3f, 0xb0, 0x0e, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0xf7,
+    0x9f, 0xf0, 0x0e, 0x3f, 0x70, 0x0d, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0xff,
+    0xff, 0x70, 0x0e, 0x3f, 0x70, 0x0d, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x3e,
+    0xfa, 0x00, 0x0e, 0x3f, 0x70, 0x0d, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x3c,
+    0xf7, 0x00, 0x0e, 0x3f, 0x70, 0x0d, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x38,
+    0xff, 0x00, 0x0e, 0x3f, 0xb0, 0x0e, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x30,
+    0xef, 0x10, 0x0e, 0x3f, 0xf0, 0x4f, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x30,
+    0xcf, 0x30, 0x0e, 0x3e, 0xf0, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x30,
+    0x8f, 0x70, 0x0e, 0x3c, 0xf2, 0xcf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x30,
+    0x0f, 0xf0, 0x0e, 0x30, 0xef, 0xfb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x30,
+    0x0e, 0xf1, 0x00, 0x00, 0x4f, 0xb1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdf,
+    0x6e, 0xff, 0xf3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdf,
+    0xff, 0xff, 0xff, 0x10, 0x8f, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdf,
+    0xff, 0x69, 0xff, 0x70, 0xcf, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcf,
+    0xf3, 0x00, 0xcf, 0xf0, 0x8f, 0xf0, 0x4f, 0xff, 0xf7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f,
+    0xf2, 0x00, 0x8f, 0xf1, 0x0d, 0x10, 0x4f, 0xff, 0xf7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f,
+    0xf1, 0x00, 0x4f, 0xf2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f,
+    0xb0, 0x00, 0x0e, 0xf3, 0x4f, 0x20, 0x04, 0xef, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f,
+    0x70, 0x00, 0x0d, 0xf3, 0xcf, 0xb0, 0x0f, 0xff, 0xf3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f,
+    0x70, 0x00, 0x0d, 0xf3, 0xcf, 0xf0, 0xcf, 0xb9, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f,
+    0xb0, 0x00, 0x0e, 0xf3, 0xcf, 0xf0, 0xff, 0x30, 0xef, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f,
+    0xf1, 0x00, 0x4f, 0xf2, 0x8f, 0xf0, 0xff, 0x20, 0xcf, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f,
+    0xf2, 0x00, 0x8f, 0xf1, 0x0e, 0xf0, 0xff, 0x10, 0xcf, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f,
+    0xf3, 0x00, 0xcf, 0xf0, 0x0e, 0xf4, 0xfb, 0x00, 0x8f, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f,
+    0xff, 0x69, 0xff, 0x70, 0x0e, 0xf8, 0xf7, 0x00, 0x4f, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f,
+    0xff, 0xff, 0xff, 0x10, 0x0e, 0xfc, 0xf7, 0x00, 0x4f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f,
+    0xf8, 0xff, 0xb1, 0x00, 0x0e, 0xfc, 0xf7, 0x00, 0x4f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f,
+    0xf0, 0xef, 0x70, 0x00, 0x0e, 0xf8, 0xf7, 0x00, 0x4f, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f,
+    0xf0, 0x8f, 0xf1, 0x00, 0x0e, 0xf4, 0xfb, 0x00, 0x8f, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f,
+    0xf0, 0x0f, 0xf7, 0x00, 0x0e, 0xf0, 0xff, 0x10, 0xcf, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f,
+    0xf0, 0x0e, 0xff, 0x00, 0x0e, 0xf0, 0xff, 0x20, 0xcf, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f,
+    0xf0, 0x08, 0xff, 0x10, 0x0e, 0xf0, 0xff, 0x30, 0xef, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f,
+    0xf0, 0x00, 0xef, 0x70, 0x0e, 0xf0, 0xcf, 0xb9, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f,
+    0xf0, 0x00, 0xcf, 0xf0, 0x0e, 0xf0, 0x0f, 0xff, 0xf3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xef, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
+    0xff, 0xbe, 0xff, 0xff, 0xf1, 0x00, 0x8f, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
+    0xff, 0xff, 0xff, 0xff, 0xf3, 0x00, 0xcf, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
+    0xff, 0xff, 0xb5, 0xdf, 0xf7, 0x00, 0xcf, 0xf0, 0x09, 0xff, 0xff, 0xf6, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0xef, 0xfb, 0x00, 0x0e, 0xff, 0x10, 0x8f, 0x70, 0x09, 0xff, 0xff, 0xf6, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x8f, 0xf2, 0x00, 0x08, 0xff, 0x70, 0x0f, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x8f, 0xf1, 0x00, 0x04, 0xff, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x8f, 0xf0, 0x00, 0x00, 0xef, 0xf0, 0x4f, 0x20, 0x00, 0x8f, 0xfb, 0x10, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x8f, 0xf0, 0x00, 0x00, 0xdf, 0xf0, 0xdf, 0xb0, 0x08, 0xff, 0xff, 0xf2, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x8f, 0xf0, 0x00, 0x00, 0xdf, 0xf0, 0xdf, 0xf0, 0x0f, 0xfb, 0x5f, 0xff, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x8f, 0xf0, 0x00, 0x00, 0xef, 0xf0, 0xdf, 0xf0, 0xcf, 0xf2, 0x0e, 0xff, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x8f, 0xf1, 0x00, 0x04, 0xff, 0xb0, 0x8f, 0xf0, 0xef, 0xb0, 0x08, 0xff, 0x20, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x8f, 0xf2, 0x00, 0x08, 0xff, 0x70, 0x0f, 0xf0, 0xff, 0x70, 0x04, 0xff, 0x30, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x8f, 0xfb, 0x00, 0x0e, 0xff, 0x10, 0x0f, 0xf0, 0xff, 0x30, 0x00, 0xef, 0x70, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x8f, 0xff, 0xb5, 0xdf, 0xf7, 0x00, 0x0f, 0xf0, 0xff, 0x30, 0x00, 0xdf, 0xb0, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x8f, 0xff, 0xff, 0xff, 0xf3, 0x00, 0x0f, 0xf0, 0xff, 0x30, 0x00, 0xdf, 0xf0, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x8f, 0xf0, 0xef, 0xfa, 0x10, 0x00, 0x0f, 0xf0, 0xff, 0x30, 0x00, 0xdf, 0xf0, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x8f, 0xf0, 0x8f, 0xf7, 0x00, 0x00, 0x0f, 0xf0, 0xff, 0x30, 0x00, 0xdf, 0xb0, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x8f, 0xf0, 0x0e, 0xff, 0x10, 0x00, 0x0f, 0xf0, 0xff, 0x30, 0x00, 0xef, 0x70, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x8f, 0xf0, 0x08, 0xff, 0x70, 0x00, 0x0f, 0xf0, 0xff, 0x70, 0x04, 0xff, 0x30, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x8f, 0xf0, 0x00, 0xef, 0xf1, 0x00, 0x0f, 0xf0, 0xef, 0xb0, 0x08, 0xff, 0x20, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x8f, 0xf0, 0x00, 0xcf, 0xf3, 0x00, 0x0f, 0xf0, 0xcf, 0xf2, 0x0e, 0xff, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x8f, 0xf0, 0x00, 0x8f, 0xf7, 0x00, 0x0f, 0xf0, 0x0f, 0xfb, 0x5f, 0xff, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x8f, 0xf0, 0x00, 0x0e, 0xff, 0x10, 0x0f, 0xf0, 0x08, 0xff, 0xff, 0xf2, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0xfb, 0x10, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x04, 0xfb, 0x00, 0x9f, 0xff, 0x60, 0x00, 0x00, 0xeb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0x6e, 0xff, 0xff, 0xf7, 0x00, 0x08, 0xff, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0xff, 0xff, 0xff, 0xff, 0x10, 0x0c, 0xff, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0xff, 0xb5, 0x9f, 0xff, 0x70, 0x0c, 0xff, 0x30, 0x09, 0xff, 0xff, 0xff, 0x60, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x08, 0xff, 0xfb, 0x00, 0x08, 0xff, 0xf1, 0x08, 0xff, 0x10, 0x09, 0xff, 0xff, 0xff, 0x60, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf2, 0x00, 0x00, 0xef, 0xf7, 0x00, 0xd7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf1, 0x00, 0x00, 0xdf, 0xfb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xb0, 0x00, 0x00, 0x8f, 0xff, 0x04, 0xfb, 0x00, 0x00, 0x4e, 0xff, 0xb1, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0x70, 0x00, 0x00, 0x4f, 0xff, 0x0d, 0xff, 0x20, 0x08, 0xff, 0xff, 0xff, 0x20, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0x70, 0x00, 0x00, 0x4f, 0xff, 0x0d, 0xff, 0x30, 0x0f, 0xff, 0x69, 0xff, 0xf0, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xb0, 0x00, 0x00, 0x8f, 0xff, 0x0d, 0xff, 0x30, 0xcf, 0xfb, 0x00, 0xef, 0xf3, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf1, 0x00, 0x00, 0xdf, 0xfb, 0x08, 0xff, 0x30, 0xef, 0xf2, 0x00, 0x8f, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf2, 0x00, 0x00, 0xef, 0xf7, 0x00, 0xef, 0x30, 0xff, 0xf1, 0x00, 0x4f, 0xff, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xfb, 0x00, 0x08, 0xff, 0xf1, 0x00, 0xef, 0x34, 0xff, 0xb0, 0x00, 0x0e, 0xff, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xff, 0xb5, 0x9f, 0xff, 0x70, 0x00, 0xef, 0x38, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xff, 0xff, 0xff, 0xff, 0x10, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xfa, 0xff, 0xff, 0xf7, 0x00, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0xef, 0xfb, 0x60, 0x00, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x8f, 0xff, 0x10, 0x00, 0x00, 0xef, 0x38, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x0e, 0xff, 0x70, 0x00, 0x00, 0xef, 0x34, 0xff, 0xb0, 0x00, 0x0e, 0xff, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x08, 0xff, 0xf1, 0x00, 0x00, 0xef, 0x30, 0xff, 0xf1, 0x00, 0x4f, 0xff, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0xef, 0xf7, 0x00, 0x00, 0xef, 0x30, 0xef, 0xf2, 0x00, 0x8f, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x8f, 0xff, 0x10, 0x00, 0xef, 0x30, 0xcf, 0xfb, 0x00, 0xef, 0xf3, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x0e, 0xff, 0x70, 0x00, 0xef, 0x30, 0x0f, 0xff, 0x69, 0xff, 0xf0, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x08, 0xff, 0xf1, 0x00, 0xef, 0x30, 0x08, 0xff, 0xff, 0xff, 0x20, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0xff, 0xb1, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x04, 0xfb, 0x00, 0x9f, 0xff, 0x60, 0x00, 0x00, 0xeb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0x6e, 0xff, 0xff, 0xf7, 0x00, 0x08, 0xff, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0xff, 0xff, 0xff, 0xff, 0x10, 0x0c, 0xff, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0xff, 0xb5, 0x9f, 0xff, 0x70, 0x0c, 0xff, 0x30, 0x09, 0xff, 0xff, 0xff, 0x60, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x08, 0xff, 0xfb, 0x00, 0x08, 0xff, 0xf1, 0x08, 0xff, 0x10, 0x09, 0xff, 0xff, 0xff, 0x60, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf2, 0x00, 0x00, 0xef, 0xf7, 0x00, 0xd7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf1, 0x00, 0x00, 0xdf, 0xfb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xb0, 0x00, 0x00, 0x8f, 0xff, 0x04, 0xfb, 0x00, 0x00, 0x4e, 0xff, 0xb1, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0x70, 0x00, 0x00, 0x4f, 0xff, 0x0d, 0xff, 0x20, 0x08, 0xff, 0xff, 0xff, 0x20, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0x70, 0x00, 0x00, 0x4f, 0xff, 0x0d, 0xff, 0x30, 0x0f, 0xff, 0x69, 0xff, 0xf0, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xb0, 0x00, 0x00, 0x8f, 0xff, 0x0d, 0xff, 0x30, 0xcf, 0xfb, 0x00, 0xef, 0xf3, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf1, 0x00, 0x00, 0xdf, 0xfb, 0x08, 0xff, 0x30, 0xef, 0xf2, 0x00, 0x8f, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf2, 0x00, 0x00, 0xef, 0xf7, 0x00, 0xef, 0x30, 0xff, 0xf1, 0x00, 0x4f, 0xff, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xfb, 0x00, 0x08, 0xff, 0xf1, 0x00, 0xef, 0x34, 0xff, 0xb0, 0x00, 0x0e, 0xff, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xff, 0xb5, 0x9f, 0xff, 0x70, 0x00, 0xef, 0x38, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xff, 0xff, 0xff, 0xff, 0x10, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xfa, 0xff, 0xff, 0xf7, 0x00, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0xef, 0xfb, 0x60, 0x00, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x8f, 0xff, 0x10, 0x00, 0x00, 0xef, 0x38, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x0e, 0xff, 0x70, 0x00, 0x00, 0xef, 0x34, 0xff, 0xb0, 0x00, 0x0e, 0xff, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x08, 0xff, 0xf1, 0x00, 0x00, 0xef, 0x30, 0xff, 0xf1, 0x00, 0x4f, 0xff, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0xef, 0xf7, 0x00, 0x00, 0xef, 0x30, 0xef, 0xf2, 0x00, 0x8f, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x8f, 0xff, 0x10, 0x00, 0xef, 0x30, 0xcf, 0xfb, 0x00, 0xef, 0xf3, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x0e, 0xff, 0x70, 0x00, 0xef, 0x30, 0x0f, 0xff, 0x69, 0xff, 0xf0, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x08, 0xff, 0xf1, 0x00, 0xef, 0x30, 0x08, 0xff, 0xff, 0xff, 0x20, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0xff, 0xb1, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x04, 0xfb, 0x00, 0x9f, 0xff, 0x60, 0x00, 0x00, 0xeb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0x6e, 0xff, 0xff, 0xf7, 0x00, 0x08, 0xff, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0xff, 0xff, 0xff, 0xff, 0x10, 0x0c, 0xff, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0xff, 0xb5, 0x9f, 0xff, 0x70, 0x0c, 0xff, 0x30, 0x09, 0xff, 0xff, 0xff, 0x60, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x08, 0xff, 0xfb, 0x00, 0x08, 0xff, 0xf1, 0x08, 0xff, 0x10, 0x09, 0xff, 0xff, 0xff, 0x60, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf2, 0x00, 0x00, 0xef, 0xf7, 0x00, 0xd7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf1, 0x00, 0x00, 0xdf, 0xfb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xb0, 0x00, 0x00, 0x8f, 0xff, 0x04, 0xfb, 0x00, 0x00, 0x4e, 0xff, 0xb1, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0x70, 0x00, 0x00, 0x4f, 0xff, 0x0d, 0xff, 0x20, 0x08, 0xff, 0xff, 0xff, 0x20, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0x70, 0x00, 0x00, 0x4f, 0xff, 0x0d, 0xff, 0x30, 0x0f, 0xff, 0x69, 0xff, 0xf0, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xb0, 0x00, 0x00, 0x8f, 0xff, 0x0d, 0xff, 0x30, 0xcf, 0xfb, 0x00, 0xef, 0xf3, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf1, 0x00, 0x00, 0xdf, 0xfb, 0x08, 0xff, 0x30, 0xef, 0xf2, 0x00, 0x8f, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf2, 0x00, 0x00, 0xef, 0xf7, 0x00, 0xef, 0x30, 0xff, 0xf1, 0x00, 0x4f, 0xff, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xfb, 0x00, 0x08, 0xff, 0xf1, 0x00, 0xef, 0x34, 0xff, 0xb0, 0x00, 0x0e, 0xff, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xff, 0xb5, 0x9f, 0xff, 0x70, 0x00, 0xef, 0x38, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xff, 0xff, 0xff, 0xff, 0x10, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xfa, 0xff, 0xff, 0xf7, 0x00, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0xef, 0xfb, 0x60, 0x00, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x8f, 0xff, 0x10, 0x00, 0x00, 0xef, 0x38, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x0e, 0xff, 0x70, 0x00, 0x00, 0xef, 0x34, 0xff, 0xb0, 0x00, 0x0e, 0xff, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x08, 0xff, 0xf1, 0x00, 0x00, 0xef, 0x30, 0xff, 0xf1, 0x00, 0x4f, 0xff, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0xef, 0xf7, 0x00, 0x00, 0xef, 0x30, 0xef, 0xf2, 0x00, 0x8f, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x8f, 0xff, 0x10, 0x00, 0xef, 0x30, 0xcf, 0xfb, 0x00, 0xef, 0xf3, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x0e, 0xff, 0x70, 0x00, 0xef, 0x30, 0x0f, 0xff, 0x69, 0xff, 0xf0, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x08, 0xff, 0xf1, 0x00, 0xef, 0x30, 0x08, 0xff, 0xff, 0xff, 0x20, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0xff, 0xb1, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x44, 0x45, 0x55, 0x9a, 0xab, 0xef, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xaa, 0xae, 0xab, 0xff, 0xff, 0xff, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x44, 0x45, 0x55, 0x9e, 0xaa, 0xef, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcf, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x04, 0xfb, 0x00, 0x9f, 0xff, 0x60, 0x00, 0x00, 0xeb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0x6e, 0xff, 0xff, 0xf7, 0x00, 0x08, 0xff, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0xff, 0xff, 0xff, 0xff, 0x10, 0x0c, 0xff, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0xff, 0xb5, 0x9f, 0xff, 0x70, 0x0c, 0xff, 0x30, 0x09, 0xff, 0xff, 0xff, 0x60, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x08, 0xff, 0xfb, 0x00, 0x08, 0xff, 0xf1, 0x08, 0xff, 0x10, 0x09, 0xff, 0xff, 0xff, 0x60, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf2, 0x00, 0x00, 0xef, 0xf7, 0x00, 0xd7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf1, 0x00, 0x00, 0xdf, 0xfb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xb0, 0x00, 0x00, 0x8f, 0xff, 0x04, 0xfb, 0x00, 0x00, 0x4e, 0xff, 0xb1, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0x70, 0x00, 0x00, 0x4f, 0xff, 0x0d, 0xff, 0x20, 0x08, 0xff, 0xff, 0xff, 0x20, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0x70, 0x00, 0x00, 0x4f, 0xff, 0x0d, 0xff, 0x30, 0x0f, 0xff, 0x69, 0xff, 0xf0, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xb0, 0x00, 0x00, 0x8f, 0xff, 0x0d, 0xff, 0x30, 0xcf, 0xfb, 0x00, 0xef, 0xf3, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf1, 0x00, 0x00, 0xdf, 0xfb, 0x08, 0xff, 0x30, 0xef, 0xf2, 0x00, 0x8f, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf2, 0x00, 0x00, 0xef, 0xf7, 0x00, 0xef, 0x30, 0xff, 0xf1, 0x00, 0x4f, 0xff, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xfb, 0x00, 0x08, 0xff, 0xf1, 0x00, 0xef, 0x34, 0xff, 0xb0, 0x00, 0x0e, 0xff, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xff, 0xb5, 0x9f, 0xff, 0x70, 0x00, 0xef, 0x38, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xff, 0xff, 0xff, 0xff, 0x10, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xfa, 0xff, 0xff, 0xf7, 0x00, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0xef, 0xfb, 0x60, 0x00, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x8f, 0xff, 0x10, 0x00, 0x00, 0xef, 0x38, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x0e, 0xff, 0x70, 0x00, 0x00, 0xef, 0x34, 0xff, 0xb0, 0x00, 0x0e, 0xff, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x08, 0xff, 0xf1, 0x00, 0x00, 0xef, 0x30, 0xff, 0xf1, 0x00, 0x4f, 0xff, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0xef, 0xf7, 0x00, 0x00, 0xef, 0x30, 0xef, 0xf2, 0x00, 0x8f, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x8f, 0xff, 0x10, 0x00, 0xef, 0x30, 0xcf, 0xfb, 0x00, 0xef, 0xf3, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x0e, 0xff, 0x70, 0x00, 0xef, 0x30, 0x0f, 0xff, 0x69, 0xff, 0xf0, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x08, 0xff, 0xf1, 0x00, 0xef, 0x30, 0x08, 0xff, 0xff, 0xff, 0x20, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0xff, 0xb1, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x45, 0x54, 0x93, 0xaa, 0xaa,
+    0xaa, 0xdf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x96, 0xaa, 0xee, 0xaf, 0xeb, 0xf3, 0xff,
+    0xff, 0xff, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x45, 0x15, 0x8d, 0x5a, 0xea, 0xaa,
+    0xaa, 0xae, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcf, 0x10,
+    0x30, 0xdf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x04, 0xfb, 0x00, 0x9f, 0xff, 0x60, 0x00, 0x00, 0xeb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0x6e, 0xff, 0xff, 0xf7, 0x00, 0x08, 0xff, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0xff, 0xff, 0xff, 0xff, 0x10, 0x0c, 0xff, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0xff, 0xb5, 0x9f, 0xff, 0x70, 0x0c, 0xff, 0x30, 0x09, 0xff, 0xff, 0xff, 0x60, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x08, 0xff, 0xfb, 0x00, 0x08, 0xff, 0xf1, 0x08, 0xff, 0x10, 0x09, 0xff, 0xff, 0xff, 0x60, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf2, 0x00, 0x00, 0xef, 0xf7, 0x00, 0xd7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf1, 0x00, 0x00, 0xdf, 0xfb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xb0, 0x00, 0x00, 0x8f, 0xff, 0x04, 0xfb, 0x00, 0x00, 0x4e, 0xff, 0xb1, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0x70, 0x00, 0x00, 0x4f, 0xff, 0x0d, 0xff, 0x20, 0x08, 0xff, 0xff, 0xff, 0x20, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0x70, 0x00, 0x00, 0x4f, 0xff, 0x0d, 0xff, 0x30, 0x0f, 0xff, 0x69, 0xff, 0xf0, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xb0, 0x00, 0x00, 0x8f, 0xff, 0x0d, 0xff, 0x30, 0xcf, 0xfb, 0x00, 0xef, 0xf3, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf1, 0x00, 0x00, 0xdf, 0xfb, 0x08, 0xff, 0x30, 0xef, 0xf2, 0x00, 0x8f, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf2, 0x00, 0x00, 0xef, 0xf7, 0x00, 0xef, 0x30, 0xff, 0xf1, 0x00, 0x4f, 0xff, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xfb, 0x00, 0x08, 0xff, 0xf1, 0x00, 0xef, 0x34, 0xff, 0xb0, 0x00, 0x0e, 0xff, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xff, 0xb5, 0x9f, 0xff, 0x70, 0x00, 0xef, 0x38, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xff, 0xff, 0xff, 0xff, 0x10, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xfa, 0xff, 0xff, 0xf7, 0x00, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0xef, 0xfb, 0x60, 0x00, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x8f, 0xff, 0x10, 0x00, 0x00, 0xef, 0x38, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x0e, 0xff, 0x70, 0x00, 0x00, 0xef, 0x34, 0xff, 0xb0, 0x00, 0x0e, 0xff, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x08, 0xff, 0xf1, 0x00, 0x00, 0xef, 0x30, 0xff, 0xf1, 0x00, 0x4f, 0xff, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0xef, 0xf7, 0x00, 0x00, 0xef, 0x30, 0xef, 0xf2, 0x00, 0x8f, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x8f, 0xff, 0x10, 0x00, 0xef, 0x30, 0xcf, 0xfb, 0x00, 0xef, 0xf3, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x0e, 0xff, 0x70, 0x00, 0xef, 0x30, 0x0f, 0xff, 0x69, 0xff, 0xf0, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x08, 0xff, 0xf1, 0x00, 0xef, 0x30, 0x08, 0xff, 0xff, 0xff, 0x20, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0xff, 0xb1, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xcb, 0x2a,
+    0xaa, 0xda, 0xaa, 0xaa, 0xef, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x15, 0x55, 0x59, 0xa6, 0xaa, 0xae, 0xaa,
+    0xfe, 0xff, 0xff, 0xff, 0xff, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x89, 0x5a, 0xea, 0xaa,
+    0xaa, 0xae, 0xaa, 0xaa, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcf, 0x10,
+    0x30, 0xdf, 0x0c, 0xaa, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x04, 0xfb, 0x00, 0x9f, 0xff, 0x60, 0x00, 0x00, 0xeb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0x6e, 0xff, 0xff, 0xf7, 0x00, 0x08, 0xff, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0xff, 0xff, 0xff, 0xff, 0x10, 0x0c, 0xff, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0xff, 0xb5, 0x9f, 0xff, 0x70, 0x0c, 0xff, 0x30, 0x09, 0xff, 0xff, 0xff, 0x60, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x08, 0xff, 0xfb, 0x00, 0x08, 0xff, 0xf1, 0x08, 0xff, 0x10, 0x09, 0xff, 0xff, 0xff, 0x60, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf2, 0x00, 0x00, 0xef, 0xf7, 0x00, 0xd7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf1, 0x00, 0x00, 0xdf, 0xfb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xb0, 0x00, 0x00, 0x8f, 0xff, 0x04, 0xfb, 0x00, 0x00, 0x4e, 0xff, 0xb1, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0x70, 0x00, 0x00, 0x4f, 0xff, 0x0d, 0xff, 0x20, 0x08, 0xff, 0xff, 0xff, 0x20, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0x70, 0x00, 0x00, 0x4f, 0xff, 0x0d, 0xff, 0x30, 0x0f, 0xff, 0x69, 0xff, 0xf0, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xb0, 0x00, 0x00, 0x8f, 0xff, 0x0d, 0xff, 0x30, 0xcf, 0xfb, 0x00, 0xef, 0xf3, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf1, 0x00, 0x00, 0xdf, 0xfb, 0x08, 0xff, 0x30, 0xef, 0xf2, 0x00, 0x8f, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf2, 0x00, 0x00, 0xef, 0xf7, 0x00, 0xef, 0x30, 0xff, 0xf1, 0x00, 0x4f, 0xff, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xfb, 0x00, 0x08, 0xff, 0xf1, 0x00, 0xef, 0x34, 0xff, 0xb0, 0x00, 0x0e, 0xff, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xff, 0xb5, 0x9f, 0xff, 0x70, 0x00, 0xef, 0x38, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xff, 0xff, 0xff, 0xff, 0x10, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xfa, 0xff, 0xff, 0xf7, 0x00, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0xef, 0xfb, 0x60, 0x00, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x8f, 0xff, 0x10, 0x00, 0x00, 0xef, 0x38, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x0e, 0xff, 0x70, 0x00, 0x00, 0xef, 0x34, 0xff, 0xb0, 0x00, 0x0e, 0xff, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x08, 0xff, 0xf1, 0x00, 0x00, 0xef, 0x30, 0xff, 0xf1, 0x00, 0x4f, 0xff, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0xef, 0xf7, 0x00, 0x00, 0xef, 0x30, 0xef, 0xf2, 0x00, 0x8f, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x8f, 0xff, 0x10, 0x00, 0xef, 0x30, 0xcf, 0xfb, 0x00, 0xef, 0xf3, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x0e, 0xff, 0x70, 0x00, 0xef, 0x30, 0x0f, 0xff, 0x69, 0xff, 0xf0, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x08, 0xff, 0xf1, 0x00, 0xef, 0x30, 0x08, 0xff, 0xff, 0xff, 0x20, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0xff, 0xb1, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcf, 0x20,
+    0x30, 0xdf, 0x9e, 0xaa, 0xaa, 0xae, 0xab, 0xbf, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x15, 0x51, 0x55, 0x6a,
+    0x59, 0xaa, 0xff, 0xab, 0xbf, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xca, 0xa9,
+    0x54, 0xae, 0x95, 0x9a, 0x3a, 0xae, 0xab, 0xaf, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcf, 0x10,
+    0x30, 0xdf, 0x0c, 0xaa, 0xff, 0xcc, 0x10, 0xf3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x04, 0xfb, 0x00, 0x9f, 0xff, 0x60, 0x00, 0x00, 0xeb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0x6e, 0xff, 0xff, 0xf7, 0x00, 0x08, 0xff, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0xff, 0xff, 0xff, 0xff, 0x10, 0x0c, 0xff, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0xff, 0xb5, 0x9f, 0xff, 0x70, 0x0c, 0xff, 0x30, 0x09, 0xff, 0xff, 0xff, 0x60, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x08, 0xff, 0xfb, 0x00, 0x08, 0xff, 0xf1, 0x08, 0xff, 0x10, 0x09, 0xff, 0xff, 0xff, 0x60, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf2, 0x00, 0x00, 0xef, 0xf7, 0x00, 0xd7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf1, 0x00, 0x00, 0xdf, 0xfb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xb0, 0x00, 0x00, 0x8f, 0xff, 0x04, 0xfb, 0x00, 0x00, 0x4e, 0xff, 0xb1, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0x70, 0x00, 0x00, 0x4f, 0xff, 0x0d, 0xff, 0x20, 0x08, 0xff, 0xff, 0xff, 0x20, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0x70, 0x00, 0x00, 0x4f, 0xff, 0x0d, 0xff, 0x30, 0x0f, 0xff, 0x69, 0xff, 0xf0, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xb0, 0x00, 0x00, 0x8f, 0xff, 0x0d, 0xff, 0x30, 0xcf, 0xfb, 0x00, 0xef, 0xf3, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf1, 0x00, 0x00, 0xdf, 0xfb, 0x08, 0xff, 0x30, 0xef, 0xf2, 0x00, 0x8f, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf2, 0x00, 0x00, 0xef, 0xf7, 0x00, 0xef, 0x30, 0xff, 0xf1, 0x00, 0x4f, 0xff, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xfb, 0x00, 0x08, 0xff, 0xf1, 0x00, 0xef, 0x34, 0xff, 0xb0, 0x00, 0x0e, 0xff, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xff, 0xb5, 0x9f, 0xff, 0x70, 0x00, 0xef, 0x38, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xff, 0xff, 0xff, 0xff, 0x10, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xfa, 0xff, 0xff, 0xf7, 0x00, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0xef, 0xfb, 0x60, 0x00, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x8f, 0xff, 0x10, 0x00, 0x00, 0xef, 0x38, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x0e, 0xff, 0x70, 0x00, 0x00, 0xef, 0x34, 0xff, 0xb0, 0x00, 0x0e, 0xff, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x08, 0xff, 0xf1, 0x00, 0x00, 0xef, 0x30, 0xff, 0xf1, 0x00, 0x4f, 0xff, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0xef, 0xf7, 0x00, 0x00, 0xef, 0x30, 0xef, 0xf2, 0x00, 0x8f, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x8f, 0xff, 0x10, 0x00, 0xef, 0x30, 0xcf, 0xfb, 0x00, 0xef, 0xf3, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x0e, 0xff, 0x70, 0x00, 0xef, 0x30, 0x0f, 0xff, 0x69, 0xff, 0xf0, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x08, 0xff, 0xf1, 0x00, 0xef, 0x30, 0x08, 0xff, 0xff, 0xff, 0x20, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0xff, 0xb1, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcf, 0x10,
+    0x30, 0xdf, 0x5e, 0x0d, 0xe1, 0x5a, 0xaa, 0xbe, 0xab, 0xea, 0xbf, 0x30, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x44, 0x65,
+    0x55, 0x55, 0x5a, 0xaa, 0xae, 0xbf, 0xbf, 0xaa, 0xbf, 0xef, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x30,
+    0x34, 0xee, 0x95, 0x9a, 0x3a, 0xae, 0xab, 0xaa, 0xab, 0xab, 0xaf, 0x30, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcf, 0x10,
+    0x30, 0xdf, 0x0c, 0x15, 0xf3, 0xcc, 0x10, 0xf3, 0x00, 0x00, 0xdf, 0x30, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x04, 0xfb, 0x00, 0x9f, 0xff, 0x60, 0x00, 0x00, 0xeb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0x6e, 0xff, 0xff, 0xf7, 0x00, 0x08, 0xff, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0xff, 0xff, 0xff, 0xff, 0x10, 0x0c, 0xff, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0xff, 0xb5, 0x9f, 0xff, 0x70, 0x0c, 0xff, 0x30, 0x09, 0xff, 0xff, 0xff, 0x60, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x08, 0xff, 0xfb, 0x00, 0x08, 0xff, 0xf1, 0x08, 0xff, 0x10, 0x09, 0xff, 0xff, 0xff, 0x60, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf2, 0x00, 0x00, 0xef, 0xf7, 0x00, 0xd7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf1, 0x00, 0x00, 0xdf, 0xfb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xb0, 0x00, 0x00, 0x8f, 0xff, 0x04, 0xfb, 0x00, 0x00, 0x4e, 0xff, 0xb1, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0x70, 0x00, 0x00, 0x4f, 0xff, 0x0d, 0xff, 0x20, 0x08, 0xff, 0xff, 0xff, 0x20, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0x70, 0x00, 0x00, 0x4f, 0xff, 0x0d, 0xff, 0x30, 0x0f, 0xff, 0x69, 0xff, 0xf0, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xb0, 0x00, 0x00, 0x8f, 0xff, 0x0d, 0xff, 0x30, 0xcf, 0xfb, 0x00, 0xef, 0xf3, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf1, 0x00, 0x00, 0xdf, 0xfb, 0x08, 0xff, 0x30, 0xef, 0xf2, 0x00, 0x8f, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf2, 0x00, 0x00, 0xef, 0xf7, 0x00, 0xef, 0x30, 0xff, 0xf1, 0x00, 0x4f, 0xff, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xfb, 0x00, 0x08, 0xff, 0xf1, 0x00, 0xef, 0x34, 0xff, 0xb0, 0x00, 0x0e, 0xff, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xff, 0xb5, 0x9f, 0xff, 0x70, 0x00, 0xef, 0x38, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xff, 0xff, 0xff, 0xff, 0x10, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xfa, 0xff, 0xff, 0xf7, 0x00, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0xef, 0xfb, 0x60, 0x00, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x8f, 0xff, 0x10, 0x00, 0x00, 0xef, 0x38, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x0e, 0xff, 0x70, 0x00, 0x00, 0xef, 0x34, 0xff, 0xb0, 0x00, 0x0e, 0xff, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x08, 0xff, 0xf1, 0x00, 0x00, 0xef, 0x30, 0xff, 0xf1, 0x00, 0x4f, 0xff, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0xef, 0xf7, 0x00, 0x00, 0xef, 0x30, 0xef, 0xf2, 0x00, 0x8f, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x8f, 0xff, 0x10, 0x00, 0xef, 0x30, 0xcf, 0xfb, 0x00, 0xef, 0xf3, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x0e, 0xff, 0x70, 0x00, 0xef, 0x30, 0x0f, 0xff, 0x69, 0xff, 0xf0, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x08, 0xff, 0xf1, 0x00, 0xef, 0x30, 0x08, 0xff, 0xff, 0xff, 0x20, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0xff, 0xb1, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcf, 0x10,
+    0x30, 0xdf, 0x0c, 0x0c, 0xf1, 0x47, 0x05, 0x39, 0x5b, 0xe2, 0xaf, 0xba, 0xbf, 0xee, 0xf3, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x30,
+    0x74, 0x15, 0x04, 0x01, 0x55, 0xbf, 0x5a, 0x9a, 0xbf, 0xef, 0xaa, 0xff, 0xff, 0xff, 0xff, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x30,
+    0x30, 0x3d, 0x0c, 0x00, 0x30, 0x5d, 0x14, 0x56, 0x9b, 0xab, 0xaf, 0xae, 0xbe, 0xae, 0xf3, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcf, 0x10,
+    0x30, 0xdf, 0x0c, 0x00, 0x30, 0xec, 0x10, 0xf3, 0x04, 0x40, 0xed, 0x22, 0xd7, 0xeb, 0xf3, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x04, 0xfb, 0x00, 0x9f, 0xff, 0x60, 0x00, 0x00, 0xeb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0x6e, 0xff, 0xff, 0xf7, 0x00, 0x08, 0xff, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0xff, 0xff, 0xff, 0xff, 0x10, 0x0c, 0xff, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0xff, 0xb5, 0x9f, 0xff, 0x70, 0x0c, 0xff, 0x30, 0x09, 0xff, 0xff, 0xff, 0x60, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x08, 0xff, 0xfb, 0x00, 0x08, 0xff, 0xf1, 0x08, 0xff, 0x10, 0x09, 0xff, 0xff, 0xff, 0x60, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf2, 0x00, 0x00, 0xef, 0xf7, 0x00, 0xd7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf1, 0x00, 0x00, 0xdf, 0xfb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xb0, 0x00, 0x00, 0x8f, 0xff, 0x04, 0xfb, 0x00, 0x00, 0x4e, 0xff, 0xb1, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0x70, 0x00, 0x00, 0x4f, 0xff, 0x0d, 0xff, 0x20, 0x08, 0xff, 0xff, 0xff, 0x20, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0x70, 0x00, 0x00, 0x4f, 0xff, 0x0d, 0xff, 0x30, 0x0f, 0xff, 0x69, 0xff, 0xf0, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xb0, 0x00, 0x00, 0x8f, 0xff, 0x0d, 0xff, 0x30, 0xcf, 0xfb, 0x00, 0xef, 0xf3, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf1, 0x00, 0x00, 0xdf, 0xfb, 0x08, 0xff, 0x30, 0xef, 0xf2, 0x00, 0x8f, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf2, 0x00, 0x00, 0xef, 0xf7, 0x00, 0xef, 0x30, 0xff, 0xf1, 0x00, 0x4f, 0xff, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xfb, 0x00, 0x08, 0xff, 0xf1, 0x00, 0xef, 0x34, 0xff, 0xb0, 0x00, 0x0e, 0xff, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xff, 0xb5, 0x9f, 0xff, 0x70, 0x00, 0xef, 0x38, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xff, 0xff, 0xff, 0xff, 0x10, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xfa, 0xff, 0xff, 0xf7, 0x00, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0xef, 0xfb, 0x60, 0x00, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x8f, 0xff, 0x10, 0x00, 0x00, 0xef, 0x38, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x0e, 0xff, 0x70, 0x00, 0x00, 0xef, 0x34, 0xff, 0xb0, 0x00, 0x0e, 0xff, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x08, 0xff, 0xf1, 0x00, 0x00, 0xef, 0x30, 0xff, 0xf1, 0x00, 0x4f, 0xff, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0xef, 0xf7, 0x00, 0x00, 0xef, 0x30, 0xef, 0xf2, 0x00, 0x8f, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x8f, 0xff, 0x10, 0x00, 0xef, 0x30, 0xcf, 0xfb, 0x00, 0xef, 0xf3, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x0e, 0xff, 0x70, 0x00, 0xef, 0x30, 0x0f, 0xff, 0x69, 0xff, 0xf0, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x08, 0xff, 0xf1, 0x00, 0xef, 0x30, 0x08, 0xff, 0xff, 0xff, 0x20, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0xff, 0xb1, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcf, 0x10,
+    0x30, 0xdf, 0x0c, 0x0c, 0xf0, 0x47, 0x00, 0x30, 0x11, 0x00, 0x61, 0x55, 0x45, 0xa8, 0xae, 0xea,
+    0xab, 0xef, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x30,
+    0x30, 0x30, 0x0c, 0x00, 0x34, 0xdc, 0x11, 0x75, 0x04, 0x61, 0xa8, 0xbf, 0xfe, 0xbf, 0xff, 0xff,
+    0xff, 0xff, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x30,
+    0x30, 0x3d, 0x0c, 0x00, 0x30, 0xef, 0x20, 0x30, 0x11, 0x02, 0x55, 0x55, 0x9a, 0x2a, 0xaa, 0xae,
+    0xaa, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcf, 0x10,
+    0x30, 0xdf, 0x0c, 0x00, 0x30, 0xec, 0x20, 0xf3, 0x00, 0x00, 0xed, 0x22, 0xd3, 0x2d, 0xf3, 0x03,
+    0x0d, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x04, 0xfb, 0x00, 0x9f, 0xff, 0x60, 0x00, 0x00, 0xeb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0x6e, 0xff, 0xff, 0xf7, 0x00, 0x08, 0xff, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0xff, 0xff, 0xff, 0xff, 0x10, 0x0c, 0xff, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0xff, 0xb5, 0x9f, 0xff, 0x70, 0x0c, 0xff, 0x30, 0x09, 0xff, 0xff, 0xff, 0x60, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x08, 0xff, 0xfb, 0x00, 0x08, 0xff, 0xf1, 0x08, 0xff, 0x10, 0x09, 0xff, 0xff, 0xff, 0x60, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf2, 0x00, 0x00, 0xef, 0xf7, 0x00, 0xd7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf1, 0x00, 0x00, 0xdf, 0xfb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xb0, 0x00, 0x00, 0x8f, 0xff, 0x04, 0xfb, 0x00, 0x00, 0x4e, 0xff, 0xb1, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0x70, 0x00, 0x00, 0x4f, 0xff, 0x0d, 0xff, 0x20, 0x08, 0xff, 0xff, 0xff, 0x20, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0x70, 0x00, 0x00, 0x4f, 0xff, 0x0d, 0xff, 0x30, 0x0f, 0xff, 0x69, 0xff, 0xf0, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xb0, 0x00, 0x00, 0x8f, 0xff, 0x0d, 0xff, 0x30, 0xcf, 0xfb, 0x00, 0xef, 0xf3, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf1, 0x00, 0x00, 0xdf, 0xfb, 0x08, 0xff, 0x30, 0xef, 0xf2, 0x00, 0x8f, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf2, 0x00, 0x00, 0xef, 0xf7, 0x00, 0xef, 0x30, 0xff, 0xf1, 0x00, 0x4f, 0xff, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xfb, 0x00, 0x08, 0xff, 0xf1, 0x00, 0xef, 0x34, 0xff, 0xb0, 0x00, 0x0e, 0xff, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xff, 0xb5, 0x9f, 0xff, 0x70, 0x00, 0xef, 0x38, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xff, 0xff, 0xff, 0xff, 0x10, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xfa, 0xff, 0xff, 0xf7, 0x00, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0xef, 0xfb, 0x60, 0x00, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x8f, 0xff, 0x10, 0x00, 0x00, 0xef, 0x38, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x0e, 0xff, 0x70, 0x00, 0x00, 0xef, 0x34, 0xff, 0xb0, 0x00, 0x0e, 0xff, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x08, 0xff, 0xf1, 0x00, 0x00, 0xef, 0x30, 0xff, 0xf1, 0x00, 0x4f, 0xff, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0xef, 0xf7, 0x00, 0x00, 0xef, 0x30, 0xef, 0xf2, 0x00, 0x8f, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x8f, 0xff, 0x10, 0x00, 0xef, 0x30, 0xcf, 0xfb, 0x00, 0xef, 0xf3, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x0e, 0xff, 0x70, 0x00, 0xef, 0x30, 0x0f, 0xff, 0x69, 0xff, 0xf0, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x08, 0xff, 0xf1, 0x00, 0xef, 0x30, 0x08, 0xff, 0xff, 0xff, 0x20, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0xff, 0xb1, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcf, 0x10,
+    0x30, 0xdf, 0x0c, 0x0c, 0xf0, 0x47, 0x00, 0x30, 0x00, 0x00, 0x47, 0x04, 0x3d, 0x4e, 0xaa, 0x99,
+    0x56, 0xe6, 0xea, 0xba, 0xbf, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x30,
+    0x30, 0x30, 0x0c, 0x00, 0x30, 0xdc, 0x10, 0x30, 0x00, 0x10, 0x98, 0x55, 0x55, 0x55, 0x55, 0x5d,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x30,
+    0x30, 0x3d, 0x0c, 0x00, 0x30, 0xef, 0x20, 0x30, 0x00, 0x01, 0xef, 0x10, 0x69, 0x1a, 0xa5, 0x4d,
+    0x66, 0xfe, 0xaa, 0xab, 0xaf, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcf, 0x10,
+    0x30, 0xdf, 0x0c, 0x00, 0x30, 0xec, 0x20, 0xf3, 0x00, 0x00, 0xed, 0x21, 0xd7, 0x0d, 0xb0, 0x03,
+    0x0d, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x04, 0xfb, 0x00, 0x9f, 0xff, 0x60, 0x00, 0x00, 0xeb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0x6e, 0xff, 0xff, 0xf7, 0x00, 0x08, 0xff, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0xff, 0xff, 0xff, 0xff, 0x10, 0x0c, 0xff, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0xff, 0xb5, 0x9f, 0xff, 0x70, 0x0c, 0xff, 0x30, 0x09, 0xff, 0xff, 0xff, 0x60, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x08, 0xff, 0xfb, 0x00, 0x08, 0xff, 0xf1, 0x08, 0xff, 0x10, 0x09, 0xff, 0xff, 0xff, 0x60, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf2, 0x00, 0x00, 0xef, 0xf7, 0x00, 0xd7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf1, 0x00, 0x00, 0xdf, 0xfb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xb0, 0x00, 0x00, 0x8f, 0xff, 0x04, 0xfb, 0x00, 0x00, 0x4e, 0xff, 0xb1, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0x70, 0x00, 0x00, 0x4f, 0xff, 0x0d, 0xff, 0x20, 0x08, 0xff, 0xff, 0xff, 0x20, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0x70, 0x00, 0x00, 0x4f, 0xff, 0x0d, 0xff, 0x30, 0x0f, 0xff, 0x69, 0xff, 0xf0, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xb0, 0x00, 0x00, 0x8f, 0xff, 0x0d, 0xff, 0x30, 0xcf, 0xfb, 0x00, 0xef, 0xf3, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf1, 0x00, 0x00, 0xdf, 0xfb, 0x08, 0xff, 0x30, 0xef, 0xf2, 0x00, 0x8f, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf2, 0x00, 0x00, 0xef, 0xf7, 0x00, 0xef, 0x30, 0xff, 0xf1, 0x00, 0x4f, 0xff, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xfb, 0x00, 0x08, 0xff, 0xf1, 0x00, 0xef, 0x34, 0xff, 0xb0, 0x00, 0x0e, 0xff, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xff, 0xb5, 0x9f, 0xff, 0x70, 0x00, 0xef, 0x38, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xff, 0xff, 0xff, 0xff, 0x10, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xfa, 0xff, 0xff, 0xf7, 0x00, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0xef, 0xfb, 0x60, 0x00, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x8f, 0xff, 0x10, 0x00, 0x00, 0xef, 0x38, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x0e, 0xff, 0x70, 0x00, 0x00, 0xef, 0x34, 0xff, 0xb0, 0x00, 0x0e, 0xff, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x08, 0xff, 0xf1, 0x00, 0x00, 0xef, 0x30, 0xff, 0xf1, 0x00, 0x4f, 0xff, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0xef, 0xf7, 0x00, 0x00, 0xef, 0x30, 0xef, 0xf2, 0x00, 0x8f, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x8f, 0xff, 0x10, 0x00, 0xef, 0x30, 0xcf, 0xfb, 0x00, 0xef, 0xf3, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x0e, 0xff, 0x70, 0x00, 0xef, 0x30, 0x0f, 0xff, 0x69, 0xff, 0xf0, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x08, 0xff, 0xf1, 0x00, 0xef, 0x30, 0x08, 0xff, 0xff, 0xff, 0x20, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0xff, 0xb1, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcf, 0x10,
+    0x30, 0xdf, 0x0c, 0x0c, 0xf0, 0x47, 0x00, 0x30, 0x00, 0x00, 0x47, 0x00, 0x3c, 0x0c, 0xf1, 0x43,
+    0x15, 0xe6, 0xe6, 0xb9, 0xb9, 0xab, 0xbe, 0xef, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x30,
+    0x30, 0x30, 0x0c, 0x00, 0x30, 0xdc, 0x10, 0x30, 0x00, 0x00, 0x98, 0x11, 0x39, 0x4d, 0x51, 0x69,
+    0xab, 0xae, 0xeb, 0xef, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x30,
+    0x30, 0x3d, 0x0c, 0x00, 0x30, 0xef, 0x20, 0x30, 0x00, 0x00, 0xef, 0x10, 0x3c, 0x08, 0x02, 0x03,
+    0x55, 0xfe, 0x59, 0x6b, 0x9a, 0xaa, 0xfe, 0xef, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcf, 0x10,
+    0x30, 0xdf, 0x0c, 0x00, 0x30, 0xec, 0x20, 0xf3, 0x00, 0x00, 0xed, 0x20, 0xd7, 0x0c, 0xf1, 0x03,
+    0x0d, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x04, 0xfb, 0x00, 0x9f, 0xff, 0x60, 0x00, 0x00, 0xeb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0x6e, 0xff, 0xff, 0xf7, 0x00, 0x08, 0xff, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0xff, 0xff, 0xff, 0xff, 0x10, 0x0c, 0xff, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0xff, 0xb5, 0x9f, 0xff, 0x70, 0x0c, 0xff, 0x30, 0x09, 0xff, 0xff, 0xff, 0x60, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x08, 0xff, 0xfb, 0x00, 0x08, 0xff, 0xf1, 0x08, 0xff, 0x10, 0x09, 0xff, 0xff, 0xff, 0x60, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf2, 0x00, 0x00, 0xef, 0xf7, 0x00, 0xd7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf1, 0x00, 0x00, 0xdf, 0xfb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xb0, 0x00, 0x00, 0x8f, 0xff, 0x04, 0xfb, 0x00, 0x00, 0x4e, 0xff, 0xb1, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0x70, 0x00, 0x00, 0x4f, 0xff, 0x0d, 0xff, 0x20, 0x08, 0xff, 0xff, 0xff, 0x20, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0x70, 0x00, 0x00, 0x4f, 0xff, 0x0d, 0xff, 0x30, 0x0f, 0xff, 0x69, 0xff, 0xf0, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xb0, 0x00, 0x00, 0x8f, 0xff, 0x0d, 0xff, 0x30, 0xcf, 0xfb, 0x00, 0xef, 0xf3, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf1, 0x00, 0x00, 0xdf, 0xfb, 0x08, 0xff, 0x30, 0xef, 0xf2, 0x00, 0x8f, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf2, 0x00, 0x00, 0xef, 0xf7, 0x00, 0xef, 0x30, 0xff, 0xf1, 0x00, 0x4f, 0xff, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xfb, 0x00, 0x08, 0xff, 0xf1, 0x00, 0xef, 0x34, 0xff, 0xb0, 0x00, 0x0e, 0xff, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xff, 0xb5, 0x9f, 0xff, 0x70, 0x00, 0xef, 0x38, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xff, 0xff, 0xff, 0xff, 0x10, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xfa, 0xff, 0xff, 0xf7, 0x00, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0xef, 0xfb, 0x60, 0x00, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x8f, 0xff, 0x10, 0x00, 0x00, 0xef, 0x38, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x0e, 0xff, 0x70, 0x00, 0x00, 0xef, 0x34, 0xff, 0xb0, 0x00, 0x0e, 0xff, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x08, 0xff, 0xf1, 0x00, 0x00, 0xef, 0x30, 0xff, 0xf1, 0x00, 0x4f, 0xff, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0xef, 0xf7, 0x00, 0x00, 0xef, 0x30, 0xef, 0xf2, 0x00, 0x8f, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x8f, 0xff, 0x10, 0x00, 0xef, 0x30, 0xcf, 0xfb, 0x00, 0xef, 0xf3, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x0e, 0xff, 0x70, 0x00, 0xef, 0x30, 0x0f, 0xff, 0x69, 0xff, 0xf0, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x08, 0xff, 0xf1, 0x00, 0xef, 0x30, 0x08, 0xff, 0xff, 0xff, 0x20, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0xff, 0xb1, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcf, 0x10,
+    0x30, 0xdf, 0x0c, 0x0c, 0xf0, 0x47, 0x00, 0x30, 0x00, 0x00, 0x47, 0x00, 0x3c, 0x0c, 0xf1, 0x03,
+    0x0d, 0x74, 0x15, 0x99, 0x55, 0x6a, 0x98, 0xaa, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x30,
+    0x30, 0x30, 0x0c, 0x00, 0x30, 0xdc, 0x10, 0x30, 0x00, 0x00, 0xdc, 0x10, 0x3c, 0x0c, 0x13, 0x57,
+    0x4a, 0x96, 0xaa, 0xaa, 0xfb, 0xfb, 0xeb, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x30,
+    0x30, 0x3d, 0x0c, 0x00, 0x30, 0xef, 0x20, 0x30, 0x00, 0x00, 0xef, 0x20, 0x3c, 0x0c, 0x03, 0x03,
+    0x17, 0xd5, 0x44, 0x55, 0x64, 0xaa, 0x99, 0xaa, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcf, 0x10,
+    0x30, 0xdf, 0x0c, 0x00, 0x30, 0xec, 0x20, 0xf3, 0x00, 0x00, 0xed, 0x20, 0xd7, 0x0c, 0xf1, 0x03,
+    0x0d, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x04, 0xfb, 0x00, 0x9f, 0xff, 0x60, 0x00, 0x00, 0xeb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0x6e, 0xff, 0xff, 0xf7, 0x00, 0x08, 0xff, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0xff, 0xff, 0xff, 0xff, 0x10, 0x0c, 0xff, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0xff, 0xb5, 0x9f, 0xff, 0x70, 0x0c, 0xff, 0x30, 0x09, 0xff, 0xff, 0xff, 0x60, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x08, 0xff, 0xfb, 0x00, 0x08, 0xff, 0xf1, 0x08, 0xff, 0x10, 0x09, 0xff, 0xff, 0xff, 0x60, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf2, 0x00, 0x00, 0xef, 0xf7, 0x00, 0xd7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf1, 0x00, 0x00, 0xdf, 0xfb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xb0, 0x00, 0x00, 0x8f, 0xff, 0x04, 0xfb, 0x00, 0x00, 0x4e, 0xff, 0xb1, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0x70, 0x00, 0x00, 0x4f, 0xff, 0x0d, 0xff, 0x20, 0x08, 0xff, 0xff, 0xff, 0x20, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0x70, 0x00, 0x00, 0x4f, 0xff, 0x0d, 0xff, 0x30, 0x0f, 0xff, 0x69, 0xff, 0xf0, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xb0, 0x00, 0x00, 0x8f, 0xff, 0x0d, 0xff, 0x30, 0xcf, 0xfb, 0x00, 0xef, 0xf3, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf1, 0x00, 0x00, 0xdf, 0xfb, 0x08, 0xff, 0x30, 0xef, 0xf2, 0x00, 0x8f, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf2, 0x00, 0x00, 0xef, 0xf7, 0x00, 0xef, 0x30, 0xff, 0xf1, 0x00, 0x4f, 0xff, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xfb, 0x00, 0x08, 0xff, 0xf1, 0x00, 0xef, 0x34, 0xff, 0xb0, 0x00, 0x0e, 0xff, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xff, 0xb5, 0x9f, 0xff, 0x70, 0x00, 0xef, 0x38, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xff, 0xff, 0xff, 0xff, 0x10, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xfa, 0xff, 0xff, 0xf7, 0x00, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0xef, 0xfb, 0x60, 0x00, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x8f, 0xff, 0x10, 0x00, 0x00, 0xef, 0x38, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x0e, 0xff, 0x70, 0x00, 0x00, 0xef, 0x34, 0xff, 0xb0, 0x00, 0x0e, 0xff, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x08, 0xff, 0xf1, 0x00, 0x00, 0xef, 0x30, 0xff, 0xf1, 0x00, 0x4f, 0xff, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0xef, 0xf7, 0x00, 0x00, 0xef, 0x30, 0xef, 0xf2, 0x00, 0x8f, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x8f, 0xff, 0x10, 0x00, 0xef, 0x30, 0xcf, 0xfb, 0x00, 0xef, 0xf3, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x0e, 0xff, 0x70, 0x00, 0xef, 0x30, 0x0f, 0xff, 0x69, 0xff, 0xf0, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x08, 0xff, 0xf1, 0x00, 0xef, 0x30, 0x08, 0xff, 0xff, 0xff, 0x20, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0xff, 0xb1, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcf, 0x10,
+    0x30, 0xdf, 0x0c, 0x0c, 0xf0, 0x47, 0x00, 0x30, 0x00, 0x00, 0x47, 0x00, 0x3c, 0x0c, 0xf1, 0x03,
+    0x0d, 0x70, 0x00, 0x10, 0x04, 0x48, 0x94, 0x59, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x30,
+    0x30, 0x30, 0x0c, 0x00, 0x30, 0xdc, 0x10, 0x30, 0x00, 0x00, 0xdc, 0x10, 0x3c, 0x0c, 0x03, 0x07,
+    0x07, 0x41, 0x51, 0x10, 0x18, 0x81, 0x99, 0xbb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x30,
+    0x30, 0x3d, 0x0c, 0x00, 0x30, 0xef, 0x20, 0x30, 0x00, 0x00, 0xef, 0x20, 0x3c, 0x0c, 0x03, 0x03,
+    0x03, 0xc0, 0x00, 0x01, 0x00, 0x04, 0x19, 0x59, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcf, 0x10,
+    0x30, 0xdf, 0x0c, 0x00, 0x30, 0xec, 0x20, 0xf3, 0x00, 0x00, 0xed, 0x20, 0xd7, 0x0c, 0xf1, 0x03,
+    0x0d, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x04, 0xfb, 0x00, 0x9f, 0xff, 0x60, 0x00, 0x00, 0xeb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0x6e, 0xff, 0xff, 0xf7, 0x00, 0x08, 0xff, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0xff, 0xff, 0xff, 0xff, 0x10, 0x0c, 0xff, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0xff, 0xb5, 0x9f, 0xff, 0x70, 0x0c, 0xff, 0x30, 0x09, 0xff, 0xff, 0xff, 0x60, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x08, 0xff, 0xfb, 0x00, 0x08, 0xff, 0xf1, 0x08, 0xff, 0x10, 0x09, 0xff, 0xff, 0xff, 0x60, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf2, 0x00, 0x00, 0xef, 0xf7, 0x00, 0xd7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf1, 0x00, 0x00, 0xdf, 0xfb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xb0, 0x00, 0x00, 0x8f, 0xff, 0x04, 0xfb, 0x00, 0x00, 0x4e, 0xff, 0xb1, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0x70, 0x00, 0x00, 0x4f, 0xff, 0x0d, 0xff, 0x20, 0x08, 0xff, 0xff, 0xff, 0x20, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0x70, 0x00, 0x00, 0x4f, 0xff, 0x0d, 0xff, 0x30, 0x0f, 0xff, 0x69, 0xff, 0xf0, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xb0, 0x00, 0x00, 0x8f, 0xff, 0x0d, 0xff, 0x30, 0xcf, 0xfb, 0x00, 0xef, 0xf3, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf1, 0x00, 0x00, 0xdf, 0xfb, 0x08, 0xff, 0x30, 0xef, 0xf2, 0x00, 0x8f, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf2, 0x00, 0x00, 0xef, 0xf7, 0x00, 0xef, 0x30, 0xff, 0xf1, 0x00, 0x4f, 0xff, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xfb, 0x00, 0x08, 0xff, 0xf1, 0x00, 0xef, 0x34, 0xff, 0xb0, 0x00, 0x0e, 0xff, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xff, 0xb5, 0x9f, 0xff, 0x70, 0x00, 0xef, 0x38, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xff, 0xff, 0xff, 0xff, 0x10, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xfa, 0xff, 0xff, 0xf7, 0x00, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0xef, 0xfb, 0x60, 0x00, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x8f, 0xff, 0x10, 0x00, 0x00, 0xef, 0x38, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x0e, 0xff, 0x70, 0x00, 0x00, 0xef, 0x34, 0xff, 0xb0, 0x00, 0x0e, 0xff, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x08, 0xff, 0xf1, 0x00, 0x00, 0xef, 0x30, 0xff, 0xf1, 0x00, 0x4f, 0xff, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0xef, 0xf7, 0x00, 0x00, 0xef, 0x30, 0xef, 0xf2, 0x00, 0x8f, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x8f, 0xff, 0x10, 0x00, 0xef, 0x30, 0xcf, 0xfb, 0x00, 0xef, 0xf3, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x0e, 0xff, 0x70, 0x00, 0xef, 0x30, 0x0f, 0xff, 0x69, 0xff, 0xf0, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x08, 0xff, 0xf1, 0x00, 0xef, 0x30, 0x08, 0xff, 0xff, 0xff, 0x20, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0xff, 0xb1, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcf, 0x10,
+    0x30, 0xdf, 0x0c, 0x0c, 0xf0, 0x47, 0x00, 0x30, 0x00, 0x00, 0x47, 0x00, 0x3c, 0x0c, 0xf1, 0x03,
+    0x0d, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x30,
+    0x30, 0x30, 0x0c, 0x00, 0x30, 0xdc, 0x10, 0x30, 0x00, 0x00, 0xdc, 0x10, 0x3c, 0x0c, 0x03, 0x03,
+    0x03, 0xc0, 0x00, 0x00, 0x14, 0x41, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x30,
+    0x30, 0x3d, 0x0c, 0x00, 0x30, 0xef, 0x20, 0x30, 0x00, 0x00, 0xef, 0x20, 0x3c, 0x0c, 0x03, 0x03,
+    0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcf, 0x10,
+    0x30, 0xdf, 0x0c, 0x00, 0x30, 0xec, 0x20, 0xf3, 0x00, 0x00, 0xed, 0x20, 0xd7, 0x0c, 0xf1, 0x03,
+    0x0d, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x04, 0xfb, 0x00, 0x9f, 0xff, 0x60, 0x00, 0x00, 0xeb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0x6e, 0xff, 0xff, 0xf7, 0x00, 0x08, 0xff, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0xff, 0xff, 0xff, 0xff, 0x10, 0x0c, 0xff, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x0d, 0xff, 0xff, 0xb5, 0x9f, 0xff, 0x70, 0x0c, 0xff, 0x30, 0x09, 0xff, 0xff, 0xff, 0x60, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x08, 0xff, 0xfb, 0x00, 0x08, 0xff, 0xf1, 0x08, 0xff, 0x10, 0x09, 0xff, 0xff, 0xff, 0x60, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf2, 0x00, 0x00, 0xef, 0xf7, 0x00, 0xd7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf1, 0x00, 0x00, 0xdf, 0xfb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xb0, 0x00, 0x00, 0x8f, 0xff, 0x04, 0xfb, 0x00, 0x00, 0x4e, 0xff, 0xb1, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0x70, 0x00, 0x00, 0x4f, 0xff, 0x0d, 0xff, 0x20, 0x08, 0xff, 0xff, 0xff, 0x20, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0x70, 0x00, 0x00, 0x4f, 0xff, 0x0d, 0xff, 0x30, 0x0f, 0xff, 0x69, 0xff, 0xf0, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xb0, 0x00, 0x00, 0x8f, 0xff, 0x0d, 0xff, 0x30, 0xcf, 0xfb, 0x00, 0xef, 0xf3, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf1, 0x00, 0x00, 0xdf, 0xfb, 0x08, 0xff, 0x30, 0xef, 0xf2, 0x00, 0x8f, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf2, 0x00, 0x00, 0xef, 0xf7, 0x00, 0xef, 0x30, 0xff, 0xf1, 0x00, 0x4f, 0xff, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xfb, 0x00, 0x08, 0xff, 0xf1, 0x00, 0xef, 0x34, 0xff, 0xb0, 0x00, 0x0e, 0xff, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xff, 0xb5, 0x9f, 0xff, 0x70, 0x00, 0xef, 0x38, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xff, 0xff, 0xff, 0xff, 0x10, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xfa, 0xff, 0xff, 0xf7, 0x00, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0xef, 0xfb, 0x60, 0x00, 0x00, 0xef, 0x3c, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x30,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x8f, 0xff, 0x10, 0x00, 0x00, 0xef, 0x38, 0xff, 0x70, 0x00, 0x0d, 0xff, 0x20,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x0e, 0xff, 0x70, 0x00, 0x00, 0xef, 0x34, 0xff, 0xb0, 0x00, 0x0e, 0xff, 0x10,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x08, 0xff, 0xf1, 0x00, 0x00, 0xef, 0x30, 0xff, 0xf1, 0x00, 0x4f, 0xff, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0xef, 0xf7, 0x00, 0x00, 0xef, 0x30, 0xef, 0xf2, 0x00, 0x8f, 0xfb, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x8f, 0xff, 0x10, 0x00, 0xef, 0x30, 0xcf, 0xfb, 0x00, 0xef, 0xf3, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x0e, 0xff, 0x70, 0x00, 0xef, 0x30, 0x0f, 0xff, 0x69, 0xff, 0xf0, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xef, 0xf0, 0x00, 0x08, 0xff, 0xf1, 0x00, 0xef, 0x30, 0x08, 0xff, 0xff, 0xff, 0x20, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0xff, 0xb1, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcf, 0x10,
+    0x30, 0xdf, 0x0c, 0x0c, 0xf0, 0x47, 0x00, 0x30, 0x00, 0x00, 0x47, 0x00, 0x3c, 0x0c, 0xf1, 0x03,
+    0x0d, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x30,
+    0x30, 0x30, 0x0c, 0x00, 0x30, 0xdc, 0x10, 0x30, 0x00, 0x00, 0xdc, 0x10, 0x3c, 0x0c, 0x03, 0x03,
+    0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x30,
+    0x30, 0x3d, 0x0c, 0x00, 0x30, 0xef, 0x20, 0x30, 0x00, 0x00, 0xef, 0x20, 0x3c, 0x0c, 0x03, 0x03,
+    0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcf, 0x10,
+    0x30, 0xdf, 0x0c, 0x00, 0x30, 0xec, 0x20, 0xf3, 0x00, 0x00, 0xed, 0x20, 0xd7, 0x0c, 0xf1, 0x03,
+    0x0d, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
Index: empeg/kernel/arch/i386/boot/compressed/vmlinux
Index: empeg/kernel/drivers/char/Config.in
diff -u empeg/kernel/drivers/char/Config.in:1.15.4.1 empeg/kernel/drivers/char/Config.in:1.17
--- empeg/kernel/drivers/char/Config.in:1.15.4.1	Tue Jun  5 19:34:05 2001
+++ empeg/kernel/drivers/char/Config.in	Tue Sep 26 15:49:13 2000
@@ -165,6 +165,7 @@
     bool '  display is upside-down' CONFIG_EMPEG_DISPLAY_INVERTED
   fi
   bool 'empeg-car power control support' CONFIG_EMPEG_POWER
+  bool 'empeg-car ram test support' CONFIG_EMPEG_RAMTEST
 fi
 
 mainmenu_option next_comment
Index: empeg/kernel/drivers/char/mem.c
diff -u empeg/kernel/drivers/char/mem.c:1.16.6.3 empeg/kernel/drivers/char/mem.c:1.19
--- empeg/kernel/drivers/char/mem.c:1.16.6.3	Tue Jun  5 19:34:22 2001
+++ empeg/kernel/drivers/char/mem.c	Tue Oct 17 17:00:59 2000
@@ -698,6 +698,9 @@
 		extern void empeg_proc_init(void);
 		extern void empeg_cs4231_init(void);
 		extern int empeg_power_init(void);
+#ifdef CONFIG_EMPEG_RAMTEST
+		extern int empeg_ramtest_init(void);
+#endif
 
 #ifdef CONFIG_EMPEG_DISPLAY
 		empeg_display_init();
@@ -706,7 +709,7 @@
 		empeg_dsp_init();
 #endif
 #if defined(CONFIG_EMPEG_DAC)
-		audio_empeg_init();
+		audio_empeg_init();		
 #endif
 #ifdef CONFIG_EMPEG_CS4231
 		empeg_cs4231_init();
@@ -728,6 +731,9 @@
 #endif
 #ifdef CONFIG_EMPEG_POWER
 		empeg_power_init();
+#endif
+#ifdef CONFIG_EMPEG_RAMTEST
+		empeg_ramtest_init();
 #endif
 	}
 #endif
Index: empeg/kernel/drivers/char/radio-empeg.c
diff -u empeg/kernel/drivers/char/radio-empeg.c:1.12.4.1 empeg/kernel/drivers/char/radio-empeg.c:1.15
--- empeg/kernel/drivers/char/radio-empeg.c:1.12.4.1	Thu May  3 17:44:56 2001
+++ empeg/kernel/drivers/char/radio-empeg.c	Tue Oct 17 17:03:07 2000
@@ -5,6 +5,8 @@
  *
  * Authors:
  *   Mike Crowe <mac@empeg.com>
+ *   John Ripley <john@empeg.com>
+ *   Hugo Fiennes <hugo@empeg.com>
  */
 
 #include <linux/module.h>	/* Modules 			*/
@@ -17,27 +19,58 @@
 #include <linux/config.h>
 #include <asm/arch/empeg.h>
 
-#define FLAG_SEARCH (1<<24)
-#define FLAG_SEARCH_UP (1<<23)
-#define FLAG_SEARCH_DOWN (0)
-#define FLAG_MONO (1<<22)
-#define FLAG_STEREO (0)
-#define FLAG_BAND_FM (0)
-#define FLAG_LOCAL (0)
-#define FLAG_DX (1<<19)
-#define FLAG_SENSITIVITY_HIGH (0)
-#define FLAG_SENSITIVITY_MEDIUM (1<<17)
-#define FLAG_SENSITIVITY_LOW (1<<16)
-#define FLAG_SENSITIVITY_VERYLOW ((1<<16)|(1<<17))
-#define FREQUENCY_MASK (0x7fff)
+#include "../arch/arm/special/empeg_mixer.h"
 
+#define RADIO_DEBUG			1
+
+#define FLAG_SEARCH			(1<<24)
+#define FLAG_SEARCH_UP			(1<<23)
+#define FLAG_SEARCH_DOWN		0
+#define FLAG_MONO			(1<<22)
+#define FLAG_STEREO			0
+#define FLAG_BAND_FM			0
+#define FLAG_LOCAL			0
+#define FLAG_DX				(1<<19)
+#define FLAG_SENSITIVITY_HIGH		0
+#define FLAG_SENSITIVITY_MEDIUM		(1<<17)
+#define FLAG_SENSITIVITY_LOW		(1<<16)
+#define FLAG_SENSITIVITY_VERYLOW	((1<<16)|(1<<17))
+#define FREQUENCY_MASK			0x7fff
+/* Sonja has an I2Cesque radio data interface */
+#define RADIO_DATAOUT			GPIO_GPIO10
+#define RADIO_DATAIN			GPIO_GPIO14
+#define RADIO_WRITE			GPIO_GPIO13
+#define RADIO_CLOCK			GPIO_GPIO12
+
+struct empeg_radio_device;
+
+/* external functions */
 void empeg_mixer_clear_stereo(void);
 void empeg_mixer_set_stereo(int on);
-int empeg_mixer_get_stereo(void);
-int empeg_mixer_get_multipath(void);
 
-static int users = 0;
+int __init empeg_radio_init(struct video_init *v);
 
+static int empeg_radio_getsigstr(struct empeg_radio_device *dev);
+static int empeg_radio_getstereo(struct empeg_radio_device *dev);
+
+#ifdef MODULE
+MODULE_AUTHOR("Mike Crowe");
+MODULE_DESCRIPTION("A driver for the empeg-car FM radio.");
+MODULE_SUPPORTED_DEVICE("radio");
+int init_module(void);
+void cleanup_module(void);
+#endif
+
+/* non-exported */
+static void empeg_radio_philips_write_bit(int data);
+static void empeg_radio_philips_write_word(int data);
+static int empeg_radio_philips_update(struct empeg_radio_device *dev,
+				      int search, int direction);
+static int empeg_radio_philips_ioctl(struct video_device *dev,
+				     unsigned int cmd, void *arg);
+static int empeg_radio_philips_open(struct video_device *dev, int flags);
+static void empeg_radio_philips_close(struct video_device *dev);
+
 struct empeg_radio_device
 {
 	/* Eventually we need to put lock strength, stereo/mono
@@ -48,14 +81,36 @@
 	int sensitivity;
 };
 
-/* Sonja has an I2Cesque radio data interface */
-#define RADIO_DATAOUT   GPIO_GPIO10
-#define RADIO_DATAIN    GPIO_GPIO14
-#define RADIO_WRITE     GPIO_GPIO13
-#define RADIO_CLOCK     GPIO_GPIO12
+
+static int use_count = 0;
+
 
-static void philips_radio_writebit(int data)
+/**********************************************************************
+ * Global stuff
+ **********************************************************************/
+
+static int empeg_radio_getsigstr(struct empeg_radio_device *dev)
 {
+	unsigned signal = empeg_mixer_get_fm_level();
+	if ((signal < 0) || (signal > 131071)) signal = 0;
+	else {
+		signal >>= 1;	/* 18 bits signed -> 16 bits unsigned */
+	}
+	return (int) signal;
+}
+
+int empeg_radio_getstereo(struct empeg_radio_device *dev)
+{
+	return empeg_mixer_get_stereo();
+}
+
+
+/**********************************************************************
+ * Philips DSP based I2C interface
+ **********************************************************************/
+
+static void empeg_radio_philips_write_bit(int data)
+{
 	if (data)
 		GPCR=EMPEG_RADIODATA;
 	else
@@ -66,7 +121,7 @@
 	udelay(7);
 }
 
-static void philips_radio_writeword(int data)
+static void empeg_radio_philips_write_word(int data)
 {
 	int a;
 	
@@ -75,7 +130,7 @@
 	udelay(10);
 	
 	/* Clock out a 25-bit frame */
-	for(a=24;a>=0;a--) philips_radio_writebit(data&(1<<a));
+	for(a=24;a>=0;a--) empeg_radio_philips_write_bit(data&(1<<a));
 	
 	/* Ensure radio data is floating again */
 	GPCR=RADIO_DATAOUT;
@@ -84,7 +139,8 @@
 	GPCR=RADIO_WRITE;
 }
 
-static int empeg_philips_radio_update(struct empeg_radio_device *dev, int search, int direction)
+static int empeg_radio_philips_update(struct empeg_radio_device *dev,
+				      int search, int direction)
 {
 	int word = 0;
 
@@ -140,23 +196,14 @@
 		divisor>>=1;
 	}
 	
-	philips_radio_writeword(word);
+	empeg_radio_philips_write_word(word);
 
 	return 0;
 }
 
-int empeg_philips_radio_getsigstr(struct empeg_radio_device *dev)
+static int empeg_radio_philips_ioctl(struct video_device *dev,
+				     unsigned int cmd, void *arg)
 {
-	return empeg_mixer_get_fm_level();
-}
-
-int empeg_philips_radio_getstereo(struct empeg_radio_device *dev)
-{
-	return empeg_mixer_get_stereo();
-}
-
-static int empeg_philips_radio_ioctl(struct video_device *dev, unsigned int cmd, void *arg)
-{
 	struct empeg_radio_device *radio=dev->priv;
 	
 	switch(cmd)
@@ -187,10 +234,10 @@
 		v.rangelow = 87500000;
 		v.rangehigh = 108000000;
 		v.flags = 0;
-		if(empeg_philips_radio_getstereo(radio))
+		if(empeg_radio_getstereo(radio))
 			v.flags |= VIDEO_TUNER_STEREO_ON;
 		v.mode = VIDEO_MODE_AUTO;
-		v.signal = empeg_philips_radio_getsigstr(radio);
+		v.signal = empeg_radio_getsigstr(radio);
 
 		if(copy_to_user(arg,&v, sizeof(v)))
 			return -EFAULT;
@@ -213,8 +260,8 @@
 	case VIDIOCSFREQ:
 		if(copy_from_user(&radio->freq, arg,sizeof(radio->freq)))
 			return -EFAULT;
-		empeg_philips_radio_update(radio, FALSE, 0);
-		empeg_mixer_clear_stereo(); // reset stereo level to 0
+		empeg_radio_philips_update(radio, FALSE, 0);
+		empeg_mixer_clear_stereo(); /* reset stereo level to 0 */
 		return 0;
 	case VIDIOCGAUDIO:
 	{	
@@ -241,41 +288,48 @@
 			radio->mono = TRUE;
 		else
 			radio->mono = FALSE;
-		empeg_philips_radio_update(radio, FALSE, 0);
+		empeg_radio_philips_update(radio, FALSE, 0);
 		return 0;
 	}
 	case EMPEG_RADIO_READ_MONO:
-		copy_to_user_ret(arg, &(radio->mono), sizeof(radio->mono), -EFAULT);
+		copy_to_user_ret(arg, &(radio->mono), sizeof(radio->mono),
+				 -EFAULT);
 		return 0;
 
 	case EMPEG_RADIO_WRITE_MONO:
-		copy_from_user_ret(&(radio->mono), arg, sizeof(radio->mono), -EFAULT);
-		empeg_philips_radio_update(radio, FALSE, 0);
+		copy_from_user_ret(&(radio->mono), arg, sizeof(radio->mono),
+				   -EFAULT);
+		empeg_radio_philips_update(radio, FALSE, 0);
 		return 0;
 
 	case EMPEG_RADIO_READ_DX:
-		copy_to_user_ret(arg, &(radio->dx), sizeof(radio->dx), -EFAULT);
+		copy_to_user_ret(arg, &(radio->dx), sizeof(radio->dx),
+				 -EFAULT);
 		return 0;
 
 	case EMPEG_RADIO_WRITE_DX:
-		copy_from_user_ret(&(radio->dx), arg, sizeof(radio->dx), -EFAULT);
-		empeg_philips_radio_update(radio, FALSE, 0);
+		copy_from_user_ret(&(radio->dx), arg, sizeof(radio->dx),
+				   -EFAULT);
+		empeg_radio_philips_update(radio, FALSE, 0);
 		return 0;
 
 	case EMPEG_RADIO_READ_SENSITIVITY:
-		copy_to_user_ret(arg, (&radio->sensitivity), sizeof(radio->sensitivity), -EFAULT);
+		copy_to_user_ret(arg, (&radio->sensitivity),
+				 sizeof(radio->sensitivity), -EFAULT);
 		return 0;
 
 	case EMPEG_RADIO_WRITE_SENSITIVITY:
-		copy_from_user_ret(&(radio->sensitivity), arg, sizeof(radio->sensitivity), -EFAULT);
-		empeg_philips_radio_update(radio, FALSE, 0);
+		copy_from_user_ret(&(radio->sensitivity), arg,
+				   sizeof(radio->sensitivity), -EFAULT);
+		empeg_radio_philips_update(radio, FALSE, 0);
 		return 0;
 
 	case EMPEG_RADIO_SEARCH:
 	{
 		int direction;
-		copy_from_user_ret(&direction, arg, sizeof(direction), -EFAULT);
-		empeg_philips_radio_update(radio, TRUE, direction);
+		copy_from_user_ret(&direction, arg, sizeof(direction),
+				   -EFAULT);
+		empeg_radio_philips_update(radio, TRUE, direction);
 		return 0;
 	}
 	case EMPEG_RADIO_GET_MULTIPATH: {
@@ -295,66 +349,68 @@
 	}
 }
 
-static int empeg_philips_radio_open(struct video_device *dev, int flags)
+static int empeg_radio_philips_open(struct video_device *dev, int flags)
 {
-	if(users)
+	if(use_count)
 		return -EBUSY;
-	users++;
+	use_count++;
 	MOD_INC_USE_COUNT;
 	return 0;
 }
 
-static void empeg_philips_radio_close(struct video_device *dev)
+static void empeg_radio_philips_close(struct video_device *dev)
 {
-	users--;
+	use_count--;
 	MOD_DEC_USE_COUNT;
 }
 
+
+/**********************************************************************
+ * Generic stuff
+ **********************************************************************/
+
 static struct empeg_radio_device empeg_unit;
 
-static struct video_device empeg_philips_radio=
-{
+static struct video_device empeg_radio_philips = {
 	"empeg Philips FM radio",
 	VID_TYPE_TUNER,
 	VID_HARDWARE_RTRACK,
-	empeg_philips_radio_open,
-	empeg_philips_radio_close,
+	empeg_radio_philips_open,
+	empeg_radio_philips_close,
 	NULL,	/* Can't read  (no capture ability) */
 	NULL,	/* Can't write */
 	NULL,	/* No poll */
-	empeg_philips_radio_ioctl,
+	empeg_radio_philips_ioctl,
 	NULL,
 	NULL
 };
 
+
 int __init empeg_radio_init(struct video_init *v)
 {
-	if (empeg_hardwarerevision() < 6) {
-		empeg_philips_radio.priv = &empeg_unit;
-		
-		empeg_unit.freq = 87500000;
-		empeg_unit.dx = 1;
-		empeg_unit.mono = 0;
-		empeg_unit.sensitivity = 10;
-		
-		if(video_register_device(&empeg_philips_radio, VFL_TYPE_RADIO)==-1)
-			return -EINVAL;
-		
-		printk(KERN_INFO "empeg FM radio driver (Philips).\n");
-		
-	} else {
-		printk(KERN_INFO "empeg FM radio not present\n");
-		return -EINVAL;
+	/* silly run-time check */
+	if (empeg_hardwarerevision() >= 6) {
+		/* Silently drop Mk.2 */
+		return 0;
 	}
 
+	empeg_radio_philips.priv = &empeg_unit;
+		
+	empeg_unit.freq = 87500000;
+	empeg_unit.dx = 1;
+	empeg_unit.mono = 0;
+	empeg_unit.sensitivity = 10;
+	
+	if(video_register_device(&empeg_radio_philips,
+				 VFL_TYPE_RADIO) == -1)
+		return -EINVAL;
+	
+	printk(KERN_INFO "empeg FM radio driver (Philips).\n");
+		
 	return 0;
 }
 
 #ifdef MODULE
-
-MODULE_AUTHOR("Mike Crowe");
-MODULE_DESCRIPTION("A driver for the empeg-car FM radio.");
-MODULE_SUPPORTED_DEVICE("radio");
 
 EXPORT_NO_SYMBOLS;
 
Index: empeg/kernel/fs/Config.in
diff -u empeg/kernel/fs/Config.in:1.3 empeg/kernel/fs/Config.in:1.4
--- empeg/kernel/fs/Config.in:1.3	Sun Jun 11 17:01:29 2000
+++ empeg/kernel/fs/Config.in	Fri Oct 20 15:54:48 2000
@@ -54,6 +54,16 @@
 if [ "$CONFIG_UFS_FS" != "n" ]; then
   bool '   UFS filesystem write support (experimental)' CONFIG_UFS_FS_WRITE
 fi
+
+#reiserfs support
+tristate 'Reiserfs support' CONFIG_REISERFS_FS
+if [ "$CONFIG_REISERFS_FS" = "y" -o "$CONFIG_REISERFS_FS" = "m" ]; then 
+
+    choice 'Reiserfs hash function' \
+           "tea_hash  CONFIG_CRYPTO_SECURE_HASH \
+	    rupasov_hash  CONFIG_YRH_HASH" tea_hash     
+fi
+
 if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
   tristate 'SGI EFS filesystem support (read only) (experimental)' CONFIG_EFS_FS
   if [ "$CONFIG_EFS_FS" != "n" ]; then
Index: empeg/kernel/fs/Makefile
diff -u empeg/kernel/fs/Makefile:1.1.1.2 empeg/kernel/fs/Makefile:1.2
--- empeg/kernel/fs/Makefile:1.1.1.2	Thu Sep 30 13:24:55 1999
+++ empeg/kernel/fs/Makefile	Fri Oct 20 15:54:49 2000
@@ -18,7 +18,7 @@
 MOD_LIST_NAME := FS_MODULES
 ALL_SUB_DIRS = coda minix ext2 fat msdos vfat proc isofs nfs umsdos ntfs \
 		hpfs sysv smbfs ncpfs ufs affs romfs autofs hfs lockd \
-		nfsd nls devpts adfs partitions qnx4 efs
+		nfsd nls devpts adfs partitions qnx4 efs reiserfs
 
 SUB_DIRS := partitions
 
@@ -246,6 +246,14 @@
 else
   ifeq ($(CONFIG_DEVPTS_FS),m)
   MOD_SUB_DIRS += devpts
+  endif
+endif
+
+ifeq ($(CONFIG_REISERFS_FS),y)
+SUB_DIRS += reiserfs
+else
+  ifeq ($(CONFIG_REISERFS_FS),m)
+  MOD_SUB_DIRS += reiserfs
   endif
 endif
 
Index: empeg/kernel/fs/buffer.c
diff -u empeg/kernel/fs/buffer.c:1.1.1.3 empeg/kernel/fs/buffer.c:1.2
--- empeg/kernel/fs/buffer.c:1.1.1.3	Sat Mar 18 15:23:17 2000
+++ empeg/kernel/fs/buffer.c	Fri Oct 20 15:54:49 2000
@@ -1924,3 +1924,5 @@
 		sync_old_buffers();
 	}
 }
+
+#include "reiserfs/buffer.c"
Index: empeg/kernel/fs/filesystems.c
diff -u empeg/kernel/fs/filesystems.c:1.1.1.3 empeg/kernel/fs/filesystems.c:1.2
--- empeg/kernel/fs/filesystems.c:1.1.1.3	Sat Mar 18 15:23:17 2000
+++ empeg/kernel/fs/filesystems.c	Fri Oct 20 15:54:49 2000
@@ -29,6 +29,7 @@
 #include <linux/ntfs_fs.h>
 #include <linux/hfs_fs.h>
 #include <linux/devpts_fs.h>
+#include <linux/reiserfs_fs.h>
 #include <linux/major.h>
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
@@ -57,6 +58,10 @@
 
 #ifdef CONFIG_MINIX_FS
 	init_minix_fs();
+#endif
+
+#ifdef CONFIG_REISERFS_FS
+	init_reiserfs_fs();
 #endif
 
 #ifdef CONFIG_ROMFS_FS
Index: empeg/kernel/fs/inode.c
diff -u empeg/kernel/fs/inode.c:1.1.1.3 empeg/kernel/fs/inode.c:1.2
--- empeg/kernel/fs/inode.c:1.1.1.3	Sat Mar 18 15:23:17 2000
+++ empeg/kernel/fs/inode.c	Fri Oct 20 15:54:49 2000
@@ -45,7 +45,7 @@
  * allowing for low-overhead inode sync() operations.
  */
 
-LIST_HEAD(inode_in_use);
+/*static*/ LIST_HEAD(inode_in_use);
 static LIST_HEAD(inode_unused);
 static struct list_head inode_hashtable[HASH_SIZE];
 
@@ -100,7 +100,7 @@
 	}
 }
 
-static void __wait_on_inode(struct inode * inode)
+/*static*/ void __wait_on_inode(struct inode * inode)
 {
 	struct wait_queue wait = { current, NULL };
 
Index: empeg/kernel/fs/super.c
diff -u empeg/kernel/fs/super.c:1.1.1.3 empeg/kernel/fs/super.c:1.2
--- empeg/kernel/fs/super.c:1.1.1.3	Sat Mar 18 15:23:17 2000
+++ empeg/kernel/fs/super.c	Wed Oct 17 15:51:36 2001
@@ -50,6 +50,10 @@
 extern int root_mountflags;
 extern void rd_load_secondary(void);
 
+#ifdef CONFIG_SA1100_EMPEG
+extern void display_bootfail(void);
+#endif
+
 static int do_remount_sb(struct super_block *sb, int flags, char * data);
 
 /* this is initialized in init/main.c */
@@ -1233,6 +1237,9 @@
 			panic("VFS: add_vfsmnt failed for root fs");
 		}
 	}
+#ifdef CONFIG_SA1100_EMPEG
+	display_bootfail();
+#endif
 	panic("VFS: Unable to mount root fs on %s",
 		kdevname(ROOT_DEV));
 }
Index: empeg/kernel/fs/reiserfs/Makefile
diff -u /dev/null empeg/kernel/fs/reiserfs/Makefile:1.1
--- /dev/null	Wed Oct 17 16:36:05 2001
+++ empeg/kernel/fs/reiserfs/Makefile	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,19 @@
+#
+# Makefile for the linux reiser-filesystem routines.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definitions are now in the main makefile...
+
+O_TARGET := reiserfs.o
+O_OBJS   := bitmap.o do_balan.o namei.o inode.o file.o dir.o symlink.o fix_node.o preserve.o super.o prints.o objectid.o version.o \
+lbalance.o ibalance.o stree.o teahash3.o buffer2.o lock.o journal.o resize.o
+M_OBJS   := $(O_TARGET)
+
+include $(TOPDIR)/Rules.make
+
+TAGS:
+	etags *.c
+
Index: empeg/kernel/fs/reiserfs/README
diff -u /dev/null empeg/kernel/fs/reiserfs/README:1.1
--- /dev/null	Wed Oct 17 16:36:05 2001
+++ empeg/kernel/fs/reiserfs/README	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,124 @@
+Reiserfs is a file system based on balanced tree algorithms, which is described at http://devlinux.com/namesys.
+
+Stop reading here.  Go there, then return.
+
+Send bug reports to reiser@idiom.com, or vs@namesys.botik.ru, or both.
+
+mkreiserfs and other utilities are in reiserfs/utils, or wherever your
+Linux provider put them.  Note that some of the utilities cannot be
+compiled without accessing to the balancing code which is in the kernel
+code, and relocating the utilities may require you to specify where that
+code can be found.
+
+Try turning REISERFS_CHECK in reiserfs_fs.h on or off if you want error
+checking or speed, respectively.  Real users, as opposed to folks who
+want to hack, will want it off.
+
+[LICENSE] ReiserFS is hereby licensed under the GNU General
+Public License version 2.  Please see the file "COPYING"
+which should have accompanied this software distribution for
+details of that license.
+
+Since that license (particularly 2.b) is necessarily vague in certain
+areas due to its generality, the following interpretations shall govern.
+Some may consider these terms to be a supplemental license to the GPL.
+You may include ReiserFS in a Linux kernel which you may then include
+with anything, and you may even include it with a Linux kernel with
+non-GPL'd kernel modules.  You may include it in any kernel which is
+wholly GPL'd including its kernel modules which you may then include
+with anything.  If you wish to use it for a kernel which you sell usage
+or copying licenses for, which is not listed above, then you must obtain
+an additional license.  If you wish to integrate it with any other
+software system which is not GPL'd, without integrating it into an
+operating system kernel, then you must obtain an additional license.
+This is an interpretation of what is and is not part of the software
+program falling under the GPL section 2.b., and is intended as a
+specification of (with a slight supplement to), not an exception to, the
+GPL as applied to this particular piece of software.
+
+Further licensing options are available for commercial and/or other
+interests directly from Hans Reiser:  reiser@idiom.com.  If you
+interpret the GPL as not allowing those additional licensing options,
+you read it wrongly, when carefully read you can see that those
+restrictions on additional terms do not apply to the owner of the
+copyright, and my interpretation of this shall govern for this license.
+
+[END LICENSE]
+
+I try to find ways to make money for those who contribute to this code.
+My success in such efforts cannot be guaranteed though:-).  You are
+encouraged to add to it.  If you ask me to include it in my standard
+distribution, and you don't request an exception to this (if you want
+the exception, talk to me about it, don't be shy), you give ownership of
+the copyright to me, and you consent to my marketing exceptions to the
+GPL.  If you want to market it as part of a system you sell, please
+contact me.  
+
+Hideous Commercial Pitch: Spread your development costs across other OS
+vendors.  Select from the best in the world, not the best in your
+building, by buying from third party OS component suppliers.  Leverage
+the software component development power of the internet.  Be the most
+aggressive in taking advantage of the commercial possibilities of
+decentralized internet development, and add value through your branded
+integration that you sell as an operating system.  Let your competitors
+be the ones to compete against the entire internet by themselves.  Be
+hip, get with the new economic trend, before your competitors do.  Send
+email to reiser@idiom.com.
+
+To understand the code, after reading the website, start reading the
+code by reading reiserfs_fs.h first.
+
+Hans Reiser was the project initiator, primary architect, source of all
+funding for the first 5.5 years, and one of the programmers.  He owns
+the copyright.
+
+Vladimir Saveljev was one of the programmers, and he worked long hours
+writing the cleanest code.  He always made the effort to be the best he
+could be, and to make his code the best that it could be.  What resulted
+was quite remarkable. I don't think that money can ever motivate someone
+to work the way he did, he is one of the most selfless men I know.
+
+Yura joined us near the end of our project, and helped with such things
+as integrating hashing back into the code, and benchmarking different
+pieces of code to help with tuning analysis.
+
+Anatoly Pinchuk is a former member of our team who worked closely with
+Vladimir throughout the project's development.  He wrote a quite
+substantial portion of the total code.  He realized that there was a
+space problem with packing tails of files for files larger than a node
+that start on a node aligned boundary (there are reasons to want to node
+align files), and he invented and implemented indirect items and
+unformatted nodes as the solution.
+
+Two other former employees were involved who won't be getting credit
+here because they tried to kill the project at the end of it, and almost
+succeeded (they cost me maybe two years).  They wanted to force me to
+sell it to the company they tried to start.  They get to keep the money
+they got from me, and that is it.  When their "VC" said that he could
+get a hundred researchers to swear in Russian Court that I had had
+nothing to do with the development of treefs, I changed the name to
+reiserfs and registered the copyright.
+
+Grigory Zaigralin was an extremely effective system administrator for our group.
+
+Igor Krasheninnikov was wonderful at hardware procurement, repair, and
+network installation.
+
+Jeremy Fitzhardinge wrote the teahash.c code, and he gives credit to a
+textbook he got the algorithm from in the code.  Note that his analysis
+of how we could use the hashing code in making 32 bit NFS cookies work
+was probably more important than the actual algorithm.  Colin Plumb also
+contributed to it.
+
+Chris Mason dived right into our code, and in just a few months produced
+the journaling code that dramatically increased the value of ReiserFS.
+He is just an amazing programmer.
+
+Igor Zagorovsky is writing much of the new item handler and extent code
+for our next major release.
+
+Ecila, MP3, and SuSE (in chronological order) made it possible for me to
+not have a day job anymore, and to dramatically increase our staffing.
+Ecila funded hypertext feature development, MP3 funded journaling, and
+SuSE funded core development.  SuSE has helped in much more than just
+funding....
Index: empeg/kernel/fs/reiserfs/bitmap.c
diff -u /dev/null empeg/kernel/fs/reiserfs/bitmap.c:1.1
--- /dev/null	Wed Oct 17 16:36:05 2001
+++ empeg/kernel/fs/reiserfs/bitmap.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,411 @@
+/*
+ * Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
+ */
+#ifdef __KERNEL__
+
+#include <linux/sched.h>
+#include <linux/reiserfs_fs.h>
+#include <linux/locks.h>
+#include <asm/bitops.h>
+
+#else
+
+#include "nokernel.h"
+
+#endif
+
+
+#ifdef REISERFS_CHECK
+#if 0
+static void check_bitmap (struct super_block * s)
+{
+  int i = 0;
+  int free = 0;
+  char * buf;
+
+  while (i < SB_BLOCK_COUNT (s)) {
+    buf = SB_AP_BITMAP (s)[i / (s->s_blocksize * 8)]->b_data;
+    if (!test_bit (i % (s->s_blocksize * 8), buf))
+      free ++;
+    i ++;
+  }
+
+  if (free != SB_FREE_BLOCKS (s))
+    reiserfs_warning ("vs-4000: check_bitmap: %d free blocks, must be %d\n",
+		      free, SB_FREE_BLOCKS (s));
+}
+#endif
+
+
+/* this checks, that block can be reused, and it has correct state
+   (free or busy) */
+int is_reusable (struct super_block * s, unsigned long block, int bit_value)
+{
+  int i, j;
+  
+  if (block == 0 || block >= SB_BLOCK_COUNT (s)) {
+    printk ("REISERFS: block number is out of range %lu (%u)\n",
+	    block, SB_BLOCK_COUNT (s));
+    return 0;
+  }
+
+  /* it can't be one of the bitmap blocks */
+  for (i = 0; i < le16_to_cpu (SB_BMAP_NR (s)); i ++)
+    if (block == SB_AP_BITMAP (s)[i]->b_blocknr) {
+      printk ("REISERFS: bitmap block %lu(%u) can't be freed or reused\n", block, le16_to_cpu (SB_BMAP_NR (s)));
+      return 0;
+    }
+  
+  i = block / (s->s_blocksize << 3);
+  if (i >= le32_to_cpu (SB_BMAP_NR (s))) {
+    printk ("REISERFS: there is no so many bitmap blocks: block=%lu, bitmap_nr=%d\n", block, i);
+    return 0;
+  }
+
+  j = block % (s->s_blocksize << 3);
+  if ((bit_value == 0 && test_bit (j, SB_AP_BITMAP (s)[i]->b_data)) ||
+      (bit_value == 1 && test_bit (j, SB_AP_BITMAP (s)[i]->b_data) == 0)) {
+    printk ("REISERFS: corresponding bit of block %lu does not match required value (i==%d, j==%d) test_bit==%d\n",
+	    block, i, j, test_bit (j, SB_AP_BITMAP (s)[i]->b_data));
+    return 0;
+  }
+
+  if (bit_value == 0 && block == SB_ROOT_BLOCK (s)) {
+    printk ("REISERFS: this is root block (%u), it must be busy", SB_ROOT_BLOCK (s));
+    return 0;
+  }
+
+  return 1;
+}
+
+#endif /* REISERFS_CHECK */
+
+
+/* get address of corresponding bit (bitmap block number and offset in it) */
+static inline void get_bit_address (struct super_block * s, unsigned long block, int * bmap_nr, int * offset)
+{
+                                /* It is in the bitmap block number equal to the block number divided by the number of
+                                   bits in a block. */
+  *bmap_nr = block / (s->s_blocksize << 3);
+                                /* Within that bitmap block it is located at bit offset *offset. */
+  *offset = block % (s->s_blocksize << 3);
+  return;
+}
+
+
+/* There would be a modest performance benefit if we write a version
+   to free a list of blocks at once. -Hans */
+void reiserfs_free_block (struct reiserfs_transaction_handle *th, struct super_block * s, unsigned long block)
+{
+  struct reiserfs_super_block * rs;
+  struct buffer_head * sbh;
+  struct buffer_head ** apbh;
+  int nr, offset;
+
+#ifdef REISERFS_CHECK
+  if (!s)
+    reiserfs_panic (s, "vs-4005: reiserfs_free_block: trying to free block on nonexistent device");
+
+  if (is_reusable (s, block, 1) == 0)
+    reiserfs_panic (s, "vs-4010: reiserfs_free_block: can not free such block");
+#endif
+
+  rs = SB_DISK_SUPER_BLOCK (s);
+  sbh = SB_BUFFER_WITH_SB (s);
+  apbh = SB_AP_BITMAP (s);
+
+  get_bit_address (s, block, &nr, &offset);
+
+  /* mark it before we clear it, just in case */
+  journal_mark_freed(th, s, block) ;
+
+  /* clear bit for the given block in bit map */
+  if (!test_and_clear_bit (offset, apbh[nr]->b_data)) {
+    printk ("bitmap-124: reiserfs_free_block: free_block (%04x:%lu)[dev:blocknr]: bit already cleared\n", 
+	    s->s_dev, block);
+  }
+
+  /* clear bit in cautious bitmap */
+  /* clear_bit (offset, SB_AP_CAUTIOUS_BITMAP (s)[nr]->b_data); journal victim */
+
+  /* update super block */
+  rs->s_free_blocks = cpu_to_le32 (le32_to_cpu (rs->s_free_blocks) + 1);
+
+  journal_mark_dirty (th, s, sbh);/* no need to place buffer on preserve list */
+  journal_mark_dirty (th, s, apbh[nr]);/* no need to place buffer on preserve list */
+  s->s_dirt = 1;
+}
+
+
+
+/* beginning from offset-th bit in bmap_nr-th bitmap block,
+   find_forward finds the closest zero bit. It returns 1 and zero
+   bit address (bitmap, offset) if zero bit found or 0 if there is no
+   zero bits in forward direction */
+static int find_forward (struct super_block * s, int * bmap_nr, int * offset, int * repeat, int for_unformatted)
+{
+  int i, j;
+  struct buffer_head * bh;
+  unsigned long block_to_try = 0;
+  unsigned long next_block_to_try = 0 ;
+
+  for (i = *bmap_nr; i < SB_BMAP_NR (s); i ++, *offset = 0) {
+    /* get corresponding bitmap block */
+    bh = SB_AP_BITMAP (s)[i];
+    (*repeat) |= test_and_wait_on_buffer(bh) ;
+retry:
+    j = find_next_zero_bit ((unsigned long *)bh->b_data, s->s_blocksize << 3, *offset);
+
+    /* wow, this really needs to be redone.  We can't allocate a block if
+    ** it is in the journal somehow.  reiserfs_in_journal makes a suggestion
+    ** for a good block if the one you ask for is in the journal.  Note,
+    ** reiserfs_in_journal might reject the block it suggests.  The big
+    ** gain from the suggestion is when a big file has been deleted, and
+    ** many blocks show free in the real bitmap, but are all not free
+    ** in the journal list bitmaps.
+    **
+    ** this whole system sucks.  The bitmaps should reflect exactly what
+    ** can and can't be allocated, and the journal should update them as
+    ** it goes.  TODO.
+    */
+    if (j < (s->s_blocksize << 3)) {
+      block_to_try = (i * (s->s_blocksize << 3)) + j; 
+
+      /* the block is not in the journal, we can proceed */
+      if (!(reiserfs_in_journal(s, s->s_dev, block_to_try, s->s_blocksize, for_unformatted, &next_block_to_try))) {
+	*bmap_nr = i;
+	*offset = j;
+	return 1;
+      } 
+      /* the block is in the journal */
+      else if ((j+1) < (s->s_blocksize << 3)) { /* try again */
+	/* reiserfs_in_journal suggested a new block to try */
+	if (next_block_to_try > 0) {
+	  int new_i ;
+	  get_bit_address (s, next_block_to_try, &new_i, offset);
+
+	  /* block is not in this bitmap. reset i and continue
+	  ** we only reset i if new_i is in a later bitmap.
+	  */
+	  if (new_i > i) {
+	    i = (new_i - 1 ); /* i gets incremented by the for loop */
+	    continue ;
+	  }
+	} else {
+	  /* no suggestion was made, just try the next block */
+	  *offset = j+1 ;
+	}
+	goto retry ;
+      }
+    }
+  }
+  /* zero bit not found */
+  return 0;
+}
+
+                                /* return 0 if no free blocks, else return 1 */
+static int find_zero_bit_in_bitmap (struct super_block * s, unsigned long search_start, int * bmap_nr, int * offset, 
+				    int * repeat, int for_unformatted)
+{
+  int retry_count = 0 ;
+  /* get bit location (bitmap number and bit offset) of search_start block */
+  get_bit_address (s, search_start, bmap_nr, offset);
+
+    /* note that we search forward in the bitmap, benchmarks have shown that it is better to allocate in increasing
+       sequence, which is probably due to the disk spinning in the forward direction.. */
+    if (find_forward (s, bmap_nr, offset, repeat, for_unformatted) == 0) {
+      /* there wasn't a free block with number greater than our
+         starting point, so we are going to go to the beginning of the disk */
+
+retry:
+      search_start = 0; /* caller will reset search_start for itself also. */
+      get_bit_address (s, search_start, bmap_nr, offset);
+      if (find_forward (s, bmap_nr, offset, repeat, for_unformatted) == 0) {
+	if (for_unformatted) {
+	  if (retry_count == 0) {
+	    /* we've got a chance that flushing async commits will free up
+	    ** some space.  Sync then retry
+	    */
+	    flush_async_commits(s, repeat) ;
+	    retry_count++ ;
+	    goto retry ;
+	  } else if (retry_count > 0) {
+	    /* nothing more we can do.  Make the others wait, flush
+	    ** all log blocks to disk, and flush to their home locations.
+	    ** this will free up any blocks held by the journal
+	    */
+	    SB_JOURNAL(s)->j_must_wait = 1 ;
+	  }
+	}
+        return 0;
+      }
+    }
+  return 1;
+}
+
+/* get amount_needed free block numbers from scanning the bitmap of free/used blocks.
+   
+   Optimize layout by trying to find them starting from search_start
+   and moving in elevator_direction, until a free block or the disk
+   edge is reached, and then if the edge was reached, changing the
+   elevator direction, and looking backwards from search_start.
+
+   search_start is the block number of the current node if we are
+   creating a new node, and it is the block number of the left
+   semantic neighbor of the current node if we are relocating a node
+   (using the write next to algorithm).  
+
+   If no free blocks are found, and there are blocks on the preserve
+   list, run sync_buffers() to free them.
+   
+   Note that when we free the preserve list we free all members of the
+   free_blocknrs array that we have gotten so far, on the assumption
+   that the freeing was likely to have created a better choice of
+   blocknrs, since needing to free implies that there were few free
+   ones to choose from, and that in turn implies that they were likely
+   to be poor choices, but if schedule occurs because of lock then we
+   guess that the old values are likely enough to be good that we
+   should not bother to see if we get better ones and save on the CPU
+   consumption and code size.  I don't know if this is correct, but it
+   seems unlikely to really matter much.
+
+   return 0 if everything is ok
+   return NO_DISK_SPACE if out of disk space,
+   or SCHEDULE_OCCURED
+   
+   return block numbers found, in the array free_blocknrs.  assumes
+   that any non-zero entries already present in the array are valid.
+
+   if number of free blocks is less than RESERVED_FOR_PRESERVE_LIST, we try to
+   get_space_from_preserve_list, because we do not want to lose free
+   blocks, that are reserved for the preserve list
+
+   If number of free blocks + number of preserved blocks is less than
+   RESERVED_FOR_PRESERVE_LIST, than reiserfs_new_blocknrs will fail until it is used for
+   preserve list
+
+   reiserfsck has its own reiserfs_new_blocknrs, which can use RESERVED_FOR_PRESERVE_LIST blocks
+*/
+
+static int do_reiserfs_new_blocknrs (struct reiserfs_transaction_handle *th, struct super_block * s, unsigned long * free_blocknrs, 
+			   unsigned long search_start, int amount_needed, int for_preserve_list, int for_unformatted)
+{
+  int i, j;
+  int retval = CARRY_ON;	/* it is set to SCHEDULE_OCCURED when
+				   get_space_from_preserve_list ran,
+				   or NO_DISK_SPACE when .. */
+  unsigned long * block_list_start = free_blocknrs;
+  int init_amount_needed = amount_needed;
+
+/*
+  if (SB_FREE_BLOCKS (s) < RESERVED_FOR_PRESERVE_LIST) {
+    get_space_from_preserve_list (s);
+    retval = SCHEDULE_OCCURRED;
+  }
+*/
+
+  if (SB_FREE_BLOCKS (s) < RESERVED_FOR_PRESERVE_LIST && !for_preserve_list) {
+    /* there is some free space just to keep preserve list working */
+    return NO_DISK_SPACE;
+  }
+
+#ifdef REISERFS_CHECK
+  if (!s)
+    reiserfs_panic (s, "vs-4020: reiserfs_new_blocknrs: trying to get new block from nonexistent device");
+
+  if (search_start == MAX_B_NUM)
+    reiserfs_panic (s, "vs-4025: reiserfs_new_blocknrs: we are optimizing location based on "
+		    "the bogus location of a temp buffer (%lu).", search_start);
+
+  if (amount_needed < 1 || amount_needed > MAX_PRESERVE_NODES) 
+    reiserfs_panic (s, "vs-4030: reiserfs_new_blocknrs: amount_needed parameter incorrect (%d)", amount_needed);
+#endif /* REISERFS_CHECK */
+
+  /* We continue the while loop if another process snatches our found
+   * free block from us after we find it but before we successfully
+   * mark it as in use, or if we need to use sync to free up some
+   * blocks on the preserve list.  */
+
+  while (amount_needed--) {
+    /* skip over any blocknrs already gotten last time. */
+    if (*(free_blocknrs) != 0) {
+#ifdef REISERFS_CHECK
+      if (is_reusable (s, *free_blocknrs, 1) == 0)
+	reiserfs_panic(s, "vs-4035: reiserfs_new_blocknrs: bad blocknr on free_blocknrs list");
+#endif /* REISERFS_CHECK */
+      free_blocknrs++;
+      continue;
+    }
+    /* look for zero bits in bitmap */
+    if (find_zero_bit_in_bitmap (s, search_start, &i, &j, &retval, for_unformatted) == 0) {
+      if (find_zero_bit_in_bitmap (s, search_start, &i, &j, &retval, for_unformatted) == 0) {
+	for ( ; block_list_start != free_blocknrs; block_list_start++) {
+	  reiserfs_free_block (th, s, *block_list_start);
+	  COMPLETE_BITMAP_DIRTING_AFTER_FREEING(s,*block_list_start / (s->s_blocksize * 8));
+	  *block_list_start = 0;
+	}
+	return NO_DISK_SPACE;
+      }
+    }
+    
+    /* i and j now contain the results of the search. i = bitmap block
+       number containing free block, j = offset in this block.  we
+       compute the blocknr which is our result, store it in
+       free_blocknrs, and increment the pointer so that on the next
+       loop we will insert into the next location in the array.  Also
+       in preparation for the next loop, search_start is changed so
+       that the next search will not rescan the same range but will
+       start where this search finished.  Note that while it is
+       possible that schedule has occurred and blocks have been freed
+       in that range, it is perhaps more important that the blocks
+       returned be near each other than that they be near their other
+       neighbors, and it also simplifies and speeds the code this way.  */
+
+    /* journal: we need to make sure the block we are giving out is not
+    ** a log block, horrible things would happen there.
+    */
+    search_start = (i * (s->s_blocksize << 3)) + j; 
+    if (search_start >= SB_JOURNAL_BLOCK(s) &&
+        search_start < (SB_JOURNAL_BLOCK(s) + JOURNAL_BLOCK_COUNT)) {
+      reiserfs_warning("bitmap-370, trying to allocate log block %lu\n",
+                        search_start) ;
+      search_start++ ;
+      continue ;
+    }
+       
+    *free_blocknrs = search_start ;
+
+#ifdef REISERFS_CHECK
+    if (buffer_locked (SB_AP_BITMAP (s)[i]) || is_reusable (s, search_start, 0) == 0)
+      reiserfs_panic (s, "vs-4040: reiserfs_new_blocknrs: bitmap block is locked or bad block number found");
+#endif
+
+    /* set bit in true bitmap, but do not set bit in cautious bitmap */
+    if (test_and_set_bit (j, SB_AP_BITMAP (s)[i]->b_data))
+      reiserfs_panic (s, "vs-4045: reiserfs_new_blocknrs: schedule did not occur and this block was free");
+    
+    journal_mark_dirty (th, s, SB_AP_BITMAP (s)[i]); 
+
+    /* it should be marked as suspected recipient when old items moved
+       to it. For now do it unconditionally */
+/*    mark_suspected_recipient (s, SB_AP_BITMAP (s)[i]);*/
+    free_blocknrs ++;
+  }
+
+  /* update free block count in super block */
+  SB_FREE_BLOCKS (s) = cpu_to_le32 (le32_to_cpu (SB_FREE_BLOCKS (s)) - init_amount_needed);
+  journal_mark_dirty (th, s, SB_BUFFER_WITH_SB (s));
+  s->s_dirt = 1;
+
+  return retval;
+}
+
+int reiserfs_new_blocknrs (struct reiserfs_transaction_handle *th, struct super_block * s, unsigned long * free_blocknrs,
+			    unsigned long search_start, int amount_needed, int for_preserve_list) {
+  return do_reiserfs_new_blocknrs(th, s, free_blocknrs, search_start, amount_needed, for_preserve_list, 0) ;
+}
+
+int reiserfs_new_unf_blocknrs(struct reiserfs_transaction_handle *th, struct super_block * s, unsigned long * free_blocknrs,
+				 unsigned long search_start, int amount_needed, int for_preserve_list) {
+  return do_reiserfs_new_blocknrs(th, s, free_blocknrs, search_start, amount_needed, for_preserve_list, 1) ;
+}
Index: empeg/kernel/fs/reiserfs/buffer.c
diff -u /dev/null empeg/kernel/fs/reiserfs/buffer.c:1.1
--- /dev/null	Wed Oct 17 16:36:05 2001
+++ empeg/kernel/fs/reiserfs/buffer.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,350 @@
+/*
+ *  Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
+ */
+
+
+/*
+ * Contains code from
+ *
+ *  linux/include/linux/lock.h and linux/fs/buffer.c /linux/fs/minix/fsync.c
+ *
+ *  Copyright (C) 1991, 1992  Linus Torvalds
+ */
+
+
+/* this is to be included from fs/buffer.c. This requires adding few lines in kernel/ksyms.c */
+
+#ifndef __KERNEL__
+
+#include "nokernel.h"
+void mark_suspected_recipients_dirty(struct reiserfs_transaction_handle *th, kdev_t a) {}
+void fixup_reiserfs_buffers (kdev_t dev) {}
+void reiserfs_show_buffers (kdev_t dev){}
+#else
+#include <linux/reiserfs_fs.h>
+#endif
+
+#define CARRY_ON                0
+#define SCHEDULE_OCCURRED       1
+
+inline int  test_and_wait_on_buffer(
+              struct buffer_head * p_s_bh
+            ) {
+  if ( buffer_locked(p_s_bh) )  {
+    __wait_on_buffer(p_s_bh);
+    return SCHEDULE_OCCURRED;
+  }
+  return CARRY_ON;
+}
+ 
+
+/* This is pretty much the same as the corresponding original linux
+   function, it differs only in that it tracks whether schedule
+   occurred. */
+/* This function function calls find_buffer which looks for the buffer
+   desired on the appropriate hash queue, and then waits for it to unlock. */
+struct buffer_head  * reiserfs_get_hash_table(
+                        kdev_t  n_dev,
+                        int     n_block,
+                        int     n_size,
+                        int   * p_n_repeat
+                      ) {
+  struct buffer_head * p_s_bh;
+
+  for ( ; ; ) {
+    if ( ! (p_s_bh = find_buffer(n_dev, n_block, n_size)) )
+      return NULL;
+    p_s_bh->b_count++;
+    *p_n_repeat |= test_and_wait_on_buffer(p_s_bh);
+    if ( *p_n_repeat == CARRY_ON ||
+	 (p_s_bh->b_dev == n_dev && p_s_bh->b_blocknr == n_block && p_s_bh->b_size == n_size) )
+      return p_s_bh;
+    p_s_bh->b_count--;
+  }
+}
+
+
+#ifdef __KERNEL__
+#if 0 /* not needed anymore */
+struct super_block * reiserfs_get_super (kdev_t dev)
+{
+  struct super_block * s = NULL ;
+
+  
+  if (!dev)
+    return NULL;
+  s = sb_entry(super_blocks.next);
+  while (s != sb_entry(&super_blocks)) {
+    if (s && s->s_dev == dev) {
+      return s;
+    } else {
+      s = sb_entry(s->s_list.next);
+    }
+  }
+  return NULL;
+}
+#endif
+
+/*   
+** end_io for all the log blocks.
+**   
+** this used to do more, but right now it only decrements j_commit_left for the
+** journal list this log block belongs to
+*/   
+void finish_log_block_io(struct super_block *p_s_sb, struct buffer_head *bh, int uptodate) {
+  int j ;
+  int index ;
+  int found = 0 ;
+  int start ;
+  unsigned long startb, endb ;
+     
+  /* desc is at start, commit is at start + len + 1 */
+  start = SB_JOURNAL_LIST_INDEX(p_s_sb) ;
+  if (start < 5) {
+    start = JOURNAL_LIST_COUNT - 5 ;
+  } else {
+    start = start - 5; 
+  }
+  for (j = 0 ; j < JOURNAL_LIST_COUNT ; j++) {
+    index = (start + j) % JOURNAL_LIST_COUNT ;
+    startb = SB_JOURNAL_LIST(p_s_sb)[index].j_start + SB_JOURNAL_BLOCK(p_s_sb) ;
+    endb = SB_JOURNAL_BLOCK(p_s_sb) + ((SB_JOURNAL_LIST(p_s_sb)[index].j_start + SB_JOURNAL_LIST(p_s_sb)[index].j_len + 1) %
+           JOURNAL_BLOCK_COUNT) ;
+    if (SB_JOURNAL_LIST(p_s_sb)[index].j_len > 0 &&
+       ( 
+         ((SB_JOURNAL_LIST(p_s_sb)[index].j_start + SB_JOURNAL_LIST(p_s_sb)[index].j_len + 1) < JOURNAL_BLOCK_COUNT &&
+           startb <= bh->b_blocknr && endb >= bh->b_blocknr) ||
+         ((SB_JOURNAL_LIST(p_s_sb)[index].j_start + SB_JOURNAL_LIST(p_s_sb)[index].j_len + 1) >= JOURNAL_BLOCK_COUNT &&
+           (startb <= bh->b_blocknr || endb >= bh->b_blocknr))
+       )
+      ) {
+      atomic_dec(&(SB_JOURNAL_LIST(p_s_sb)[index].j_commit_left)) ;
+      found = 1 ;
+      break ;
+    }
+  }
+  if (found == 0) { 
+    printk("buffer-115: Unable to find journal list for block %lu\n", bh->b_blocknr) ;
+  } 
+  mark_buffer_uptodate(bh, uptodate);
+  unlock_buffer(bh);
+}
+
+
+/* no longer need, should just make journal.c use the default handler */
+void reiserfs_journal_end_io (struct buffer_head *bh, int uptodate)
+{
+  mark_buffer_uptodate(bh, uptodate);
+  unlock_buffer(bh);
+  return ;
+}
+
+
+/* struct used to service end_io events.  kmalloc'd in 
+** reiserfs_end_buffer_io_sync 
+*/
+struct reiserfs_end_io {
+  struct buffer_head *bh ; /* buffer head to check */
+  struct tq_struct task ;  /* task struct to use */
+  struct reiserfs_end_io *self ; /* pointer to this struct for kfree to use */
+} ;
+
+/*
+** does the hash list updating required to release a buffer head.
+** must not be called at interrupt time (so I can use the non irq masking 
+** spinlocks).  Right now, put onto the schedule task queue, one for
+** each block that gets written
+*/
+static void reiserfs_end_io_task(struct reiserfs_end_io *io) {
+  struct buffer_head *bh = io->bh ;
+
+  if (buffer_journal_dirty(bh)) {
+    struct reiserfs_journal_cnode *cur ;
+    struct super_block * s = get_super (bh->b_dev);
+
+    if (!s) 
+      goto done ;
+
+    lock_kernel() ;
+    if (!buffer_journal_dirty(bh)) { 
+      unlock_kernel() ;
+      goto done ;
+    }
+    mark_buffer_notjournal_dirty(bh) ;
+    cur = (journal_hash(SB_JOURNAL(s)->j_list_hash_table, bh->b_dev, bh->b_blocknr)) ;
+    while(cur) {
+      if (cur->bh && cur->blocknr == bh->b_blocknr && cur->dev == bh->b_dev) {
+	if (cur->jlist) { /* since we are clearing the bh, we must decrement nonzerolen */
+	  atomic_dec(&(cur->jlist->j_nonzerolen)) ;
+	}
+	cur->bh = NULL ;
+      }
+      cur = cur->hnext ;
+    }
+    bh->b_count-- ;
+    unlock_kernel() ;
+  }
+done:
+  kfree(io->self) ;
+  return ;
+}
+
+/*
+** general end_io routine for all reiserfs blocks.
+** logged blocks will come in here marked buffer_journal_dirty()
+** a reiserfs_end_io struct is kmalloc'd for them, and a task is put 
+** on the scheduler queue.  It then does all the required hash table
+** operations to reflect the buffer as writen
+*/
+void reiserfs_end_buffer_io_sync (struct buffer_head *bh, int uptodate)
+{
+
+  mark_buffer_notjournal_new(bh) ;
+  if (buffer_journal_dirty(bh)) {
+    struct reiserfs_end_io *io = kmalloc(sizeof(struct reiserfs_end_io), 
+                                         GFP_ATOMIC) ;
+    /* note, if kmalloc fails, this buffer will be taken care of
+    ** by a check at the end of do_journal_end() in journal.c
+    */
+    if (io) {
+      io->task.next = NULL ;
+      io->task.sync = 0 ;
+      io->task.routine = (void *)(void *)reiserfs_end_io_task ;
+      io->task.data = io ;
+      io->self = io ;
+      io->bh = bh ;
+      queue_task(&(io->task), &tq_scheduler) ;
+    } else {
+      printk("reiserfs/buffer.c-184: kmalloc returned NULL\n") ;
+    }
+  }
+  mark_buffer_uptodate(bh, uptodate);
+  unlock_buffer(bh);
+}
+
+/* This is pretty much the same as the corresponding original linux
+   function, it differs only in that it tracks whether schedule
+   occurred. */
+/* This function looks for a buffer which contains a given block.  If
+   the block is in cache it returns it, otherwise it returns a new
+   buffer which is not uptodate.  This is called by reiserfs_bread and
+   other functions. Note that get_new_buffer ought to be called this
+   and this ought to be called get_new_buffer, since this doesn't
+   actually get the block off of the disk. */
+struct buffer_head  * reiserfs_getblk(
+                        kdev_t    n_dev,
+                        int       n_block,
+                        int       n_size,
+                        int     * p_n_repeat
+                      ) {
+   struct buffer_head  * p_s_bh;
+  int                   n_isize;
+
+repeat:
+
+  p_s_bh = reiserfs_get_hash_table(n_dev, n_block, n_size, p_n_repeat);
+  if ( p_s_bh ) {
+    if ( ! buffer_dirty(p_s_bh) ) {
+      p_s_bh->b_flushtime = 0;
+    }
+    p_s_bh->b_end_io = reiserfs_end_buffer_io_sync;
+    return p_s_bh;
+  }
+
+  n_isize = BUFSIZE_INDEX(n_size);
+get_free:
+  p_s_bh = free_list[n_isize];
+  if (!p_s_bh)
+    goto refill;
+  remove_from_free_list(p_s_bh);
+
+  /* OK, FINALLY we know that this buffer is the only one of its kind,
+   * and that it's unused (b_count=0), unlocked, and clean.
+   */
+  init_buffer(p_s_bh, n_dev, n_block, reiserfs_end_buffer_io_sync, NULL);
+  p_s_bh->b_state=0;
+  insert_into_queues(p_s_bh);
+  return p_s_bh;
+
+  /*
+   * If we block while refilling the free list, somebody may
+   * create the buffer first ... search the hashes again.
+   */
+refill:
+  *p_n_repeat |= SCHEDULE_OCCURRED;
+  refill_freelist(n_size);
+  if (!find_buffer(n_dev,n_block,n_size))
+    goto get_free;
+  goto repeat;
+
+}
+
+void fixup_reiserfs_buffers (kdev_t dev)
+{
+  int i;
+  int nlist;
+  int slept;
+  struct buffer_head * bh;
+  
+ again:
+  slept = 0;
+  for(nlist = 0; nlist < NR_LIST; nlist++) {
+    bh = lru_list[nlist];
+    for (i = nr_buffers_type[nlist] ; i > 0 ; bh = bh->b_next_free, i--) {
+      if (bh->b_dev != dev)
+	continue;
+      if (buffer_locked(bh))
+      {
+	slept = 1;
+	__wait_on_buffer(bh);
+      }
+
+      /* set the end_io callback once the buffer is not under I/O,
+         nobody can start I/O from under us because we are protected
+         by the big kernel lock */
+      bh->b_end_io = end_buffer_io_sync;
+      if (bh->b_count > 0) {
+        printk("buffer-300: BAD, count is %d for buffer %lu\n", bh->b_count, bh->b_blocknr) ;
+      }
+      if (slept)
+        goto again;
+    }
+  }
+}
+
+/* call by unpreserve when cautous bitmap block is being dirtied */
+void reiserfs_refile_buffer (struct buffer_head * buf)
+{
+  if (BUF_DIRTY != buf->b_list)
+    file_buffer (buf, BUF_DIRTY);
+}
+
+void reiserfs_file_buffer(struct buffer_head *bh, int list) {
+  file_buffer(bh, list) ;
+}
+
+#else
+
+void reiserfs_end_buffer_io_sync (struct buffer_head *bh, int uptodate)
+{
+ ;
+}
+
+int reiserfs_add_handler(struct buffer_head *bh) {
+  bh->b_end_io =  reiserfs_end_buffer_io_sync  ;
+  return 0 ;
+}
+
+struct buffer_head * reiserfs_getblk (kdev_t dev, int block, int size, int * p_n_repeat) {
+  struct buffer_head *bh ;
+  bh = getblk(dev, block, size) ;
+  if (bh) {
+    bh->b_end_io = reiserfs_end_buffer_io_sync ;
+  }
+  return bh ;
+}
+
+
+#endif /* __KERNEL__ */
+
+
Index: empeg/kernel/fs/reiserfs/buffer2.c
diff -u /dev/null empeg/kernel/fs/reiserfs/buffer2.c:1.1
--- /dev/null	Wed Oct 17 16:36:05 2001
+++ empeg/kernel/fs/reiserfs/buffer2.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,340 @@
+/*
+ *  Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
+ */
+
+
+/*
+ * Contains code from
+ *
+ *  linux/include/linux/lock.h and linux/fs/buffer.c /linux/fs/minix/fsync.c
+ *
+ *  Copyright (C) 1991, 1992  Linus Torvalds
+ */
+#ifdef __KERNEL__
+
+#include <linux/sched.h>
+#include <linux/locks.h>
+#include <linux/reiserfs_fs.h>
+
+
+
+/*
+ * wait_buffer_until_released
+ *  reiserfs_bread
+ *  reiserfs_sync_block
+ *  sync_unf_nodes
+ *  sync_file_item
+ *  sync_file_items
+ *  reiserfs_sync_file
+ */
+
+
+/* when we allocate a new block (get_new_buffer, get_empty_nodes,
+   get_nodes_for_preserving) and get buffer for it, it is possible
+   that it is held by someone else or even by this process. In this
+   function we wait until all other holders release buffer. To make
+   sure, that current process does not hold we did free all buffers in
+   tree balance structure (get_empty_nodes and
+   get_nodes_for_preserving) or in path structure only
+   (get_new_buffer) just before calling this */
+void wait_buffer_until_released (struct buffer_head * bh)
+{
+  int repeat_counter = 0;
+
+  while (bh->b_count > 1) {
+    if ( !(++repeat_counter % 200000) ) {
+      reiserfs_warning ("vs-3050: wait_buffer_until_released: nobody releases buffer (%b). Still waiting (%d) %cJDIRTY %cJWAIT\n",
+			bh, repeat_counter, buffer_journaled(bh) ? ' ' : '!',
+			buffer_journal_dirty(bh) ? ' ' : '!');
+    }
+    current->policy |= SCHED_YIELD;
+    schedule();
+  }
+}
+
+
+/* This is pretty much the same as the corresponding original linux
+   function, it differs only in that it tracks whether schedule
+   occurred. */
+/*
+ * reiserfs_bread() reads a specified block and returns the buffer that contains
+ * it. It returns NULL if the block was unreadable.
+ */
+/* It first tries to find the block in cache, and if it cannot do so
+   then it creates a new buffer and schedules I/O to read the
+   block. */
+
+struct buffer_head  * reiserfs_bread(
+                        kdev_t  n_dev,
+                        int     n_block,
+                        int     n_size,
+                        int   * p_n_repeat
+                      ) {
+  struct buffer_head * p_s_bh;
+
+  p_s_bh = reiserfs_getblk(n_dev, n_block, n_size, p_n_repeat);
+  if ( buffer_uptodate(p_s_bh) )
+    return p_s_bh;
+  ll_rw_block(READ, 1, &p_s_bh);
+  *p_n_repeat |= SCHEDULE_OCCURRED;
+  wait_on_buffer(p_s_bh);
+  if ( buffer_uptodate(p_s_bh) )
+    return p_s_bh;
+  printk("reiserfs_bread: unable to read dev = %d block = %d size = %d\n", n_dev, n_block, n_size);
+  brelse(p_s_bh);
+  return NULL;
+}
+
+
+
+
+
+/* Synchronize a block of reiserfs. */
+static int  reiserfs_sync_block(
+              struct buffer_head  * p_s_bh,   /* Pointer to the buffer header to sync.  */
+              int                   n_wait,   /* Wait parameter.                        */
+              struct path         * p_s_path  /* Pointer to the path contains buffer.
+                                                  NULL in case of an unformatted node.  */
+            ) {
+  if ( n_wait && buffer_req(p_s_bh) && ! buffer_uptodate(p_s_bh) )  {
+    /* Release buffer if it is unformatted node. If not it will be released by pathrelse(). */
+    if ( ! p_s_path )
+      brelse(p_s_bh);
+    return -1;
+  }
+  if ( n_wait || ! buffer_uptodate(p_s_bh) || ! buffer_dirty(p_s_bh) )  {
+    if ( ! p_s_path )
+      brelse(p_s_bh);
+    return 0;
+  }
+
+  /* unformatted nodes can go right to the disk, but they are
+  ** skipped if they have been logged recently.  Committing the
+  ** transaction will be good enough to call them synced
+  */
+  if (!p_s_path && !buffer_journaled(p_s_bh) && !buffer_journal_dirty(p_s_bh)) {
+    ll_rw_block(WRITE, 1, &p_s_bh); 
+  }
+  p_s_bh->b_count--;
+
+  /* Decrement path length if it is buffer at the path. */
+  if ( p_s_path ) {
+
+#ifdef REISERFS_CHECK
+    if ( p_s_path->path_length < FIRST_PATH_ELEMENT_OFFSET )
+      reiserfs_panic(0, "PAP-16015: reiserfs_sync_block: path length is too small");
+#endif
+
+    p_s_path->path_length--;
+  }
+
+  return 0;
+}
+
+
+/* Sync unformatted nodes of the item *p_s_ih. */
+static int  sync_unf_nodes(
+              struct inode      * p_s_inode,        /* Pointer to the file inode.         */
+              struct item_head  * p_s_ih,           /* Pointer to the found item header.  */
+              int               * p_n_pos_in_item,  /* Position in the found item.        */
+              struct path       * p_s_path_to_item, /* Path to the found item.            */
+              int                 n_wait,           /* Wait parameter.                    */
+              unsigned long     * p_n_synced  /* Returned value. UNFM number were
+                                                        synced in this call.        */
+            ) {
+  struct key            s_item_key;
+  struct buffer_head  * p_s_unfm_bh;
+  unsigned long         n_unfm_pointer;
+  int                   n_repeat,
+                        n_counter,
+                        n_unfm_number_to_sync = I_UNFM_NUM(p_s_ih) - *p_n_pos_in_item;
+
+  /* Form key to search for the first unformatted node to be synced. */
+  copy_key(&s_item_key, &(p_s_ih->ih_key));
+  s_item_key.k_offset += *p_n_pos_in_item * p_s_inode->i_sb->s_blocksize;
+  if ( search_for_position_by_key(p_s_inode->i_sb, &s_item_key, p_s_path_to_item, p_n_pos_in_item, &n_repeat) == POSITION_NOT_FOUND )
+    return 1; /* Item to sync UNFM was not found. */
+  /* Remember found item header.  */
+  copy_item_head(p_s_ih, PATH_PITEM_HEAD(p_s_path_to_item));
+
+  /* Calculate number of the UNFM to be synced. */
+  if ( n_unfm_number_to_sync > I_UNFM_NUM(p_s_ih) - *p_n_pos_in_item/*vs*/)
+    /* do not sync more unformatted nodes, than number of synced unformatted node pointers. If there
+       is no so many unformatted nodes in found indirect item as we need, sync what we have. */
+    n_unfm_number_to_sync = I_UNFM_NUM(p_s_ih) - *p_n_pos_in_item/*vs*/;
+
+  for ( n_counter = 0; n_counter < n_unfm_number_to_sync; n_counter++ ) {
+    /* Found item is not at the path. */
+    if ( comp_items(p_s_ih, p_s_path_to_item) )
+      return 0;
+    /* Calculate block number of the UNFM. */
+    n_unfm_pointer = B_I_POS_UNFM_POINTER(PATH_PLAST_BUFFER(p_s_path_to_item),
+					  p_s_ih, *p_n_pos_in_item + n_counter);
+    /* It is hole. Nothing to sync. */
+    if ( ! n_unfm_pointer ) {
+      *p_n_synced += 1;
+      continue;
+    }
+    /* Get buffer contains UNFM. */
+    n_repeat = CARRY_ON;
+    p_s_unfm_bh = reiserfs_get_hash_table(p_s_inode->i_dev, n_unfm_pointer,
+					  p_s_inode->i_sb->s_blocksize, &n_repeat);
+    /* There is not needed buffer. */
+    if ( ! p_s_unfm_bh )  {
+      *p_n_synced += 1;
+      continue;
+    }
+    /* Check whether the found item at the path. */
+    if ( comp_items(p_s_ih, p_s_path_to_item) ) {
+      brelse(p_s_unfm_bh);
+      return 0;
+    }
+
+    /* Number of the UNFM is changed. */
+    if ( n_unfm_pointer != B_I_POS_UNFM_POINTER(PATH_PLAST_BUFFER(p_s_path_to_item), p_s_ih, *p_n_pos_in_item + n_counter) ) {
+      brelse(p_s_unfm_bh);
+      return 1;
+    }
+
+    /* Sync UNFM. */
+    if ( reiserfs_sync_block(p_s_unfm_bh, n_wait, NULL) )
+      return -1;
+
+    *p_n_synced += 1;
+
+  }
+  return 0;
+}
+
+
+/* Sync a reiserfs file item. */
+static int  sync_file_item(
+              struct inode  * p_s_inode,        /* Pointer to the file inode.             */
+              struct path   * p_s_path_to_item, /* Pointer to the path to the found item. */
+              int           * p_n_pos_in_item,  /* Position in the found item.            */
+              int             n_wait,           /* Sync parameter.                        */
+              unsigned long * p_n_synced  /* Returned value. Bytes number were
+                                                    synced in this call.            */
+            ) {
+  struct item_head      s_ih;
+  int                   n_ret_value;
+
+  *p_n_synced = 0;
+  /* Copy found item header. */
+  copy_item_head(&s_ih, PATH_PITEM_HEAD(p_s_path_to_item));
+
+  /* Sync found item. */
+  if ( (n_ret_value = reiserfs_sync_block(PATH_PLAST_BUFFER(p_s_path_to_item), n_wait, p_s_path_to_item)) )
+    return n_ret_value;
+
+  if ( I_IS_DIRECT_ITEM(&s_ih) )  {
+    /* s_ih.ih_item_len bytes was synced. */
+    *p_n_synced = s_ih.ih_item_len;
+    return 0;
+  }
+  /* Sync unformatted nodes pointed by the synced indirect item. */
+  n_ret_value = sync_unf_nodes(p_s_inode, &s_ih, p_n_pos_in_item,
+			       p_s_path_to_item, n_wait, p_n_synced);
+
+#ifdef REISERFS_CHECK
+  if (!n_wait &&  ! *p_n_synced && ! n_ret_value )
+    reiserfs_warning("sync_file_item: no unformatted nodes were synced (ih %h) pass %d\n", &s_ih, n_wait);
+#endif
+
+  *p_n_synced *= p_s_inode->i_sb->s_blocksize;
+  return n_ret_value;
+}
+
+
+/* Sync a reiserfs file items. */
+static int sync_file_items(
+             struct inode  * p_s_inode,
+	     int             n_wait
+           ) {
+  struct key          s_item_key;
+  struct path         s_path_to_item;
+  int                 n_pos_in_item,
+                      n_repeat,
+                      n_ret_value = 0;
+  unsigned long       n_synced;
+
+  
+  init_path (&s_path_to_item);
+  /* Form key to search for the first file item. */
+  copy_key(&s_item_key, &(p_s_inode->u.reiserfs_i.i_key));
+  s_item_key.k_offset = 1;
+  if ( 1 == p_s_inode->u.reiserfs_i.i_first_direct_byte )
+    s_item_key.k_uniqueness = TYPE_DIRECT;
+  else
+    s_item_key.k_uniqueness = TYPE_INDIRECT;
+  /* While next file item is presented in the tree. */
+  while ( search_for_position_by_key(p_s_inode->i_sb, &s_item_key, &s_path_to_item, &n_pos_in_item, &n_repeat) == POSITION_FOUND )  {
+
+#ifdef REISERFS_CHECK
+    if ( I_IS_DIRECTORY_ITEM(PATH_PITEM_HEAD(&s_path_to_item)) ||
+	 I_IS_STAT_DATA_ITEM(PATH_PITEM_HEAD(&s_path_to_item)) )
+      reiserfs_panic (p_s_inode->i_sb, "PAP-16030: sync_file_items: unexpected item type");
+#endif
+
+    /* Synchronize the current item. */  
+    if ( (n_ret_value = sync_file_item(p_s_inode, &s_path_to_item, &n_pos_in_item,
+				       n_wait, &n_synced)) )
+      break;
+    /* Update key to search for the next file item. */
+    if ( (s_item_key.k_offset += n_synced) >= p_s_inode->u.reiserfs_i.i_first_direct_byte )
+      s_item_key.k_uniqueness = TYPE_DIRECT;  
+  }
+
+  decrement_counters_in_path(&s_path_to_item);
+  return n_ret_value;
+}
+
+
+
+/* Sync a reiserfs file. */
+int reiserfs_sync_file(
+      struct file   * p_s_filp,
+      struct dentry * p_s_dentry
+    ) {
+  struct inode * p_s_inode = p_s_dentry->d_inode;
+  struct reiserfs_transaction_handle th ;
+  int n_wait,
+      n_err = 0;
+  int windex ;
+  int jbegin_count = JOURNAL_PER_BALANCE_CNT * 2 ;
+  if ( S_ISDIR(p_s_inode->i_mode) )
+    reiserfs_panic (p_s_inode->i_sb,
+		    "PAP-16040: reiserfs_sync_file: attempt to sync directory using reiserfs_sync_file()");
+
+  if ( ! (S_ISREG(p_s_inode->i_mode) || S_ISLNK(p_s_inode->i_mode)) )
+    return -EINVAL;
+
+  /* note, since the transaction can't end while we have the
+  ** read_sync_counter incremented (deadlock), sync_file_items is not allowed
+  ** to do a polite transaction end.  I've fixed that by 
+  ** having it not log anything at all, it only puts unformatted
+  ** nodes on the disk, and only if they have not already been logged
+  */
+  increment_i_read_sync_counter(p_s_inode);
+  for ( n_wait = 0; n_wait < 2; n_wait++ )
+    n_err |= sync_file_items(p_s_inode, n_wait);
+  decrement_i_read_sync_counter(p_s_inode);
+
+  /* now we sync the inode, and commit the transaction.
+  ** this will commit any logged blocks involved with this file
+  */
+  if (reiserfs_inode_in_this_transaction(p_s_inode) || 
+      p_s_inode->i_state & I_DIRTY) {
+    journal_begin(&th, p_s_inode->i_sb, jbegin_count) ;
+    windex = push_journal_writer("reiserfs_sync_file") ;
+    n_err |= reiserfs_sync_inode(&th, p_s_inode);
+    pop_journal_writer(windex) ;
+    journal_end_sync(&th, th.t_super,jbegin_count) ;
+  } else {
+    reiserfs_commit_for_inode(p_s_inode) ;
+  }
+  return ( n_err < 0 ) ? -EIO : 0;
+}
+
+#endif /* __KERNEL__ */
+
Index: empeg/kernel/fs/reiserfs/dir.c
diff -u /dev/null empeg/kernel/fs/reiserfs/dir.c:1.1
--- /dev/null	Wed Oct 17 16:36:05 2001
+++ empeg/kernel/fs/reiserfs/dir.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,237 @@
+/*
+ * Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
+ */
+#ifdef __KERNEL__
+
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/reiserfs_fs.h>
+#include <linux/stat.h>
+#include <asm/uaccess.h>
+
+#else
+
+#include "nokernel.h"
+
+#endif
+
+
+extern struct key  MIN_KEY;
+
+static ssize_t reiserfs_dir_read  (struct file * filp, char * buf, size_t count, loff_t * ppos)
+{
+  return -EISDIR;
+}
+
+/*static loff_t reiserfs_llseek(struct file *file, loff_t offset, int origin);*/
+static int reiserfs_readdir (struct file *, void *, filldir_t);
+int reiserfs_dir_fsync(struct file *filp, struct dentry *dentry)  ;
+
+static struct file_operations reiserfs_dir_operations = {
+	NULL/*reiserfs_llseek*/,	/* lseek */
+	reiserfs_dir_read,	/* read */
+	NULL,			/* write */
+	reiserfs_readdir,	/* readdir */
+	NULL,			/* poll */
+	NULL,			/* ioctl */
+	NULL,			/* mmap */
+	NULL,			/* open */
+	NULL,			/* flush */
+	NULL,			/* release */
+	reiserfs_dir_fsync,	/* fsync */ 
+	NULL, 			/* fasync */
+	NULL,			/* check_media_change */
+	NULL,			/* revalidate */
+	NULL			/* lock */
+};
+
+/*
+ * directories can handle most operations...
+ */
+struct inode_operations reiserfs_dir_inode_operations = {
+	&reiserfs_dir_operations,	/* default_file_ops */
+	reiserfs_create,		/* create */
+	reiserfs_lookup,		/* lookup */
+	reiserfs_link,			/* link */
+	reiserfs_unlink,		/* unlink */
+	reiserfs_symlink,		/* symlink */
+	reiserfs_mkdir,			/* mkdir */
+	reiserfs_rmdir,			/* rmdir */
+	reiserfs_mknod,			/* mknod */
+	reiserfs_rename,		/* rename */
+	NULL,				/* readlink */
+	NULL,				/* follow_link */
+	NULL,				/* readpage */
+	NULL,				/* writepage */
+	NULL,				/* bmap */
+	NULL,				/* truncate */
+	NULL,				/* permission */
+	NULL,				/* smap */
+	NULL,				/* updatepage */
+	NULL				/* revalidate */
+};
+
+int reiserfs_dir_fsync(struct file *filp, struct dentry *dentry) {
+  struct reiserfs_transaction_handle th ;
+  if (!dentry || !dentry->d_inode) {
+     return file_fsync(filp, dentry) ;
+  }
+  /* ret = file_fsync(filp, dentry) ; we don't need this */
+
+  /* if any changes were made to the dir, this will catch them */
+  if (reiserfs_inode_in_this_transaction(dentry->d_inode)) {
+    journal_begin(&th, dentry->d_inode->i_sb, 1) ;
+    journal_end_sync(&th, dentry->d_inode->i_sb, 1) ;
+  } else {
+    reiserfs_commit_for_inode(dentry->d_inode) ;
+  }
+  return 0 ;
+}
+
+
+/* read ahead can be used also for directory */
+static int reiserfs_readdir (struct file * filp, void * dirent, filldir_t filldir)
+{
+  struct inode *inode = filp->f_dentry->d_inode;
+  struct key pos_key;	/* key of current position in the directory (key of directory entry) */
+  struct path path_to_entry;
+  struct buffer_head * bh;
+  int item_num, entry_num;
+  int repeat;
+
+  struct key * rkey;
+  struct item_head * ih;
+  int search_res;
+
+  init_path (&path_to_entry);
+
+  if (!inode || !inode->i_sb || !S_ISDIR (inode->i_mode))
+    return -EBADF;
+
+  /* form key for search the next directory entry using f_pos field of file structure  */
+  copy_key (&pos_key, INODE_PKEY (inode));
+  pos_key.k_offset = (filp->f_pos) ? (filp->f_pos) : DOT_OFFSET;
+  pos_key.k_uniqueness = DIRENTRY_UNIQUENESS;
+
+  while (1) {
+    /* search the directory item, containing entry with specified key */
+    search_res = search_by_entry_key (inode->i_sb, &pos_key, &path_to_entry, &entry_num, &repeat);
+
+    bh = PATH_PLAST_BUFFER (&path_to_entry);
+    item_num = PATH_LAST_POSITION (&path_to_entry);
+    ih = B_N_PITEM_HEAD (bh, item_num);
+		
+#ifdef REISERFS_CHECK
+    /* we must have found item, that is item of this directory, */
+    if (COMP_SHORT_KEYS (&pos_key, B_N_PKEY (bh, item_num)))
+      reiserfs_panic (inode->i_sb, "vs-9000: reiserfs_readdir: can not find directory item (%lu %lu)",
+		      pos_key.k_dir_id, pos_key.k_objectid);
+      
+    if (item_num > B_NR_ITEMS (bh) - 1)
+      reiserfs_panic (inode->i_sb, "vs-9005: reiserfs_readdir: item_num == %d, item amount == %d",
+		      item_num, B_NR_ITEMS (bh));
+      
+    /* and entry must be not more than number of entries in the item */
+    if (I_ENTRY_COUNT (ih) < entry_num)
+      reiserfs_panic (inode->i_sb, "vs-9010: reiserfs_readdir: entry number is too big %d (%d)",
+		      entry_num, I_ENTRY_COUNT (ih));
+#endif	/* REISERFS_CHECK */
+
+    if (search_res == POSITION_FOUND || entry_num < I_ENTRY_COUNT (ih)) {
+      /* go through all entries in the directory item beginning from the entry, that has been found */
+      struct reiserfs_de_head * deh = B_I_DEH (bh, ih) + entry_num;
+
+      for (; entry_num < I_ENTRY_COUNT (ih); entry_num ++, deh ++) {
+	if (!de_visible (deh))
+	  /* it is hidden entry */
+	  continue;
+	if (filldir (dirent, B_I_DEH_ENTRY_FILE_NAME (bh, ih, deh), I_DEH_N_ENTRY_FILE_NAME_LENGTH (ih, deh, entry_num),
+		     deh->deh_offset,
+		     DEH_OBJECTID (deh)) < 0) {
+	  pathrelse (&path_to_entry);
+	  return 0;
+	}
+
+	/* set position in directory to the next entry */
+	filp->f_pos = deh->deh_offset + 1;
+
+      } /* for */
+    }
+    /* item we went through is last item of node. Using right
+       delimiting key check is it directory end */
+    if (item_num == B_NR_ITEMS (bh) - 1) {
+      rkey = get_rkey (&path_to_entry, inode->i_sb);
+      if (! COMP_KEYS (rkey, &MIN_KEY)) {
+#ifdef REISERFS_CHECK
+	printk ("reiserfs_readdir could not calculate rigth delimiting key (path has been changed)\n");
+#endif
+	/* set pos_key to key, that is the smallest and greater
+	   that key of the last entry in the item */
+	pos_key.k_offset = filp->f_pos;
+	continue;
+      }
+
+      if ( COMP_SHORT_KEYS (rkey, &pos_key)) {
+	/* end of the directory */
+	pathrelse (&path_to_entry);
+	return 0;
+      }
+      /* directory continues in the right neighboring block */
+      copy_key (&pos_key, rkey);
+      continue;
+    }
+
+    /* directory item is not a last item of the node. End of the directory is achieved */
+    pathrelse (&path_to_entry);
+    return 0;
+  } /* while */
+
+  return 0;
+}
+
+
+#if 0
+static loff_t reiserfs_llseek(struct file *file, loff_t offset, int origin)
+{
+  long long retval;
+
+  switch (origin) {
+  case 2:
+    offset += file->f_dentry->d_inode->i_size;
+    break;
+  case 1:
+    offset += file->f_pos;
+  }
+  retval = -EINVAL;
+ /* if (offset >= 0) {*/
+    if (offset != file->f_pos) {
+      file->f_pos = offset;
+      file->f_reada = 0;
+      file->f_version = ++event;
+    }
+    retval = offset;
+/*  }*/
+  return retval;
+}
+#endif
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
Index: empeg/kernel/fs/reiserfs/do_balan.c
diff -u /dev/null empeg/kernel/fs/reiserfs/do_balan.c:1.1
--- /dev/null	Wed Oct 17 16:36:05 2001
+++ empeg/kernel/fs/reiserfs/do_balan.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,1990 @@
+/*
+ * Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
+ */
+
+/* Now we have all buffers that must be used in balancing of the tree 	*/
+/* Further calculations can not cause schedule(), and thus the buffer 	*/
+/* tree will be stable until the balancing will be finished 		*/
+/* balance the tree according to the analysis made before,		*/
+/* and using buffers obtained after all above.				*/
+
+
+/**
+ ** balance_leaf_when_delete
+ ** balance_leaf
+ ** do_balance
+ **
+ **/
+
+#ifdef __KERNEL__
+
+#include <asm/uaccess.h>
+#include <linux/sched.h>
+#include <linux/reiserfs_fs.h>
+
+#else
+
+#include "nokernel.h"
+
+#endif
+
+
+#ifdef REISERFS_CHECK
+
+struct tree_balance * cur_tb = NULL; /* detects whether more than one copy of tb exists as a means
+					of checking whether schedule is interrupting do_balance */
+struct tree_balance init_tb;	/* Sometimes used to store a snapshot of tb during debugging. */
+int init_item_pos, init_pos_in_item, init_mode;  /* Sometimes used to store a snapshot of tb during debugging. */
+
+struct buffer_head * buffers[MAX_HEIGHT];
+
+#endif /* REISERFS_CHECK */
+
+
+
+/* summary: 
+ if deleting something ( tb->insert_size[0] < 0 )
+   return(balance_leaf_when_delete()); (flag d handled here)
+ else
+   if lnum is larger than 0 we put items into the left node
+   if rnum is larger than 0 we put items into the right node
+   if snum1 is larger than 0 we put items into the new node s1
+   if snum2 is larger than 0 we put items into the new node s2 
+Note that all *num* count new items being created.
+
+It would be easier to read balance_leaf() if each of these summary
+lines was a separate procedure rather than being inlined.  I think
+that there are many passages here and in balance_leaf_when_delete() in
+which two calls to one procedure can replace two passages, and it
+might save cache space and improve software maintenance costs to do so.  
+
+Vladimir made the perceptive comment that we should offload most of
+the decision making in this function into fix_nodes/check_balance, and
+then create some sort of structure in tb that says what actions should
+be performed by do_balance.
+
+-Hans */
+
+
+
+/* Balance leaf node in case of delete or cut: insert_size[0] < 0
+ *
+ * lnum, rnum can have values >= -1
+ *	-1 means that the neighbor must be joined with S
+ *	 0 means that nothing should be done with the neighbor
+ *	>0 means to shift entirely or partly the specified number of items to the neighbor
+ */
+static int	balance_leaf_when_delete (
+					  struct reiserfs_transaction_handle *th,
+					  struct tree_balance * tb, 
+					  int pos_in_item, 
+					  int flag
+					  )
+{
+  struct buffer_head * tbS0 = PATH_PLAST_BUFFER (tb->tb_path);
+  int item_pos = PATH_LAST_POSITION (tb->tb_path);
+  struct buffer_info bi;
+  int n;
+  struct item_head * ih;
+
+#ifdef REISERFS_CHECK
+  if ( tb->FR[0] && B_BLK_HEAD(tb->FR[0])->blk_level <= DISK_LEAF_NODE_LEVEL )
+    reiserfs_panic (tb->tb_sb,
+                    "balance_leaf_when_delete: 11999:level == %u\n", B_BLK_HEAD(tb->FR[0])->blk_level);
+  if ( tb->blknum[0] > 1 )
+    reiserfs_panic (tb->tb_sb,
+		    "PAP-12005: balance_leaf_when_delete: tb->blknum == %d, can not be > 1", tb->blknum[0]);
+	
+  if ( ! tb->blknum[0] && ! PATH_H_PPARENT(tb->tb_path, 0))
+    reiserfs_panic (tb->tb_sb, "PAP-12010: balance_leaf_when_delete: tree can not be empty");
+#endif
+
+  ih = B_N_PITEM_HEAD (tbS0, item_pos);
+
+  /* Delete or truncate the item */
+
+  switch (flag) {
+  case M_DELETE:   /* delete item in S[0] */
+
+#ifdef REISERFS_CHECK
+    if ( ! item_pos && (! tb->L[0] || COMP_KEYS(B_PRIGHT_DELIM_KEY(tb->L[0]), B_N_PKEY(tbS0, 0))) ) {
+      print_tb (flag, item_pos, pos_in_item, tb, "12006");
+      reiserfs_panic (tb->tb_sb, "PAP-12015: balance_leaf_when_delete: L0's rkey does not match to 1st key of S0: "
+		      "rkey in L %k, first key in S0 %k, rkey in CFL %k",
+		      tb->L[0] ? B_PRIGHT_DELIM_KEY(tb->L[0]) : 0, 
+		      B_N_PKEY(tbS0, 0),
+		      tb->CFL[0] ? B_N_PDELIM_KEY(tb->CFL[0],tb->lkey[0]) : 0);
+    }
+#endif
+
+    bi.bi_bh = tbS0;
+    bi.bi_parent = PATH_H_PPARENT (tb->tb_path, 0);
+    bi.bi_position = PATH_H_POSITION (tb->tb_path, 1);
+    leaf_delete_items (th, &bi, 0, item_pos, 1, -1);
+
+    if ( ! item_pos && tb->CFL[0] ) {
+      if ( B_NR_ITEMS(tbS0) ) {
+	replace_key(th, tb->CFL[0],tb->lkey[0],tbS0,0);
+	copy_key(B_PRIGHT_DELIM_KEY(tb->L[0]), B_N_PKEY(tbS0, 0));
+	/* reiserfs_mark_buffer_dirty (tb->L[0], 0); journal victim */
+	journal_mark_dirty (th, tb->tb_sb, tb->L[0]); 
+      }
+      else {
+	if ( ! PATH_H_POSITION (tb->tb_path, 1) )
+	  replace_key(th, tb->CFL[0],tb->lkey[0],PATH_H_PPARENT(tb->tb_path, 0),0);
+	copy_key(B_PRIGHT_DELIM_KEY(tb->L[0]), B_PRIGHT_DELIM_KEY(tbS0));
+	/* reiserfs_mark_buffer_dirty (tb->L[0], 0); journal victim */
+	journal_mark_dirty (th, tb->tb_sb, tb->L[0]);
+      }
+    } 
+
+#ifdef REISERFS_CHECK
+    if (! item_pos && (!tb->CFL[0] || !tb->L[0]))
+      reiserfs_panic (tb->tb_sb, "PAP-12020: balance_leaf_when_delete: tb->CFL[0]==%p, tb->L[0]==%p", tb->CFL[0], tb->L[0]);
+#endif
+    
+    break;
+
+  case M_CUT: {  /* cut item in S[0] */
+    bi.bi_bh = tbS0;
+    bi.bi_parent = PATH_H_PPARENT (tb->tb_path, 0);
+    bi.bi_position = PATH_H_POSITION (tb->tb_path, 1);
+    if (I_IS_DIRECTORY_ITEM (ih)) {
+
+#ifdef REISERFS_CHECK
+      if ( ! item_pos && ! pos_in_item && (! tb->L[0] || COMP_KEYS(B_PRIGHT_DELIM_KEY(tb->L[0]), 
+								   B_N_PKEY(tbS0, 0))) )
+	reiserfs_panic(tb->tb_sb, "PAP-12025: balance_leaf_when_delete: illegal right delimiting key");
+#endif
+
+      /* UFS unlink semantics are such that you can only delete one directory entry at a time. */
+      /* when we cut a directory tb->insert_size[0] means number of entries to be cut (always 1) */
+      tb->insert_size[0] = -1;
+      leaf_cut_from_buffer (th, &bi, item_pos, pos_in_item, -tb->insert_size[0]);
+
+#ifdef REISERFS_CHECK
+      if (! item_pos && ! pos_in_item && ! tb->CFL[0])
+	reiserfs_panic (tb->tb_sb, "PAP-12030: balance_leaf_when_delete: can not change delimiting key. CFL[0]=%p", tb->CFL[0]);
+#endif /* REISERFS_CHECK */
+
+      if ( ! item_pos && ! pos_in_item && tb->CFL[0] ) {
+	replace_key(th, tb->CFL[0],tb->lkey[0],tbS0,0);
+	copy_key(B_PRIGHT_DELIM_KEY(tb->L[0]), B_N_PKEY(tbS0, 0));
+	/* reiserfs_mark_buffer_dirty (tb->L[0], 0); journal victim */
+	journal_mark_dirty (th, tb->tb_sb, tb->L[0]);
+      }
+    } else {
+      leaf_cut_from_buffer (th, &bi, item_pos, pos_in_item, -tb->insert_size[0]);
+
+#ifdef REISERFS_CHECK
+      if (! ih->ih_item_len)
+	reiserfs_panic (tb->tb_sb, "PAP-12035: balance_leaf_when_delete: cut must leave non-zero dynamic length of item");
+#endif /* REISERFS_CHECK */
+    }
+    break;
+  }
+
+  default:
+    print_tb(flag, item_pos, pos_in_item, tb,"when_del");
+    reiserfs_panic (tb->tb_sb, "PAP-12040: balance_leaf_when_delete: unexpectable mode: %s(%d)",
+		    (flag == M_PASTE) ? "PASTE" : ((flag == M_INSERT) ? "INSERT" : "UNKNOWN"), flag);
+  }
+
+  /* the rule is that no shifting occurs unless by shifting a node can be freed */
+  n = B_NR_ITEMS(tbS0);
+  if ( tb->lnum[0] )     /* L[0] takes part in balancing */
+    {
+      if ( tb->lnum[0] == -1 )    /* L[0] must be joined with S[0] */
+	{
+	  if ( tb->rnum[0] == -1 )    /* R[0] must be also joined with S[0] */
+	    {			
+	      if ( tb->FR[0] == PATH_H_PPARENT(tb->tb_path, 0) )
+		{
+		  /* all contents of all the 3 buffers will be in L[0] */
+		  if ( PATH_H_POSITION (tb->tb_path, 1) == 0 && 1 < B_NR_ITEMS(tb->FR[0]) )
+		    replace_key(th, tb->CFL[0],tb->lkey[0],tb->FR[0],1);
+
+		  /* update right_delimiting_key field */
+		  copy_key (B_PRIGHT_DELIM_KEY (tb->L[0]), B_PRIGHT_DELIM_KEY (tb->R[0]));
+
+		  leaf_move_items (th, LEAF_FROM_S_TO_L, tb, n, -1, 0);
+		  leaf_move_items (th, LEAF_FROM_R_TO_L, tb, B_NR_ITEMS(tb->R[0]), -1, 0);
+
+		  reiserfs_invalidate_buffer (th, tb, tbS0, 1/*do_free_block*/);
+		  reiserfs_invalidate_buffer (th, tb, tb->R[0], 1/*do_free_block*/);
+/*		  preserve_invalidate(th, tb, tbS0, tb->L[0]); 
+		  preserve_invalidate(th, tb, tb->R[0], tb->L[0]);*/
+
+		  return 0;
+		}
+	      /* all contents of all the 3 buffers will be in R[0] */
+	      leaf_move_items(th, LEAF_FROM_S_TO_R, tb, n, -1, 0);
+	      leaf_move_items(th, LEAF_FROM_L_TO_R, tb, B_NR_ITEMS(tb->L[0]), -1, 0);
+
+	      /* right_delimiting_key is correct in R[0] */
+	      replace_key(th, tb->CFR[0],tb->rkey[0],tb->R[0],0);
+
+	      /* mark tb->R[0] as suspected recipient */
+	      reiserfs_invalidate_buffer (th, tb, tbS0, 1/*do_free_block*/);
+	      reiserfs_invalidate_buffer (th, tb, tb->L[0], 1/*do_free_block*/);
+/*	      preserve_invalidate(th, tb,tbS0, tb->R[0]);
+	      preserve_invalidate(th, tb,tb->L[0], tb->R[0]); */
+
+	      return -1;
+	    }
+
+#ifdef REISERFS_CHECK
+	  if ( tb->rnum[0] != 0 )
+	    reiserfs_panic (tb->tb_sb, "PAP-12045: balance_leaf_when_delete: rnum must be 0 (%d)", tb->rnum[0]);
+#endif /* REISERFS_CHECK */
+
+	  /* all contents of L[0] and S[0] will be in L[0] */
+	  leaf_shift_left(th, tb, n, -1);
+
+	  reiserfs_invalidate_buffer (th, tb, tbS0, 1/*do_free_block*/);
+	  /*preserve_invalidate(th, tb, tbS0, tb->L[0]);*/  /* preserved, shifting */
+
+	  return 0;
+	}
+      /* a part of contents of S[0] will be in L[0] and the rest part of S[0] will be in R[0] */
+
+#ifdef REISERFS_CHECK
+      if (( tb->lnum[0] + tb->rnum[0] < n ) || ( tb->lnum[0] + tb->rnum[0] > n+1 ))
+	reiserfs_panic (tb->tb_sb, "PAP-12050: balance_leaf_when_delete: rnum(%d) and lnum(%d) and item number in S[0] are not consistent",
+                        tb->rnum[0], tb->lnum[0], n);
+
+      if (( tb->lnum[0] + tb->rnum[0] == n ) && (tb->lbytes != -1 || tb->rbytes != -1))
+	reiserfs_panic (tb->tb_sb, "PAP-12055: balance_leaf_when_delete: bad rbytes (%d)/lbytes (%d) parameters when items are not split", 
+                        tb->rbytes, tb->lbytes);
+      if (( tb->lnum[0] + tb->rnum[0] == n + 1 ) && (tb->lbytes < 1 || tb->rbytes != -1))
+	reiserfs_panic (tb->tb_sb, "PAP-12060: balance_leaf_when_delete: bad rbytes (%d)/lbytes (%d) parameters when items are split", 
+                        tb->rbytes, tb->lbytes);
+#endif
+
+      leaf_shift_left (th, tb, tb->lnum[0], tb->lbytes);
+      leaf_shift_right(th, tb, tb->rnum[0], tb->rbytes);
+
+      reiserfs_invalidate_buffer (th, tb, tbS0, 1/*do_free_block*/);
+      /*preserve_invalidate (th, tb, tbS0, tb->L[0]);
+      if (!buffer_dirty (tb->R[0]) && !buffer_journaled(tb->R[0]))
+	printk ("clean buffer marked sr 1\n");
+      mark_suspected_recipient (tb->tb_sb, tb->R[0]);*/
+
+      return 0;
+    }
+
+  if ( tb->rnum[0] == -1 ) {
+    /* all contents of R[0] and S[0] will be in R[0] */
+    leaf_shift_right(th, tb, n, -1);
+    reiserfs_invalidate_buffer (th, tb, tbS0, 1/*do_free_block*/);
+/*    preserve_invalidate(th, tb, tbS0, tb->R[0]); */
+    return 0;
+  }
+
+#ifdef REISERFS_CHECK
+  if ( tb->rnum[0] )
+    reiserfs_panic (tb->tb_sb, "PAP-12065: balance_leaf_when_delete: bad rnum parameter must be 0 (%d)", tb->rnum[0]);
+#endif
+
+  return 0;
+}
+
+
+static int	balance_leaf(
+			     struct reiserfs_transaction_handle *th, 
+			     struct tree_balance * tb,		/* see reiserfs_fs.h */
+			     int pos_in_item,                /* position in item, in bytes for direct
+								and indirect items, in entries for
+								directories (for which it is an index
+								into the array of directory entry
+								headers.) */
+
+			     struct item_head * ih,		/* item header of inserted item */
+			     const char * body,		/* body  of inserted item or bytes to paste */
+			     int flag,			/* i - insert, d - delete, c - cut, p - paste
+							   (see comment to do_balance) */
+			     int mem_mode,	  /* memory mode; must be REISERFS_USER_MEM or REISERFS_KERNEL_MEM,
+						     depending on whether the body parameter is located in a
+						     user buffer in user memory or not. */
+			     int zeros_number,		/* will be commented later */
+				
+			     struct item_head * insert_key,  /* in our processing of one level we sometimes determine what
+								must be inserted into the next higher level.  This insertion
+								consists of a key or two keys and their corresponding
+								pointers */
+			     struct buffer_head ** insert_ptr /* inserted node-ptrs for the next level */
+			     )
+{
+  struct buffer_head * tbS0 = PATH_PLAST_BUFFER (tb->tb_path);
+/*  struct buffer_head * tbF0 = PATH_H_PPARENT (tb->tb_path, 0);
+  int S0_b_item_order = PATH_H_B_ITEM_ORDER (tb->tb_path, 0);*/
+  int item_pos = PATH_LAST_POSITION (tb->tb_path);	/*  index into the array of item headers in S[0] 
+							    of the affected item */
+  struct buffer_info bi;
+  struct buffer_head *S_new[2];  /* new nodes allocated to hold what could not fit into S */
+  int snum[2];			   /* number of items that will be placed into S_new (includes partially shifted items) */
+  int sbytes[2];                   /* if an item is partially shifted into S_new then 
+				      if it is a directory item 
+				      it is the number of entries from the item that are shifted into S_new
+				      else
+				      it is the number of bytes from the item that are shifted into S_new
+				      */
+  int n, i;
+  int ret_val;
+
+  /* Make balance in case insert_size[0] < 0 */
+  if ( tb->insert_size[0] < 0 )
+    return balance_leaf_when_delete (th, tb, pos_in_item, flag);
+  
+  /* for indirect item pos_in_item is measured in unformatted node
+     pointers. Recalculate to bytes */
+  if (flag != M_INSERT && I_IS_INDIRECT_ITEM (B_N_PITEM_HEAD (tbS0, item_pos)))
+    pos_in_item *= UNFM_P_SIZE;
+
+  if ( tb->lnum[0] > 0 ) {
+    /* Shift lnum[0] items from S[0] to the left neighbor L[0] */
+    if ( item_pos < tb->lnum[0] ) {
+      /* new item or it part falls to L[0], shift it too */
+      n = B_NR_ITEMS(tb->L[0]);
+
+      switch (flag) {
+      case M_INSERT:   /* insert item into L[0] */
+
+	if ( item_pos == tb->lnum[0] - 1 && tb->lbytes != -1 ) {
+	  /* part of new item falls into L[0] */
+	  int new_item_len;
+
+#ifdef REISERFS_CHECK
+	  if (!I_IS_DIRECT_ITEM (ih))
+	    reiserfs_panic (tb->tb_sb, "PAP-12075: balance_leaf: " 
+			    "only direct inserted item can be broken. k_uniqueness=%lu",
+			    ih->ih_key.k_uniqueness);
+#endif
+	  ret_val = leaf_shift_left (th, tb, tb->lnum[0]-1, -1);
+	  /* when reading the if conditions preceding the subsequent preserve_shifted
+	     lines understand that their goal is to determine if all that we are
+	     shifting is the new data being added */
+/*
+	  if (tb->lnum[0] - 1 > 0) {
+	    preserve_shifted(tb, &(PATH_PLAST_BUFFER (tb->tb_path)), tbF0, S0_b_item_order, tb->L[0]);
+	    tbS0 = PATH_PLAST_BUFFER (tb->tb_path);
+	  }
+*/
+	  /* Calculate item length to insert to S[0] */
+	  new_item_len = ih->ih_item_len - tb->lbytes;
+	  /* Calculate and check item length to insert to L[0] */
+	  ih->ih_item_len -= new_item_len;
+
+#ifdef REISERFS_CHECK
+	  if ( (int)(ih->ih_item_len) <= 0 )
+	    reiserfs_panic(tb->tb_sb, "PAP-12080: balance_leaf: "
+			   "there is nothing to insert into L[0]: ih_item_len=%d",
+			   (int)ih->ih_item_len);
+#endif
+
+	  /* Insert new item into L[0] */
+	  bi.bi_bh = tb->L[0];
+	  bi.bi_parent = tb->FL[0];
+	  bi.bi_position = get_left_neighbor_position (tb, 0);
+	  leaf_insert_into_buf (th, &bi, n + item_pos - ret_val, ih, body, mem_mode,
+				zeros_number > ih->ih_item_len ? ih->ih_item_len : zeros_number);
+/*
+	  if (tb->preserve_mode == PRESERVE_INDIRECT_TO_DIRECT){
+	    if (!buffer_dirty (bi.bi_bh) && !buffer_journaled(bi.bi_bh))
+	      printk ("clean buffer marked sr 2\n");
+	    mark_suspected_recipient (tb->tb_sb, bi.bi_bh);
+	  }
+*/  
+	  /* Calculate key component, item length and body to insert into S[0] */
+	  ih->ih_key.k_offset += tb->lbytes;
+	  ih->ih_item_len = new_item_len;
+          if ( tb->lbytes >  zeros_number ) {
+            body += (tb->lbytes - zeros_number);
+            zeros_number = 0;
+          }
+          else
+            zeros_number -= tb->lbytes;
+
+#ifdef REISERFS_CHECK
+	  if ( (int)(ih->ih_item_len) <= 0 )
+	    reiserfs_panic(tb->tb_sb, "PAP-12085: balance_leaf: "
+			   "there is nothing to insert into S[0]: ih_item_len=%d",
+			   (int)ih->ih_item_len);
+#endif
+	} else {
+	  /* new item in whole falls into L[0] */
+	  /* Shift lnum[0]-1 items to L[0] */
+	  ret_val = leaf_shift_left(th, tb, tb->lnum[0]-1, tb->lbytes);
+/*
+	  if (tb->lnum[0] > 1) {
+	    preserve_shifted(tb, &(PATH_PLAST_BUFFER (tb->tb_path)), tbF0, S0_b_item_order, tb->L[0]);
+	    tbS0 = PATH_PLAST_BUFFER (tb->tb_path);
+	  }
+*/
+	  /* Insert new item into L[0] */
+	  bi.bi_bh = tb->L[0];
+	  bi.bi_parent = tb->FL[0];
+	  bi.bi_position = get_left_neighbor_position (tb, 0);
+	  leaf_insert_into_buf (th, &bi, n + item_pos - ret_val, ih, body, mem_mode, zeros_number);
+/*
+	  if (tb->preserve_mode == PRESERVE_INDIRECT_TO_DIRECT){
+	    if (!buffer_dirty (bi.bi_bh) && !buffer_journaled(bi.bi_bh))
+	      printk ("clean buffer marked sr 3\n");
+	    mark_suspected_recipient (tb->tb_sb, bi.bi_bh);
+	  }
+*/
+	  tb->insert_size[0] = 0;
+          zeros_number = 0;
+	}
+	break;
+
+      case M_PASTE:   /* append item in L[0] */
+
+	if ( item_pos == tb->lnum[0] - 1 && tb->lbytes != -1 ) {
+	  /* we must shift the part of the appended item */
+	  if ( I_IS_DIRECTORY_ITEM (B_N_PITEM_HEAD (tbS0, item_pos))) {
+
+#ifdef REISERFS_CHECK
+	    if ( zeros_number )
+              reiserfs_panic(tb->tb_sb, "PAP-12090: balance_leaf: illegal parameter in case of a directory");
+#endif
+            
+	    /* directory item */
+	    if ( tb->lbytes > pos_in_item ) {
+	      /* new directory entry falls into L[0] */
+	      struct item_head * pasted;
+	      int l_pos_in_item = pos_in_item;
+							  
+	      /* Shift lnum[0] - 1 items in whole. Shift lbytes - 1 entries from given directory item */
+	      ret_val = leaf_shift_left(th, tb, tb->lnum[0], tb->lbytes - 1);
+/*	      preserve_shifted(tb, &(PATH_PLAST_BUFFER (tb->tb_path)), tbF0, S0_b_item_order, tb->L[0]);
+	      tbS0 = PATH_PLAST_BUFFER (tb->tb_path);*/
+	      if ( ret_val && ! item_pos ) {
+		pasted =  B_N_PITEM_HEAD(tb->L[0],B_NR_ITEMS(tb->L[0])-1);
+		l_pos_in_item += I_ENTRY_COUNT(pasted) - (tb->lbytes-1);
+	      }
+
+	      /* Append given directory entry to directory item */
+	      bi.bi_bh = tb->L[0];
+	      bi.bi_parent = tb->FL[0];
+	      bi.bi_position = get_left_neighbor_position (tb, 0);
+	      leaf_paste_in_buffer (th, &bi, n + item_pos - ret_val, l_pos_in_item,
+				    tb->insert_size[0], body, mem_mode, zeros_number);
+
+	      /* previous string prepared space for pasting new entry, following string pastes this entry */
+
+	      /* when we have merge directory item, pos_in_item has been changed too */
+
+	      /* paste new directory entry. 1 is entry number */
+	      leaf_paste_entries (bi.bi_bh, n + item_pos - ret_val, l_pos_in_item, 1,
+				  (struct reiserfs_de_head *)body, 
+				  body + DEH_SIZE, tb->insert_size[0]
+				  );
+	      tb->insert_size[0] = 0;
+	    } else {
+	      /* new directory item doesn't fall into L[0] */
+	      /* Shift lnum[0]-1 items in whole. Shift lbytes directory entries from directory item number lnum[0] */
+	      leaf_shift_left (th, tb, tb->lnum[0], tb->lbytes);
+/*	      preserve_shifted(tb, &(PATH_PLAST_BUFFER (tb->tb_path)), tbF0, S0_b_item_order, tb->L[0]);
+	      tbS0 = PATH_PLAST_BUFFER (tb->tb_path);*/
+	    }
+	    /* Calculate new position to append in item body */
+	    pos_in_item -= tb->lbytes;
+          }
+	  else {
+	    /* regular object */
+
+#ifdef REISERFS_CHECK
+	    if ( tb->lbytes  <= 0 )
+	      reiserfs_panic(tb->tb_sb, "PAP-12095: balance_leaf: " 
+			     "there is nothing to shift to L[0]. lbytes=%d",
+			     tb->lbytes);
+	    if ( pos_in_item != B_N_PITEM_HEAD(tbS0, item_pos)->ih_item_len )
+	      reiserfs_panic(tb->tb_sb, "PAP-12100: balance_leaf: " 
+			     "incorrect position to paste: item_len=%d, pos_in_item=%d",
+			     B_N_PITEM_HEAD(tbS0,item_pos)->ih_item_len, pos_in_item);
+#endif
+
+	    if ( tb->lbytes >= pos_in_item ) {
+	      /* appended item will be in L[0] in whole */
+	      int l_n;
+
+	      /* this bytes number must be appended to the last item of L[h] */
+	      l_n = tb->lbytes - pos_in_item;
+
+	      /* Calculate new insert_size[0] */
+	      tb->insert_size[0] -= l_n;
+
+#ifdef REISERFS_CHECK
+	      if ( tb->insert_size[0] <= 0 )
+		reiserfs_panic(tb->tb_sb, "PAP-12105: balance_leaf: " 
+			       "there is nothing to paste into L[0]. insert_size=%d",
+			       tb->insert_size[0]);
+#endif
+
+	      ret_val =  leaf_shift_left(th, tb,tb->lnum[0], 
+					 B_N_PITEM_HEAD(tbS0,item_pos)->ih_item_len);
+/*	      preserve_shifted(tb, &(PATH_PLAST_BUFFER (tb->tb_path)), tbF0, S0_b_item_order, tb->L[0]);
+	      tbS0 = PATH_PLAST_BUFFER (tb->tb_path);*/
+	      /* Append to body of item in L[0] */
+	      bi.bi_bh = tb->L[0];
+	      bi.bi_parent = tb->FL[0];
+	      bi.bi_position = get_left_neighbor_position (tb, 0);
+	      leaf_paste_in_buffer(th, 
+				   &bi,n + item_pos - ret_val,
+				   B_N_PITEM_HEAD(tb->L[0],n+item_pos-ret_val)->ih_item_len,
+				   l_n,body,mem_mode, zeros_number > l_n ? l_n : zeros_number
+				   );
+
+#ifdef REISERFS_CHECK
+	      if (l_n && I_IS_INDIRECT_ITEM(B_N_PITEM_HEAD(tb->L[0],
+							   n + item_pos - ret_val)))
+		reiserfs_panic(tb->tb_sb, "PAP-12110: balance_leaf: "
+			       "pasting more than 1 unformatted node pointer into indirect item");
+#endif
+
+	      /* 0-th item in S0 can be only of DIRECT type when l_n != 0*/
+	      B_N_PKEY (tbS0, 0)->k_offset += l_n;
+	      B_N_PDELIM_KEY(tb->CFL[0],tb->lkey[0])->k_offset += l_n;
+
+	      B_PRIGHT_DELIM_KEY(tb->L[0])->k_offset += l_n;
+
+#ifdef REISERFS_CHECK /* killed for journal */
+	      if (0 && (!buffer_dirty (tbS0) || !buffer_dirty (tb->CFL[0]) || !buffer_dirty (tb->L[0])))
+		reiserfs_panic(tb->tb_sb, "PAP-12115: balance_leaf: L, CLF and S must be dirty already");
+#endif
+
+	      /* Calculate new body, position in item and insert_size[0] */
+              if ( l_n > zeros_number ) {
+                body += (l_n - zeros_number);
+                zeros_number = 0;
+              }
+              else
+                zeros_number -= l_n;
+	      pos_in_item = 0;	
+
+#ifdef REISERFS_CHECK	
+	      if (COMP_SHORT_KEYS (B_N_PKEY(tbS0,0),
+				   B_N_PKEY(tb->L[0],B_NR_ITEMS(tb->L[0])-1)) ||
+		  !is_left_mergeable (B_N_PITEM_HEAD (tbS0, 0), tbS0->b_size) ||
+		  !is_left_mergeable((struct item_head *)B_N_PDELIM_KEY(tb->CFL[0],tb->lkey[0]), tbS0->b_size))
+		reiserfs_panic (tb->tb_sb, "PAP-12120: balance_leaf: "
+				"item must be merge-able with left neighboring item");
+#endif
+
+	    }
+	    else /* only part of the appended item will be in L[0] */
+	      {
+		/* Calculate position in item for append in S[0] */
+		pos_in_item -= tb->lbytes;
+
+#ifdef REISERFS_CHECK
+		if ( pos_in_item <= 0 )
+		  reiserfs_panic(tb->tb_sb, "PAP-12125: balance_leaf: "
+				 "no place for paste. pos_in_item=%d", pos_in_item);
+#endif
+
+		/* Shift lnum[0] - 1 items in whole. Shift lbytes - 1 byte from item number lnum[0] */
+		leaf_shift_left(th, tb,tb->lnum[0],tb->lbytes);
+/*		preserve_shifted(tb, &(PATH_PLAST_BUFFER (tb->tb_path)), tbF0, S0_b_item_order, tb->L[0]);
+		tbS0 = PATH_PLAST_BUFFER (tb->tb_path);*/
+	      }
+	  }
+	}
+	else /* appended item will be in L[0] in whole */
+	  {
+	    struct item_head * pasted;
+
+#ifdef REISERFS_FSCK
+	    if ( ! item_pos  && is_left_mergeable (tb->tb_sb, tb->tb_path) == 1 )
+#else
+	    if ( ! item_pos  && is_left_mergeable (B_N_PITEM_HEAD (tbS0, 0), tbS0->b_size) )
+#endif
+	      { /* if we paste into first item of S[0] and it is left mergable */
+		/* then increment pos_in_item by the size of the last item in L[0] */
+		pasted = B_N_PITEM_HEAD(tb->L[0],n-1);
+		if ( I_IS_DIRECTORY_ITEM(pasted) )
+		  pos_in_item += I_ENTRY_COUNT(pasted);
+		else
+		  pos_in_item += pasted->ih_item_len;
+	      }
+
+	    /* Shift lnum[0] - 1 items in whole. Shift lbytes - 1 byte from item number lnum[0] */
+	    ret_val = leaf_shift_left(th, tb,tb->lnum[0],tb->lbytes);
+/*	    preserve_shifted(tb, &(PATH_PLAST_BUFFER (tb->tb_path)), tbF0, S0_b_item_order, tb->L[0]);
+	    tbS0 = PATH_PLAST_BUFFER (tb->tb_path);*/
+	    /* Append to body of item in L[0] */
+	    bi.bi_bh = tb->L[0];
+	    bi.bi_parent = tb->FL[0];
+	    bi.bi_position = get_left_neighbor_position (tb, 0);
+	    leaf_paste_in_buffer (th, &bi, n + item_pos - ret_val, pos_in_item, tb->insert_size[0],
+				  body, mem_mode, zeros_number);
+
+	    /* if appended item is directory, paste entry */
+	    pasted = B_N_PITEM_HEAD (tb->L[0], n + item_pos - ret_val);
+	    if (I_IS_DIRECTORY_ITEM (pasted))
+	      leaf_paste_entries (
+				  bi.bi_bh, n + item_pos - ret_val, pos_in_item, 1, 
+				  (struct reiserfs_de_head *)body, body + DEH_SIZE, tb->insert_size[0]
+				  );
+	    /* if appended item is indirect item, put unformatted node into un list */
+	    if (I_IS_INDIRECT_ITEM (pasted))
+	      pasted->u.ih_free_space = ((struct unfm_nodeinfo*)body)->unfm_freespace;
+	    tb->insert_size[0] = 0;
+	    zeros_number = 0;
+	  }
+	break;
+      default:    /* cases d and t */
+	reiserfs_panic (tb->tb_sb, "PAP-12130: balance_leaf: lnum > 0: unexpectable mode: %s(%d)",
+			(flag == M_DELETE) ? "DELETE" : ((flag == M_CUT) ? "CUT" : "UNKNOWN"), flag);
+      }
+    } else { 
+      /* new item doesn't fall into L[0] */
+      leaf_shift_left(th, tb,tb->lnum[0],tb->lbytes);
+/*      preserve_shifted(tb, &(PATH_PLAST_BUFFER (tb->tb_path)), tbF0, S0_b_item_order, tb->L[0]);
+      tbS0 = PATH_PLAST_BUFFER (tb->tb_path);*/
+    }
+  }	/* tb->lnum[0] > 0 */
+
+  /* Calculate new item position */
+  item_pos -= ( tb->lnum[0] - (( tb->lbytes != -1 ) ? 1 : 0));
+
+  if ( tb->rnum[0] > 0 ) {
+    /* shift rnum[0] items from S[0] to the right neighbor R[0] */
+    n = B_NR_ITEMS(tbS0);
+    switch ( flag ) {
+
+    case M_INSERT:   /* insert item */
+      if ( n - tb->rnum[0] < item_pos )
+	{ /* new item or its part falls to R[0] */
+	  if ( item_pos == n - tb->rnum[0] + 1 && tb->rbytes != -1 )
+	    { /* part of new item falls into R[0] */
+	      int old_key_comp, old_len, r_zeros_number;
+	      const char * r_body;
+
+#ifdef REISERFS_CHECK
+	      if ( !I_IS_DIRECT_ITEM(ih) )
+		reiserfs_panic(tb->tb_sb, "PAP-12135: balance_leaf: "
+			       "only direct item can be split. Offset and uniqueness are: [%lu %lu]",
+			       ih->ih_key.k_offset, ih->ih_key.k_uniqueness);
+#endif
+
+	      leaf_shift_right(th, tb,tb->rnum[0]-1,-1);
+/*
+	      if (tb->rnum[0]>1) {
+		preserve_shifted(tb, &(PATH_PLAST_BUFFER (tb->tb_path)), tbF0, S0_b_item_order, tb->R[0]);
+		tbS0 = PATH_PLAST_BUFFER (tb->tb_path);
+	      }
+*/
+	      /* Remember key component and item length */
+	      old_key_comp = ih->ih_key.k_offset;
+	      old_len = ih->ih_item_len;
+
+	      /* Calculate key component and item length to insert into R[0] */
+	      ih->ih_key.k_offset += (old_len - tb->rbytes);
+	      ih->ih_item_len = tb->rbytes;
+	      /* Insert part of the item into R[0] */
+	      bi.bi_bh = tb->R[0];
+	      bi.bi_parent = tb->FR[0];
+	      bi.bi_position = get_right_neighbor_position (tb, 0);
+	      if ( ih->ih_key.k_offset - old_key_comp > zeros_number ) {
+		r_zeros_number = 0;
+		r_body = body + ih->ih_key.k_offset - old_key_comp - zeros_number;
+	      }
+	      else {
+		r_body = body;
+		r_zeros_number = zeros_number - (ih->ih_key.k_offset - old_key_comp);
+		zeros_number -= r_zeros_number;
+	      }
+
+	      leaf_insert_into_buf (th, &bi, 0, ih, r_body, mem_mode, r_zeros_number);
+/*	      if (tb->preserve_mode == PRESERVE_INDIRECT_TO_DIRECT){
+		if (!buffer_dirty (bi.bi_bh) && !buffer_journaled(bi.bi_bh))
+		  printk ("clean buffer marked sr 4\n");
+		mark_suspected_recipient (tb->tb_sb, bi.bi_bh);
+	      }
+*/
+
+	      /* Replace right delimiting key by first key in R[0] */
+	      replace_key(th, tb->CFR[0],tb->rkey[0],tb->R[0],0);
+
+	      /* update right delimiting key */
+	      copy_key(B_PRIGHT_DELIM_KEY(tbS0), &(ih->ih_key));
+	      journal_mark_dirty (th, tb->tb_sb, tbS0); /* probably not needed */
+
+	      /* Calculate key component and item length to insert into S[0] */
+	      ih->ih_key.k_offset = old_key_comp;
+	      ih->ih_item_len = old_len - tb->rbytes;
+
+	      tb->insert_size[0] -= tb->rbytes;
+
+	    }
+	  else /* whole new item falls into R[0] */
+	    {					  
+	      /* Shift rnum[0]-1 items to R[0] */
+	      ret_val = leaf_shift_right(th, tb,tb->rnum[0]-1,tb->rbytes);
+/*	      if (tb->rnum[0]>1) {
+		preserve_shifted(tb, &(PATH_PLAST_BUFFER (tb->tb_path)), tbF0, S0_b_item_order, tb->R[0]);
+		tbS0 = PATH_PLAST_BUFFER (tb->tb_path);
+	      }*/
+	      /* Insert new item into R[0] */
+	      bi.bi_bh = tb->R[0];
+	      bi.bi_parent = tb->FR[0];
+	      bi.bi_position = get_right_neighbor_position (tb, 0);
+	      leaf_insert_into_buf (th, &bi, item_pos - n + tb->rnum[0] - 1, ih, body, mem_mode, zeros_number);
+/*
+	      if (tb->preserve_mode == PRESERVE_INDIRECT_TO_DIRECT){
+		if (!buffer_dirty (bi.bi_bh) && !buffer_journaled(bi.bi_bh))
+		  printk ("clean buffer marked sr 5\n");
+		mark_suspected_recipient (tb->tb_sb, bi.bi_bh);
+	      }
+*/
+	      /* If we insert new item in the begin of R[0] change the right delimiting key */
+	      if ( item_pos - n + tb->rnum[0] - 1 == 0 ) {
+		replace_key(th, tb->CFR[0],tb->rkey[0],tb->R[0],0);
+
+		/* update right delimiting key */
+		copy_key(B_PRIGHT_DELIM_KEY(tbS0), &(ih->ih_key));
+		/* reiserfs_mark_buffer_dirty (tbS0, 0); journal victim */
+		journal_mark_dirty (th, tb->tb_sb, tbS0);
+	      }
+	      zeros_number = tb->insert_size[0] = 0;
+	    }
+	}
+      else /* new item or part of it doesn't fall into R[0] */
+	{
+	  leaf_shift_right(th, tb,tb->rnum[0],tb->rbytes);
+/*	  preserve_shifted(tb, &(PATH_PLAST_BUFFER (tb->tb_path)), tbF0, S0_b_item_order, tb->R[0]);
+	  tbS0 = PATH_PLAST_BUFFER (tb->tb_path);*/
+	}
+      break;
+
+    case M_PASTE:   /* append item */
+
+      if ( n - tb->rnum[0] <= item_pos )  /* pasted item or part of it falls to R[0] */
+	{
+	  if ( item_pos == n - tb->rnum[0] && tb->rbytes != -1 )
+	    { /* we must shift the part of the appended item */
+	      if ( I_IS_DIRECTORY_ITEM (B_N_PITEM_HEAD(tbS0, item_pos)))
+		{ /* we append to directory item */
+		  int entry_count;
+
+#ifdef REISERFS_CHECK
+		  if ( zeros_number )
+		    reiserfs_panic(tb->tb_sb, "PAP-12145: balance_leaf: illegal parametr in case of a directory");
+#endif
+
+		  entry_count = I_ENTRY_COUNT(B_N_PITEM_HEAD(tbS0, item_pos));
+		  if ( entry_count - tb->rbytes < pos_in_item )
+		    /* new directory entry falls into R[0] */
+		    {
+		      int paste_entry_position;
+
+#ifdef REISERFS_CHECK
+		      if ( tb->rbytes - 1 >= entry_count || ! tb->insert_size[0] )
+			reiserfs_panic(tb->tb_sb, "PAP-12150: balance_leaf: "
+				       "no enough of entries to shift to R[0]: rbytes=%d, entry_count=%d",
+				       tb->rbytes, entry_count);
+#endif
+
+		      /* Shift rnum[0]-1 items in whole. Shift rbytes-1 directory entries from directory item number rnum[0] */
+		      leaf_shift_right(th, tb,tb->rnum[0],tb->rbytes - 1);
+		      /* if we are shifting more than just the new entry */
+/*
+		      if (tb->rbytes > 1 || tb->rnum[0] > 1) {
+			preserve_shifted(tb, &(PATH_PLAST_BUFFER (tb->tb_path)), tbF0, S0_b_item_order, tb->R[0]);
+			tbS0 = PATH_PLAST_BUFFER (tb->tb_path);
+		      }
+*/
+		      /* Paste given directory entry to directory item */
+		      paste_entry_position = pos_in_item - entry_count + tb->rbytes - 1;
+
+		      bi.bi_bh = tb->R[0];
+		      bi.bi_parent = tb->FR[0];
+		      bi.bi_position = get_right_neighbor_position (tb, 0);
+		      leaf_paste_in_buffer (th, &bi, 0, paste_entry_position,
+					    tb->insert_size[0],body,mem_mode,zeros_number);
+		      /* paste entry */
+		      leaf_paste_entries (
+					  bi.bi_bh, 0, paste_entry_position, 1, (struct reiserfs_de_head *)body, 
+					  body + DEH_SIZE, tb->insert_size[0]
+					  );								
+						
+		      if ( paste_entry_position == 0 ) {
+			/* change delimiting keys */
+			replace_key(th, tb->CFR[0],tb->rkey[0],tb->R[0],0);
+			copy_key(B_PRIGHT_DELIM_KEY(tbS0), B_N_PKEY(tb->R[0], 0));
+			/* reiserfs_mark_buffer_dirty (tbS0, 0); journal victim */
+			journal_mark_dirty (th, tb->tb_sb, tbS0);
+		      }
+
+		      tb->insert_size[0] = 0;
+		      pos_in_item++;
+		    }
+		  else /* new directory entry doesn't fall into R[0] */
+		    {
+		      leaf_shift_right(th, tb,tb->rnum[0],tb->rbytes);
+/*
+		      preserve_shifted(tb, &(PATH_PLAST_BUFFER (tb->tb_path)), tbF0, S0_b_item_order, tb->R[0]);
+		      tbS0 = PATH_PLAST_BUFFER (tb->tb_path);
+*/
+		    }
+		}
+	      else /* regular object */
+		{
+		  int n_shift, n_rem, r_zeros_number;
+		  const char * r_body;
+
+		  /* Calculate number of bytes which must be shifted from appended item */
+		  if ( (n_shift = tb->rbytes - tb->insert_size[0]) < 0 )
+		    n_shift = 0;
+
+#ifdef REISERFS_CHECK
+		  if (pos_in_item != B_N_PITEM_HEAD (tbS0, item_pos)->ih_item_len)
+		    reiserfs_panic(tb->tb_sb,"PAP-12155: balance_leaf: invalid position to paste. ih_item_len=%d, pos_in_item=%d",
+				   pos_in_item, B_N_PITEM_HEAD(tbS0,item_pos)->ih_item_len);
+#endif
+
+		  leaf_shift_right(th, tb,tb->rnum[0],n_shift);
+		  /* if we are shifting an old part from the appended item or more than the appended item is going into R */
+/*
+		  if (n_shift || tb->rnum[0] > 1) {
+		    preserve_shifted(tb, &(PATH_PLAST_BUFFER (tb->tb_path)), tbF0, S0_b_item_order, tb->R[0]);
+		    tbS0 = PATH_PLAST_BUFFER (tb->tb_path);
+		  }
+*/
+		  /* Calculate number of bytes which must remain in body after appending to R[0] */
+		  if ( (n_rem = tb->insert_size[0] - tb->rbytes) < 0 )
+		    n_rem = 0;
+
+		  B_N_PKEY(tb->R[0],0)->k_offset += n_rem;
+		  B_N_PDELIM_KEY(tb->CFR[0],tb->rkey[0])->k_offset += n_rem;
+		  /* reiserfs_mark_buffer_dirty (tb->CFR[0], 0); */
+		  journal_mark_dirty (th, tb->tb_sb, tb->CFR[0]);
+
+		  B_PRIGHT_DELIM_KEY(tbS0)->k_offset += n_rem;
+		  /* reiserfs_mark_buffer_dirty (tbS0, 0); journal victim */
+		  journal_mark_dirty (th, tb->tb_sb, tbS0); 
+		  /* Append part of body into R[0] */
+		  bi.bi_bh = tb->R[0];
+		  bi.bi_parent = tb->FR[0];
+		  bi.bi_position = get_right_neighbor_position (tb, 0);
+		  if ( n_rem > zeros_number ) {
+		    r_zeros_number = 0;
+		    r_body = body + n_rem - zeros_number;
+		  }
+		  else {
+		    r_body = body;
+		    r_zeros_number = zeros_number - n_rem;
+		    zeros_number -= r_zeros_number;
+		  }
+
+		  leaf_paste_in_buffer(th, &bi, 0, n_shift, tb->insert_size[0] - n_rem, r_body, mem_mode, r_zeros_number);
+
+		  if (I_IS_INDIRECT_ITEM(B_N_PITEM_HEAD(tb->R[0],0))) {
+
+#ifdef REISERFS_CHECK
+		    if (n_rem)
+		      reiserfs_panic(tb->tb_sb, "PAP-12160: balance_leaf: paste more than one unformatted node pointer");
+#endif
+
+		    B_N_PITEM_HEAD(tb->R[0],0)->u.ih_free_space = ((struct unfm_nodeinfo*)body)->unfm_freespace;
+		  }
+
+		  tb->insert_size[0] = n_rem;
+		  if ( ! n_rem )
+		    pos_in_item ++;
+		}
+	    }
+	  else /* pasted item in whole falls into R[0] */
+	    {
+	      struct item_head * pasted;
+
+	      ret_val = leaf_shift_right(th, tb,tb->rnum[0],tb->rbytes);
+/*
+	      preserve_shifted(tb, &(PATH_PLAST_BUFFER (tb->tb_path)), tbF0, S0_b_item_order, tb->R[0]);
+	      tbS0 = PATH_PLAST_BUFFER (tb->tb_path);
+*/
+	      /* append item in R[0] */
+	      if ( pos_in_item >= 0 ) {
+		bi.bi_bh = tb->R[0];
+		bi.bi_parent = tb->FR[0];
+		bi.bi_position = get_right_neighbor_position (tb, 0);
+		leaf_paste_in_buffer(th, &bi,item_pos - n + tb->rnum[0], pos_in_item,
+				     tb->insert_size[0],body,mem_mode, zeros_number);
+	      }
+
+	      /* paste new entry, if item is directory item */
+	      pasted = B_N_PITEM_HEAD(tb->R[0], item_pos - n + tb->rnum[0]);
+	      if (I_IS_DIRECTORY_ITEM (pasted) && pos_in_item >= 0 ) {
+		leaf_paste_entries (
+				    bi.bi_bh, item_pos - n + tb->rnum[0], pos_in_item, 1, 
+				    (struct reiserfs_de_head *)body, body + DEH_SIZE, tb->insert_size[0]
+				    );
+		if ( ! pos_in_item ) {
+
+#ifdef REISERFS_CHECK
+		  if ( item_pos - n + tb->rnum[0] )
+		    reiserfs_panic (tb->tb_sb, "PAP-12165: balance_leaf: " 
+				    "directory item must be first item of node when pasting is in 0th position");
+#endif
+
+		  /* update delimiting keys */
+		  replace_key(th, tb->CFR[0],tb->rkey[0],tb->R[0],0);
+		  copy_key(B_PRIGHT_DELIM_KEY(tbS0),B_N_PKEY(tb->R[0], 0));
+		  /* reiserfs_mark_buffer_dirty (tbS0, 0); */
+		  journal_mark_dirty (th, tb->tb_sb, tbS0);
+		}
+	      }
+
+	      if (I_IS_INDIRECT_ITEM (pasted))
+		pasted->u.ih_free_space = ((struct unfm_nodeinfo*)body)->unfm_freespace;
+	      zeros_number = tb->insert_size[0] = 0;
+	    }
+	}
+      else /* new item doesn't fall into R[0] */
+	{
+	  leaf_shift_right(th, tb,tb->rnum[0],tb->rbytes);
+/*
+	  preserve_shifted(tb, &(PATH_PLAST_BUFFER (tb->tb_path)), tbF0, S0_b_item_order, tb->R[0]);
+	  tbS0 = PATH_PLAST_BUFFER (tb->tb_path);
+*/
+	}
+      break;
+    default:    /* cases d and t */
+      reiserfs_panic (tb->tb_sb, "PAP-12175: balance_leaf: rnum > 0: unexpectable mode: %s(%d)",
+		      (flag == M_DELETE) ? "DELETE" : ((flag == M_CUT) ? "CUT" : "UNKNOWN"), flag);
+    }
+    
+  }	/* tb->rnum[0] > 0 */
+
+
+#ifdef REISERFS_CHECK
+  if ( tb->blknum[0] > 3 )  
+    reiserfs_panic (tb->tb_sb, "PAP-12180: balance_leaf: blknum can not be %d. It must be <= 3",  tb->blknum[0]);
+
+  if ( tb->blknum[0] < 0 )  
+    reiserfs_panic (tb->tb_sb, "PAP-12185: balance_leaf: blknum can not be %d. It must be >= 0",  tb->blknum[0]);
+#endif
+
+  /* if while adding to a node we discover that it is possible to split
+     it in two, and merge the left part into the left neighbor and the
+     right part into the right neighbor, eliminating the node */
+  if ( tb->blknum[0] == 0 ) { /* node S[0] is empty now */
+
+#ifdef REISERFS_CHECK
+    if ( ! tb->lnum[0] || ! tb->rnum[0] )
+      reiserfs_panic(tb->tb_sb, "PAP-12190: balance_leaf: lnum and rnum must not be zero");
+    if (COMP_KEYS (B_N_PKEY(tb->R[0], 0), B_PRIGHT_DELIM_KEY(tbS0)))
+      reiserfs_panic (tb->tb_sb, "vs-12192: balance_leaf: S[0] is being removed from the tree, it has incorrect right delimiting key");
+#endif
+
+    /* if insertion was done before 0-th position in R[0], right delimiting key of the tb->L[0]'s
+       and left delimiting key are not set correctly */
+    if (tb->L[0]) {
+      copy_key(B_PRIGHT_DELIM_KEY(tb->L[0]), B_PRIGHT_DELIM_KEY(tbS0));
+      /* reiserfs_mark_buffer_dirty (tb->L[0], 0); journal victim */
+      journal_mark_dirty (th, tb->tb_sb, tb->L[0]);
+    }
+
+    if (tb->CFL[0]) {
+      copy_key (B_N_PDELIM_KEY (tb->CFL[0], tb->lkey[0]), B_PRIGHT_DELIM_KEY(tbS0));
+      /* reiserfs_mark_buffer_dirty (tb->CFL[0], 0); journal victim */
+      journal_mark_dirty (th, tb->tb_sb, tb->CFL[0]);
+    }
+
+    /* we can free block because tbS0 must be preserved (lnum[0] > 0 && rnum[0] > 0) or
+       unwritten. If it was suspected recipient, L[0] and R[0] are suspected recipients already */
+    reiserfs_invalidate_buffer(th, tb,tbS0, 1);									
+    return 0;
+  }
+
+
+  /* Fill new nodes that appear in place of S[0] */
+
+  /* I am told that this copying is because we need an array to enable
+     the looping code. -Hans */
+  snum[0] = tb->s1num,
+    snum[1] = tb->s2num;
+  sbytes[0] = tb->s1bytes;
+  sbytes[1] = tb->s2bytes;
+  for( i = tb->blknum[0] - 2; i >= 0; i-- ) {
+
+#ifdef REISERFS_CHECK
+    if (!snum[i])
+      reiserfs_panic(tb->tb_sb,"PAP-12200: balance_leaf: snum[%d] == %d. Must be > 0", i, snum[i]);
+#endif /* REISERFS_CHECK */
+
+    /* here we shift from S to S_new nodes */
+
+    S_new[i] = get_FEB(tb);
+
+    /* initialized block type and tree level */
+    B_BLK_HEAD(S_new[i])->blk_level = DISK_LEAF_NODE_LEVEL;
+
+
+    n = B_NR_ITEMS(tbS0);
+	
+    switch (flag) {
+    case M_INSERT:   /* insert item */
+
+      if ( n - snum[i] < item_pos )
+	{ /* new item or it's part falls to first new node S_new[i]*/
+	  if ( item_pos == n - snum[i] + 1 && sbytes[i] != -1 )
+	    { /* part of new item falls into S_new[i] */
+	      int old_key_comp, old_len, r_zeros_number;
+	      const char * r_body;
+
+#ifdef REISERFS_CHECK
+	      if ( !I_IS_DIRECT_ITEM(ih) )
+		/* The items which can be inserted are:
+		   Stat_data item, direct item, indirect item and directory item which consist of only two entries "." and "..".
+		   These items must not be broken except for a direct one. */
+		reiserfs_panic(tb->tb_sb, "PAP-12205: balance_leaf: "
+			       "non-direct item can not be broken when inserting");
+#endif
+
+	      /* Move snum[i]-1 items from S[0] to S_new[i] */
+	      leaf_move_items(th, LEAF_FROM_S_TO_SNEW, tb, snum[i] - 1, -1, S_new[i]);
+/*
+	      if (snum[i] > 1 ) {
+		preserve_shifted(tb, &(PATH_PLAST_BUFFER (tb->tb_path)), tbF0, S0_b_item_order, S_new[i]);
+		tbS0 = PATH_PLAST_BUFFER (tb->tb_path);
+	      }
+*/
+	      /* Remember key component and item length */
+	      old_key_comp = ih->ih_key.k_offset;
+	      old_len = ih->ih_item_len;
+
+	      /* Calculate key component and item length to insert into S_new[i] */
+	      ih->ih_key.k_offset += (old_len - sbytes[i]);
+
+	      ih->ih_item_len = sbytes[i];
+
+	      /* Insert part of the item into S_new[i] before 0-th item */
+	      bi.bi_bh = S_new[i];
+	      bi.bi_parent = 0;
+	      bi.bi_position = 0;
+
+	      if ( ih->ih_key.k_offset - old_key_comp > zeros_number ) {
+		r_zeros_number = 0;
+		r_body = body + (ih->ih_key.k_offset - old_key_comp) - zeros_number;
+	      }
+	      else {
+		r_body = body;
+		r_zeros_number = zeros_number - (ih->ih_key.k_offset - old_key_comp);
+		zeros_number -= r_zeros_number;
+	      }
+
+	      leaf_insert_into_buf (th, &bi, 0, ih, r_body, mem_mode, r_zeros_number);
+/*
+	      if (tb->preserve_mode == PRESERVE_INDIRECT_TO_DIRECT){
+		if (!buffer_dirty (bi.bi_bh) && !buffer_journaled(bi.bi_bh))
+		  printk ("clean buffer marked sr 5\n");
+		mark_suspected_recipient (tb->tb_sb, bi.bi_bh);
+	      }
+*/
+	      /* Calculate key component and item length to insert into S[i] */
+	      ih->ih_key.k_offset = old_key_comp;
+	      ih->ih_item_len = old_len - sbytes[i];
+	      tb->insert_size[0] -= sbytes[i];
+	    }
+	  else /* whole new item falls into S_new[i] */
+	    {
+	      /* Shift snum[0] - 1 items to S_new[i] (sbytes[i] of split item) */
+	      leaf_move_items(th, LEAF_FROM_S_TO_SNEW, tb, snum[i] - 1, sbytes[i], S_new[i]);
+/*
+	      if (snum[i] > 1 ) {
+		preserve_shifted(tb, &(PATH_PLAST_BUFFER (tb->tb_path)), tbF0, S0_b_item_order, S_new[i]);
+		tbS0 = PATH_PLAST_BUFFER (tb->tb_path);
+	      }
+*/
+	      /* Insert new item into S_new[i] */
+	      bi.bi_bh = S_new[i];
+	      bi.bi_parent = 0;
+	      bi.bi_position = 0;
+	      leaf_insert_into_buf (th, &bi, item_pos - n + snum[i] - 1, ih, body, mem_mode, zeros_number);
+/*
+	      if (tb->preserve_mode == PRESERVE_INDIRECT_TO_DIRECT){
+		if (!buffer_dirty (bi.bi_bh) && !buffer_journaled(bi.bi_bh))
+		  printk ("clean buffer marked sr 6\n");
+		mark_suspected_recipient (tb->tb_sb, bi.bi_bh);
+	      }
+*/
+	      zeros_number = tb->insert_size[0] = 0;
+	    }
+	}
+
+      else /* new item or it part don't falls into S_new[i] */
+	{
+	  leaf_move_items(th, LEAF_FROM_S_TO_SNEW, tb, snum[i], sbytes[i], S_new[i]);
+/*
+	  preserve_shifted(tb, &(PATH_PLAST_BUFFER (tb->tb_path)), tbF0, S0_b_item_order, S_new[i]);
+	  tbS0 = PATH_PLAST_BUFFER (tb->tb_path);
+*/
+	}
+      break;
+
+    case M_PASTE:   /* append item */
+
+      if ( n - snum[i] <= item_pos )  /* pasted item or part if it falls to S_new[i] */
+	{
+	  if ( item_pos == n - snum[i] && sbytes[i] != -1 )
+	    { /* we must shift part of the appended item */
+	      struct item_head * aux_ih;
+
+#ifdef REISERFS_CHECK
+	      if ( ih )
+		reiserfs_panic (tb->tb_sb, "PAP-12210: balance_leaf: ih must be 0");
+#endif /* REISERFS_CHECK */
+
+	      if ( I_IS_DIRECTORY_ITEM (aux_ih = B_N_PITEM_HEAD(tbS0,item_pos))) {
+		/* we append to directory item */
+
+		int entry_count;
+		
+		entry_count = I_ENTRY_COUNT(aux_ih);
+
+		if ( entry_count - sbytes[i] < pos_in_item  && pos_in_item <= entry_count ) {
+		  /* new directory entry falls into S_new[i] */
+		  
+#ifdef REISERFS_CHECK
+		  if ( ! tb->insert_size[0] )
+		    reiserfs_panic (tb->tb_sb, "PAP-12215: balance_leaif: insert_size is already 0");
+		  if ( sbytes[i] - 1 >= entry_count )
+		    reiserfs_panic (tb->tb_sb, "PAP-12220: balance_leaf: "
+				    "there are no so much entries (%d), only %d",
+				    sbytes[i] - 1, entry_count);
+#endif
+
+		  /* Shift snum[i]-1 items in whole. Shift sbytes[i] directory entries from directory item number snum[i] */
+		  leaf_move_items(th, LEAF_FROM_S_TO_SNEW, tb, snum[i], sbytes[i]-1, S_new[i]);
+		  /* if more than the affected item is shifted, or if more than
+		     one entry (from the affected item) is shifted */
+/*
+		  if (snum[i] > 1 || sbytes[i] > 1) {
+		    preserve_shifted(tb, &(PATH_PLAST_BUFFER (tb->tb_path)), tbF0, S0_b_item_order, S_new[i]);
+		    tbS0 = PATH_PLAST_BUFFER (tb->tb_path);
+		  }
+*/
+		  /* Paste given directory entry to directory item */
+		  bi.bi_bh = S_new[i];
+		  bi.bi_parent = 0;
+		  bi.bi_position = 0;
+		  leaf_paste_in_buffer (th, &bi, 0, pos_in_item - entry_count + sbytes[i] - 1,
+					tb->insert_size[0], body, mem_mode,zeros_number);
+		  /* paste new directory entry */
+		  leaf_paste_entries (
+				      bi.bi_bh, 0, pos_in_item - entry_count + sbytes[i] - 1,
+				      1, (struct reiserfs_de_head *)body, body + DEH_SIZE,
+				      tb->insert_size[0]
+				      );
+		  tb->insert_size[0] = 0;
+		  pos_in_item++;
+		} else { /* new directory entry doesn't fall into S_new[i] */
+		  leaf_move_items(th, LEAF_FROM_S_TO_SNEW, tb, snum[i], sbytes[i], S_new[i]);
+/*
+		  preserve_shifted(tb, &(PATH_PLAST_BUFFER (tb->tb_path)), tbF0, S0_b_item_order, S_new[i]);
+		  tbS0 = PATH_PLAST_BUFFER (tb->tb_path);
+*/
+		}
+	      }
+	      else /* regular object */
+		{
+		  int n_shift, n_rem, r_zeros_number;
+		  const char * r_body;
+
+#ifdef REISERFS_CHECK
+		  if ( pos_in_item != B_N_PITEM_HEAD(tbS0,item_pos)->ih_item_len ||
+		       tb->insert_size[0] <= 0 )
+		    reiserfs_panic (tb->tb_sb, "PAP-12225: balance_leaf: item too short or insert_size <= 0");
+#endif
+
+		  /* Calculate number of bytes which must be shifted from appended item */
+		  n_shift = sbytes[i] - tb->insert_size[0];
+		  if ( n_shift < 0 )
+		    n_shift = 0;
+		  leaf_move_items(th, LEAF_FROM_S_TO_SNEW, tb, snum[i], n_shift, S_new[i]);
+/*
+		  if (n_shift || snum[i] > 1) {
+		    preserve_shifted(tb, &(PATH_PLAST_BUFFER (tb->tb_path)), tbF0, S0_b_item_order, S_new[i]);
+		    tbS0 = PATH_PLAST_BUFFER (tb->tb_path);
+		  }
+*/
+		  /* Calculate number of bytes which must remain in body after append to S_new[i] */
+		  n_rem = tb->insert_size[0] - sbytes[i];
+		  if ( n_rem < 0 )
+		    n_rem = 0;
+		  /* Append part of body into S_new[0] */
+		  bi.bi_bh = S_new[i];
+		  bi.bi_parent = 0;
+		  bi.bi_position = 0;
+
+		  if ( n_rem > zeros_number ) {
+		    r_zeros_number = 0;
+		    r_body = body + n_rem - zeros_number;
+		  }
+		  else {
+		    r_body = body;
+		    r_zeros_number = zeros_number - n_rem;
+		    zeros_number -= r_zeros_number;
+		  }
+
+		  leaf_paste_in_buffer(th, &bi, 0, n_shift, tb->insert_size[0]-n_rem, r_body, mem_mode,r_zeros_number);
+		  if (I_IS_INDIRECT_ITEM(B_N_PITEM_HEAD(S_new[i],0))) {
+		    if (n_rem)
+		      reiserfs_panic (tb->tb_sb, "PAP-12230: balance_leaf: invalid action with indirect item");
+		    B_N_PITEM_HEAD(S_new[i],0)->u.ih_free_space = ((struct unfm_nodeinfo*)body)->unfm_freespace;
+		  }
+
+		  B_N_PKEY(S_new[i],0)->k_offset += n_rem;
+
+		  tb->insert_size[0] = n_rem;
+		  if ( ! n_rem )
+		    pos_in_item++;
+		}
+	    }
+	  else
+	    /* item falls wholly into S_new[i] */
+	    {
+	      int ret_val;
+	      struct item_head * pasted;
+
+#ifdef REISERFS_CHECK
+	      struct item_head * ih = B_N_PITEM_HEAD(tbS0,item_pos);
+
+	      if ( ! I_IS_DIRECTORY_ITEM(ih) && (pos_in_item != ih->ih_item_len ||
+						 tb->insert_size[0] <= 0) )
+		reiserfs_panic (tb->tb_sb, "PAP-12235: balance_leaf: pos_in_item must be equal to ih_item_len");
+#endif /* REISERFS_CHECK */
+
+	      ret_val = leaf_move_items(th, LEAF_FROM_S_TO_SNEW, tb, snum[i], sbytes[i], S_new[i]);
+	      /* we must preserve that which we are pasting onto the end of and shifting */
+/*
+	      preserve_shifted(tb, &(PATH_PLAST_BUFFER (tb->tb_path)), tbF0, S0_b_item_order, S_new[i]);
+	      tbS0 = PATH_PLAST_BUFFER (tb->tb_path);
+*/
+#ifdef REISERFS_CHECK
+	      if ( ret_val )
+		reiserfs_panic (tb->tb_sb, "PAP-12240: balance_leaf: "
+				"unexpected value returned by leaf_move_items (%d)",
+				ret_val);
+#endif /* REISERFS_CHECK */
+
+	      /* paste into item */
+	      bi.bi_bh = S_new[i];
+	      bi.bi_parent = 0;
+	      bi.bi_position = 0;
+	      leaf_paste_in_buffer(th, &bi, item_pos - n + snum[i], pos_in_item, tb->insert_size[0], body, mem_mode, zeros_number);
+
+	      pasted = B_N_PITEM_HEAD(S_new[i], item_pos - n + snum[i]);
+	      if (I_IS_DIRECTORY_ITEM (pasted))
+		{
+		  leaf_paste_entries (
+				      bi.bi_bh, item_pos - n + snum[i], pos_in_item, 1, 
+				      (struct reiserfs_de_head *)body, body + DEH_SIZE, tb->insert_size[0]
+				      );
+		}
+
+	      /* if we paste to indirect item update ih_free_space */
+	      if (I_IS_INDIRECT_ITEM (pasted))
+		pasted->u.ih_free_space = ((struct unfm_nodeinfo*)body)->unfm_freespace;
+	      zeros_number = tb->insert_size[0] = 0;
+	    }
+	}
+
+      else /* pasted item doesn't fall into S_new[i] */
+	{
+	  leaf_move_items(th, LEAF_FROM_S_TO_SNEW, tb, snum[i], sbytes[i], S_new[i]);
+/*
+	  preserve_shifted(tb, &(PATH_PLAST_BUFFER (tb->tb_path)), tbF0, S0_b_item_order, S_new[i]);
+	  tbS0 = PATH_PLAST_BUFFER (tb->tb_path);
+*/
+	}
+      break;
+    default:    /* cases d and t */
+      reiserfs_panic (tb->tb_sb, "PAP-12245: balance_leaf: blknum > 2: unexpectable mode: %s(%d)",
+		      (flag == M_DELETE) ? "DELETE" : ((flag == M_CUT) ? "CUT" : "UNKNOWN"), flag);
+    }
+
+    memcpy (insert_key + i,B_N_PKEY(S_new[i],0),KEY_SIZE);
+    insert_ptr[i] = S_new[i];
+
+#ifdef REISERFS_CHECK
+    if (S_new[i]->b_count != 1) {
+      if (buffer_journaled(S_new[i]) || buffer_journal_dirty(S_new[i])) {
+        ;
+      } else {
+	reiserfs_panic (tb->tb_sb, "PAP-12247: balance_leaf: S_new[%d]->b_count=%u blocknr = %lu\n", i, S_new[i]->b_count,
+	                S_new[i]->b_blocknr);
+      }
+    }
+#endif
+
+    /* update right_delimiting_key fields */
+    copy_key (B_PRIGHT_DELIM_KEY (S_new[i]), B_PRIGHT_DELIM_KEY (tbS0));
+    copy_key (B_PRIGHT_DELIM_KEY (tbS0), B_N_PKEY (S_new[i], 0));
+    /* reiserfs_mark_buffer_dirty (tbS0, 0); journal victim */
+    journal_mark_dirty (th, tb->tb_sb, tbS0);
+
+    /*brelse(S_new[i]);*/
+  }
+
+  /* if the affected item was not wholly shifted then we perform all necessary operations on that part or whole of the
+     affected item which remains in S */
+  if ( 0 <= item_pos && item_pos < tb->s0num )
+    { /* if we must insert or append into buffer S[0] */
+
+      switch (flag)
+	{
+	case M_INSERT:   /* insert item into S[0] */
+	  bi.bi_bh = tbS0;
+	  bi.bi_parent = PATH_H_PPARENT (tb->tb_path, 0);
+	  bi.bi_position = PATH_H_POSITION (tb->tb_path, 1);
+	  leaf_insert_into_buf (th, &bi, item_pos, ih, body, mem_mode, zeros_number);
+/*
+	  if (tb->preserve_mode == PRESERVE_INDIRECT_TO_DIRECT){
+	    if (!buffer_dirty (bi.bi_bh) && !buffer_journaled(bi.bi_bh))
+	      printk ("clean buffer marked sr 7\n");
+	    mark_suspected_recipient (tb->tb_sb, bi.bi_bh);
+	  }
+*/
+
+	  /* If we insert the first key change the delimiting key */
+	  if( item_pos == 0 ) {
+	    if (tb->CFL[0]) /* can be 0 in reiserfsck */
+	      replace_key(th, tb->CFL[0], tb->lkey[0],tbS0,0);
+
+#ifdef REISERFS_CHECK
+	    if ( ! tb->CFL[0] || ! tb->L[0] || (B_NR_ITEMS (tbS0) > 1 && 
+						COMP_KEYS(B_PRIGHT_DELIM_KEY(tb->L[0]), B_N_PKEY(tbS0, 1))) )
+	      reiserfs_panic(tb->tb_sb, "PAP-12250: balance_leaf: invalid right delimiting key");
+	    if (!buffer_dirty (tb->L[0]) && !buffer_journaled(tb->L[0]))
+	      reiserfs_panic (tb->tb_sb, "PAP-12255: balance_leaf: tb->L[0] must be dirty");
+#endif
+	    if (tb->L[0]) /* can be 0 in reiserfsck */
+	      copy_key (B_PRIGHT_DELIM_KEY (tb->L[0]), &(ih->ih_key));   
+	  }
+	  break;
+
+	case M_PASTE: {  /* append item in S[0] */
+	  struct item_head * pasted;
+
+	  pasted = B_N_PITEM_HEAD (tbS0, item_pos);
+	  /* when directory, may be new entry already pasted */
+	  if (I_IS_DIRECTORY_ITEM (pasted)) {
+	    if ( pos_in_item >= 0 && pos_in_item <= I_ENTRY_COUNT (pasted) ) {
+
+#ifdef REISERFS_CHECK
+	      if ( ! tb->insert_size[0] )
+		reiserfs_panic (tb->tb_sb, "PAP-12260: balance_leaf: insert_size is 0 already");
+#endif /* REISERFS_CHECK */
+
+	      /* prepare space */
+	      bi.bi_bh = tbS0;
+	      bi.bi_parent = PATH_H_PPARENT (tb->tb_path, 0);
+	      bi.bi_position = PATH_H_POSITION (tb->tb_path, 1);
+	      leaf_paste_in_buffer(th, &bi, item_pos, pos_in_item, tb->insert_size[0], body, mem_mode, zeros_number);
+
+
+#ifdef REISERFS_CHECK
+	      if ( ! item_pos && ! pos_in_item  && (! tb->L[0] || COMP_KEYS(B_PRIGHT_DELIM_KEY(tb->L[0]), 
+									    B_N_PKEY(tbS0, 0))) )
+		reiserfs_panic(tb->tb_sb, "PAP-12265: balance_leaf: invalid right delimiting key");
+#endif
+
+	      /* paste entry */
+	      leaf_paste_entries (
+				  bi.bi_bh, item_pos, pos_in_item, 1, (struct reiserfs_de_head *)body,
+				  body + DEH_SIZE, tb->insert_size[0]
+				  );
+	      if ( ! item_pos && ! pos_in_item ) {
+
+#ifdef REISERFS_CHECK
+		if (!tb->CFL[0] || !tb->L[0])
+		  reiserfs_panic (tb->tb_sb, "PAP-12270: balance_leaf: CFL[0]/L[0] must be specified");
+#endif /* REISERFS_CHECK */
+
+		if (tb->CFL[0]) {
+		  replace_key(th, tb->CFL[0], tb->lkey[0],tbS0,0);
+
+		  /* update right delimiting key */
+		  copy_key (B_PRIGHT_DELIM_KEY (tb->L[0]), B_N_PKEY(tbS0, 0));   
+		  /* probably not needed as something has been shifted to tb->L[0] already */
+		  /* reiserfs_mark_buffer_dirty (tb->L[0], 0); journal victim */
+		  journal_mark_dirty (th, tb->tb_sb, tb->L[0]);
+		}
+	      }
+	      tb->insert_size[0] = 0;
+	    }
+	  } else { /* regular object */
+	    if ( pos_in_item == pasted->ih_item_len ) {
+
+#ifdef REISERFS_CHECK
+	      if ( tb->insert_size[0] <= 0 )
+		reiserfs_panic (tb->tb_sb,
+				"PAP-12275: balance_leaf: insert size must not be %d", tb->insert_size[0]);
+#endif /* REISERFS_CHECK */
+
+	      bi.bi_bh = tbS0;
+	      bi.bi_parent = PATH_H_PPARENT (tb->tb_path, 0);
+	      bi.bi_position = PATH_H_POSITION (tb->tb_path, 1);
+	      leaf_paste_in_buffer (th, &bi, item_pos, pos_in_item, tb->insert_size[0], body, mem_mode, zeros_number);
+
+	      if (I_IS_INDIRECT_ITEM (pasted)) {
+
+#ifdef REISERFS_CHECK
+		if ( tb->insert_size[0] != UNFM_P_SIZE )
+		  reiserfs_panic (tb->tb_sb,
+				  "PAP-12280: balance_leaf: insert_size for indirect item must be %d, not %d",
+				  UNFM_P_SIZE, tb->insert_size[0]);
+#endif /* REISERFS_CHECK */
+
+		pasted->u.ih_free_space = ((struct unfm_nodeinfo*)body)->unfm_freespace;
+	      }
+	      tb->insert_size[0] = 0;
+	    }
+
+#ifdef REISERFS_CHECK
+	    else {
+	      if ( tb->insert_size[0] ) {
+		print_tb (init_mode, init_item_pos, init_pos_in_item, &init_tb, "12285");
+		reiserfs_panic (tb->tb_sb, "PAP-12285: balance_leaf: insert_size must be 0 (%d)", tb->insert_size[0]);
+	      }
+	    }
+#endif /* REISERFS_CHECK */
+	    
+	  }
+	} /* case M_PASTE: */
+	}
+    }
+
+#ifdef REISERFS_CHECK
+  if ( flag == M_PASTE && tb->insert_size[0] ) {
+    print_tb (M_PASTE, item_pos, pos_in_item, tb, "balance");
+    reiserfs_panic (tb->tb_sb, "PAP-12290: balance_leaf: insert_size is still not 0 (%d)", tb->insert_size[0]);
+  }
+#endif /* REISERFS_CHECK */
+
+  return 0;
+} /* Leaf level of the tree is balanced (end of balance_leaf) */
+
+
+
+/* Make empty node */
+void make_empty_node (struct buffer_info * bi)
+{
+  struct block_head * blkh;
+
+#ifdef REISERFS_CHECK
+  if (bi->bi_bh == NULL)
+    reiserfs_panic (0, "PAP-12295: make_empty_node: pointer to the buffer is NULL");
+#endif
+
+  (blkh = B_BLK_HEAD(bi->bi_bh))->blk_nr_item = 0;
+  blkh->blk_free_space = MAX_CHILD_SIZE(bi->bi_bh); 
+
+  if (bi->bi_parent)
+    B_N_CHILD (bi->bi_parent, bi->bi_position)->dc_size = 0; 
+}
+
+
+/* Get first empty buffer */
+struct buffer_head * get_FEB (struct tree_balance * tb)
+{
+  int i;
+  struct buffer_head * first_b;
+  struct buffer_info bi;
+
+  for (i = 0; i < MAX_FEB_SIZE; i ++)
+    if (tb->FEB[i] != 0)
+      break;
+
+  if (i == MAX_FEB_SIZE)
+    reiserfs_panic(tb->tb_sb, "vs-12300: get_FEB: FEB list is empty");
+
+  bi.bi_bh = first_b = tb->FEB[i];
+  bi.bi_parent = 0;
+  bi.bi_position = 0;
+  make_empty_node (&bi);
+  set_bit(BH_Uptodate, &first_b->b_state);
+
+/*  mark_buffer_unwritten (first_b);*/
+
+  tb->FEB[i] = 0;
+  tb->used[i] = first_b;
+#ifdef REISERFS_FSCK
+  mark_block_formatted (first_b->b_blocknr);
+#endif
+
+  return(first_b);
+}
+
+
+/* Replace n_dest'th key in buffer dest by n_src'th key of buffer src.*/
+void	replace_key (
+		     struct reiserfs_transaction_handle *th, 
+		     struct buffer_head * dest, 
+		     int n_dest,
+		     struct buffer_head * src,
+		     int n_src
+		     )
+{
+
+#ifdef REISERFS_CHECK
+  if (dest == NULL || src == NULL)
+    reiserfs_panic (0, "vs-12305: replace_key: sourse or destination buffer is 0 (src=%p, dest=%p)", src, dest);
+
+  if ( ! B_IS_KEYS_LEVEL (dest) )
+    reiserfs_panic (0, "vs-12310: replace_key: invalid level (%d) for destination buffer. Must be > %d",
+		    B_BLK_HEAD(dest)->blk_level, DISK_LEAF_NODE_LEVEL);
+
+  if (n_dest < 0 || n_src < 0)
+    reiserfs_panic (0, "vs-12315: replace_key: src(%d) or dest(%d) key number less than 0", n_src, n_dest);
+
+  if (n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src))
+    reiserfs_panic (0, "vs-12320: replace_key: src(%d(%d)) or dest(%d(%d)) key number is too big",
+		    n_src, B_NR_ITEMS(src), n_dest, B_NR_ITEMS(dest));
+#endif	/* REISERFS_CHECK */
+   
+  if (B_IS_ITEMS_LEVEL (src))
+    /* source buffer contains leaf node */
+    memcpy (B_N_PDELIM_KEY(dest,n_dest), B_N_PITEM_HEAD(src,n_src), KEY_SIZE);
+  else
+    memcpy (B_N_PDELIM_KEY(dest,n_dest), B_N_PDELIM_KEY(src,n_src), KEY_SIZE);
+
+  /* not preserved, preserves are in balance_leaf() and  balance_leaf_when_delete() */
+  /* reiserfs_mark_buffer_dirty(dest, 0); journal victim */
+  journal_mark_dirty(th, th->t_super, dest);
+}
+
+
+void reiserfs_invalidate_buffer (struct reiserfs_transaction_handle *th,
+                                 struct tree_balance * tb, struct buffer_head * bh, int do_free_block)
+{
+
+  B_BLK_HEAD (bh)->blk_level = FREE_LEVEL;
+  reiserfs_mark_buffer_clean (bh);
+  /*refile_buffer(bh);*/
+
+  /* unwritten and preserved flag will be reset by getblk when buffer will be reused */
+/*  unmark_suspected_recipient (tb->tb_sb, bh);*/
+
+#ifdef REISERFS_CHECK
+  B_NR_ITEMS (bh) = 0;
+#endif
+
+  if (do_free_block/*!is_buffer_preserved (bh)*/) {
+#ifdef REISERFS_FSCK
+    struct buffer_head * to_be_forgotten;
+
+    to_be_forgotten = find_buffer (bh->b_dev, bh->b_blocknr, bh->b_size);
+    if (to_be_forgotten) {
+      to_be_forgotten->b_count ++;
+      bforget (to_be_forgotten);
+    }
+    unmark_block_formatted (bh->b_blocknr);
+#endif
+    reiserfs_free_block (th, tb->tb_sb, bh->b_blocknr);
+
+    /* in reiserfs_free_block, we have atomically dirtied bitmap block
+       of both bitmaps, containing bit, that corresponds to
+       bh->b_blocknr. Tree balance contains 1 bit per each bitmap
+       block. Set there bit corresponding to dirtied bitmap */
+    set_bit (bh->b_blocknr / (bh->b_size * 8), DIRTY_BITMAP_MAP (tb));
+    /* cautious bitmap */
+    set_bit (bh->b_blocknr / (bh->b_size * 8) + SB_BMAP_NR (tb->tb_sb), DIRTY_BITMAP_MAP (tb));
+  }
+}
+
+
+int get_left_neighbor_position (
+				struct tree_balance * tb, 
+				int h
+				)
+{
+  int Sh_position = PATH_H_POSITION (tb->tb_path, h + 1);
+
+#ifdef REISERFS_CHECK
+  if (PATH_H_PPARENT (tb->tb_path, h) == 0 || tb->FL[h] == 0)
+    reiserfs_panic (tb->tb_sb, "vs-12325: get_left_neighbor_position: FL[%d](%p) or F[%d](%p) does not exist", 
+		    h, tb->FL[h], h, PATH_H_PPARENT (tb->tb_path, h));
+#endif
+
+  if (Sh_position == 0)
+    return B_NR_ITEMS (tb->FL[h]);
+  else
+    return Sh_position - 1;
+}
+
+
+int get_right_neighbor_position (struct tree_balance * tb, int h)
+{
+  int Sh_position = PATH_H_POSITION (tb->tb_path, h + 1);
+
+#ifdef REISERFS_CHECK
+  if (PATH_H_PPARENT (tb->tb_path, h) == 0 || tb->FR[h] == 0)
+    reiserfs_panic (tb->tb_sb, "vs-12330: get_right_neighbor_position: F[%d](%p) or FR[%d](%p) does not exist", 
+		    h, PATH_H_PPARENT (tb->tb_path, h), h, tb->FR[h]);
+#endif
+
+  if (Sh_position == B_NR_ITEMS (PATH_H_PPARENT (tb->tb_path, h)))
+    return 0;
+  else
+    return Sh_position + 1;
+}
+
+
+#ifdef REISERFS_CHECK
+
+int is_reusable (struct super_block * s, unsigned long block, int bit_value);
+static void check_internal_node (struct super_block * s, struct buffer_head * bh, char * mes)
+{
+  struct disk_child * dc;
+  int i;
+
+  if (!bh)
+    reiserfs_panic (s, "PAP-12336: check_internal_node: bh == 0");
+
+  if (!bh || !B_IS_IN_TREE (bh))
+    return;
+ 
+  if (!buffer_dirty (bh) && !buffer_journaled(bh) ) {
+    reiserfs_panic (s, "PAP-12337: check_internal_node: buffer (%b) must be dirty", bh);
+  }
+
+  dc = B_N_CHILD (bh, 0);
+
+  for (i = 0; i <= B_NR_ITEMS (bh); i ++, dc ++) {
+    if (!is_reusable (s, dc->dc_block_number, 1) ) {
+      print_tb (init_mode, init_item_pos, init_pos_in_item, &init_tb, mes);
+      reiserfs_panic (s, "PAP-12338: check_internal_node: invalid child pointer %y in %b", dc, bh);
+    }
+  }
+}
+
+
+static int locked_or_not_in_tree (struct buffer_head * bh, char * which)
+{
+  if ( buffer_locked (bh) || !B_IS_IN_TREE (bh) ) {
+    reiserfs_warning ("vs-12339: locked_or_not_in_tree: %s (%b)\n", which, bh);
+    return 1;
+  }
+  return 0;
+}
+
+
+static int check_before_balancing (struct tree_balance * tb)
+{
+  int retval = 0;	
+  int i;
+
+  for (i = 0; i < MAX_HEIGHT; i ++)
+    buffers[i] = 0;
+
+  if ( cur_tb ) {
+    reiserfs_panic (tb->tb_sb, "vs-12335: check_before_balancing: "
+		    "suspect that schedule occurred based on cur_tb not being null at this point in code. "
+		    "do_balance cannot properly handle schedule occuring while it runs.");
+  }
+  
+  /* double check that buffers that we will modify are unlocked. (fix_nodes should already have
+     prepped all of these for us). */
+  if ( tb->lnum[0] ) {
+    retval |= locked_or_not_in_tree (tb->L[0], "L[0]");
+    retval |= locked_or_not_in_tree (tb->FL[0], "FL[0]");
+    retval |= locked_or_not_in_tree (tb->CFL[0], "CFL[0]");
+    check_leaf (tb->L[0]);
+  }
+  if ( tb->rnum[0] ) {
+    retval |= locked_or_not_in_tree (tb->R[0], "R[0]");
+    retval |= locked_or_not_in_tree (tb->FR[0], "FR[0]");
+    retval |= locked_or_not_in_tree (tb->CFR[0], "CFR[0]");
+    check_leaf (tb->R[0]);
+  }
+  retval |= locked_or_not_in_tree (PATH_PLAST_BUFFER (tb->tb_path), "S[0]");
+  check_leaf (PATH_PLAST_BUFFER (tb->tb_path));
+  return retval;
+}
+
+#if 0
+static int check_before_balancing (struct tree_balance * tb)
+{
+  int needed_buffer_locked = 0;	
+  int i;
+
+  for (i = 0; i < MAX_HEIGHT; i ++)
+    buffers[i] = 0;
+
+  if ( cur_tb ) {
+    reiserfs_panic (tb->tb_sb, "vs-12335: check_before_balancing: "
+		    "suspect that schedule occurred based on cur_tb not being null at this point in code. "
+		    "do_balance cannot properly handle schedule occuring while it runs.");
+  }
+  
+  /* double check that buffers that we will modify are unlocked. (fix_nodes should already have
+     prepped all of these for us). */
+  if ( tb->lnum[0] ) {
+    if ( buffer_locked(tb->L[0]) || !B_IS_IN_TREE (tb->L[0])) {
+      reiserfs_warning ("vs-12336: check_before_balancing: L[0] locked %b\n", tb->L[0]);
+      needed_buffer_locked = 1;
+    }
+    if ( buffer_locked(tb->FL[0]) || !B_IS_IN_TREE (tb->FL[0]))	{
+      needed_buffer_locked = 1;
+      reiserfs_warning ("vs-12337: check_before_balancing: FL[0] locked %b\n", tb->FL[0]);
+    }
+    if ( buffer_locked(tb->CFL[0]) || !B_IS_IN_TREE (tb->CFL[0])) {
+      needed_buffer_locked = 1;
+      print_buffer_head(tb->CFL[0],"CFL[0]");
+    }
+  }
+  if ( tb->rnum[0] ) {
+    if ( buffer_locked(tb->R[0]) || !B_IS_IN_TREE (tb->R[0])) {
+      needed_buffer_locked = 1;
+      print_buffer_head(tb->R[0],"R[0]");
+    }
+    if ( buffer_locked(tb->FR[0]) || !B_IS_IN_TREE (tb->FR[0]))	{
+      needed_buffer_locked = 1;
+      print_buffer_head(tb->FR[0],"FR[0]");
+    }
+    if ( buffer_locked(tb->CFR[0]) || !B_IS_IN_TREE (tb->CFR[0])) {
+      needed_buffer_locked = 1;
+      print_buffer_head(tb->CFR[0],"CFR[0]");
+    }
+  }
+  if ( buffer_locked(PATH_PLAST_BUFFER (tb->tb_path)) || !B_IS_IN_TREE (PATH_PLAST_BUFFER (tb->tb_path)))
+    {
+      needed_buffer_locked = 1;
+      print_buffer_head(PATH_PLAST_BUFFER (tb->tb_path), "S[0]");
+    }
+  if ( needed_buffer_locked )
+    printk ("There are %d locked buffers\n", needed_buffer_locked);
+
+  return needed_buffer_locked;
+}
+#endif
+
+
+void check_after_balance_leaf (struct tree_balance * tb)
+{
+  if (tb->lnum[0]) {
+    if (B_BLK_HEAD (tb->L[0])->blk_free_space != 
+	MAX_CHILD_SIZE (tb->L[0]) - B_N_CHILD (tb->FL[0], get_left_neighbor_position (tb, 0))->dc_size) {
+      print_tb (init_mode, init_item_pos, init_pos_in_item, &init_tb, "12221");
+      reiserfs_panic (tb->tb_sb, "PAP-12355: check_after_balance_leaf: shift to left was incorrect");
+    }
+  }
+  if (tb->rnum[0]) {
+    if (B_BLK_HEAD (tb->R[0])->blk_free_space != 
+	MAX_CHILD_SIZE (tb->R[0]) - B_N_CHILD (tb->FR[0], get_right_neighbor_position (tb, 0))->dc_size) {
+      print_tb (init_mode, init_item_pos, init_pos_in_item, &init_tb, "12222");
+      reiserfs_panic (tb->tb_sb, "PAP-12360: check_after_balance_leaf: shift to right was incorrect");
+    }
+  }
+  if (PATH_H_PBUFFER(tb->tb_path,1) && 
+      B_BLK_HEAD (PATH_H_PBUFFER(tb->tb_path,0))->blk_free_space != 
+      MAX_CHILD_SIZE (PATH_H_PBUFFER(tb->tb_path,0)) -
+      B_N_CHILD (PATH_H_PBUFFER(tb->tb_path,1), 
+		 PATH_H_POSITION (tb->tb_path, 1))->dc_size) {
+    print_tb (init_mode, init_item_pos, init_pos_in_item, &init_tb, "12223");
+    reiserfs_panic (tb->tb_sb, "PAP-12365: check_after_balance_leaf: S is incorrect");
+  }
+}
+
+void check_after_balancing (struct tree_balance * tb)
+{
+  int h;
+
+  /* check all internal nodes */
+  for (h = 1; tb->insert_size[h]; h ++) {
+    check_internal_node (tb->tb_sb, PATH_H_PBUFFER (tb->tb_path, h), "BAD BUFFER ON PATH");
+    if (tb->lnum[h])
+      check_internal_node (tb->tb_sb, tb->L[h], "BAD L");
+    if (tb->rnum[h])
+      check_internal_node (tb->tb_sb, tb->R[h], "BAD R");
+    /* check new buffers if any */
+    if (buffers[h])
+      check_internal_node (tb->tb_sb, buffers[h], "BAD S_NEW");
+  }
+
+}
+
+#endif
+
+
+void check_leaf_level (struct tree_balance * tb)
+{
+  check_leaf (tb->L[0]);
+  check_leaf (tb->R[0]);
+  check_leaf (PATH_PLAST_BUFFER (tb->tb_path));
+}
+
+
+void check_internal_level (struct tree_balance * tb)
+{
+
+}
+
+
+/* Now we have all of the buffers that must be used in balancing of the tree.  We rely on the
+   assumption that schedule() will not occur while do_balance works. ( Only interrupt handlers are
+   acceptable.)  We balance the tree according to the analysis made before this, using buffers already
+   obtained.  For SMP support it will someday be necessary to add ordered locking of tb. */
+
+/* Some interesting rules of balancing:
+
+   we delete a maximum of two nodes per level per balancing: we never delete R, when we delete two
+   of three nodes L, S, R then we move them into R.
+
+   we only delete L if we are deleting two nodes, if we delete only one node we delete S
+
+   if we shift leaves then we shift as much as we can: this is a deliberate policy of extremism in
+   node packing which results in higher average utilization after repeated random balance
+   operations at the cost of more memory copies and more balancing as a result of small insertions
+   to full nodes.
+
+   if we shift internal nodes we try to evenly balance the node utilization, with consequent less
+   balancing at the cost of lower utilization.
+
+   one could argue that the policy for directories in leaves should be that of internal nodes, but
+   we will wait until another day to evaluate this....  It would be nice to someday measure and
+   prove these assumptions as to what is optimal....
+
+*/
+
+void	do_balance (
+		    struct reiserfs_transaction_handle *th, 
+		    struct tree_balance * tb,		/* tree_balance structure 		*/
+		    int pos_in_item,                /* position in item, in bytes for direct
+						       and indirect items, in entries for
+						       directories (for which it is an index
+						       into the array of directory entry
+						       headers.) */
+		    struct item_head * ih,			/* item header of inserted item 	*/
+		    const char * body,					/* body  of inserted item or bytes to paste */
+		    int flag,		   /* i - insert, d - delete
+					      c - cut, p - paste
+						      
+					      Cut means delete part of an item (includes removing
+					      an entry from a directory).
+						      
+					      Delete means delete whole item.
+						      
+					      Insert means add a new item into the tree.
+						      						      
+					      Paste means to append to the end of an existing file
+					      or to insert a directory entry.
+					      */
+		    int mem_mode,		/* memory mode; must be REISERFS_USER_MEM or REISERFS_KERNEL_MEM,
+						   depending on whether the body parameter is located in a
+						   user buffer in user memory or not. */
+		    int zeros_num
+		    )
+{
+  int child_pos,					/* position of a child node in its parent */
+    h;								/* level of the tree being processed */
+  struct item_head insert_key[2]; /* in our processing of one level we sometimes determine what
+				     must be inserted into the next higher level.  This insertion
+				     consists of a key or two keys and their corresponding
+				     pointers */
+  struct buffer_head *insert_ptr[2]; /* inserted node-ptrs for the next
+					level */
+
+
+#ifdef REISERFS_CHECK
+  memcpy(&init_tb, tb, sizeof(struct tree_balance));
+  init_item_pos = PATH_LAST_POSITION (tb->tb_path);
+  init_pos_in_item = pos_in_item;
+  init_mode = flag;
+
+  /* do not delete, just comment it out */
+  /*print_tb(flag, PATH_LAST_POSITION(tb->tb_path), pos_in_item, tb, "check");*/
+
+  if (check_before_balancing (tb))
+    reiserfs_panic (tb->tb_sb, "PAP-12340: do_balance: locked buffers in TB");
+
+#ifdef REISERFS_CHECK_ONE_PROCESS
+  if ( (PATH_PLAST_BUFFER(tb->tb_path)->b_count > 1 || (tb->L[0] && tb->L[0]->b_count > 1) ||
+       (tb->R[0] && tb->R[0]->b_count > 1)) ) {
+    print_tb(0, 0, 0, tb, "first three parameters are invalid");
+    reiserfs_panic (tb->tb_sb, "PAP-12345: do_balance: counter too big");
+  }
+#endif
+
+  cur_tb = tb;
+#endif /* REISERFS_CHECK */
+
+  /* if we have no real work to do  */
+  if ( ! tb->insert_size[0] ) {
+#ifdef REISERFS_CHECK
+    cur_tb = NULL;
+    if (flag != M_CUT)
+      reiserfs_panic (tb->tb_sb, "PAP-12350: do_balance: insert_size == 0, mode == %c", flag);
+#endif
+    unfix_nodes(th, tb);
+    return;
+  }
+
+#ifdef REISERFS_FSCK
+  if (flag == M_INTERNAL) {
+    insert_ptr[0] = (struct buffer_head *)body;
+    /* we must prepare insert_key */
+
+    if (PATH_H_B_ITEM_ORDER (tb->tb_path, 0)/*LAST_POSITION (tb->tb_path)*//*item_pos*/ == -1) {
+      /* get delimiting key from buffer in tree */
+      copy_key (&insert_key[0].ih_key, B_N_PKEY (PATH_PLAST_BUFFER (tb->tb_path), 0));
+      /*insert_ptr[0]->b_item_order = 0;*/
+    } else {
+      /* get delimiting key from new buffer */
+      copy_key (&insert_key[0].ih_key, B_N_PKEY((struct buffer_head *)body,0));
+      /*insert_ptr[0]->b_item_order = item_pos;*/
+    }
+      
+    /* and insert_ptr instead of balance_leaf */
+    child_pos = PATH_H_B_ITEM_ORDER (tb->tb_path, 0)/*item_pos*/;
+  } else
+#endif
+
+  /* balance leaf returns 0 except if combining L R and S into one node.  see balance_internal()
+     for explanation of this line of code.*/
+  child_pos = PATH_H_B_ITEM_ORDER (tb->tb_path, 0) +
+    balance_leaf (th, tb, pos_in_item, ih, body, flag, mem_mode, zeros_num, insert_key, insert_ptr);
+
+#ifdef REISERFS_CHECK
+  check_after_balance_leaf (tb);
+#endif
+
+  /* Balance internal level of the tree. */
+  for ( h = 1; h < MAX_HEIGHT && tb->insert_size[h]; h++ )
+    child_pos = balance_internal (th, tb, h, child_pos, insert_key, insert_ptr);
+
+/*&&&&&&&&&&&&&&&&&*/
+  check_leaf_level (tb);
+  check_internal_level (tb);
+/*&&&&&&&&&&&&&&&&&*/
+
+#ifdef REISERFS_CHECK
+  cur_tb = NULL;
+  check_after_balancing (tb);
+#endif
+
+  /* Release all (except for S[0]) non NULL buffers fixed by fix_nodes() */
+  unfix_nodes(th, tb);
+
+#ifdef REISERFS_CHECK
+  tb->tb_sb->u.reiserfs_sb.s_do_balance ++;
+#endif
+
+}
+
+
+
+
+
+
+
+
+
+
+
+
Index: empeg/kernel/fs/reiserfs/file.c
diff -u /dev/null empeg/kernel/fs/reiserfs/file.c:1.1
--- /dev/null	Wed Oct 17 16:36:05 2001
+++ empeg/kernel/fs/reiserfs/file.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,2059 @@
+/*
+ * Copyright 1996, 1997, 1998, 1999 Hans Reiser, see reiserfs/README for licensing and copyright details
+ */
+
+/* Contains the routines related to read and write. */
+
+/*
+ * direct_to_indirect
+ * get_new_buffer
+ * reiserfs_file_write
+ * reiserfs_file_read
+*/
+
+#ifdef __KERNEL__
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+
+#include <linux/sched.h>
+
+#include <linux/reiserfs_fs.h>
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/fcntl.h>
+#include <linux/locks.h>
+#include <linux/stat.h>
+#include <linux/string.h>
+
+#else
+
+#include "nokernel.h"
+
+#endif
+
+static ssize_t reiserfs_file_read  (struct file *, char *, size_t, loff_t *);
+static ssize_t reiserfs_file_write (struct file *, const char *, size_t, loff_t *);
+
+int reiserfs_bmap (struct inode * inode, int block);
+int reiserfs_readpage (struct file * file, struct page * page);
+
+
+static struct file_operations reiserfs_file_operations = {
+                NULL,        		/* lseek */
+                reiserfs_file_read,     /* read */
+                reiserfs_file_write,    /* write */
+                NULL,                   /* readdir */
+                NULL,                   /* poll */
+                NULL,                   /* ioctl */
+                generic_file_mmap,     	/* mmap */
+                NULL,                   /* open */
+		NULL,			/* flush */
+                reiserfs_file_release,  /* release */
+                reiserfs_sync_file,   	/* fsync */
+                NULL,		        /* fasync */
+                NULL, 	                /* check_media_change */
+                NULL,		        /* revalidate*/
+                NULL	       	        /* lock */
+};
+
+
+struct  inode_operations reiserfs_file_inode_operations = {
+          &reiserfs_file_operations,  /* default file operations */
+          NULL,                       /* create */
+          NULL,                       /* lookup */
+          NULL,                       /* link */
+          NULL,                       /* unlink */
+          NULL,                       /* symlink */
+          NULL,                       /* mkdir */
+          NULL,                       /* rmdir */
+          NULL,                       /* mknod */
+          NULL,                       /* rename */
+          NULL,                       /* readlink */
+	  NULL,			      /* follow_link */
+          reiserfs_readpage,          /* readpage */
+          NULL,		              /* writepage */
+          reiserfs_bmap,              /* bmap */
+          reiserfs_truncate_file,     /* truncate */
+          NULL,                       /* permission */
+          NULL,		              /* smap */ 
+          NULL,		              /* updatepage */
+          NULL		              /* revalidate */
+};
+
+/*
+** this will put an updated inode in the current transaction, and
+** then restart it.  Make sure you release any paths you are holding
+** before calling this.
+**
+** th is your handle
+** p_s_inode is a pointer to the inode to update
+** n_pos_in_file is file_write's concept of its current spot in the file.
+** 
+** after running this, the inode's size will be the greater of
+** p_s_inode->i_size and (n_pos_in_file -1)
+*/
+static void 
+update_inode_and_restart_transaction(struct reiserfs_transaction_handle *th,
+                               struct inode *p_s_inode,
+			       unsigned long n_pos_in_file) {
+  int orig_count = th->t_blocks_allocated ;
+  struct super_block *s = th->t_super ;
+  if ((n_pos_in_file - 1) > p_s_inode->i_size) { 
+    p_s_inode->i_size = (n_pos_in_file - 1) ;
+    p_s_inode->i_ctime = CURRENT_TIME ;
+  }
+  p_s_inode->i_mtime = CURRENT_TIME ;
+  if_in_ram_update_sd(th, p_s_inode) ; 
+  journal_end(th, s, orig_count) ;
+  journal_begin(th, s, orig_count) ;
+  reiserfs_update_inode_transaction(p_s_inode) ;
+}
+
+
+
+/* Converts direct items to an unformatted node. Returns 1 if conversion has been done, 0 if it has
+   been done somewhere else, -1 if no disk space for conversion */
+static int  direct_to_indirect(
+	      struct reiserfs_transaction_handle *th,
+              struct super_block  * p_s_sb,               /* Pointer to the super block.        */
+              struct inode        * p_s_inode,            /* Pointer to the file inode.         */
+              struct path         * p_s_search_path,      /* Path to the item to be converted.  */
+              int                   n_item_zeros_to_add,  /* Number of zeros to be inserted
+                                                              (file hole related).              */
+              const char          * p_c_buf,              /* Buffer with user data being
+                                                              written.                          */
+              int                   n_item_bytes_to_write,/* The number of bytes to be written
+                                                              from buf to the new unformatted
+                                                              node.                             */
+              struct buffer_head  * p_s_un_bh             /* The new unformatted node pointer.  */
+            ) {
+  struct key		s_key_to_search;  /* Key to search for the last byte of the converted
+                                                item.                                           */
+  struct item_head   * 	p_s_ih,           /* Pointer to the item header of the converted item.*/
+			s_item_to_insert;
+  unsigned long		n_unp;            /* Unformatted node block number.                   */
+  int			n_blk_size,       /* Block size.                                      */
+			n_len_to_move,    /* Length of tail to be converted.                  */
+			n_pos_in_item,    /* Found position in the item                       */
+			n_repeat,	  /* used for tracking whether schedule occurred */
+    			n_retval;	  /* returned value for reiserfs_insert_item and clones */
+  char		     *	p_c_to;	    /* End of the unformatted node.                     */
+  struct unfm_nodeinfo	s_node_to_write;  /* Handle on an unformatted node that will be
+                                                inserted in the tree.                           */
+
+  p_s_sb->u.reiserfs_sb.s_direct2indirect ++;
+
+#ifdef REISERFS_CHECK
+  if ( ! p_s_un_bh )
+    reiserfs_panic (p_s_sb, "PAP-14010: direct_to_indirect: pointer to the unfm buffer is NULL");
+#endif
+
+  n_blk_size = p_s_un_bh->b_size;
+  n_unp = p_s_un_bh->b_blocknr;
+  /* Set the key to search for the last byte of the converted item and
+      key to search for append or insert pointer to the new unformatted node. */
+  copy_key(&s_key_to_search,(struct key *)PATH_PITEM_HEAD(p_s_search_path));
+  copy_item_head(&s_item_to_insert,PATH_PITEM_HEAD(p_s_search_path));
+
+  s_key_to_search.k_offset += s_item_to_insert.ih_item_len - 1;
+  s_item_to_insert.ih_key.k_offset -= (s_item_to_insert.ih_key.k_offset - 1) % n_blk_size;
+  s_item_to_insert.ih_key.k_uniqueness = TYPE_INDIRECT;
+
+#ifdef REISERFS_CHECK
+  if ( s_item_to_insert.ih_key.k_offset != p_s_inode->u.reiserfs_i.i_first_direct_byte )
+    reiserfs_panic(p_s_sb, "PAP-14020: direct_to_indirect: illegal first direct byte position");
+#endif
+
+  /* Calculate length of tail to be converted (tail may be stored in two
+     direct items in different nodes). */
+  n_len_to_move = s_key_to_search.k_offset % n_blk_size;
+  /* Calculate address to copy from user buffer. */
+  p_c_to = p_s_un_bh->b_data + n_len_to_move;
+   /* let only one process append at a time */
+  lock_inode_to_convert(p_s_inode);
+  if (p_s_inode->u.reiserfs_i.i_first_direct_byte == NO_BYTES_IN_DIRECT_ITEM) {
+    /* somewhere else mmap or bmap did this conversion */
+    /*brelse(p_s_un_bh);*/
+    unlock_inode_after_convert (p_s_inode);
+    return 0;
+  }
+
+  if ( search_for_position_by_key (p_s_sb, (struct key *)&s_item_to_insert, p_s_search_path, &n_pos_in_item, &n_repeat) == POSITION_FOUND )
+    reiserfs_panic (p_s_sb, "PAP-14030: direct_to_indirect: pasted or inserted byte exists in the tree");
+  p_s_ih = PATH_PITEM_HEAD(p_s_search_path);
+
+#ifdef REISERFS_CHECK
+  if ( n_blk_size - n_len_to_move - n_item_zeros_to_add - n_item_bytes_to_write < 0 )
+    reiserfs_panic (p_s_sb, "PAP-14040: direct_to_indirect: illegal ih_free_space");
+#endif
+
+  if (p_c_buf)
+    s_node_to_write.unfm_freespace = n_blk_size - n_len_to_move - n_item_zeros_to_add - n_item_bytes_to_write;
+  else
+    s_node_to_write.unfm_freespace = n_blk_size - n_len_to_move;
+
+  /* Insert indirect item. */
+  if ( I_IS_STAT_DATA_ITEM(p_s_ih) )  {
+    s_item_to_insert.u.ih_free_space = s_node_to_write.unfm_freespace;
+    s_item_to_insert.ih_item_len      = UNFM_P_SIZE;
+    PATH_LAST_POSITION(p_s_search_path)++;
+    n_retval = reiserfs_insert_item (th, p_s_sb, p_s_search_path, &s_item_to_insert, (char *)&n_unp, REISERFS_KERNEL_MEM, 0/*zero number*/, NOTHING_SPECIAL);
+  }
+  /* Paste into last object indirect item. */
+  else  {
+    s_node_to_write.unfm_nodenum    = n_unp;
+    /*s_node_to_write.unfm_freespace = n_repeat;*/
+    n_retval = reiserfs_paste_into_item(th, p_s_sb, p_s_search_path, &n_pos_in_item, &(s_item_to_insert.ih_key),
+					(char *)&s_node_to_write, UNFM_P_SIZE, REISERFS_KERNEL_MEM, 0);
+  }
+  if ( n_retval < 0 ) {
+    /*brelse(p_s_un_bh);*/
+    unlock_inode_after_convert(p_s_inode);
+    return -1; /* Can not convert direct item. */
+  }
+
+  /* i_blocks counts only unformatted nodes */
+  /*  p_s_inode->i_blocks += p_s_sb->s_blocksize / 512;*/
+
+  /* copy data from user space to a new unformatted node */
+  if (p_c_buf) {
+    memset(p_c_to, '\0', n_item_zeros_to_add);
+    copy_from_user(p_c_to + n_item_zeros_to_add, p_c_buf, n_item_bytes_to_write);
+
+    update_vm_cache (p_s_inode, s_item_to_insert.ih_key.k_offset - 1 + n_len_to_move + n_item_zeros_to_add, 
+		     p_c_to + n_item_zeros_to_add, n_item_bytes_to_write);
+
+    memset(p_c_to + n_item_zeros_to_add + n_item_bytes_to_write, '\0',
+	   s_node_to_write.unfm_freespace);
+  } else {
+    /* this works when we convert tail stored in direct item(s) to unformatted node without appending from user buffer */
+    memset(p_c_to, 0, s_node_to_write.unfm_freespace);
+  }
+  /* non-atomic mark_buffer_dirty is allowed here */
+  journal_mark_dirty_nolog(th, p_s_sb, p_s_un_bh); /* Destination buffer, preserve not needed. */
+
+  /* Move bytes from the direct items to the new unformatted node. */
+  while ( n_len_to_move )  {
+    if ( search_for_position_by_key (p_s_sb, &s_key_to_search, p_s_search_path, &n_pos_in_item, &n_repeat) == POSITION_NOT_FOUND )
+      reiserfs_panic (p_s_sb, "PAP-14050: direct_to_indirect: indirect item does not exist");
+    n_retval = reiserfs_delete_item (th, p_s_inode, p_s_search_path, &n_pos_in_item, &s_key_to_search, 
+                                     p_s_un_bh, PRESERVE_DIRECT_TO_INDIRECT);
+
+#ifdef REISERFS_CHECK
+    if ( n_retval <= 0 || n_retval > n_len_to_move)
+      reiserfs_panic(p_s_sb, "PAP-14060: direct_to_indirect: illegal case");
+#endif
+
+    n_len_to_move -= n_retval;
+    s_key_to_search.k_offset -= n_retval;
+  }
+  brelse (p_s_un_bh);
+
+  p_s_inode->u.reiserfs_i.i_first_direct_byte = NO_BYTES_IN_DIRECT_ITEM;
+  unlock_inode_after_convert(p_s_inode);
+  return 1;
+}
+
+
+#ifdef NEW_GET_NEW_BUFFER
+
+/* returns one buffer with a blocknr near blocknr. */
+static int get_new_buffer_near_blocknr(
+		   struct reiserfs_transaction_handle *th,
+                   struct super_block *  p_s_sb,
+                   int blocknr,
+                   struct buffer_head ** pp_s_new_bh,
+                   struct path         * p_s_path 
+                   ) {
+  unsigned      long n_new_blocknumber = 0;
+  int           n_ret_value,
+                n_repeat = CARRY_ON;
+
+#ifdef REISERFS_CHECK
+  int repeat_counter = 0;
+  
+  if (!blocknr)
+    printk ("blocknr passed to get_new_buffer_near_blocknr was 0");
+#endif
+
+
+  if ( (n_ret_value = reiserfs_new_unf_blocknrs (th, p_s_sb, &n_new_blocknumber,
+                                             blocknr, 1)) == NO_DISK_SPACE )
+    return NO_DISK_SPACE;
+  
+  *pp_s_new_bh = reiserfs_getblk(p_s_sb->s_dev, n_new_blocknumber, p_s_sb->s_blocksize, &n_repeat);
+  if ( buffer_uptodate(*pp_s_new_bh) ) {
+
+#ifdef REISERFS_CHECK
+    if ( buffer_dirty(*pp_s_new_bh) || (*pp_s_new_bh)->b_dev == NODEV ) {
+      reiserfs_panic(p_s_sb, "PAP-14080: get_new_buffer: invalid uptodate buffer %b for the new block", *pp_s_new_bh);
+    }
+#endif
+
+    /* Free path buffers to prevent deadlock. */
+    /* It is possible that this process has the buffer, which this function is getting, already in
+       its path, and is responsible for double incrementing the value of b_count.  If we recalculate
+       the path after schedule we can avoid risking an endless loop.  This problematic situation is
+       possible in a multiple processing environment.  Suppose process 1 has acquired a path P; then
+       process 2 balanced and remove block A from the tree.  Process 1 continues and runs
+       get_new_buffer, that returns buffer with block A. If node A was on the path P, then it will
+       have b_count == 2. If we now will simply wait in while ( (*pp_s_new_bh)->b_count > 1 ) we get
+       into an endless loop, as nobody will release this buffer and the current process holds buffer
+       twice. That is why we do decrement_counters_in_path(p_s_path) before waiting until b_count
+       becomes 1. (it there were other processes holding node A, then eventually we will get a
+       moment, when all of them released a buffer). */
+    if ( (*pp_s_new_bh)->b_count > 1  ) {
+      decrement_counters_in_path(p_s_path);
+      n_ret_value |= SCHEDULE_OCCURRED;
+    }
+
+    while ( (*pp_s_new_bh)->b_count > 1 ) {
+
+#ifdef REISERFS_INFO
+      printk("get_new_buffer() calls schedule to decrement b_count\n");
+#endif
+
+#ifdef REISERFS_CHECK
+      if ( ! (++repeat_counter % 10000) )
+	printk("get_new_buffer(%u): counter(%d) too big", current->pid, repeat_counter);
+#endif
+
+      current->policy |= SCHED_YIELD;
+      schedule();
+    }
+
+#ifdef REISERFS_CHECK
+    if ( buffer_dirty(*pp_s_new_bh) || (*pp_s_new_bh)->b_dev == NODEV ) {
+      print_buffer_head(*pp_s_new_bh,"get_new_buffer");
+      reiserfs_panic(p_s_sb, "PAP-14090: get_new_buffer: invalid uptodate buffer %b for the new block(case 2)", *pp_s_new_bh);
+    }
+#endif
+
+  }
+  else {
+    ;
+
+#ifdef REISERFS_CHECK
+    /* journal victim */
+    if ( 0 && (*pp_s_new_bh)->b_count != 1 && !buffer_journaled(*pp_s_new_bh)) {
+      reiserfs_panic(p_s_sb,"PAP-14100: get_new_buffer: not uptodate buffer %b for the new block has b_count more than one",
+		     *pp_s_new_bh);
+    }
+#endif
+
+  }
+  /* marking buffer here gives it the chance to die in the journal if we free it before commit */
+  if (*pp_s_new_bh) {
+    mark_buffer_journal_new(*pp_s_new_bh) ;
+  }
+  return (n_ret_value | n_repeat);
+}
+
+
+/* returns the block number of the last unformatted node, assumes p_s_key_to_search.k_offset is a byte in the tail of
+   the file, Useful for when you want to append to a file, and convert a direct item into an unformatted node near the
+   last unformatted node of the file.  Putting the unformatted node near the direct item is potentially very bad to do.
+   If there is no unformatted node in the file, then we return the block number of the direct item.  */
+inline int get_last_unformatted_node_blocknr_of_file(  struct key * p_s_key_to_search, struct super_block * p_s_sb,
+                                                       struct buffer_head * p_s_bh, int * p_n_repeat, 
+                                                       struct path * p_unf_search_path, struct inode * p_s_inode)
+
+{
+  struct key unf_key_to_search;
+  struct item_head * p_s_ih;
+  int n_pos_in_item;
+  struct buffer_head * p_indirect_item_bh;
+
+      copy_key(&unf_key_to_search,p_s_key_to_search);
+      unf_key_to_search.k_uniqueness = TYPE_INDIRECT;
+      unf_key_to_search.k_offset = p_s_inode->u.reiserfs_i.i_first_direct_byte -1;
+
+        /* p_s_key_to_search->k_offset -  MAX_ITEM_LEN(p_s_sb->s_blocksize); */
+      if (search_for_position_by_key (p_s_sb, &unf_key_to_search, p_unf_search_path, &n_pos_in_item, p_n_repeat) == POSITION_FOUND)
+        {
+          p_s_ih = B_N_PITEM_HEAD(p_indirect_item_bh = PATH_PLAST_BUFFER(p_unf_search_path), PATH_LAST_POSITION(p_unf_search_path));
+          return (B_I_POS_UNFM_POINTER(p_indirect_item_bh, p_s_ih, n_pos_in_item));
+        }
+     /*  else */
+      printk("reiser-1800: search for unformatted node failed, p_s_key_to_search->k_offset = %u,  unf_key_to_search.k_offset = %u, MAX_ITEM_LEN(p_s_sb->s_blocksize) = %ld, debug this\n", p_s_key_to_search->k_offset, unf_key_to_search.k_offset,  MAX_ITEM_LEN(p_s_sb->s_blocksize) );
+      print_buffer_head(PATH_PLAST_BUFFER(p_unf_search_path), "the buffer holding the item before the key we failed to find");
+      print_block_head(PATH_PLAST_BUFFER(p_unf_search_path), "the block head");
+      return 0;                         /* keeps the compiler quiet */
+}
+
+
+                                /* hasn't been out of disk space tested  */
+static int get_buffer_near_last_unf (struct reiserfs_transaction_handle *th,
+				     struct super_block * p_s_sb, struct key * p_s_key_to_search,
+                                                 struct inode *  p_s_inode,  struct buffer_head * p_s_bh, 
+                                                 struct buffer_head ** pp_s_un_bh, struct path * p_s_search_path)
+{
+  int unf_blocknr = 0, /* blocknr from which we start search for a free block for an unformatted node, if 0
+                          then we didn't find an unformatted node though we might have found a file hole */
+    n_repeat = CARRY_ON;        /* did schedule occur?  if so, then don't carry on, and recalc things */
+  struct key unf_key_to_search;
+  struct path unf_search_path;
+
+  copy_key(&unf_key_to_search,p_s_key_to_search);
+  unf_key_to_search.k_uniqueness = TYPE_INDIRECT;
+  
+  if (
+      (p_s_inode->u.reiserfs_i.i_first_direct_byte > 4095) /* i_first_direct_byte gets used for all sorts of
+                                                              crap other than what the name indicates, thus
+                                                              testing to see if it is 0 is not enough */
+      && (p_s_inode->u.reiserfs_i.i_first_direct_byte < MAX_KEY_OFFSET) /* if there is no direct item then
+                                                                           i_first_direct_byte = MAX_KEY_OFFSET */
+      )
+    {
+                                /* actually, we don't want the last unformatted node, we want the last unformatted node
+                                   which is before the current file offset */
+      unf_key_to_search.k_offset = ((p_s_inode->u.reiserfs_i.i_first_direct_byte -1) < unf_key_to_search.k_offset) ? p_s_inode->u.reiserfs_i.i_first_direct_byte -1 :  unf_key_to_search.k_offset;
+
+      while (unf_key_to_search.k_offset > -1)
+        {
+                                /* This is our poorly documented way of initializing paths. -Hans */
+          init_path (&unf_search_path);
+                                /* get the blocknr from which we start the search for a free block. */
+          unf_blocknr = get_last_unformatted_node_blocknr_of_file(  p_s_key_to_search, /* assumes this points to the file tail */
+                                                                    p_s_sb,     /* lets us figure out the block size */
+                                                                    p_s_bh, /* if there is no unformatted node in the file,
+                                                                               then it returns p_s_bh->b_blocknr */
+                                                                    &n_repeat, /* tells us if schedule occurred */
+                                                                    &unf_search_path,
+                                                                    p_s_inode
+                                                                    );
+/*        printk("in while loop: unf_blocknr = %d,  *pp_s_un_bh = %p\n", unf_blocknr, *pp_s_un_bh); */
+          if (unf_blocknr) 
+            break;
+          else                  /* release the path and search again, this could be really slow for huge
+                                   holes.....better to spend the coding time adding compression though.... -Hans */
+            {
+                                /* Vladimir, is it a problem that I don't brelse these buffers ?-Hans */
+              decrement_counters_in_path(&unf_search_path);
+              unf_key_to_search.k_offset -= 4096;
+            }
+        }
+      if (unf_blocknr) {
+        n_repeat |= get_new_buffer_near_blocknr(th, p_s_sb, unf_blocknr, pp_s_un_bh, p_s_search_path);
+      }
+      else {                    /* all unformatted nodes are holes */
+        n_repeat |= get_new_buffer_near_blocknr(th, p_s_sb, p_s_bh->b_blocknr, pp_s_un_bh, p_s_search_path); 
+      }
+    }
+  else {                        /* file has no unformatted nodes */
+    n_repeat |= get_new_buffer_near_blocknr(th, p_s_sb, p_s_bh->b_blocknr, pp_s_un_bh, p_s_search_path);
+/*     printk("in else: unf_blocknr = %d,  *pp_s_un_bh = %p\n", unf_blocknr, *pp_s_un_bh); */
+/*     print_path (0,  p_s_search_path); */
+  }
+
+  return n_repeat;
+}
+
+#endif /* NEW_GET_NEW_BUFFER */
+
+
+#ifdef OLD_GET_NEW_BUFFER
+/*
+** BIG CHANGE HERE!  If this fails to get a block, it will update the inode
+** release the path, stop the transaction, start a new transaction, and
+** try again.
+*/
+static int get_new_buffer(
+		   struct reiserfs_transaction_handle *th,
+		   struct super_block *	 p_s_sb,
+		   struct buffer_head *  p_s_bh,
+		   struct buffer_head ** pp_s_new_bh,
+		   struct path	       * p_s_path,
+		   struct inode        * p_s_inode,     /* for update of inode*/
+		   unsigned long         n_pos_in_file /* from file_write */
+		   ) {
+  unsigned	long n_new_blocknumber = 0;
+  int		n_repeat, n_repeat1, disk_full_check;
+
+
+  if ( (n_repeat = reiserfs_new_unf_blocknrs (th, p_s_sb, &n_new_blocknumber, p_s_bh->b_blocknr, 1, 0/*not for preserve list*/)) == NO_DISK_SPACE ) {
+
+    /* We might not be out of space.  The journal might be able to reclaim
+    ** some, but not while our transaction is open.  So, we update our inode
+    ** and restart the transaction hoping there will be more space when we
+    ** get back.  
+    */
+    n_repeat |= SCHEDULE_OCCURRED;
+    decrement_counters_in_path(p_s_path);
+    update_inode_and_restart_transaction(th, p_s_inode, n_pos_in_file) ;
+    if ( (disk_full_check = reiserfs_new_unf_blocknrs (th, p_s_sb, 
+                                                       &n_new_blocknumber, 
+						       p_s_bh->b_blocknr, 
+						       1, 
+						       0)) == NO_DISK_SPACE ) {
+
+      return NO_DISK_SPACE;
+    }
+  } 
+  n_repeat1 = CARRY_ON;
+  *pp_s_new_bh = reiserfs_getblk(p_s_sb->s_dev, n_new_blocknumber, p_s_sb->s_blocksize, &n_repeat1);
+  n_repeat |= n_repeat1;
+  if ((*pp_s_new_bh)->b_count > 1) {
+    /* Free path buffers to prevent deadlock which can occur in the
+       situation like : this process holds p_s_path; Block
+       (*pp_s_new_bh)->b_blocknr is on the path p_s_path, but it is
+       not necessary, that *pp_s_new_bh is in the tree; process 2
+       could remove it from the tree and freed block
+       (*pp_s_new_bh)->b_blocknr. Reiserfs_new_blocknrs in above
+       returns block (*pp_s_new_bh)->b_blocknr. Reiserfs_getblk gets
+       buffer for it, and it has b_count > 1. If we now will simply
+       wait in while ( (*pp_s_new_bh)->b_count > 1 ) we get into an
+       endless loop, as nobody will release this buffer and the
+       current process holds buffer twice. That is why we do
+       decrement_counters_in_path(p_s_path) before waiting until
+       b_count becomes 1. (it there were other processes holding node
+       pp_s_new_bh, then eventually we will get a moment, when all of
+       them released a buffer). */
+    decrement_counters_in_path(p_s_path);
+    n_repeat |= SCHEDULE_OCCURRED;
+    wait_buffer_until_released (*pp_s_new_bh);
+  }
+
+#ifdef REISERFS_CHECK
+  if (0 && !buffer_journaled(*pp_s_new_bh) && ((*pp_s_new_bh)->b_count != 1 || buffer_dirty (*pp_s_new_bh))) {
+    reiserfs_panic(p_s_sb,"PAP-14100: get_new_buffer: not free or dirty buffer %b for the new block",
+		   *pp_s_new_bh);
+  }
+#endif
+  if (*pp_s_new_bh) {
+    mark_buffer_journal_new(*pp_s_new_bh) ;
+  }
+
+  return n_repeat;
+}
+
+#endif /* OLD_GET_NEW_BUFFER */
+
+
+#ifdef GET_MANY_BLOCKNRS
+                                /* code not yet functional */
+get_next_blocknr (
+                  unsigned long *       p_blocknr_array,          /* we get a whole bunch of blocknrs all at once for
+                                                                     the write.  This is better than getting them one at
+                                                                     a time.  */
+                  unsigned long **      p_blocknr_index,        /* pointer to current offset into the array. */
+                  unsigned long        blocknr_array_length
+)
+{
+  unsigned long return_value;
+
+  if (*p_blocknr_index < p_blocknr_array + blocknr_array_length) {
+    return_value = **p_blocknr_index;
+    **p_blocknr_index = 0;
+    *p_blocknr_index++;
+    return (return_value);
+  }
+  else
+    {
+      kfree (p_blocknr_array);
+    }
+}
+#endif /* GET_MANY_BLOCKNRS */
+
+
+
+/* Summary:
+
+We have a file consisting of some number of indirect items and direct
+items.  We translate filp->f_pos into where we are supposed to start
+the write in terms of the tree data structures.  We then write one
+node at a time, decrementing the count of bytes that we are to write,
+after we write each node, by the appropriate amount.  We loop until
+count is zero.  We have a complex if statement that handles each
+possible case in writing a node, taking into account holes,
+conversions from direct to indirect, overwrites, etc.  This if
+statement is horrible, and should be rewritten. -Hans
+
+reiserfs_paste_into_item, direct_to_indirect, and reiserfs_insert_into_item perform
+all balancing that results from the write.
+
+We return either the number of bytes successfully written or an error.
+Note that if we successfully write some bytes and have an error, we
+return the number of bytes written, not the error.  This allows the
+user to record that the bytes were written, retry, and then get the
+errorid on the retry, or if the error goes away, to never know.  Note
+that ENOSPC errors are complicated by the preserve list (see
+preserve.c). - Hans
+
+*/
+
+/*
+
+We don't need to worry about schedule for direct items because they
+search for one buffer and use it.  Schedule is a problem only when
+searching for two things, and the second search invalidates the first.
+Insertion of direct items is also not a concern, for the same reason.
+It is only {insertion of a pointer into an indirect item coupled with
+getting a buffer to hold the unformatted node, and converting direct
+to indirect items} that require that upon schedule we decide whether
+to continue, free resources gotten, and retry.
+
+When schedule occurs, we look at the indirect item that we found, and
+make sure it is still there.  If something else is there that has the
+same string of bytes as the item we are looking for, we will have a
+bug?  This can happen for preserved nodes?
+
+*/
+
+/* Write n_count bytes from user buffer p_c_buf into a system buffer. */
+static ssize_t reiserfs_file_write(
+                                   struct file   * p_s_filp, /* current position in the file, man write() for details. */
+                                   const char    * p_c_buf,  /* The user space buffer from which we copy. */
+                                   size_t          n_count,   /* The number of bytes to write: once the function
+                                                                 starts up, count is the number of bytes remaining
+                                                                 to be written. */
+                                   loff_t        * p_n_pos
+            ) {
+  struct inode * p_s_inode = p_s_filp->f_dentry->d_inode;
+  struct super_block  * p_s_sb;
+  struct key            s_key_to_search;      	/* Key of item we are searching for that we are
+                                                  going to write into. */
+  /*loff_t*/unsigned long	        n_pos_in_file;        	/* Position (in bytes from beginning of object)
+                                                  where you must write. */
+  unsigned long         n_unp,                  /* Unformatted node number. */
+                        n_append_startpoint;    /* Offset of the byte after the last byte in the file. */
+  struct path           s_search_path;        /* path from root of tree to some leaf, we keep this
+						 data around so that it is faster to go up and down
+						 the tree */
+  ssize_t               n_written;              /* Bytes written, or errorid. */
+  size_t        n_orig_count = n_count ;           /* original number of bytes wanted */
+  int                   n_pos_in_item,
+                        n_search_res,
+                        n_pos_in_buffer,
+                        n_item_bytes_to_write,  /* The number of bytes from the user buffer to be
+			                                              written in this pass of the loop to the
+                                                    current item. */
+                        n_item_zeros_to_add,    /* Number of zeros to be added to this item.  */
+                        n_repeat,	              /* If schedule occured. */
+                        n_item_size,	          /* Number of bytes in the current item. */
+                        n_offset_in_node,       /* Write offset in the unformatted node. */
+                        n_zero_bytes,           /* Number of zero bytes which must be created
+                                                    (if we write past the end of the file). */
+                        n_blk_size,             /* Block size in bytes. */
+                        n_bytes_in_item,        /* Item bytes number. */
+                        n_cur_len,              /* Length of current item. */
+                        retval,                 /* What direct_to_indirect returns */
+                        n_max_squeeze_in;       /* Maximum amount that could be added to the direct item
+                                                    and still fit into it or an unformatted node that it
+                                                    is converted into */
+  struct buffer_head  * p_s_bh,                 /* Buffer contains found item. */
+                      * p_s_un_bh;              /* Buffer contains unformatted node. */
+  struct item_head      s_ih,
+                        s_item_to_insert,       /* Header of mythical item: it contains the key to
+                                                    search for. */
+                      * p_s_ih;                 /* Found item header. */
+  struct unfm_nodeinfo	s_node_to_write;      /* Handle on an unformatted node that will be passed
+                                                    to do_balance the last byte of the file. */
+#ifdef GET_MANY_BLOCKNRS
+  unsigned long *       p_blocknr_array,          /* we get a whole bunch of blocknrs all at once for the write.  This is
+                                                     better than getting them one at a time.  */
+                        p_blocknr_index;        /* current offset into the array. */
+  unsigned long        blocknr_array_length;
+
+#endif /* GET_MANY_BLOCKNRS */
+  char * local_buf = 0;
+  int j;
+  int jbegin_count = JOURNAL_PER_BALANCE_CNT * 3 ;
+  int windex ;
+  struct reiserfs_transaction_handle th ;
+  unsigned long	limit = current->rlim[RLIMIT_FSIZE].rlim_cur;
+  unsigned long pos = *p_n_pos;
+  
+/*
+  if (!p_s_inode->i_op || !p_s_inode->i_op->updatepage)
+      return -EIO;
+  */
+  if (p_s_filp->f_error) {
+      int error = p_s_filp->f_error;
+      p_s_filp->f_error = 0;
+      return error;
+  }
+
+  /* Calculate position in the file. */
+  if ( p_s_filp->f_flags & O_APPEND ) {
+    n_pos_in_file = p_s_inode->i_size + 1;
+    pos = p_s_inode->i_size;
+  } else
+    n_pos_in_file = *p_n_pos + 1;
+
+  if (pos >= limit)
+      return -EFBIG;
+
+  if (n_count > limit - pos)
+      n_count = limit - pos;
+
+  n_written = 0;
+  p_s_sb = p_s_inode->i_sb;
+
+  journal_begin(&th, p_s_sb, jbegin_count) ;
+  windex = push_journal_writer("file-write") ;
+
+  reiserfs_update_inode_transaction(p_s_inode) ;
+
+  /* Set key_to_search to search for first item of object */
+  copy_key(&s_key_to_search, INODE_PKEY (p_s_inode));
+
+
+  /*  printk ("File_write: objectid = %lu offset = %lu, count = %lu\n", s_key_to_search.k_objectid, n_pos_in_file - 1, n_count);*/
+
+  /* Set key_to_search to search for item we write into */
+  s_key_to_search.k_offset = n_pos_in_file;
+  if ( n_pos_in_file >= p_s_inode->u.reiserfs_i.i_first_direct_byte )
+    s_key_to_search.k_uniqueness = TYPE_DIRECT;
+  else
+    s_key_to_search.k_uniqueness = TYPE_INDIRECT;
+
+  n_written = 0;
+  n_blk_size = p_s_sb->s_blocksize;
+  p_s_un_bh = NULL;
+  init_path (&s_search_path);
+
+  local_buf = reiserfs_kmalloc (n_blk_size, GFP_KERNEL, p_s_sb);
+  if (local_buf == 0) {
+    pop_journal_writer(windex) ;
+    journal_end(&th, p_s_sb, jbegin_count) ;
+    return -ENOMEM;
+  }
+
+  while ( n_count ) {
+    if (current->need_resched)
+      schedule();
+
+
+    /* Search for the item which contains 'n_pos_in_file-th' object byte.  If we are writing past the
+       end of the file then item_num and bh are set to the last item in the file.
+       Note: the repeat of this expensive search plus do_balance for every iteration
+       of this loop is a performance loss source for large files.  We should calculate how
+       many unformatted nodes we are going to add and insert their
+       pointers into the indirect item all at once. Though, if we used extents.... -Hans */
+    n_search_res = search_for_position_by_key (p_s_sb, &s_key_to_search, &s_search_path, &n_pos_in_item, &n_repeat);
+
+    /* The item which contains 'pos-th' object byte.  If we are writing past the end
+       of the file p_s_ih is set to the last item in the file. */
+    p_s_ih = B_N_PITEM_HEAD(p_s_bh = PATH_PLAST_BUFFER(&s_search_path),
+			    n_pos_in_buffer = PATH_LAST_POSITION(&s_search_path));
+    /* Remember the found item header. */
+    copy_item_head(&s_ih, p_s_ih);
+
+    /* Item which contains 'n_pos_in_file-th' byte is found. */
+    if ( n_search_res == POSITION_FOUND )  {
+      n_item_zeros_to_add = 0;
+      if ( I_IS_DIRECT_ITEM(p_s_ih) ) {
+	n_item_bytes_to_write = p_s_ih->ih_item_len - n_pos_in_item;
+	if ( n_item_bytes_to_write > n_count )
+	  n_item_bytes_to_write = n_count;
+	/* copy data from user space to intermediate buffer */
+	copy_from_user (local_buf, p_c_buf, n_item_bytes_to_write);
+
+	/* make sure, that direct item is still on its old place */
+	if (comp_items (&s_ih, &s_search_path)) {
+	  printk ("reiserfs_file_write: item has been moved while we were in copy_from_user (overwriting the direct item)\n");
+	  continue;
+	}
+	/* Overwrite to end of this direct item or end of count bytes from user buffer to direct item. */
+	memcpy (B_I_PITEM(p_s_bh, p_s_ih) + n_pos_in_item, local_buf, n_item_bytes_to_write);
+	/* mark buffer dirty atomically. It will be refiled in pathrelse */
+	journal_mark_dirty(&th, p_s_sb, p_s_bh) ;
+
+	update_vm_cache(p_s_inode, n_pos_in_file - 1,
+			B_I_PITEM(p_s_bh, p_s_ih) + n_pos_in_item, n_item_bytes_to_write);
+
+      }
+      else  { /* Indirect item. */
+	/* Set n_unp to blocknr containing the byte we start the write at. */
+        n_unp = B_I_POS_UNFM_POINTER(p_s_bh, p_s_ih, n_pos_in_item);
+	/* The number of bytes in the unformatted node that are to be overwritten
+	   (calculation adjusts for the case in which not all bytes are used in the
+	   unformatted node). */
+	n_item_bytes_to_write = (n_item_size = I_POS_UNFM_SIZE(p_s_ih, n_pos_in_item, n_blk_size))
+	  			- ((int)n_pos_in_file - 1) % n_blk_size;
+	if ( n_item_bytes_to_write > n_count )
+	  n_item_bytes_to_write = n_count;
+
+#ifdef REISERFS_CHECK
+	if ( n_item_bytes_to_write <= 0 ) {
+	  printk("n_item_size = %d n_pos_in_file = %lu\n", n_item_size, n_pos_in_file);
+	  reiserfs_panic(p_s_sb, "PAP-14110: reiserfs_file_write: n_item_bytes_to_write <= 0");
+	}
+#endif
+
+	/* If not a hole in the file. */
+	if ( n_unp )  {
+	  /* Get the block we are to write into. */
+	  n_repeat = CARRY_ON;
+          p_s_un_bh = reiserfs_getblk(p_s_bh->b_dev, n_unp, n_blk_size, &n_repeat);
+
+	  /* If we are not overwriting the entire node and we have not yet read the buffer from disk
+	     then we must read the block into memory before writing. */
+	  if ( n_item_bytes_to_write != n_item_size && ! buffer_uptodate(p_s_un_bh) ) {
+	    ll_rw_block(READ, 1, &p_s_un_bh);
+	    wait_on_buffer(p_s_un_bh);
+	    /* Check for I/O error. */
+	    if ( ! buffer_uptodate(p_s_un_bh) ) {
+	      brelse(p_s_un_bh);
+              p_s_un_bh = NULL;
+	      pathrelse(&s_search_path);
+	      if ( ! n_written )  {
+		printk ("reiserfs_file_write() returned EIO1\n");
+		n_written = -EIO;
+	      }
+	      break;
+	    }
+          }
+
+	  /* Do the write. */
+	  copy_from_user(p_s_un_bh->b_data + ((int)n_pos_in_file - 1) % n_blk_size,
+                                                        p_c_buf, n_item_bytes_to_write);
+	  update_vm_cache(p_s_inode, n_pos_in_file - 1,
+			  p_s_un_bh->b_data + ((int)n_pos_in_file - 1) % n_blk_size, n_item_bytes_to_write);
+	  mark_buffer_uptodate (p_s_un_bh, 1);
+	  /* non-atomic mark_buffer_dirty is allowed here */
+	  /* mark_buffer_dirty(p_s_un_bh, 0);  */
+	  journal_mark_dirty_nolog(&th, p_s_sb, p_s_un_bh) ;
+	  brelse (p_s_un_bh);
+	  p_s_un_bh = NULL;
+
+        }
+	else  { /* If writing to a hole. */
+          /* Get a new buffer for the unformatted node. */
+          if ( ! p_s_un_bh )  {
+#ifdef OLD_GET_NEW_BUFFER
+	    n_repeat = get_new_buffer(&th, p_s_sb, p_s_bh, &p_s_un_bh, &s_search_path, p_s_inode, n_pos_in_file);
+#else
+	    /* if there is an unformatted node in the file, then get our unformatted node from near
+	       the last one of them else get it from near the direct item.  */
+	    n_repeat = get_buffer_near_last_unf ( &th, p_s_sb, &s_key_to_search,
+						  p_s_inode, p_s_bh, 
+						  &p_s_un_bh, &s_search_path);
+#endif /* NEW_GET_NEW_BUFFER */
+						  
+            if ( ! p_s_un_bh )  {
+              /* No disk space for new block. */
+              if ( ! n_written )
+                n_written = -ENOSPC;
+	      pathrelse(&s_search_path);
+	      break;
+            }
+	    memset (p_s_un_bh->b_data, 0, n_blk_size);
+
+	    if ( n_repeat != CARRY_ON && (s_search_path.path_length == ILLEGAL_PATH_ELEMENT_OFFSET || 
+					  comp_items(&s_ih, &s_search_path)) ) {
+	      /* other processes are allowed */
+	      j = p_s_un_bh->b_blocknr / (p_s_sb->s_blocksize * 8);
+	      COMPLETE_BITMAP_DIRTING_AFTER_ALLOCATING (p_s_sb, j);
+	      continue;
+	    }
+          }
+
+#ifdef REISERFS_CHECK
+	  if (B_I_POS_UNFM_POINTER (p_s_bh, p_s_ih, n_pos_in_item) != 0)
+	    reiserfs_panic (p_s_sb, "vs-14120: reiserfs_file_write: unformatted node pointer %lu, must 0",
+			    B_I_POS_UNFM_POINTER(p_s_bh,p_s_ih, n_pos_in_item));
+#endif
+	  /* Initialize pointer to the unformatted node in the its parent. */
+	  B_I_POS_UNFM_POINTER(p_s_bh,p_s_ih, n_pos_in_item) = p_s_un_bh->b_blocknr;
+          /* reiserfs_mark_buffer_dirty(p_s_bh, 1); journal victim */
+          journal_mark_dirty(&th, p_s_sb, p_s_bh); 
+
+	  /* Put zeros before the place where the write starts. */
+	  n_offset_in_node = ((int)n_pos_in_file - 1) % n_blk_size;
+	  //memset(p_s_un_bh->b_data, '\0', n_offset_in_node = ((int)n_pos_in_file - 1) % n_blk_size);
+	  /* Do the write at the appropriate spot. */
+	  copy_from_user(p_s_un_bh->b_data + n_offset_in_node, p_c_buf, n_item_bytes_to_write);
+
+	  update_vm_cache(p_s_inode, n_pos_in_file - 1, 
+			  p_s_un_bh->b_data + n_offset_in_node, n_item_bytes_to_write);
+
+	  /* it is not a hole now */
+	  p_s_inode->i_blocks += p_s_sb->s_blocksize / 512;
+
+	  /* Put zeros after the place where the write finishes. */
+	  //memset(p_s_un_bh->b_data + n_offset_in_node + n_item_bytes_to_write, '\0',
+	  //	 n_blk_size - n_offset_in_node - n_item_bytes_to_write);
+
+	  mark_buffer_uptodate(p_s_un_bh, 1);
+	  /* non-atomic mark_buffer_dirty is allowed here */
+	  /* mark_buffer_dirty(p_s_un_bh, 0);   */
+	  journal_mark_dirty_nolog(&th, p_s_sb, p_s_un_bh) ;
+
+	  /* compelte what was not finished in reiserfs_new_blocknrs */
+	  j = p_s_un_bh->b_blocknr / (p_s_sb->s_blocksize * 8);
+	  COMPLETE_BITMAP_DIRTING_AFTER_ALLOCATING (p_s_sb, j);
+
+	  brelse (p_s_un_bh);
+	  p_s_un_bh = NULL;
+        }	/* replace hole with unformatted node */
+      }		/* overwrite indirect item */
+      pathrelse(&s_search_path);
+    } 		/* position we are going to write to is found */
+
+    /* Item containing n_pos_in_file-th byte not found (writing past current end of file). */
+    else  {
+      /* Form item key to insert. */
+      copy_key(&(s_item_to_insert.ih_key),&s_key_to_search);
+      /* We calculate offset of the byte after the last byte in the file. */
+      n_append_startpoint = ( I_IS_STAT_DATA_ITEM(p_s_ih) ) ? 1 :
+				p_s_ih->ih_key.k_offset + I_BYTES_NUMBER(p_s_ih, n_blk_size);
+      /* Calculate number of zero bytes which must be created. */
+
+      n_zero_bytes = n_pos_in_file - n_append_startpoint;
+
+#ifdef REISERFS_CHECK
+      if ( COMP_SHORT_KEYS(&(p_s_ih->ih_key), &s_key_to_search) || n_zero_bytes < 0 ) {
+	printk("n_pos_in_file  = %lu n_append_startpoint = %lu\n",n_pos_in_file, n_append_startpoint);
+        reiserfs_panic(p_s_sb, "PAP-14130: reiserfs_file_write: item found %h, key to search %k", p_s_ih, &s_key_to_search);
+      }
+#endif
+#ifdef GET_MANY_BLOCKNRS
+                                /* Allocate space for blocknr_array if we don't have one. */
+      if (!p_blocknr_array) {
+        /* Calculate maximum amount that could be added to the direct item and still
+             fit into it or an unformatted node that it is converted into */
+        n_max_squeeze_in = n_blk_size - (n_append_startpoint - 1) % n_blk_size;
+        blocknr_array_length = (count > n_max_squeeze_in) ?((count - n_max_squeeze_in) / n_blk_size): 0;
+        if (blocknr_array_length) {
+          p_blocknr_array = kmalloc (sizeof(unsigned long) * blocknr_array_length, GFP_ATOMIC);
+          if (!p_blocknr_array) {
+            reiserfs_panic("reiserfs-1830: reiserfs_file_write: kmalloc failed");
+	  }
+        }
+      }
+#endif /*  GET_MANY_BLOCKNRS */
+
+      /* Last file item is the stat_data. */
+      if ( I_IS_STAT_DATA_ITEM(p_s_ih) )  {
+
+        /* Calculate zeros to insert before write into unformatted node. */
+	n_item_zeros_to_add = ( n_zero_bytes < n_blk_size ) ? n_zero_bytes : n_blk_size;
+	/* Calculate the amount to write into unformatted node. */
+	n_item_bytes_to_write = ( n_item_zeros_to_add < n_blk_size ) ?
+	  ( n_blk_size - n_item_zeros_to_add) : 0;
+	if ( n_item_bytes_to_write > n_count )
+          n_item_bytes_to_write = n_count;
+
+	s_item_to_insert.ih_key.k_offset = n_append_startpoint;
+	/* Insert pointer to the unformatted node. */
+	if ( dont_have_tails (p_s_sb) ||
+	     (n_item_zeros_to_add + n_item_bytes_to_write > MAX_DIRECT_ITEM_LEN(n_blk_size)) ||
+	     (n_orig_count >= MIN_PACK_ON_CLOSE) ||
+	     STORE_TAIL_IN_UNFM (0, n_item_zeros_to_add + n_item_bytes_to_write, n_blk_size) )  {
+
+	  if (!STORE_TAIL_IN_UNFM (0, n_item_zeros_to_add + n_item_bytes_to_write, n_blk_size)) {
+	    p_s_inode->u.reiserfs_i.i_pack_on_close = 1 ;
+	  } else {
+	    p_s_inode->u.reiserfs_i.i_pack_on_close = 0 ;
+	  }
+          if ( n_item_bytes_to_write &&  ! p_s_un_bh ) {
+#ifdef OLD_GET_NEW_BUFFER
+            /* Get new buffer for an unformatted node. */
+            n_repeat = get_new_buffer(&th, p_s_sb, p_s_bh, &p_s_un_bh, &s_search_path, p_s_inode, n_pos_in_file);
+#else
+	    /* if there is an unformatted node in the file, then get
+	       our unformatted node from near the last one of them
+	       else get it from near the direct item.  */
+	    n_repeat = get_buffer_near_last_unf (&th,  p_s_sb, &s_key_to_search,
+						  p_s_inode, p_s_bh,
+						  &p_s_un_bh, &s_search_path);
+#endif /* NEW_GET_NEW_BUFFER */
+	    if ( ! p_s_un_bh )  {
+	      /* No disk space for new block. */
+	      if ( ! n_written )
+                n_written = -ENOSPC;
+	      pathrelse(&s_search_path);
+	      break;
+            }
+	    memset (p_s_un_bh->b_data, 0, n_blk_size);
+	    if ( n_repeat != CARRY_ON && (s_search_path.path_length == ILLEGAL_PATH_ELEMENT_OFFSET || comp_items(&s_ih, &s_search_path)) ) {
+	      /* compelte what was not finished in reiserfs_new_blocknrs */
+	      j = p_s_un_bh->b_blocknr / (p_s_sb->s_blocksize * 8);
+	      COMPLETE_BITMAP_DIRTING_AFTER_ALLOCATING (p_s_sb, j);
+	      continue;
+	    }
+          }
+	  n_unp = p_s_un_bh ? p_s_un_bh->b_blocknr : 0;
+
+          /* Form indirect item header. */
+	  s_item_to_insert.ih_key.k_uniqueness = TYPE_INDIRECT;
+	  s_item_to_insert.u.ih_free_space = n_blk_size - n_item_zeros_to_add - n_item_bytes_to_write;
+	  s_item_to_insert.ih_item_len = UNFM_P_SIZE;
+          /* reiserfs_insert_item() inserts before given position in the node, so we must
+	     increment to point to the next item after searched one. */
+	  PATH_LAST_POSITION(&s_search_path)++;
+          /* Insert indirect item. */
+	  if ( reiserfs_insert_item (&th, p_s_sb, &s_search_path, &s_item_to_insert, (char *)&n_unp, REISERFS_KERNEL_MEM, 0, NOTHING_SPECIAL) < 0 )  {
+            if ( ! n_written )
+	      n_written = -ENOSPC;
+	    if ( p_s_un_bh ) {
+	      reiserfs_free_block (&th, p_s_sb, p_s_un_bh->b_blocknr);
+
+	      j = p_s_un_bh->b_blocknr / (p_s_sb->s_blocksize * 8);
+	      COMPLETE_BITMAP_DIRTING_AFTER_FREEING(p_s_sb,j);
+
+              bforget(p_s_un_bh);
+	      p_s_un_bh = NULL;
+	    }
+	    break; /* No disk space. */
+          }
+          if ( p_s_un_bh ) {
+	    /* pointer to an unformatted node is in tree. Copy data */
+            //memset(p_s_un_bh->b_data, '\0', n_item_zeros_to_add);
+	    copy_from_user(p_s_un_bh->b_data + n_item_zeros_to_add, p_c_buf, n_item_bytes_to_write);
+	    //memset(p_s_un_bh->b_data + n_item_zeros_to_add + n_item_bytes_to_write, '\0',
+	    //   n_blk_size - n_item_zeros_to_add - n_item_bytes_to_write);
+
+	    update_vm_cache(p_s_inode, n_pos_in_file - 1,
+			    p_s_un_bh->b_data + n_item_zeros_to_add, n_item_bytes_to_write);
+            mark_buffer_uptodate(p_s_un_bh, 1);
+	    /* non-atomic mark_buffer_dirty is allowed here */
+            /* mark_buffer_dirty(p_s_un_bh, 0); journal victim */
+	    journal_mark_dirty_nolog(&th, p_s_sb, p_s_un_bh) ;
+
+	    /* compelte what was not finished in reiserfs_new_blocknrs */
+	    j = p_s_un_bh->b_blocknr / (p_s_sb->s_blocksize * 8);
+	    COMPLETE_BITMAP_DIRTING_AFTER_ALLOCATING (p_s_sb, j);
+	    
+            brelse(p_s_un_bh);
+            p_s_un_bh = NULL;
+
+	    /* i_blocks counts only unformatted nodes */
+	    p_s_inode->i_blocks += p_s_sb->s_blocksize / 512;
+          }
+        }
+        /* Insert direct item. */
+        else  {
+	  p_s_inode->u.reiserfs_i.i_pack_on_close = 0 ;
+
+#ifdef REISERFS_CHECK
+	  if ( p_s_inode->u.reiserfs_i.i_first_direct_byte != NO_BYTES_IN_DIRECT_ITEM )
+	    reiserfs_panic(p_s_sb, "PAP-14140: reiserfs_file_write: file must have no direct items");
+#endif
+
+	  /* copy data from user space to intermediate buffer */
+	  copy_from_user (local_buf, p_c_buf, n_item_bytes_to_write);
+
+	  /* make sure, that direct item is still on its old place */
+	  if (comp_items (&s_ih, &s_search_path)) {
+	    printk ("reiserfs_file_write: item has been moved while we were in copy_from_user (inserting direct item after stat data)\n");
+	    continue;
+	  }
+
+          /* Form direct item header. */
+	  s_item_to_insert.ih_key.k_uniqueness = TYPE_DIRECT;
+	  s_item_to_insert.u.ih_free_space = MAX_US_INT;
+	  s_item_to_insert.ih_item_len = n_item_zeros_to_add + n_item_bytes_to_write;
+          /* reiserfs_insert_item() inserts before given position in the node, so we must
+	     increment to point to the next item after searched one. */
+	  PATH_LAST_POSITION(&s_search_path)++;
+          /* Insert direct item. */
+	  if ( reiserfs_insert_item (&th, p_s_sb, &s_search_path, &s_item_to_insert,
+				     local_buf, REISERFS_KERNEL_MEM, n_item_zeros_to_add, NOTHING_SPECIAL) < 0 )  {
+	    if ( ! n_written )
+	      n_written = -ENOSPC;
+	    break; /* No disk space. */
+          }
+#ifdef REISERFS_CHECK
+	  if (n_pos_in_file != n_append_startpoint + n_item_zeros_to_add)
+	    reiserfs_panic (p_s_sb, "vs-14145: reiserfs_file_write: wrong positions in file");
+#endif
+	  update_vm_cache (p_s_inode, n_pos_in_file - 1, p_c_buf, n_item_bytes_to_write);
+
+	  p_s_inode->u.reiserfs_i.i_first_direct_byte = n_append_startpoint;
+
+	  /* calculate direct item as whole block */
+	  p_s_inode->i_blocks += p_s_sb->s_blocksize / 512;
+        }
+      }
+
+      else  {
+        /* Last file item is the direct one. */
+	if ( I_IS_DIRECT_ITEM(p_s_ih) ) {
+	  /* n_cur_len is not always equal to p_s_ih->ih_item_len, if you write past the end
+	     of the file, cur_len can be the length the item would be if it extended to
+	     where we start the write. */
+          n_cur_len =  (n_append_startpoint - 1) % n_blk_size;
+#ifndef GET_MANY_BLOCKNRS
+          /* Calculate maximum amount that could be added to the direct item and still
+             fit into it or an unformatted node that it is converted into */
+          n_max_squeeze_in = n_blk_size - (n_append_startpoint - 1) % n_blk_size;
+#endif
+          /* Calculate whether write requires converting direct item into an unformatted node. */
+
+          if ( dont_have_tails (p_s_sb) ||
+	       STORE_TAIL_IN_UNFM(n_append_startpoint - 1, n_cur_len + n_zero_bytes + n_count, n_blk_size) )  {
+
+	    p_s_inode->u.reiserfs_i.i_pack_on_close = 0 ; /* no sense in packing here, we're already doing direct->
+							  ** indirect conversion.  This was the case we are trying to
+							  ** avoid, it really slows down the journal
+	                                                  */
+
+            /* Calculate number of zeros to be added to this item.  */
+            n_item_zeros_to_add = ( n_zero_bytes > n_max_squeeze_in ) ? n_max_squeeze_in : n_zero_bytes;
+            /* Item_bytes_to_write is the number of bytes from the user buffer to be
+               written after the zeros to the new indirect item to be created.  */
+            n_item_bytes_to_write = ( n_item_zeros_to_add < n_max_squeeze_in ) ?
+              (n_max_squeeze_in - n_item_zeros_to_add) : 0;
+            if ( n_item_bytes_to_write > n_count )
+              n_item_bytes_to_write = n_count;
+
+            /* Get a new buffer for storing the unformatted node. */
+            if ( ! p_s_un_bh )  {
+#ifdef OLD_GET_NEW_BUFFER
+	      /* Minor design issue: putting the unformatted node in the place where the
+		 formatted node used to be would result in more optimal layout, but then we
+		 could not preserve the old formatted node.  This means that slowly grown
+		 files (e.g. logs) use every other block of the available blocks.  At least
+		 it is much better in layout than what some other fs`s do to slowly growing
+		 files that are interspersed with other writes. A better solution will wait
+		 until later. */
+	      n_repeat = get_new_buffer(&th, p_s_sb, p_s_bh, &p_s_un_bh, &s_search_path, p_s_inode, n_pos_in_file);
+#else
+              /* This code gets the last non-hole blocknr of the last unformatted node without reading from disk that unformatted
+                 node, but possibly reading from disk the node of the indirect item pointing to it. For large holes it
+                 is inefficient, but better to spend the time writing code to compress holes than to fix that..  */
+              /* if there is an unformatted node in the file, then get our unformatted node from near the last one of
+                 them else get it from near the direct item.  */
+              n_repeat = get_buffer_near_last_unf (&th, p_s_sb, &s_key_to_search,
+                                                    p_s_inode, p_s_bh, 
+                                                    &p_s_un_bh, &s_search_path);
+#endif
+              if ( ! p_s_un_bh )  {
+                /* No disk space for new block. */
+                if ( ! n_written )
+                  n_written = -ENOSPC;
+                pathrelse(&s_search_path);
+                break;
+              }
+	      memset (p_s_un_bh->b_data, 0, n_blk_size);
+              if ( n_repeat != CARRY_ON && (s_search_path.path_length == ILLEGAL_PATH_ELEMENT_OFFSET ||
+					    comp_items(&s_ih, &s_search_path)) ) {
+		/* compelte what was not finished in reiserfs_new_blocknrs */
+		j = p_s_un_bh->b_blocknr / (p_s_sb->s_blocksize * 8);
+		COMPLETE_BITMAP_DIRTING_AFTER_ALLOCATING (p_s_sb, j);
+		continue;
+	      }
+            }
+	    mark_buffer_uptodate(p_s_un_bh, 1);
+
+	    /* bitmap block containing set bit */
+	    j = p_s_un_bh->b_blocknr / (p_s_sb->s_blocksize * 8);
+	    /* Perform the conversion. */
+	    retval = direct_to_indirect (&th, p_s_sb, p_s_inode, &s_search_path, n_item_zeros_to_add,
+					 p_c_buf, n_item_bytes_to_write, p_s_un_bh);
+	    if (retval <= 0) {
+	      /* conversion is done by another process (in bmap or mmap) or there is no disk space to
+                 perform coversion */
+	      reiserfs_free_block (&th, p_s_sb, p_s_un_bh->b_blocknr);
+	      bforget (p_s_un_bh);
+
+	      COMPLETE_BITMAP_DIRTING_AFTER_FREEING(p_s_sb,j);
+
+	      p_s_un_bh = NULL;
+	      if (retval < 0) {
+		if ( ! n_written )
+		  n_written = -ENOSPC;
+		break;/* No disk space */
+	      }
+	      /* direct2indirect returned 0. Conversion has been done
+                 by other process */
+	      continue;
+	    }
+	    /* complete what was not finished in reiserfs_new_blocknrs */
+	    COMPLETE_BITMAP_DIRTING_AFTER_ALLOCATING (p_s_sb, j);
+
+	    /* ok, conversion is done. Unformatted node brelsed in direct_to_indirect */
+	    p_s_un_bh = NULL;
+	  }
+	  /* If it is possible to perform write without converting to an unformatted node then
+	     append to the direct item. */
+	  else  {
+	    p_s_inode->u.reiserfs_i.i_pack_on_close = 0 ;
+
+	    n_item_bytes_to_write = n_count;
+	    n_item_zeros_to_add   = n_zero_bytes;
+	    if ( n_append_startpoint)
+	      s_item_to_insert.ih_key.k_offset =  n_append_startpoint;
+            n_bytes_in_item = p_s_ih->ih_item_len;
+
+	    /* copy data from user space to intermediate buffer */
+	    copy_from_user (local_buf, p_c_buf, n_item_bytes_to_write);
+	    /* make sure, that direct item is still on its old place */
+	    if (comp_items (&s_ih, &s_search_path)) {
+	      printk ("reiserfs_file_write: item has been moved while we were in copy_from_user (appending to the direct item)\n");
+	      continue;
+	    }
+
+	    if ( reiserfs_paste_into_item(&th, p_s_sb, &s_search_path, &n_bytes_in_item, &(s_item_to_insert.ih_key),
+					  local_buf, n_count + n_zero_bytes, REISERFS_KERNEL_MEM, n_zero_bytes) < 0 ) {
+	      if ( ! n_written )
+		n_written = -ENOSPC;
+	      break;
+            }
+	    
+	    update_vm_cache (p_s_inode, n_pos_in_file - 1, p_c_buf, n_item_bytes_to_write);
+
+          }
+        }
+        else  { /* last item is indirect item */
+
+#ifdef REISERFS_CHECK
+	  if ( COMP_SHORT_KEYS (&(p_s_ih->ih_key), INODE_PKEY (p_s_inode)) || !I_IS_INDIRECT_ITEM (p_s_ih) || n_pos_in_item != I_UNFM_NUM(p_s_ih) )
+	    reiserfs_panic(p_s_sb,
+			   "PAP-14150: reiserfs_file_write: item of another file, not indirect item or illegal position in the indirect item");
+#endif
+
+	  /* Blocknr from last entry in last item in file. */
+	  n_unp = B_I_POS_UNFM_POINTER(p_s_bh,p_s_ih, n_pos_in_item - 1);
+	  if ( p_s_ih->u.ih_free_space )  { /* Unformatted node has free space. */
+	    /* Set n_pos_in_item to point to last entry of last indirect item. */
+	    n_pos_in_item--;
+	    /* See comments above, it is the same except that we paste into unused space at the
+	       end of the unformatted node. */
+	    n_max_squeeze_in = p_s_ih->u.ih_free_space;
+	    n_item_zeros_to_add = ( n_zero_bytes < n_max_squeeze_in ) ? n_zero_bytes : n_max_squeeze_in;
+	    n_item_bytes_to_write = ( n_item_zeros_to_add < n_max_squeeze_in ) ?
+	      ( n_max_squeeze_in - n_item_zeros_to_add) : 0;
+	    if ( n_item_bytes_to_write > n_count )
+	      n_item_bytes_to_write = n_count;
+	    if ( n_unp )  {
+	      if ( ! p_s_un_bh ) {
+		n_repeat = CARRY_ON;
+                p_s_un_bh = reiserfs_getblk(p_s_bh->b_dev, n_unp, n_blk_size, &n_repeat);
+		if ( ! buffer_uptodate(p_s_un_bh) ) {
+		  n_repeat |= SCHEDULE_OCCURRED;
+		  ll_rw_block(READ, 1, &p_s_un_bh);
+		  wait_on_buffer(p_s_un_bh);
+		  if ( ! buffer_uptodate(p_s_un_bh) ) {
+		    pathrelse(&s_search_path);
+		    brelse(p_s_un_bh);
+		    if ( ! n_written )  {
+		      
+#ifdef REISERFS_INFO
+		      printk ("REISERFS: reiserfs_file_write() returned EIO2\n");
+#endif
+		      
+		      n_written = -EIO;
+		    }
+		    break;
+		  }
+		}
+		
+		if ( n_repeat != CARRY_ON && comp_items(&s_ih, &s_search_path) )
+		  continue;
+	      }
+
+	      /* set free space of the indirect item */
+	      p_s_ih->u.ih_free_space -= (n_item_zeros_to_add + n_item_bytes_to_write);
+	      /* reiserfs_mark_buffer_dirty(p_s_bh, 1); */
+	      journal_mark_dirty(&th,  p_s_sb, p_s_bh);
+
+	      /* copy user data to the unformatted node */
+	      memset(p_s_un_bh->b_data + n_blk_size - n_max_squeeze_in, '\0', n_item_zeros_to_add);
+	      copy_from_user(p_s_un_bh->b_data + n_blk_size - n_max_squeeze_in + n_item_zeros_to_add,
+			     p_c_buf, n_item_bytes_to_write);
+	      update_vm_cache(p_s_inode, n_pos_in_file - 1,
+			      p_s_un_bh->b_data + n_blk_size - n_max_squeeze_in + n_item_zeros_to_add,
+			      n_item_bytes_to_write);
+	      /* unformatted node is uptodate already */
+	      /* non-atomic mark_buffer_dirty is allowed here */
+	      /* mark_buffer_dirty(p_s_un_bh, 0);  */
+	      journal_mark_dirty_nolog(&th, p_s_sb, p_s_un_bh) ;
+	      brelse(p_s_un_bh);
+	      p_s_un_bh = NULL;
+            }
+            else
+              /* If last entry of last item is a hole (an undesirable feature, that can occur after
+                 truncate). */
+              if ( n_item_bytes_to_write ) {/* If writing to this item rather than to somewhere past it. */
+                if ( ! p_s_un_bh )  {
+#ifdef OLD_GET_NEW_BUFFER
+		  n_repeat = get_new_buffer(&th, p_s_sb, p_s_bh, &p_s_un_bh, &s_search_path, p_s_inode, n_pos_in_file);
+#else
+		  n_repeat = get_buffer_near_last_unf (&th,p_s_sb, &s_key_to_search, p_s_inode, p_s_bh, &p_s_un_bh, &s_search_path);
+#endif
+                  if ( ! p_s_un_bh )  {
+                    /* No disk space for new block. */
+                    if ( ! n_written )
+                      n_written = -ENOSPC;
+                    pathrelse(&s_search_path);
+                    break;
+                  }
+		  memset (p_s_un_bh->b_data, 0, n_blk_size);
+		  if ( n_repeat != CARRY_ON && (s_search_path.path_length == ILLEGAL_PATH_ELEMENT_OFFSET || comp_items(&s_ih, &s_search_path)) ) {
+		    /* compelte what was not finished in reiserfs_new_blocknrs */
+		    j = p_s_un_bh->b_blocknr / (p_s_sb->s_blocksize * 8);
+		    COMPLETE_BITMAP_DIRTING_AFTER_ALLOCATING (p_s_sb, j);
+		    continue;
+		  }
+                }
+
+#ifdef REISERFS_CHECK
+		if (B_I_POS_UNFM_POINTER (p_s_bh, p_s_ih, n_pos_in_item) != 0)
+		  reiserfs_panic (p_s_sb, "vs-14160: reiserfs_file_write: unformatted node pointer %lu, must 0 (hole at the end of file)",
+				  B_I_POS_UNFM_POINTER(p_s_bh,p_s_ih, n_pos_in_item));
+#endif
+
+		/* set pointer to the unformatted node and free space of the indirect item */
+		B_I_POS_UNFM_POINTER(p_s_bh, p_s_ih, n_pos_in_item) = p_s_un_bh->b_blocknr;
+		n_cur_len = n_blk_size - p_s_ih->u.ih_free_space + n_item_zeros_to_add;
+		p_s_ih->u.ih_free_space -= (n_item_zeros_to_add + n_item_bytes_to_write);
+		/* reiserfs_mark_buffer_dirty(p_s_bh, 1); journal victim */
+		journal_mark_dirty(&th, p_s_sb, p_s_bh); 
+
+		/* copy user data to the unformatted node */
+                //memset(p_s_un_bh->b_data, '\0',
+		//     n_cur_len = n_blk_size - p_s_ih->u.ih_free_space + n_item_zeros_to_add);
+		copy_from_user(p_s_un_bh->b_data + n_cur_len, p_c_buf, n_item_bytes_to_write);
+
+		update_vm_cache(p_s_inode, n_pos_in_file - 1,
+				p_s_un_bh->b_data + n_cur_len, n_item_bytes_to_write);
+
+		p_s_inode->i_blocks += p_s_sb->s_blocksize / 512;
+
+		//memset(p_s_un_bh->b_data + n_cur_len + n_item_bytes_to_write, '\0',
+		//     n_blk_size - n_cur_len - n_item_bytes_to_write);
+                mark_buffer_uptodate(p_s_un_bh, 1);
+		/* non-atomic mark_buffer_dirty is allowed here */
+                /* mark_buffer_dirty(p_s_un_bh, 0); journal victim */
+		journal_mark_dirty_nolog(&th, p_s_sb, p_s_un_bh) ;
+
+		/* compelte what was not finished in reiserfs_new_blocknrs */
+		j = p_s_un_bh->b_blocknr / (p_s_sb->s_blocksize * 8);
+		COMPLETE_BITMAP_DIRTING_AFTER_ALLOCATING (p_s_sb, j);
+
+		brelse(p_s_un_bh);
+		p_s_un_bh = NULL;
+              }
+            pathrelse(&s_search_path);
+          } /* appending to the free space */
+
+	  else  { /* Unformatted node doesn't have free space. */
+	    /* This is where we could see a performance improvement by writing a little bit of code to:
+	       1) calculate number of unformatted nodes to add at a time
+	       entries_can_add_to_indirect_item = (end_of_node - end_of_item)/ indirect item entry size
+	       if ( entries_can_add_to_indirect_item > 0) 
+	       entries_can_add_to_indirect_item = min (entries_can_add_to_indirect_item, disk space free,
+	       count) 
+	       else
+	       entries_can_add_to_indirect_item = min (max_indirect_item_size, disk space free, count)
+	       2) construct new indirect item,
+	       3) fill new indirect item with new blocknrs using reiserfs_new_block_nrs 
+	       3) for each new blocknr, get_new_buffer, and write to that buffer
+	       4) replace old indirect item with new indirect item
+	       5) let this loop continue its work
+	       
+	       What do you think Volodya? -Hans
+	       */
+	    /* If we need to create an unformatted node. */
+            if ( dont_have_tails (p_s_sb) ||
+		 (n_orig_count >= MIN_PACK_ON_CLOSE) ||
+		 STORE_TAIL_IN_UNFM(n_append_startpoint - 1, n_zero_bytes + n_count, n_blk_size) ) {
+
+	      if (!STORE_TAIL_IN_UNFM(n_append_startpoint - 1, n_zero_bytes + n_count, n_blk_size) ) {
+		p_s_inode->u.reiserfs_i.i_pack_on_close = 1 ;
+	      } else {
+		p_s_inode->u.reiserfs_i.i_pack_on_close = 0 ;
+	      }
+              /* Calculate zeros to insert before write into unformatted node. */
+              n_item_zeros_to_add = ( n_zero_bytes < n_blk_size ) ? n_zero_bytes : n_blk_size;
+              /* Calculate the amount to write into unformatted node. */
+              n_item_bytes_to_write = ( n_item_zeros_to_add < n_blk_size ) ?
+                ( n_blk_size - n_item_zeros_to_add) : 0;
+              if ( n_item_bytes_to_write > n_count )
+                n_item_bytes_to_write = n_count;
+              /* If not making a hole. */
+              if ( n_item_bytes_to_write )  {
+                if ( ! p_s_un_bh )  {
+#ifdef OLD_GET_NEW_BUFFER		  
+		  n_repeat = get_new_buffer(&th, p_s_sb, p_s_bh, &p_s_un_bh, &s_search_path, p_s_inode, n_pos_in_file);
+#else
+                  if (n_unp) {
+                    n_repeat = get_new_buffer_near_blocknr(&th, p_s_sb, n_unp, &p_s_un_bh, &s_search_path);
+                  }
+                  else {
+		    n_repeat = get_buffer_near_last_unf (&th,p_s_sb,&s_key_to_search,p_s_inode, p_s_bh, &p_s_un_bh, &s_search_path);
+		  }
+#endif /* NEW_GET_NEW_BUFFER */  
+                  if ( ! p_s_un_bh )  {
+                    /* No disk space for new block. */
+                    if ( ! n_written )
+                      n_written = -ENOSPC;
+                    pathrelse(&s_search_path);
+                    break;
+                  }
+		  memset (p_s_un_bh->b_data, 0, n_blk_size);
+		  if ( n_repeat != CARRY_ON && (s_search_path.path_length == ILLEGAL_PATH_ELEMENT_OFFSET || comp_items(&s_ih, &s_search_path)) ) {
+		    /* compelte what was not finished in reiserfs_new_blocknrs */
+		    j = p_s_un_bh->b_blocknr / (p_s_sb->s_blocksize * 8);
+		    COMPLETE_BITMAP_DIRTING_AFTER_ALLOCATING (p_s_sb, j);
+		    continue;
+		  }
+                }
+
+		s_node_to_write.unfm_nodenum = p_s_un_bh->b_blocknr;
+		s_node_to_write.unfm_freespace = n_blk_size - n_item_zeros_to_add - n_item_bytes_to_write;
+              }
+              else  { /* If making a hole. */
+
+#ifdef REISERFS_CHECK
+		if ( p_s_un_bh ) {
+		  reiserfs_panic(p_s_sb, "PAP-14170: reiserfs_file_write: pointer to the unformatted node buffer must be equals NULL");
+		}
+#endif
+		s_node_to_write.unfm_nodenum = 0;
+		s_node_to_write.unfm_freespace = 0;
+              }
+
+#ifdef REISERFS_CHECK
+	      if ( n_append_startpoint < n_blk_size + 1 )
+		reiserfs_panic (p_s_sb, "PAP-14180: reiserfs_file_write: offset is 0");
+	      if ( p_s_ih->ih_item_len % UNFM_P_SIZE ) {
+		reiserfs_panic (p_s_sb, "PAP-14190: reiserfs_file_write: item %h length is incorrect", p_s_ih);
+	      }
+#endif
+              s_item_to_insert.ih_key.k_offset = n_append_startpoint;
+	      n_bytes_in_item = p_s_ih->ih_item_len / UNFM_P_SIZE;
+
+	      /* Paste entry for p_s_un_bh into last indirect item. */
+	      if ( reiserfs_paste_into_item(&th, p_s_sb, &s_search_path, &n_bytes_in_item, &(s_item_to_insert.ih_key),
+					    (char *)&s_node_to_write, UNFM_P_SIZE, REISERFS_KERNEL_MEM, 0) < 0 ) {
+		/* If no disk space for balancing required to insert entry for new unformatted
+		   node into last indirect item. */
+		if ( ! n_written )
+		  n_written = -ENOSPC;
+                if ( p_s_un_bh )  {
+		  reiserfs_free_block(&th, p_s_sb, p_s_un_bh->b_blocknr);
+		  j = p_s_un_bh->b_blocknr / (p_s_sb->s_blocksize * 8);
+		  COMPLETE_BITMAP_DIRTING_AFTER_FREEING(p_s_sb,j);
+
+                  bforget(p_s_un_bh);
+                  p_s_un_bh = NULL;
+                }
+                break;
+              }
+              if ( p_s_un_bh )	{ /* If not a hole. */
+		/* copy user data to the unformatted node */
+                //memset(p_s_un_bh->b_data, '\0', n_item_zeros_to_add);
+		copy_from_user(p_s_un_bh->b_data + n_item_zeros_to_add, p_c_buf, n_item_bytes_to_write);
+		//memset(p_s_un_bh->b_data + n_item_zeros_to_add + n_item_bytes_to_write, '\0', s_node_to_write.unfm_freespace);
+
+		update_vm_cache(p_s_inode, n_pos_in_file - 1,
+				p_s_un_bh->b_data + n_item_zeros_to_add, n_item_bytes_to_write);
+                mark_buffer_uptodate(p_s_un_bh,1);
+		/* non-atomic mark_buffer_dirty is allowed here */
+		/* mark_buffer_dirty(p_s_un_bh, 0); */
+		journal_mark_dirty_nolog(&th, p_s_sb, p_s_un_bh) ;
+
+		/* compelte what was not finished in reiserfs_new_blocknrs */
+		j = p_s_un_bh->b_blocknr / (p_s_sb->s_blocksize * 8);
+		COMPLETE_BITMAP_DIRTING_AFTER_ALLOCATING (p_s_sb, j);
+
+		brelse(p_s_un_bh);
+                p_s_un_bh = NULL;
+
+		/* i_blocks counts only unformatted nodes */
+		p_s_inode->i_blocks += p_s_sb->s_blocksize / 512;
+	      }
+            }
+            else  { /* Insert direct item. */
+	      p_s_inode->u.reiserfs_i.i_pack_on_close = 0 ;
+
+	      n_item_bytes_to_write = n_count;
+	      n_item_zeros_to_add = n_zero_bytes;
+	      /* Create direct item header. */
+	      s_item_to_insert.ih_key.k_offset = n_append_startpoint;
+              /* Mark item as not mergeable. */
+	      s_item_to_insert.ih_key.k_uniqueness = TYPE_DIRECT;
+              /* Mark item as direct. */
+	      s_item_to_insert.u.ih_free_space = MAX_US_INT;
+	      s_item_to_insert.ih_item_len = n_zero_bytes + n_item_bytes_to_write;
+
+	      /* copy data from user space to intermediate buffer */
+	      copy_from_user (local_buf, p_c_buf, n_item_bytes_to_write);
+	      /* make sure, that direct item is still on its old place */
+	      if (comp_items (&s_ih, &s_search_path)) {
+		printk ("reiserfs_file_write: item has been moved while we were in copy_from_user (inserting the direct item after the last indirect)\n");
+		continue;
+	      }
+
+              /* reiserfs_insert_item() inserts before given position in the node, so we must
+		 increment to point to the next item after searched one. */
+	      PATH_LAST_POSITION(&s_search_path)++;
+	      if ( reiserfs_insert_item (&th, p_s_sb, &s_search_path, &s_item_to_insert,
+					 local_buf, REISERFS_KERNEL_MEM, n_zero_bytes, NOTHING_SPECIAL) < 0 )  {
+		if ( ! n_written )
+		  n_written = -ENOSPC;
+		break; /* No disk space. */
+              }
+	      
+	      update_vm_cache(p_s_inode, n_pos_in_file - 1, p_c_buf, n_item_bytes_to_write);
+
+	      /* calculate direct item as whole block */
+	      p_s_inode->i_blocks += p_s_sb->s_blocksize / 512;
+
+#ifdef REISERFS_CHECK
+	      if ( p_s_inode->u.reiserfs_i.i_first_direct_byte != NO_BYTES_IN_DIRECT_ITEM ||
+		   n_append_startpoint + n_zero_bytes != n_pos_in_file)
+		reiserfs_panic(p_s_sb, "PAP-14200: reiserfs_file_write: file must have no direct items");
+#endif
+
+	      p_s_inode->u.reiserfs_i.i_first_direct_byte = n_append_startpoint;
+            }
+          }
+	}
+      }
+    }
+
+    n_count       -= n_item_bytes_to_write;
+    p_c_buf       += n_item_bytes_to_write;
+    n_pos_in_file += n_item_bytes_to_write;
+    n_written     += n_item_bytes_to_write;
+
+    if ( (s_key_to_search.k_offset += n_item_bytes_to_write) >= p_s_inode->u.reiserfs_i.i_first_direct_byte )
+      s_key_to_search.k_uniqueness = TYPE_DIRECT;
+    else
+      s_key_to_search.k_uniqueness = TYPE_INDIRECT;
+
+    /* here we do a polite test to see if the journal needs a little more room.
+    ** if so, we write our inode to make sure it stays with this transaction, and give
+    ** the journal_end/begin pair the chance to end the current transaction
+    ** don't bother ending if we're already done writing
+    */
+    if (n_count > 0 && journal_transaction_should_end(&th, jbegin_count)) {
+      pathrelse(&s_search_path);
+      update_inode_and_restart_transaction(&th, p_s_inode, n_pos_in_file) ;
+    }
+  }
+
+  
+  if ( --n_pos_in_file > p_s_inode->i_size )  {
+    p_s_inode->i_size   = n_pos_in_file;
+    p_s_inode->i_ctime  = CURRENT_TIME;
+  }
+
+  p_s_inode->i_mtime  = CURRENT_TIME;
+  *p_n_pos = n_pos_in_file;
+
+  if_in_ram_update_sd (&th, p_s_inode); 
+
+  reiserfs_kfree (local_buf, n_blk_size, p_s_inode->i_sb);
+  pop_journal_writer(windex) ;
+  journal_end(&th, p_s_sb, jbegin_count) ;
+  return n_written;
+}
+
+
+
+/* Please note that the benchmarking of the right numbers for
+   RESIERFS_NBUF, etc., was insufficiently investigated.
+
+   Hans */
+
+
+
+/* Wait for and then release the read-ahead blocks. We need a brelse that does not wait. */
+#define RELEASE_READ_AHEAD_BLOCKS       while ( p_s_bhe != p_s_bhb ) {\
+                                                brelse(p_s_bhe->bi_buf);\
+                                                if ( ++p_s_bhe == &a_p_s_range_bufs_ids[REISERFS_NBUF] )\
+                                                        p_s_bhe = a_p_s_range_bufs_ids;\
+                                        }
+#define INCREASE_P_S_BHE		if ( ++p_s_bhe == &a_p_s_range_bufs_ids[REISERFS_NBUF] )\
+              					p_s_bhe = a_p_s_range_bufs_ids
+
+
+/* if Hans understands correctly this works by oscillating between a
+   request and a fulfill loop.  (It would be nice if Anatoly edited the
+   code to make it clearer as to its design objectives and algorithm,
+   as that might make it easier to see ways to simplify it).
+
+   The request loop assembles a list of not more than NBUF buffers
+   (buflist) which are within the range and which are cache children
+   (their parents are in cache, they are not).  It then requests I/O
+   on that list, and then the fulfill loop starts processing the list.
+
+   The fulfill loop goes through the list, and completes as much of
+   the read as it can.  If the fulfill loop processes a buffer whose
+   children contain data that needs to be read, then it oscillates
+   back to the request loop, which will then request not only those
+   new cache children which were children of the buffer that the
+   fulfill loop stopped on, but all cache children in the range.
+
+   The request loop works by calling get_buffer_by_range(), which
+   returns a buffer which either contains the node containing the
+   readkey, or which is prepared for requesting I/O on to get the
+   cache child corresponding to the readkey.  The readkey is
+   incremented as a result of each get_buffer_by_range so that it
+   holds the key of the next byte after the buffer that was returned
+   in the range.
+   
+   The reason for this algorithm is to allow one to read as much in
+   parallel as possible, and this is done by ensuring that there is an
+   outstanding request for all of the first NBUF cache children that
+   are in the range, and submitting new requests that contain more
+   cache children as soon as possible.  Question: what happens if
+   there are NBUF outstanding requests, the first of them completes,
+   it contains an indirect item with lots of buffers which must be
+   read, but bhreq is full?  Is the indirect item requested one buffer
+   at a time?  Or will all of the nodes on the request list get
+   processed, and bhreq gets freed up? Will we get a pathological
+   behaviour in which the disk head starts to move towards the other
+   nodes on the request list, but keeps getting dragged back to handle
+   one more node from the indirect item, each request for which is
+   separated by a rotation? Can we test to see if this ever
+   happens?  Maybe we can printk some blocknumbers? -Hans */
+
+static ssize_t  reiserfs_file_read(		/*  Read from file system into user buffer.		*/
+              struct file     *	p_s_filp,   	/*  Object table entry for this inode. ( p_s_filp->f_pos
+						    will provide us with the offset from which we 
+						    start the read, and we will update it to reflect
+						    how much we have read as we perform the read.)	*/
+              char 	      *	p_c_buf,	/*  Address of the user buffer.				*/
+              size_t		n_count,		/*  Count of bytes copied into user buffer.		*/
+	      loff_t	      * p_n_pos
+            ) {
+  struct inode * p_s_inode = p_s_filp->f_dentry->d_inode;
+  struct super_block  *	p_s_sb;			/* Pointer to the super block.			*/
+  struct key            s_range_begin,		/*  Minimal range key to request.       	*/
+                        s_range_end,		/*  Maximal range key to request.       	*/
+                        s_readkey;		/*  Current read key,
+					    	    (the key version of offset )		*/
+  ssize_t		n_read;			/*  Number of bytes which have been read.	*/
+  unsigned int		n_pos_in_file,		/* Current offset in the file.			*/
+			n_file_size,
+			n_left;			/*  Number of bytes remaining to read.		*/
+
+
+ 
+  int                   n_offset_in_item,       /*  Offset in unformatted node or direct item.  */
+                        n_chars,                /*  Number of bytes to copy.                    */
+#ifdef READ_LOCK_REISERFS
+                        this_syscall_has_the_read_lock = 0, /* flag to indicate whether this read syscall is the one that
+                                                        locked the FS, if so then don't worry about the FS being read
+                                                        locked */
+#endif /* READ_LOCK_REISERFS */
+                        n_blocksize;            /* Buffer size.                                 */
+
+  char                * p_c_addr = NULL;        /*  Address in a system buffer.                 */
+
+
+  struct buffer_head  * a_p_s_bhreq[REISERFS_NBUF],      /*  Array of the not uptodate buffers
+                                                    from  the read range.                       */
+                      * p_s_bh;
+  struct buffer_and_id a_p_s_range_bufs_ids[REISERFS_NBUF];      /*  Array of all buffers and ids from
+                                                            the read range.                     */
+
+                                /* it seems that bhb is used in the
+                                   request preparation to point to
+                                   where to insert the next buffer
+                                   onto bhreq, and bhe is used in the
+                                   post-request processing to go
+                                   through the array to do things with
+                                   every buffer that has completed its
+                                   requested I/O and is now uptodate
+                                   and unlocked.  The case in which
+                                   bhe = bhb represents the case in
+                                   which either all requests have
+                                   completed, or bhreq is completely
+                                   filled with requests uncompleted.
+				   
+				   Note that both bhb and bhe are
+				   allowed to wrap around the end of
+				   buflist.  This is necessary for
+				   when the read is larger than bhreq
+				   can hold.  -Hans */
+  struct buffer_and_id	      *	p_s_bhb,	/*  We need two variables to go through		*/
+    			      *	p_s_bhe;	/*  array a_p_s_range_bufs_ids.                 */
+  int                   	n_bhrequest,	/* offset in the array a_p_s_bhreq.		*/
+                        	n_uptodate;
+  char * local_buf;		/* copy_to_user can cause schedule. Therefore we can not copy bytes
+				   directly from direct item to user buffer. Local_buf is used as
+				   intermediate buffer */
+
+#ifdef REISERFS_CHECK
+  int				n_repeat_counter = 0;
+#endif
+
+#ifdef __KERNEL__
+  if (use_genericread (p_s_inode->i_sb)) {
+    increment_i_read_sync_counter(p_s_inode);
+    n_read = generic_file_read (p_s_filp, p_c_buf, n_count, p_n_pos);
+    decrement_i_read_sync_counter(p_s_inode);
+    return n_read;
+  }
+#endif
+
+  if ( ! p_s_inode ) {
+    printk("reiserfs_file_read: pointer to the inode = NULL\n");
+    return -EINVAL;
+  }
+
+  if ( ! S_ISREG(p_s_inode->i_mode) && ! S_ISLNK(p_s_inode->i_mode) ) {
+    printk("reiserfs_file_read: mode = %07o\n",p_s_inode->i_mode);
+    return -EINVAL;
+  }
+
+  /* Calculate position in the file. */
+  n_pos_in_file = *p_n_pos + 1 ;
+
+  /* Calculate object size. */
+  n_file_size = p_s_inode->i_size;
+
+  /* Using position in the file, file size, and the given number of bytes to read
+     calculate the number of bytes, that should be actually read;
+     put it in variable n_left. */
+  if ( n_pos_in_file > n_file_size || n_count <= 0 ) /* Nothing to read. */
+    return 0;
+
+  increment_i_read_sync_counter(p_s_inode);
+
+  n_left = n_file_size - n_pos_in_file + 1;
+  if ( n_left > n_count )
+    n_left = n_count;
+  n_read = 0;
+
+  p_s_sb = p_s_inode->i_sb;
+
+  /* Initialize read range. */
+  copy_key(&s_range_begin, &(p_s_inode->u.reiserfs_i.i_key));
+  s_range_begin.k_offset = n_pos_in_file;
+  if ( INODE_OFFSET_IN_DIRECT(p_s_inode, n_pos_in_file) )
+    s_range_begin.k_uniqueness = TYPE_DIRECT;
+  else
+    s_range_begin.k_uniqueness = TYPE_INDIRECT;
+
+  copy_key(&s_range_end, &(p_s_inode->u.reiserfs_i.i_key));
+  s_range_end.k_offset = n_pos_in_file + n_left - 1;
+  if ( INODE_OFFSET_IN_DIRECT(p_s_inode, s_range_end.k_offset) )
+    s_range_end.k_uniqueness = TYPE_DIRECT;
+  else
+    s_range_end.k_uniqueness = TYPE_INDIRECT;
+
+#ifdef REISERFS_OBJECT_READ_AHEAD
+  s_range_end.k_offset = n_file_size;
+  s_range_end.k_uniqueness = TYPE_DIRECT;
+#endif
+
+#ifdef PACKING_LOCALITY_READ_AHEAD
+  s_range_end.k_objectid = MAX_KEY_OBJECTID;
+  s_range_end.k_offset = MAX_KEY_OFFSET;
+  s_range_end.k_uniqueness = MAX_KEY_UNIQUENESS;
+#endif
+
+  /* Set current key to read . */
+  copy_key(&s_readkey, &s_range_begin);
+
+  p_s_bhb = p_s_bhe = a_p_s_range_bufs_ids;
+
+  n_blocksize = p_s_sb->s_blocksize;
+
+  local_buf = reiserfs_kmalloc (n_blocksize, GFP_KERNEL, p_s_sb);
+  if (local_buf == 0) {
+    return -ENOMEM;
+  }
+
+  /* Here is the loop to cause us to oscillate between requesting and fulfilling */
+  do {
+
+#ifdef REISERFS_CHECK
+    if ( ! (++n_repeat_counter % 50000) ) {
+      reiserfs_panic(p_s_sb, "PAP-14205: reiserfs_fileread: counter(%d) too big. Range begin %k",
+		     n_repeat_counter, &s_range_begin);
+    }
+#endif
+
+    n_bhrequest = 0;
+
+    /* This says no, there are not any buffers that we are waiting for I/O to complete for. -Hans */
+    n_uptodate = 1;
+
+    if ( p_s_bhb == p_s_bhe && COMP_KEYS(&s_range_begin, &s_range_end) == 1 ) {
+
+#ifdef REISERFS_INFO
+      printk("reiserfs_fileread: request key is not in the range and request is empty but there are bytes to read \n");
+#endif
+
+      copy_key(&s_range_begin, &s_readkey);
+    }
+
+    /* Request loop (well, actually the prepare to request loop) */
+    /* This while loop assembles a request array (bhreq) which contains either a single buffer which does not require
+       I/O to fetch and which we will proceed to read into the user buffer immediately or enough cache children in the
+       range to fill bhreq so that we can get REISERFS_NBUF buffers all at once.  -Hans */
+    while ( COMP_KEYS(&s_range_begin, &s_range_end) != 1 )  { /* While current key is in the range. */
+
+      /* Calculate next buffer from range. This returns either a
+         buffer that was in cache, or a buffer all set for us to
+         request I/O on. */
+      get_buffer_by_range(p_s_sb, &s_range_begin, &s_range_end, &(p_s_bhb->bi_buf), &(p_s_bhb->bi_id));
+
+      /* Buffer is not uptodate (in other words, it wasn't in cache
+         and we need to read it). Put it in the request array. */
+      if ( p_s_bhb->bi_buf && ! buffer_uptodate(p_s_bhb->bi_buf) ) {
+        n_uptodate = 0;
+        a_p_s_bhreq[n_bhrequest++] = p_s_bhb->bi_buf;
+      }
+
+      /* Increment, and possibly wraparound to beginning of list */
+      if ( ++p_s_bhb == &a_p_s_range_bufs_ids[REISERFS_NBUF] )
+        p_s_bhb = a_p_s_range_bufs_ids;
+
+      /* If all of the buffers we have processed so far in this pass
+         of the loop are uptodate (in which case there is only one
+         such buffer) then go ahead and copy its contents to user
+         space now rather than assembling more buffers. */
+
+      if ( n_uptodate )
+        break;
+      if ( p_s_bhb == p_s_bhe )
+        break;
+    }
+
+#ifdef REISERFS_CHECK
+    /* Check whether buffers from the request have valid device. */
+    for ( n_chars = 0; n_chars < n_bhrequest; n_chars++ )
+      if ( a_p_s_bhreq[n_chars]->b_dev == NODEV )
+	reiserfs_panic(p_s_sb, "PAP-14210: reiserfs_file_read: device is NODEV");
+#endif
+
+    /* Now request them all. */
+    if ( n_bhrequest ) {
+#ifdef READ_LOCK_REISERFS
+                                /* So why read_lock the FS?  Because serial reads are more efficient than parallel
+                                   reads, substantially so say the benchmarks.  now you might ask, why not wait on the
+                                   lock?  The reason is that I have an untested hope that it will cause a series of
+                                   large reads from the same process succeeding in its lock once to tend to get
+                                   priority.  It is deliberately unfair.  Don't go moving that disk head.... -Hans */
+      while (!try_ulong_lock(&(p_s_sb->u.reiserfs_sb.read_lock), 0) && !this_syscall_has_the_read_lock)
+        {
+/*        printk("blocked for lock %lu:", p_s_sb->u.reiserfs_sb.read_lock); */
+          schedule();
+          /*  don't know if schedule can invalidate what we are reading, or if the read picks up all the pieces properly
+              when this is done. -Hans */
+        }
+      this_syscall_has_the_read_lock = 1;
+#endif /* READ_LOCK_REISERFS */
+      ll_rw_block(READ, n_bhrequest, a_p_s_bhreq);
+    }
+
+    /* fulfillment loop */
+    /* Finish off all I/O that has actually completed. */
+    do {
+      /* Check to see if read error occured. In this case we break read function.  */
+      if ( (p_s_bh = p_s_bhe->bi_buf) ) {
+        wait_on_buffer(p_s_bh);
+        if ( ! buffer_uptodate(p_s_bh) ) {
+          brelse(p_s_bh);
+	  INCREASE_P_S_BHE;
+          n_left = 0;
+	  printk ("reiserfs_file_read: I/O error (block %lu, dev 0%o, size %ld)\n", p_s_bh->b_blocknr, p_s_bh->b_dev, p_s_bh->b_size);
+          break;
+        }
+      }
+
+      /* If buffer is not in tree, or is key level, then repeat buffer calculating.  Buffer is not in tree means that
+        some balancing occured while we were waiting for the needed buffer or getting next buffer from range. This
+        balancing removed needed buffer from the tree.  It is possible for all tree levels. It is not possible just for
+        unformatted nodes.  If after waiting we have internal node buffer we can not read from it(it does not contain
+        data).  In both cases we call get_buffer_from range once more to get bytes for read. -Anatoly.  */
+
+      /* ok, so if we now have a formatted node, check to confirm that
+         we got the right one, then copy our data to user space,
+         checking as we copy to see if we need to descend into any
+         unformatted node children.  If we so need, then we better
+         oscillate back to the request loop to read those children
+         into memory (and while in that request loop we might as well
+         try to read everything else in the range that we can....)
+         -Hans */
+      if ( p_s_bh && p_s_bhe->bi_id == MAX_KEY_OBJECTID ) {
+	if ( ! B_IS_IN_TREE(p_s_bh) || ! B_IS_ITEMS_LEVEL(p_s_bh) ) {
+	  /* We are repeating the read starting from the current s_readkey */   
+          brelse(p_s_bh);
+          INCREASE_P_S_BHE;
+          RELEASE_READ_AHEAD_BLOCKS;
+          copy_key(&s_range_begin, &s_readkey);
+          p_s_bhb = p_s_bhe = a_p_s_range_bufs_ids;
+          break;
+        }
+
+        /* Needed byte should be in the leaf we were waiting for */
+        if ( COMP_KEYS(B_N_PKEY(p_s_bh, 0), &s_readkey) < 1 &&
+	     COMP_KEYS(B_PRIGHT_DELIM_KEY(p_s_bh), &s_readkey) == 1 ) {
+
+          int 			n_search_res,
+				n_item_pos;
+	  struct item_head    *	p_s_ih;
+
+          /* Find item contains needed byte. */
+          n_search_res = bin_search(&s_readkey, B_N_PITEM_HEAD(p_s_bh, 0), B_NR_ITEMS(p_s_bh), IH_SIZE, &n_item_pos);
+          p_s_ih = B_N_PITEM_HEAD(p_s_bh, n_item_pos);
+          /* We are looking for an item contains needed byte of the needed object. In case of n_search_res = 0 it can
+             not be *p_s_ih. Probably *(p_s_ih--) it is. We are checking it. */
+          if ( n_search_res == ITEM_NOT_FOUND )
+            p_s_ih--;
+
+	  /* error checking: if ih does not contain the byte corresponding to readkey -Hans */
+	  if ( ! I_K_KEY_IN_ITEM(p_s_ih, &s_readkey, n_blocksize) ) {
+
+#ifdef REISERFS_CHECK
+            printk ("reiserfs_file_read: can not read bytes (file was truncated or deleted)\n");
+#endif
+
+            brelse(p_s_bh);
+	    INCREASE_P_S_BHE;
+            n_left = 0;
+            break;
+          }
+
+          /* If needed byte is located in an unformatted node then oscillate
+             back to request loop so that it will be gotten for us,
+             but only do so after waiting for completion of all
+             read_ahead blocks. */
+          if ( I_IS_INDIRECT_ITEM(p_s_ih) ) {
+
+#ifdef REISERFS_CHECK
+	    if ( s_readkey.k_uniqueness != TYPE_INDIRECT )
+	      reiserfs_panic(p_s_sb, "PAP-14240: reiserfs_file_read: invalid uniqueness in the read key");
+#endif
+
+            brelse(p_s_bh);
+            INCREASE_P_S_BHE;
+                                /* waits for as well as releases */
+            RELEASE_READ_AHEAD_BLOCKS;
+            copy_key(&s_range_begin, &s_readkey);
+            p_s_bhb = p_s_bhe = a_p_s_range_bufs_ids;
+            break;
+          }
+
+#ifdef REISERFS_CHECK
+	  if ( s_readkey.k_uniqueness != TYPE_DIRECT )
+	    reiserfs_panic(p_s_sb, "PAP-14250: reiserfs_file_read: invalid uniqueness in the read key");
+#endif
+
+	  /* So, there are bytes to copy from the direct item. */
+          n_offset_in_item = n_pos_in_file - p_s_ih->ih_key.k_offset;
+          n_chars = p_s_ih->ih_item_len - n_offset_in_item;
+          p_c_addr  = B_I_PITEM(p_s_bh, p_s_ih) + n_offset_in_item;
+	}
+        else {
+
+#ifdef REISERFS_CHECK
+          printk("reiserfs_file_read: key is not in the buffer\n");
+#endif
+
+          brelse(p_s_bh);
+	  INCREASE_P_S_BHE;
+          RELEASE_READ_AHEAD_BLOCKS;
+
+          copy_key(&s_range_begin, &s_readkey);
+          p_s_bhb = p_s_bhe = a_p_s_range_bufs_ids;
+          break;
+        }
+      }
+
+      else {
+	/* We waited for an unformatted node. Read from it. */
+	if ( p_s_bh ||  p_s_bhe->bi_id != MAX_KEY_OBJECTID ) {
+
+	  if ( p_s_bhe->bi_id != s_readkey.k_objectid ) {
+	    
+#ifdef REISERFS_CHECK
+	    /*printk("reiserfs_file_read: can not read bytes(3) (file was truncated or deleted)\n");*/
+#endif
+            
+            brelse(p_s_bh);
+            INCREASE_P_S_BHE;
+            n_left = 0;
+            
+            break;
+          }
+          
+#ifdef REISERFS_CHECK
+          if ( s_readkey.k_uniqueness != TYPE_INDIRECT ) {
+            print_block(p_s_bh, 0, -1, -1);
+            printk("size = %ld, first_direct = %d\n", p_s_inode->i_size, p_s_inode->u.reiserfs_i.i_first_direct_byte);
+            printk ("p_s_bhe->bi_id==%lu\n", p_s_bhe->bi_id);
+            reiserfs_panic(p_s_sb, "PAP-14270: reiserfs_file_read: invalid uniqueness in the read key %k. TYPE_INDIRECT expected",
+			   &s_readkey);
+          }
+#endif
+
+	}
+
+        /* Calculate offset in the unformatted node. */
+        n_offset_in_item = (n_pos_in_file - 1) % n_blocksize;
+        n_chars = n_blocksize - n_offset_in_item;
+        if ( p_s_bh )
+          p_c_addr = n_offset_in_item + p_s_bh->b_data;
+      }
+
+      if ( n_chars > n_left )
+        n_chars = n_left;
+      *p_n_pos += n_chars ; /* p_s_filp->f_pos += n_chars; */
+      n_left -= n_chars;
+      n_read += n_chars;
+      n_pos_in_file += n_chars;
+      /* Here is one place where we reset readkey so that the next
+         buffer is gotten on the next loop iteration.. */
+      s_readkey.k_offset = n_pos_in_file;
+      if ( n_pos_in_file >= p_s_inode->u.reiserfs_i.i_first_direct_byte )
+	s_readkey.k_uniqueness = TYPE_DIRECT;
+
+#ifdef REISERFS_CHECK
+      if ( n_chars < 0 || n_chars > n_blocksize )
+	reiserfs_panic(p_s_sb, "PAP-14280: reiserfs_file_read: illegal bytes number to read");
+#endif
+
+      if (p_s_bhe->bi_id != MAX_KEY_OBJECTID) {
+	/* when copying bytes from an unformatted node, we do not need intermediate buffer */
+	if ( p_s_bh ) {
+	  copy_to_user(p_c_buf, p_c_addr, n_chars);
+	  brelse(p_s_bh);
+	  p_c_buf += n_chars;
+	} else {
+	  while ( n_chars-- > 0 )
+	    if ( put_user(0, p_c_buf++) )
+	      reiserfs_panic(p_s_sb, "PAP-14290: reiserfs_file_read: put_user failed");
+	}
+      } else {
+	/* Copy bytes from direct item into intermediate buffer. */
+	if ( p_s_bh ) {
+	  memcpy (local_buf, p_c_addr, n_chars);
+	  brelse(p_s_bh);
+	} else {
+	  memset (local_buf, 0, n_chars);
+	}
+
+	/* copy bytes from intermediate buffer to the user buffer */
+	copy_to_user(p_c_buf, local_buf, n_chars);
+	p_c_buf += n_chars;
+      }
+
+      INCREASE_P_S_BHE;
+    } while ( n_left > 0 && p_s_bhe != p_s_bhb && (! p_s_bhe->bi_buf || ! buffer_locked(p_s_bhe->bi_buf)) ) ;
+  } while ( n_left > 0 );
+
+  RELEASE_READ_AHEAD_BLOCKS;
+
+  decrement_i_read_sync_counter(p_s_inode);
+
+#ifdef READ_LOCK_REISERFS
+  unlock_ulong_lock(&(p_s_sb->u.reiserfs_sb.read_lock), 0,  &(p_s_sb->u.reiserfs_sb.read_wait));
+ /*  printk("unlocked lock %lu:", p_s_sb->u.reiserfs_sb.read_lock); */
+#endif /* READ_LOCK_REISERFS */
+
+  reiserfs_kfree (local_buf, n_blocksize, p_s_sb);
+  if ( ! n_read ) {
+    return -EIO;
+  }
+  UPDATE_ATIME(p_s_inode);
+
+  return n_read;
+}
+
+
Index: empeg/kernel/fs/reiserfs/fix_node.c
diff -u /dev/null empeg/kernel/fs/reiserfs/fix_node.c:1.1
--- /dev/null	Wed Oct 17 16:36:05 2001
+++ empeg/kernel/fs/reiserfs/fix_node.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,2989 @@
+/*
+ * Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
+ */
+
+/**
+ ** old_item_num
+ ** old_entry_num
+ ** set_entry_sizes
+ ** create_virtual_node
+ ** check_left
+ ** check_right
+ ** directory_part_size
+ ** get_num_ver
+ ** item_length
+ ** set_parameters
+ ** is_leaf_removable
+ ** are_leaves_removable
+ ** get_empty_nodes
+ ** get_lfree
+ ** get_rfree
+ ** is_left_neighbor_in_cache
+ ** decrement_key
+ ** get_far_parent
+ ** get_parents
+ ** can_node_be_removed
+ ** ip_check_balance
+ ** dc_check_balance_internal
+ ** dc_check_balance_leaf
+ ** dc_check_balance
+ ** check_balance
+ ** get_direct_parent
+ ** get_neighbors
+ ** fix_nodes
+ ** 
+ ** 
+ **/
+
+
+#ifdef __KERNEL__
+
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/reiserfs_fs.h>
+
+#else
+
+#include "nokernel.h"
+
+#endif
+
+
+#define ROUND_UP(x,n) (((x)+(n)-1u) & ~((n)-1u))
+
+
+/* To make any changes in the tree we find a node, that contains item
+   to be changed/deleted or position in the node we insert a new item
+   to. We call this node S. To do balancing we need to decide what we
+   will shift to left/right neighbor, or to a new node, where new item
+   will be etc. To make this analysis simpler we build virtual
+   node. Virtual node is an array of items, that will replace items of
+   node S. (For instance if we are going to delete an item, virtual
+   node does not contain it). Virtual node keeps information about
+   item sizes and types, mergeability of first and last items, sizes
+   of all entries in directory item. We use this array of items when
+   calculating what we can shift to neighbors and how many nodes we
+   have to have if we do not any shiftings, if we shift to left/right
+   neighbor or to both. */
+
+
+/* taking item number in virtual node, returns number of item, that it has in source buffer */
+static inline int old_item_num (int new_num, int affected_item_num, int mode)
+{
+  if (mode == M_PASTE || mode == M_CUT || new_num < affected_item_num)
+    return new_num;
+
+  if (mode == M_INSERT) {
+
+#ifdef REISERFS_CHECK
+    if (new_num == 0)
+      reiserfs_panic (0,"vs-8005: old_item_num: for INSERT mode and item number of inserted item");
+#endif
+
+    return new_num - 1;
+  }
+
+#ifdef REISERFS_CHECK
+  if (mode != M_DELETE)
+      reiserfs_panic (0, "vs-8010: old_item_num: mode must be M_DELETE (mode = \'%c\'", mode);
+#endif
+
+  /* delete mode */
+  return new_num + 1;
+}
+
+
+/*
+ * function returns old entry number in directory item in real node
+ * using new entry number in virtual item in virtual node */
+static inline int old_entry_num (int new_num, int affected_item_num, int new_entry_num, int pos_in_item, int mode)
+{
+  if ( mode == M_INSERT || mode == M_DELETE)
+    return new_entry_num;
+
+  if (new_num != affected_item_num) {
+    /* cut or paste is applied to another item */
+    return new_entry_num;
+  }
+
+  if (new_entry_num < pos_in_item)
+    return new_entry_num;
+
+  if (mode == M_CUT)
+    return new_entry_num + 1;
+
+#ifdef REISERFS_CHECK  
+  if (mode != M_PASTE)
+      reiserfs_panic (0, "vs-8015: old_entry_num: mode must be M_PASTE (mode = \'%c\'", mode);
+#endif
+
+  return new_entry_num - 1;
+}
+
+
+
+/*
+ * Create an array of sizes of directory entries for virtual item
+ */
+static void set_entry_sizes (struct tree_balance * tb,
+			     int old_num, int new_num,
+			     struct buffer_head * bh,
+			     struct item_head * ih
+			     )
+{
+  struct virtual_node * vn = tb->tb_vn;
+  int i;
+  struct reiserfs_de_head * deh;
+  struct virtual_item * vi;
+  
+  deh = B_I_DEH (bh, ih);
+
+  /* seek to given virtual item in array of virtual items */
+  vi = vn->vn_vi + new_num;
+
+  /* virtual directory item have this amount of entry after */
+  vi->vi_entry_count = I_ENTRY_COUNT (ih) + 
+    ((old_num == vn->vn_affected_item_num) ? ((vn->vn_mode == M_CUT) ? -1 :
+					      (vn->vn_mode == M_PASTE ? 1 : 0)) : 0);
+
+#ifdef REISERFS_CHECK
+  /* check whether we have enough space for array of entry sizes */
+  if (tb->vn_buf + tb->vn_buf_size - vn->vn_free_ptr < vi->vi_entry_count * sizeof (__u16))
+    reiserfs_panic (tb->tb_sb, "vs-8020: set_entry_sizes: "
+		    "no enough space for %d entries of virtual item", vi->vi_entry_count);
+#endif
+
+  vi->vi_entry_sizes = (__u16 *)vn->vn_free_ptr;
+  vn->vn_free_ptr += vi->vi_entry_count * sizeof (__u16);
+
+  /* set sizes of old entries */
+  for (i = 0; i < vi->vi_entry_count; i ++) {
+    int j;
+    
+    j = old_entry_num (old_num, vn->vn_affected_item_num, i, vn->vn_pos_in_item, vn->vn_mode);
+    vi->vi_entry_sizes[i] = I_DEH_N_ENTRY_LENGTH (ih, &(deh[j]), j) + DEH_SIZE;
+  }
+  
+  /* set size of pasted entry */
+  if (old_num == vn->vn_affected_item_num && vn->vn_mode == M_PASTE)
+    vi->vi_entry_sizes[vn->vn_pos_in_item] = tb->insert_size[0];
+
+
+#ifdef REISERFS_CHECK
+  /* compare total size of entries with item length */
+  {
+    int k, l;
+    
+    l = 0;
+    for (k = 0; k < vi->vi_entry_count; k ++)
+      l += vi->vi_entry_sizes[k];
+    
+    if (l + IH_SIZE != vi->vi_item_len + 
+	((old_num == vn->vn_affected_item_num && (vn->vn_mode == M_PASTE || vn->vn_mode == M_CUT)) ? tb->insert_size[0] : 0) ) {
+      reiserfs_panic (0, "vs-8025: set_entry_sizes: (mode==%c, old_num==%d, aff_num==%d, insert_size==%d), invalid length of directory item",
+		      vn->vn_mode, old_num, vn->vn_affected_item_num, tb->insert_size[0]);
+    }
+  }
+#endif
+
+}
+
+
+static void create_virtual_node (struct tree_balance * tb, int h)
+{
+  struct item_head * ih;
+  struct virtual_node * vn = tb->tb_vn;
+  int new_num;
+  struct buffer_head * Sh;	/* this comes from tb->S[h] */
+
+  Sh = PATH_H_PBUFFER (tb->tb_path, h);
+
+  /* size of changed node */
+  vn->vn_size = MAX_CHILD_SIZE (Sh) - B_BLK_HEAD (Sh)->blk_free_space + tb->insert_size[h];
+
+  /* for internal nodes array if virtual items is not created */
+  if (h) {
+    vn->vn_nr_item = (vn->vn_size - DC_SIZE) / (DC_SIZE + KEY_SIZE);
+    return;
+  }
+
+  /* number of items in virtual node  */
+  vn->vn_nr_item = B_NR_ITEMS (Sh) + ((vn->vn_mode == M_INSERT)? 1 : 0) - ((vn->vn_mode == M_DELETE)? 1 : 0);
+
+  /* first virtual item */
+  vn->vn_vi = (struct virtual_item *)(tb->tb_vn + 1);
+  memset (vn->vn_vi, 0, vn->vn_nr_item * sizeof (struct virtual_item));
+  vn->vn_free_ptr += vn->vn_nr_item * sizeof (struct virtual_item);
+
+
+  /* first item in the node */
+  ih = B_N_PITEM_HEAD (Sh, 0);
+
+  /* define the mergeability for 0-th item (if it is not being deleted) */
+#ifdef REISERFS_FSCK
+  if (is_left_mergeable (tb->tb_sb, tb->tb_path) == 1 && (vn->vn_mode != M_DELETE || vn->vn_affected_item_num))
+#else
+  if (is_left_mergeable (ih, Sh->b_size) && (vn->vn_mode != M_DELETE || vn->vn_affected_item_num))
+#endif
+    vn->vn_vi[0].vi_type |= VI_TYPE_LEFT_MERGEABLE;
+
+  /* go through all items those remain in the virtual node (except for the new (inserted) one) */
+  for (new_num = 0; new_num < vn->vn_nr_item; new_num ++) {
+    int j;
+    
+    if (vn->vn_affected_item_num == new_num && vn->vn_mode == M_INSERT)
+      continue;
+    
+    /* get item number in source node */
+    j = old_item_num (new_num, vn->vn_affected_item_num, vn->vn_mode);
+    
+    vn->vn_vi[new_num].vi_item_len += ih[j].ih_item_len + IH_SIZE;
+    
+    if (I_IS_STAT_DATA_ITEM (ih + j)) {
+      vn->vn_vi[new_num].vi_type |= VI_TYPE_STAT_DATA;
+
+#ifdef REISERFS_CHECK
+      if (new_num == vn->vn_affected_item_num && (vn->vn_mode == M_CUT || vn->vn_mode == M_PASTE))
+	reiserfs_panic (0, "vs-8035: create_virtual_node: stat data cannot be affected item");
+#endif
+
+      continue;
+    }
+
+    /* set type of item */
+    if (I_IS_DIRECT_ITEM (ih + j))
+      vn->vn_vi[new_num].vi_type |= VI_TYPE_DIRECT;
+    
+    if (I_IS_INDIRECT_ITEM (ih + j))
+      vn->vn_vi[new_num].vi_type |= VI_TYPE_INDIRECT;
+
+    if (I_IS_DIRECTORY_ITEM (ih + j)) {
+      set_entry_sizes (tb, j, new_num, Sh, ih + j);
+      vn->vn_vi[new_num].vi_type |= VI_TYPE_DIRECTORY;
+      if (ih[j].ih_key.k_offset == DOT_OFFSET)
+	vn->vn_vi[new_num].vi_type |= VI_TYPE_FIRST_DIRECTORY_ITEM;
+    }
+    
+    if (new_num != vn->vn_affected_item_num)
+      /* this is not being changed */
+      continue;
+    
+    if (vn->vn_mode == M_PASTE || vn->vn_mode == M_CUT)
+      vn->vn_vi[new_num].vi_item_len += tb->insert_size[0];
+  }
+  
+  
+  /* virtual inserted item is not defined yet */
+  if (vn->vn_mode == M_INSERT) {
+      
+#ifdef REISERFS_CHECK
+    if (vn->vn_ins_ih == 0)
+      reiserfs_panic (0, "vs-8040: create_virtual_node: item header of inserted item is not specified");
+#endif
+
+    vn->vn_vi[vn->vn_affected_item_num].vi_item_len = tb->insert_size[0];
+    
+    switch (vn->vn_ins_ih->ih_key.k_uniqueness) {
+    case TYPE_STAT_DATA:
+      vn->vn_vi[vn->vn_affected_item_num].vi_type |= VI_TYPE_STAT_DATA;
+      break;
+    case TYPE_DIRECT:
+      vn->vn_vi[vn->vn_affected_item_num].vi_type |= VI_TYPE_DIRECT;
+      break;
+    case TYPE_INDIRECT:
+      vn->vn_vi[vn->vn_affected_item_num].vi_type |= VI_TYPE_INDIRECT;
+      break;
+    default:
+      /* inseted item is directory (it must be item with "." and "..") */
+      vn->vn_vi[vn->vn_affected_item_num].vi_type |= 
+	(VI_TYPE_DIRECTORY | VI_TYPE_FIRST_DIRECTORY_ITEM | VI_TYPE_INSERTED_DIRECTORY_ITEM);
+      
+      /* this directory item can not be split, so do not set sizes of entries */
+      break;
+    }
+  }
+  
+  /* set right merge flag we take right delimiting key and check whether it is a mergeable item */
+  if (tb->CFR[0]) {
+    ih = (struct item_head *)B_N_PDELIM_KEY (tb->CFR[0], tb->rkey[0]);
+#ifdef REISERFS_FSCK
+    if (is_right_mergeable (tb->tb_sb, tb->tb_path) == 1 && (vn->vn_mode != M_DELETE ||
+							     vn->vn_affected_item_num != B_NR_ITEMS (Sh) - 1))
+#else
+    if (is_left_mergeable (ih, Sh->b_size) && (vn->vn_mode != M_DELETE ||
+					       vn->vn_affected_item_num != B_NR_ITEMS (Sh) - 1))
+#endif
+      vn->vn_vi[vn->vn_nr_item-1].vi_type |= VI_TYPE_RIGHT_MERGEABLE;
+
+#ifdef REISERFS_CHECK
+    if (is_left_mergeable (ih, Sh->b_size) &&
+	!(vn->vn_mode != M_DELETE || vn->vn_affected_item_num != B_NR_ITEMS (Sh) - 1) ) {
+      /* we delete last item and it could be merged with right neighbor's first item */
+      if (!(B_NR_ITEMS (Sh) == 1 && I_IS_DIRECTORY_ITEM (B_N_PITEM_HEAD (Sh, 0)) &&
+	    I_ENTRY_COUNT (B_N_PITEM_HEAD (Sh, 0)) == 1)) {
+	/* node contains more than 1 item, or item is not directory item, or this item contains more than 1 entry */
+	print_block (Sh, 0, -1, -1);
+	reiserfs_panic (tb->tb_sb, "vs-8045: create_virtual_node: rdkey %k, affected item==%d (mode==%c) Must be %c", 
+			&(ih->ih_key), vn->vn_affected_item_num, vn->vn_mode, M_DELETE);
+      } else
+	/* we can delete directory item, that has only one directory entry in it */
+	;
+    }
+#endif
+    
+  }
+}
+
+
+/* using virtual node check, how many items can be shifted to left
+   neighbor */
+static  int check_left (struct tree_balance * tb, int h, int cur_free)
+{
+  int i;
+  struct virtual_node * vn = tb->tb_vn;
+  int d_size, ih_size, bytes = -1;
+
+#ifdef REISERFS_CHECK
+  if (cur_free < 0)
+    reiserfs_panic (0, "vs-8050: check_left: cur_free (%d) < 0", cur_free);
+#endif
+
+  /* internal level */
+  if (h > 0) {	
+    if (!cur_free ) {
+      tb->lnum[h] = 0; 
+      return 0;
+    }
+    tb->lnum[h] = cur_free / (DC_SIZE + KEY_SIZE);
+    return -1;
+  }
+
+  /* leaf level */
+
+  if (!cur_free || !vn->vn_nr_item) {
+    /* no free space */
+    tb->lnum[h] = 0;
+    tb->lbytes = -1;
+    return 0;
+  }
+
+#ifdef REISERFS_CHECK
+  if (!PATH_H_PPARENT (tb->tb_path, 0))
+    reiserfs_panic (0, "vs-8055: check_left: parent does not exist or invalid");
+#endif
+
+  if ((unsigned int)cur_free >= (vn->vn_size - ((vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE) ? IH_SIZE : 0))) {
+    /* all contents of S[0] fits into L[0] */
+
+#ifdef REISERFS_CHECK
+    if (vn->vn_mode == M_INSERT || vn->vn_mode == M_PASTE)
+      reiserfs_panic (0, "vs-8055: check_left: invalid mode or balance condition failed");
+#endif
+
+    tb->lnum[0] = vn->vn_nr_item;
+    tb->lbytes = -1;
+    return -1;
+  }
+  
+
+  d_size = 0, ih_size = IH_SIZE;
+
+  /* first item may be merge with last item in left neighbor */
+  if (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)
+    d_size = -((int)IH_SIZE), ih_size = 0;
+
+  tb->lnum[0] = 0;
+  for (i = 0; i < vn->vn_nr_item; i ++, ih_size = IH_SIZE, d_size = 0) {
+    d_size += vn->vn_vi[i].vi_item_len;
+    if (cur_free >= d_size) {	
+      /* the item can be shifted entirely */
+      cur_free -= d_size;
+      tb->lnum[0] ++;
+      continue;
+    }
+      
+    /* the item cannot be shifted entirely, try to split it */
+    /* check whether L[0] can hold ih and at least one byte of the item body */
+    if (cur_free <= ih_size) {
+      /* cannot shift even a part of the current item */
+      tb->lbytes = -1;
+      return -1;
+    }
+    cur_free -= ih_size;
+    
+    if (vn->vn_vi[i].vi_type & VI_TYPE_STAT_DATA ||
+	vn->vn_vi[i].vi_type & VI_TYPE_INSERTED_DIRECTORY_ITEM)	{
+      /* virtual item is a stat_data or empty directory body ("." and ".."), that is not split able */
+      tb->lbytes = -1;
+      return -1;
+    }
+    
+    if (vn->vn_vi[i].vi_type & VI_TYPE_DIRECT)
+      /* body of a direct item can be split at any byte */
+      tb->lbytes = bytes = cur_free;
+    
+    if (vn->vn_vi[i].vi_type & VI_TYPE_INDIRECT)
+      /* body of a indirect item can be split at unformatted pointer bound */
+      tb->lbytes = bytes = cur_free - cur_free % UNFM_P_SIZE;
+    
+    /* item is of directory type */     
+    if (vn->vn_vi[i].vi_type & VI_TYPE_DIRECTORY) {
+      /* directory entries are the solid granules of the directory
+	 item, they cannot be split in the middle */
+      
+      /* calculate number of dir entries that can be shifted, and
+	 their total size */
+      int j;
+      struct virtual_item * vi;
+      
+      tb->lbytes = 0;
+      bytes = 0;
+      vi = &vn->vn_vi[i];
+      
+      for (j = 0; j < vi->vi_entry_count; j ++) {
+	if (vi->vi_entry_sizes[j] > cur_free)
+	  /* j-th entry doesn't fit into L[0] */
+	  break;
+		  
+	bytes += vi->vi_entry_sizes[j];
+	cur_free -= vi->vi_entry_sizes[j];
+	tb->lbytes ++;
+      }
+      /* "." can not be cut from first directory item */
+      if ((vn->vn_vi[i].vi_type & VI_TYPE_FIRST_DIRECTORY_ITEM) && tb->lbytes < 2)
+	tb->lbytes = 0;
+    }
+    
+
+    if (tb->lbytes <= 0) {
+      /* nothing can flow from the item */
+      tb->lbytes = -1;
+      return -1;
+    }
+    
+    /* something can flow from the item */
+    tb->lnum[0] ++;
+
+#ifdef REISERFS_CHECK
+    if (bytes == -1)
+      reiserfs_panic (tb->tb_sb, "vs-8060: check_left: bytes is not initialized");
+#endif      
+
+    return bytes;	/* part of split item in bytes */
+  }
+  
+
+  reiserfs_panic (0, "vs: 8065: check_left: all items fit in the left neighbor");
+  return 0;
+}
+	
+
+/* using virtual node check, how many items can be shifted to right
+   neighbor */
+static int check_right (struct tree_balance * tb, int h, int cur_free)
+{
+  int i;
+  struct virtual_node * vn = tb->tb_vn;
+  int d_size, ih_size, bytes = -1;
+
+#ifdef REISERFS_CHECK
+  if (cur_free < 0)
+    reiserfs_panic (tb->tb_sb, "vs-8070: check_right: cur_free < 0");
+#endif
+    
+  /* internal level */
+  if (h > 0) {
+    if (!cur_free) {
+      tb->rnum[h] = 0; 
+      return 0;
+    }
+    tb->rnum[h] = cur_free / (DC_SIZE + KEY_SIZE);
+    return -1;
+  }
+
+  /* leaf level */
+
+  if (!cur_free || !vn->vn_nr_item) {
+    /* no free space  */
+    tb->rnum[h] = 0;
+    tb->rbytes = -1;
+    return 0;
+  }
+  
+#ifdef REISERFS_CHECK
+  if (!PATH_H_PPARENT (tb->tb_path, 0))
+    reiserfs_panic (tb->tb_sb, "vs-8075: check_right: parent does not exist or invalid");
+#endif
+  
+  if ((unsigned int)cur_free >= (vn->vn_size - ((vn->vn_vi[vn->vn_nr_item-1].vi_type & VI_TYPE_RIGHT_MERGEABLE) ? IH_SIZE : 0)))
+    {
+      /* all contents of S[0] fits into R[0] */
+
+#ifdef REISERFS_CHECK
+      if (vn->vn_mode == M_INSERT || vn->vn_mode == M_PASTE)
+	reiserfs_panic (tb->tb_sb, "vs-8080: check_right: invalid mode or balance condition failed");
+#endif
+
+      tb->rnum[h] = vn->vn_nr_item;
+      tb->rbytes = -1;
+      return -1;
+    }
+
+  d_size = 0, ih_size = IH_SIZE;
+
+  /* last item may be merge with first item in right neighbor */
+  if (vn->vn_vi[vn->vn_nr_item - 1].vi_type & VI_TYPE_RIGHT_MERGEABLE)
+    d_size = -(int)IH_SIZE, ih_size = 0;
+
+  tb->rnum[0] = 0;
+  for (i = vn->vn_nr_item - 1; i >= 0; i --, d_size = 0, ih_size = IH_SIZE)
+    {
+      d_size += vn->vn_vi[i].vi_item_len;
+      if (cur_free >= d_size)
+	{	
+	  /* the item can be shifted entirely */
+	  cur_free -= d_size;
+	  tb->rnum[0] ++;
+	  continue;
+	}
+
+      /* the item cannot be shifted entirely, try to split it */
+      if (vn->vn_vi[i].vi_type & VI_TYPE_STAT_DATA || vn->vn_vi[i].vi_type & VI_TYPE_INSERTED_DIRECTORY_ITEM)
+	{
+	  /* virtual item is a stat_data or empty directory body ("." and "..), that is not split able */
+	  tb->rbytes = -1;
+	  return -1;
+	}
+      
+      /* check whether R[0] can hold ih and at least one byte of the item body */
+      if ( cur_free <= ih_size )
+	/* cannot shift even a part of the current item */
+	{
+	  tb->rbytes = -1;
+	  return -1;
+	}
+      
+      /* R[0] can hold the header of the item and at least one byte of its body */
+      cur_free -= ih_size;	/* cur_free is still > 0 */
+
+      /* item is of direct type */
+      if (vn->vn_vi[i].vi_type & VI_TYPE_DIRECT)
+	/* body of a direct item can be split at any byte */
+	tb->rbytes = bytes = cur_free;
+	
+      /* item is of indirect type */
+      if (vn->vn_vi[i].vi_type & VI_TYPE_INDIRECT)
+	/* an unformatted node pointer (having size long) is a solid granule of the item */
+	tb->rbytes = bytes = cur_free - cur_free % UNFM_P_SIZE;
+
+      /* item is of directory type */
+      if (vn->vn_vi[i].vi_type & VI_TYPE_DIRECTORY)
+	{
+	  int j;
+	  struct virtual_item * vi;
+	  
+	  tb->rbytes = 0;
+	  bytes = 0;
+	  vi = &vn->vn_vi[i];
+	  
+	  for (j = vi->vi_entry_count - 1; j >= 0; j --)
+	    {
+	      if (vi->vi_entry_sizes[j] > cur_free)
+		/* j-th entry doesn't fit into L[0] */
+		break;
+	      
+	      bytes += vi->vi_entry_sizes[j];
+	      cur_free -= vi->vi_entry_sizes[j];
+	      tb->rbytes ++;
+	    }
+
+	  /* ".." can not be cut from first directory item */
+	  if ((vn->vn_vi[i].vi_type & VI_TYPE_FIRST_DIRECTORY_ITEM) && tb->rbytes > vi->vi_entry_count - 2) {
+
+#ifdef REISERFS_CHECK
+	    if (tb->rbytes > vi->vi_entry_count - 1) {
+	      reiserfs_panic (tb->tb_sb, "vs-8085: check_right: all entries can be shifted to right neighbor");
+	    }
+#endif
+
+	    tb->rbytes = vi->vi_entry_count - 2;
+	  }
+	}
+	
+	if ( tb->rbytes <= 0 )
+	  {
+	    /* nothing can flow from the item */
+	    tb->rbytes = -1;
+	    return -1;
+	  }
+
+
+	/* something can flow from the item */
+	tb->rnum[0] ++;
+#ifdef REISERFS_CHECK
+	if (bytes == -1)
+	  reiserfs_panic (tb->tb_sb, "vs-8090: check_right: bytes is not initialized");
+#endif      
+	return bytes;	/* part of split item in bytes */
+    }
+
+  reiserfs_panic (tb->tb_sb, "vs-8095: check_right: all items fit in the left neighbor");
+  return 0;
+}
+
+
+/* sum of entry sizes between from-th and to-th entries including both edges */
+static int directory_part_size (struct virtual_item * vi, int from, int to)
+{
+  int i, retval;
+
+  retval = 0;
+  for (i = from; i <= to; i ++)
+    retval += vi->vi_entry_sizes[i];
+
+  return retval;
+}
+
+
+/*
+ * from - number of items, which are shifted to left neighbor entirely
+ * to - number of item, which are shifted to right neighbor entirely
+ * from_bytes - number of bytes of boundary item (or directory entries) which are shifted to left neighbor
+ * to_bytes - number of bytes of boundary item (or directory entries) which are shifted to right neighbor */
+static int get_num_ver (int mode, struct tree_balance * tb, int h,
+			int from, int from_bytes,
+			int to,   int to_bytes,
+			short * snum012, int flow
+			)
+{
+  int i;
+  int bytes;
+  struct virtual_node * vn = tb->tb_vn;
+  struct virtual_item * vi;
+
+  int total_node_size, max_node_size, current_item_size;
+  int needed_nodes;
+  int start_item, 	/* position of item we start filling node from */
+    end_item,	/* position of item we finish filling node by */
+    start_bytes,/* number of first bytes (entries for directory) of start_item-th item 
+		   we do not include into node that is being filled */
+    end_bytes;	/* number of last bytes (entries for directory) of end_item-th item 
+		   we do node include into node that is being filled */
+  int splitted_item_positions[2];	/* these are positions in virtual item of items, 
+					   that are splitted between S[0] and S1new and S1new and S2new */
+
+
+#ifdef REISERFS_CHECK
+  /* We only create additional nodes if we are in insert or paste mode
+     or we are in replace mode at the internal level. If h is 0 and
+     the mode is M_REPLACE then in fix_nodes we change the mode to
+     paste or insert before we get here in the code.  */
+  if ( tb->insert_size[h] < 0  || (mode != M_INSERT && mode != M_PASTE))
+    reiserfs_panic (0, "vs-8100: get_num_ver: insert_size < 0 in overflow");
+#endif
+
+  max_node_size = MAX_CHILD_SIZE (PATH_H_PBUFFER (tb->tb_path, h));
+
+  /* snum012 [0-2] - number of items, that lay
+     to S[0], first new node and second new node */
+  snum012[3] = -1;	/* s1bytes */
+  snum012[4] = -1;	/* s2bytes */
+
+
+  /* internal level */
+  if (h > 0) {
+    i = ((to - from) * (KEY_SIZE + DC_SIZE) + DC_SIZE);
+    if (i == max_node_size)
+      return 1;
+    return (i / max_node_size + 1);
+  }
+
+
+  /* leaf level */
+  needed_nodes = 1;
+  total_node_size = 0;
+
+  start_item = from;
+  start_bytes = from_bytes;
+  end_item = vn->vn_nr_item - to - 1;
+  end_bytes = to_bytes;
+
+  /* go through all item begining from the start_item-th item and ending
+     by the end_item-th item. If start_bytes != -1 we take only tailing part of start_bytes-th
+     item. If end_bytes != -1 we take only head of the end_item-th item. */
+  for (i = start_item; i <= end_item; i ++) {
+
+#ifdef REISERFS_CHECK
+    if (needed_nodes > 3)
+      reiserfs_panic (0, "vs-8105: get_num_ver: too many nodes are needed");
+#endif
+
+    /* get size of current item */
+    current_item_size = (vi = &vn->vn_vi[i])->vi_item_len;
+
+    /* do not take in calculation head part (from_bytes) of from-th item */
+    if (i == start_item && start_bytes != -1) {
+      if (vi->vi_type & VI_TYPE_DIRECTORY)
+	current_item_size -= directory_part_size (vi, 0, start_bytes - 1);
+      else
+	current_item_size -= start_bytes;
+    }
+      
+    /* do not take in calculation tail part of (to-1)-th item */
+    if (i == end_item && end_bytes != -1) {
+      if (vi->vi_type & VI_TYPE_DIRECTORY)
+	/* first entry, that is not included */
+	current_item_size -= directory_part_size (vi, vi->vi_entry_count - end_bytes, vi->vi_entry_count - 1);
+      else
+	current_item_size -= end_bytes;
+    }
+
+    /* if item fits into current node entierly */
+    if (total_node_size + current_item_size <= max_node_size) {
+      snum012[needed_nodes - 1] ++;
+      total_node_size += current_item_size;
+      continue;
+    }
+
+    if (current_item_size > max_node_size) {
+      /* virtual item length is longer, than max size of item in a node. It is impossible for direct item */
+#ifdef REISERFS_CHECK
+      if (vi->vi_type & VI_TYPE_DIRECT)
+	reiserfs_panic (0, "vs-8110: get_num_ver: direct item length is %d. It can not be longer than %d", 
+			current_item_size, max_node_size);
+#endif
+      /* we will try to split it */
+      flow = 1;
+    }
+
+    if (!flow) {
+      /* as we do not split items, take new node and continue */
+      needed_nodes ++; i --; total_node_size = 0;
+      continue;
+    }
+
+    if (total_node_size + (int)IH_SIZE >= max_node_size) {
+      /* even minimal item does not fit into current node, take new node and continue */
+      needed_nodes ++, i--, total_node_size = 0;
+      continue;
+    }
+    if (vi->vi_type & VI_TYPE_STAT_DATA) {
+
+      /* stat data can not be split */
+      needed_nodes ++, i--, total_node_size = 0;
+      continue;
+    }
+
+    /* body of a direct item can be split at any byte */
+    /* bytes is free space in filled node */
+    bytes = max_node_size - total_node_size - IH_SIZE;
+
+    /* item is of indirect type */
+    if (vi->vi_type & VI_TYPE_INDIRECT)
+      /* an unformatted node pointer (having size long) is a solid granule of the item */
+      /* bytes of unformatted node pointers fits into free space of filled node */
+      bytes -= (bytes) % UNFM_P_SIZE;
+
+    /* S1bytes or S2bytes. It depends from needed_nodes */
+    snum012[needed_nodes - 1 + 3] = bytes;
+
+    /* item is of directory type */
+    if (vi->vi_type & VI_TYPE_DIRECTORY) {
+      /* calculate, how many entries can be put into current node */
+      int j;
+      int end_entry;
+
+      snum012[needed_nodes - 1 + 3] = 0;
+
+      total_node_size += IH_SIZE;
+      if (start_bytes == -1 || i != start_item)
+	start_bytes = 0;
+
+      end_entry = vi->vi_entry_count - ((i == end_item && end_bytes != -1) ? end_bytes : 0);
+      for (j = start_bytes; j < end_entry; j ++) {
+	/* j-th entry doesn't fit into current node */
+	if (total_node_size + vi->vi_entry_sizes[j] > max_node_size)
+	  break;
+	snum012[needed_nodes - 1 + 3] ++;
+	bytes += vi->vi_entry_sizes[j];
+	total_node_size += vi->vi_entry_sizes[j];
+      }
+      /* "." can not be cut from first directory item */
+      if (start_bytes == 0 && (vn->vn_vi[i].vi_type & VI_TYPE_FIRST_DIRECTORY_ITEM) && 
+	  snum012[needed_nodes - 1 + 3] < 2)
+	snum012[needed_nodes - 1 + 3] = 0;
+
+
+#ifdef REISERFS_CHECK
+      if (vi->vi_entry_count && 
+	  vi->vi_entry_count - ((i == end_item && end_bytes != -1) ? end_bytes : 0)
+	  - (start_bytes) <= snum012[needed_nodes - 1 + 3])
+	reiserfs_panic (0, "vs-8115: get_num_ver: required part of directory fits into current node");
+#endif
+    }
+
+    if (snum012[needed_nodes-1+3] <= 0 ) {
+      /* nothing fits into current node, take new node and continue */
+      needed_nodes ++, i--, total_node_size = 0;
+      continue;
+    }
+
+    /* something fits into the current node */
+    if (vi->vi_type & VI_TYPE_DIRECTORY)
+      start_bytes += snum012[needed_nodes - 1 + 3];
+    else
+      start_bytes = bytes;
+
+    snum012[needed_nodes - 1] ++;
+    splitted_item_positions[needed_nodes - 1] = i;
+
+    needed_nodes ++;
+    /* continue from the same item with start_bytes != -1 */
+    start_item = i;
+    i --;
+    total_node_size = 0;
+  }
+
+
+  /* snum012[3] and snum012[4] contain how many bytes (entries) of
+     split item can be in S[0] and S1new. s1bytes and s2bytes are how
+     many bytes (entries) can be in S1new and S2new. Recalculate it */
+  
+  if (snum012[4] > 0) {	/* s2bytes */
+    /* get number of item that is splitted between S1new and S2new */
+    int splitted_item_num;
+    int bytes_to_r;
+
+    splitted_item_num = splitted_item_positions[1];
+    bytes_to_r = ((end_item == splitted_item_num && end_bytes != -1) ? end_bytes : 0);
+    if (vn->vn_vi[splitted_item_num].vi_type & VI_TYPE_DIRECTORY) {
+      int entries_to_S2new;
+
+      /* calculate number of entries fitted into S2new */
+      entries_to_S2new =  vn->vn_vi[splitted_item_num].vi_entry_count - snum012[4] - bytes_to_r;
+      if (snum012[3] != -1 && snum012[1] == 1) {
+	/* directory splitted into 3 nodes */
+	int entries_to_S1new;
+
+	entries_to_S2new -= snum012[3];
+	entries_to_S1new = snum012[4];
+	snum012[3] = entries_to_S1new;
+	snum012[4] = entries_to_S2new;
+	return needed_nodes;
+      }
+      snum012[4] = entries_to_S2new;
+    } else {
+      /* item is not of directory type */
+      int bytes_to_S2new;
+
+      bytes_to_S2new = vn->vn_vi[splitted_item_num].vi_item_len - IH_SIZE - snum012[4] - bytes_to_r;
+      snum012[4] = bytes_to_S2new;
+    }
+  }
+
+  /* now we know S2bytes, calculate S1bytes */
+  if (snum012[3] > 0) {	/* s1bytes */
+    /* get number of item that is splitted between S0 and S1new */
+    int splitted_item_num;
+    int bytes_to_r;
+
+    splitted_item_num = splitted_item_positions[0];
+    bytes_to_r = ((end_item == splitted_item_num && end_bytes != -1) ? end_bytes : 0);
+    if (vn->vn_vi[splitted_item_num].vi_type & VI_TYPE_DIRECTORY) {
+      /* entries, who go to S1new node */
+      snum012[3] =  vn->vn_vi[splitted_item_num].vi_entry_count - snum012[3] - bytes_to_r;
+    } else
+      /* bytes, who go to S1new node (not including HI_SIZE) */
+      snum012[3] = vn->vn_vi[splitted_item_num].vi_item_len - IH_SIZE - snum012[3] - bytes_to_r;
+  }
+
+  return needed_nodes;
+}
+
+
+#ifdef REISERFS_CHECK
+extern struct tree_balance * cur_tb;
+#endif
+
+
+/* size of item_num-th item in bytes when regular and in entries when
+   item is directory */
+static int item_length (struct tree_balance * tb, int item_num)
+{
+  struct virtual_node * vn = tb->tb_vn;
+
+#ifdef REISERFS_CHECK
+  if (item_num >= vn->vn_nr_item)
+    reiserfs_panic (tb->tb_sb, "vs-8120: item_length: invalid index of item: index = %d (item number = %d)", item_num, vn->vn_nr_item);
+#endif
+
+  if (vn->vn_vi[item_num].vi_type & VI_TYPE_DIRECTORY)
+    return vn->vn_vi[item_num].vi_entry_count;
+
+  return vn->vn_vi[item_num].vi_item_len - IH_SIZE;
+}
+
+
+/* Set parameters for balancing.
+ * Performs write of results of analysis of balancing into structure tb,
+ * where it will later be used by the functions that actually do the balancing. 
+ * Parameters:
+ *	tb	tree_balance structure;
+ *	h	current level of the node;
+ *	lnum	number of items from S[h] that must be shifted to L[h];
+ *	rnum	number of items from S[h] that must be shifted to R[h];
+ *	blk_num	number of blocks that S[h] will be splitted into;
+ *	s012	number of items that fall into splitted nodes.
+ *	lbytes	number of bytes which flow to the left neighbor from the item that is not
+ *		not shifted entirely
+ *	rbytes	number of bytes which flow to the right neighbor from the item that is not
+ *		not shifted entirely
+ *	s1bytes	number of bytes which flow to the first  new node when S[0] splits (this number is contained in s012 array)
+ */
+
+static void set_parameters (struct tree_balance * tb, int h, int lnum,
+			    int rnum, int blk_num, short * s012, int lb, int rb)
+{
+
+  tb->lnum[h] = lnum;
+  tb->rnum[h] = rnum;
+  tb->blknum[h] = blk_num;
+
+  if (h == 0)
+    {  /* only for leaf level */
+      if (s012 != NULL)
+	{
+	  tb->s0num = * s012 ++,
+	  tb->s1num = * s012 ++,
+	  tb->s2num = * s012 ++;
+	  tb->s1bytes = * s012 ++;
+	  tb->s2bytes = * s012;
+	}
+      tb->lbytes = lb;
+      tb->rbytes = rb;
+    }
+}
+
+static void decrement_key(
+			  struct key * p_s_key
+			  ) {
+  unsigned long * p_n_key_field = (unsigned long *)p_s_key + REISERFS_FULL_KEY_LEN - 1;
+  int		  n_counter;
+
+  for( n_counter = 0; n_counter < REISERFS_FULL_KEY_LEN; n_counter++, p_n_key_field-- )
+    if ( *p_n_key_field ) {
+      (*p_n_key_field)--;
+      break;
+    }
+
+#ifdef REISERFS_CHECK
+  if ( n_counter == REISERFS_FULL_KEY_LEN )
+    reiserfs_panic(NULL, "PAP-8175: decrement_key: zero key");
+#endif
+
+}
+
+
+#ifndef REISERFS_FSCK
+
+inline int is_left_mergeable (struct item_head * ih, unsigned long bsize)
+{
+  if (I_IS_DIRECT_ITEM (ih))
+    return (ih->ih_key.k_offset % bsize != 1);
+
+  if (I_IS_INDIRECT_ITEM (ih))
+    return (ih->ih_key.k_offset != 1);
+
+  if (I_IS_DIRECTORY_ITEM (ih))
+   return ((ih)->ih_key.k_offset != DOT_OFFSET);
+
+#ifdef REISERFS_CHECK
+  if ( ! I_IS_STAT_DATA_ITEM (ih))
+    reiserfs_panic (0, "vs-16060: is_left_mergeable: item [%h] must be a stat data", ih);
+#endif
+
+  return 0;
+}
+
+#else
+
+int are_items_mergeable (struct item_head * left, struct item_head * right, int bsize)
+{
+  if (comp_keys (&left->ih_key, &right->ih_key) != -1) {
+    reiserfs_panic (0, "vs-16070: are_items_mergeable: left %k, right %k", &(left->ih_key), &(right->ih_key));
+  }
+
+  if (comp_short_keys (&left->ih_key, &right->ih_key))
+    return 0;
+
+  if (I_IS_DIRECTORY_ITEM (left)) {
+    return 1;
+  }
+
+  if ((I_IS_DIRECT_ITEM (left) && I_IS_DIRECT_ITEM (right)) || 
+      (I_IS_INDIRECT_ITEM (left) && I_IS_INDIRECT_ITEM (right)))
+    return (left->ih_key.k_offset + I_BYTES_NUMBER (left, bsize) == right->ih_key.k_offset) ? 1 : 0;
+
+  return 0;
+}
+
+/* get left neighbor of the leaf node */
+static struct buffer_head * get_left_neighbor (struct super_block * s, struct path * path)
+{
+  struct key key;
+  struct path path_to_left_neighbor;
+  struct buffer_head * bh;
+  int repeat;
+
+  copy_key (&key, B_N_PKEY (PATH_PLAST_BUFFER (path), 0));
+  decrement_key (&key);
+
+  init_path (&path_to_left_neighbor);
+  search_by_key (s, &key, &path_to_left_neighbor, &repeat, DISK_LEAF_NODE_LEVEL, READ_BLOCKS);
+  if (PATH_LAST_POSITION (&path_to_left_neighbor) == 0) {
+    pathrelse (&path_to_left_neighbor);
+    return 0;
+  }
+  bh = PATH_PLAST_BUFFER (&path_to_left_neighbor);
+  bh->b_count ++;
+  pathrelse (&path_to_left_neighbor);
+  return bh;
+}
+
+extern struct key  MIN_KEY;
+static struct buffer_head * get_right_neighbor (struct super_block * s, struct path * path)
+{
+  struct key key;
+  struct key * rkey;
+  int repeat;
+  struct path path_to_right_neighbor;
+  struct buffer_head * bh;
+
+  rkey = get_rkey (path, s);
+  if (comp_keys (rkey, &MIN_KEY) == 0)
+    reiserfs_panic (s, "vs-16080: get_right_neighbor: get_rkey returned min key (path has changed)");
+  copy_key (&key, rkey);
+
+  
+  init_path (&path_to_right_neighbor);
+  search_by_key (s, &key, &path_to_right_neighbor, &repeat, DISK_LEAF_NODE_LEVEL, READ_BLOCKS);
+  if (PATH_PLAST_BUFFER (&path_to_right_neighbor) == PATH_PLAST_BUFFER (path)) {
+    pathrelse (&path_to_right_neighbor);
+    return 0;
+  }
+  bh = PATH_PLAST_BUFFER (&path_to_right_neighbor);
+  bh->b_count ++;
+  pathrelse (&path_to_right_neighbor);
+  return bh;
+}
+
+
+int is_left_mergeable (struct super_block * s, struct path * path)
+{
+  struct item_head * right;
+  struct buffer_head * bh;
+  int retval;
+  
+  right = B_N_PITEM_HEAD (PATH_PLAST_BUFFER (path), 0);
+
+  bh = get_left_neighbor (s, path);
+  if (bh == 0) {
+    return 0;
+  }
+  retval = are_items_mergeable (B_N_PITEM_HEAD (bh, B_NR_ITEMS (bh) - 1), right, bh->b_size);
+  brelse (bh);
+  return retval;
+}
+
+
+int is_right_mergeable (struct super_block * s, struct path * path)
+{
+  struct item_head * left;
+  struct buffer_head * bh;
+  int retval;
+  
+  left = B_N_PITEM_HEAD (PATH_PLAST_BUFFER (path), B_NR_ITEMS (PATH_PLAST_BUFFER (path)) - 1);
+
+  bh = get_right_neighbor (s, path);
+  if (bh == 0) {
+    return 0;
+  }
+  retval = are_items_mergeable (left, B_N_PITEM_HEAD (bh, 0), bh->b_size);
+  brelse (bh);
+  return retval;
+}
+
+#endif /* REISERFS_FSCK */
+
+
+
+/* check, does node disappear if we shift tb->lnum[0] items to left
+   neighbor and tb->rnum[0] to the right one. */
+static int is_leaf_removable (struct tree_balance * tb)
+{
+  struct virtual_node * vn = tb->tb_vn;
+  int to_left, to_right;
+  int size;
+  int remain_items;
+
+  /* number of items, that will be shifted to left (right) neighbor
+     entirely */
+  to_left = tb->lnum[0] - ((tb->lbytes != -1) ? 1 : 0);
+  to_right = tb->rnum[0] - ((tb->rbytes != -1) ? 1 : 0);
+  remain_items = vn->vn_nr_item;
+
+  /* how many items remain in S[0] after shiftings to neighbors */
+  remain_items -= (to_left + to_right);
+
+  if (remain_items < 1) {
+    /* all content of node can be shifted to neighbors */
+    set_parameters (tb, 0, to_left, vn->vn_nr_item - to_left, 0, NULL, -1, -1);    
+    return 1;
+  }
+  
+  if (remain_items > 1 || tb->lbytes == -1 || tb->rbytes == -1)
+    /* S[0] is not removable */
+    return 0;
+
+  /* check, whether we can divide 1 remaining item between neighbors */
+
+  /* get size of remaining item (in directory entry count if directory) */
+  size = item_length (tb, to_left);
+
+  if (tb->lbytes + tb->rbytes >= size) {
+    set_parameters (tb, 0, to_left + 1, to_right + 1, 0, NULL, tb->lbytes, -1);
+    return 1;
+  }
+
+  return 0;
+}
+
+
+/* check whether L, S, R can be joined in one node */
+static int are_leaves_removable (struct tree_balance * tb, int lfree, int rfree)
+{
+    struct virtual_node * vn = tb->tb_vn;
+    int ih_size;
+    struct buffer_head *S0;
+
+    S0 = PATH_H_PBUFFER (tb->tb_path, 0);
+
+    ih_size = 0;
+    if (vn->vn_nr_item) {
+	if (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)
+	    ih_size += IH_SIZE;
+    
+	if (vn->vn_vi[vn->vn_nr_item-1].vi_type & VI_TYPE_RIGHT_MERGEABLE)
+	    ih_size += IH_SIZE;
+    } else {
+	/* there was only one item and it will be deleted */
+	struct item_head * ih;
+    
+#ifdef REISERFS_CHECK
+	if (B_NR_ITEMS (S0) != 1)
+	    reiserfs_panic (0, "vs-8125: are_leaves_removable: item number must be 1: it is %d", B_NR_ITEMS(S0));
+#endif
+
+	ih = B_N_PITEM_HEAD (S0, 0);
+	if (tb->CFR[0] && !COMP_SHORT_KEYS (&(ih->ih_key), B_N_PDELIM_KEY (tb->CFR[0], tb->rkey[0])))
+	    if (I_IS_DIRECTORY_ITEM(ih)) {
+#ifndef REISERFS_FSCK
+	
+		/* Directory must be in correct state here: that is
+		   somewhere at the left side should exist first
+		   directory item. But the item being deleted can not
+		   be that first one because its right neighbor is
+		   item of the same directory. (But first item always
+		   gets deleted in last turn). So, neighbors of
+		   deleted item can be merged, so we can save ih_size */
+		ih_size = IH_SIZE;
+
+#ifdef REISERFS_CHECK
+		/* we might check that left neighbor exists and is of
+                   the same directory */
+		if (ih->ih_key.k_offset == DOT_OFFSET)
+		    reiserfs_panic (tb->tb_sb, "vs-8130: are_leaves_removable: "
+				    "first directory item can not be removed until directory is not empty");
+#endif
+	
+	
+#else	/* REISERFS_FSCK */
+
+		/* we can delete any directory item in fsck (if it is unreachable) */
+		if (ih->ih_key.k_offset != DOT_OFFSET) {
+		    /* must get left neighbor here to make sure, that
+                       left neighbor is of the same directory */
+		    struct buffer_head * left;
+		    
+		    left = get_left_neighbor (tb->tb_sb, tb->tb_path);
+		    if (left) {
+			struct item_head * last;
+
+			if (B_NR_ITEMS (left) == 0)
+			    reiserfs_panic (tb->tb_sb, "vs-8135: are_leaves_removable: "
+					    "empty node in the tree");
+			last = B_N_PITEM_HEAD (left, B_NR_ITEMS (left) - 1);
+			if (!comp_short_keys (&last->ih_key, &ih->ih_key))
+			    ih_size = IH_SIZE;
+			brelse (left);
+		    }
+		}
+#endif
+	    }
+    
+    }
+
+    if (MAX_CHILD_SIZE (S0) + vn->vn_size <= rfree + lfree + ih_size) {
+	set_parameters (tb, 0, -1, -1, -1, NULL, -1, -1);
+	return 1;  
+    }
+    return 0;
+  
+}
+
+
+
+/* when we do not split item, lnum and rnum are numbers of entire items */
+#define SET_PAR_SHIFT_LEFT \
+if (h)\
+{\
+   int to_l;\
+   \
+   to_l = (MAX_NR_KEY(Sh)+1 - lpar + vn->vn_nr_item + 1) / 2 -\
+	      (MAX_NR_KEY(Sh) + 1 - lpar);\
+	      \
+	      set_parameters (tb, h, to_l, 0, lnver, NULL, -1, -1);\
+}\
+else \
+{\
+   if (lset==LEFT_SHIFT_FLOW)\
+     set_parameters (tb, h, lpar, 0, lnver, snum012+lset,\
+		     tb->lbytes, -1);\
+   else\
+     set_parameters (tb, h, lpar - (tb->lbytes!=-1), 0, lnver, snum012+lset,\
+		     -1, -1);\
+}
+
+
+#define SET_PAR_SHIFT_RIGHT \
+if (h)\
+{\
+   int to_r;\
+   \
+   to_r = (MAX_NR_KEY(Sh)+1 - rpar + vn->vn_nr_item + 1) / 2 - (MAX_NR_KEY(Sh) + 1 - rpar);\
+   \
+   set_parameters (tb, h, 0, to_r, rnver, NULL, -1, -1);\
+}\
+else \
+{\
+   if (rset==RIGHT_SHIFT_FLOW)\
+     set_parameters (tb, h, 0, rpar, rnver, snum012+rset,\
+		  -1, tb->rbytes);\
+   else\
+     set_parameters (tb, h, 0, rpar - (tb->rbytes!=-1), rnver, snum012+rset,\
+		  -1, -1);\
+}
+
+
+void free_buffers_in_tb (
+		       struct tree_balance * p_s_tb
+		       ) {
+  int n_counter;
+
+  decrement_counters_in_path(p_s_tb->tb_path);
+  
+  for ( n_counter = 0; n_counter < MAX_HEIGHT; n_counter++ ) {
+    decrement_bcount(p_s_tb->L[n_counter]);
+    p_s_tb->L[n_counter] = NULL;
+    decrement_bcount(p_s_tb->R[n_counter]);
+    p_s_tb->R[n_counter] = NULL;
+    decrement_bcount(p_s_tb->FL[n_counter]);
+    p_s_tb->FL[n_counter] = NULL;
+    decrement_bcount(p_s_tb->FR[n_counter]);
+    p_s_tb->FR[n_counter] = NULL;
+    decrement_bcount(p_s_tb->CFL[n_counter]);
+    p_s_tb->CFL[n_counter] = NULL;
+    decrement_bcount(p_s_tb->CFR[n_counter]);
+    p_s_tb->CFR[n_counter] = NULL;
+  }
+}
+
+
+/* Get new buffers for storing new nodes that are created while balancing.
+ * Returns:	SCHEDULE_OCCURED - schedule occured while the function worked;
+ *	        CARRY_ON - schedule didn't occur while the function worked;
+ *	        NO_DISK_SPACE - no disk space.
+ */
+static int  get_empty_nodes(
+	      struct reiserfs_transaction_handle *th,
+              struct tree_balance * p_s_tb,
+              int n_h
+            ) {
+  struct buffer_head  * p_s_new_bh,
+    		      *	p_s_Sh = PATH_H_PBUFFER (p_s_tb->tb_path, n_h);
+  unsigned long	      *	p_n_blocknr,
+    			a_n_blocknrs[MAX_AMOUNT_NEEDED] = {0, };
+  int       		n_counter,
+   			n_number_of_freeblk,
+                	n_amount_needed,/* number of needed empty blocks */
+   			n_repeat1,
+			n_repeat;
+  struct super_block *	p_s_sb = p_s_tb->tb_sb;
+
+
+#ifdef REISERFS_FSCK
+   if (n_h == 0 && p_s_tb->insert_size[n_h] == 0x7fff)
+     return CARRY_ON;
+#endif
+
+  /* number_of_freeblk is the number of empty blocks which have been
+     acquired for use by the balancing algorithm minus the number of
+     empty blocks used in the previous levels of the analysis,
+     number_of_freeblk = tb->cur_blknum can be non-zero if a schedule occurs
+     after empty blocks are acquired, and the balancing analysis is
+     then restarted, amount_needed is the number needed by this level
+     (n_h) of the balancing analysis.
+			    
+     Note that for systems with many processes writing, it would be
+     more layout optimal to calculate the total number needed by all
+     levels and then to run reiserfs_new_blocks to get all of them at once.  */
+
+  /* Initiate number_of_freeblk to the amount acquired prior to the restart of
+     the analysis or 0 if not restarted, then subtract the amount needed
+     by all of the levels of the tree below n_h. */
+  /* blknum includes S[n_h], so we subtract 1 in this calculation */
+  for ( n_counter = 0, n_number_of_freeblk = p_s_tb->cur_blknum; n_counter < n_h; n_counter++ )
+    n_number_of_freeblk -= ( p_s_tb->blknum[n_counter] ) ? (p_s_tb->blknum[n_counter] - 1) : 0;
+
+  /* Allocate missing empty blocks. */
+  /* if p_s_Sh == 0  then we are getting a new root */
+  n_amount_needed = ( p_s_Sh ) ? (p_s_tb->blknum[n_h] - 1) : 1;
+  /*  Amount_needed = the amount that we need more than the amount that we have. */
+  if ( n_amount_needed > n_number_of_freeblk )
+    n_amount_needed -= n_number_of_freeblk;
+  else /* If we have enough already then there is nothing to do. */
+    return CARRY_ON;
+
+  if ( (n_repeat = reiserfs_new_blocknrs (th, p_s_tb->tb_sb, a_n_blocknrs,
+					  PATH_PLAST_BUFFER(p_s_tb->tb_path)->b_blocknr, n_amount_needed, 0/*not for preserve list*/)) != CARRY_ON ) {
+    return n_repeat; /* Out of disk space or schedule() occured. */ 
+  }
+
+
+  /* for each blocknumber we just got, get a buffer and stick it on FEB */
+  for ( p_n_blocknr = a_n_blocknrs, n_counter = 0; n_counter < n_amount_needed;
+	p_n_blocknr++, n_counter++ ) { 
+
+#ifdef REISERFS_CHECK
+    if ( ! *p_n_blocknr )
+      reiserfs_panic(p_s_sb, "PAP-8135: get_empty_nodes: reiserfs_new_blocknrs failed when got new blocks");
+#endif
+
+    n_repeat1 = CARRY_ON;
+    p_s_new_bh = reiserfs_getblk(p_s_sb->s_dev, *p_n_blocknr, p_s_sb->s_blocksize, &n_repeat1);
+    n_repeat |= n_repeat1;
+    if (p_s_new_bh->b_count > 1) {
+      n_repeat |= SCHEDULE_OCCURRED;
+      free_buffers_in_tb (p_s_tb);
+      wait_buffer_until_released (p_s_new_bh);
+    }
+#ifdef REISERFS_CHECK_NOCHECK
+    if ((p_s_new_bh->b_count != 1 && !buffer_journaled(p_s_new_bh)) 
+         || (buffer_dirty (p_s_new_bh) && !buffer_journal_dirty(p_s_new_bh))) {
+      reiserfs_panic(p_s_sb,"PAP-8140: get_empty_nodes: not free or dirty buffer %b for the new block",
+		     p_s_new_bh);
+    }
+#endif
+    mark_buffer_journal_new(p_s_new_bh) ;
+    
+    /* Put empty buffers into the array. */
+    p_s_tb->FEB[p_s_tb->cur_blknum++] = p_s_new_bh;
+
+    /* in the reiserfs_new_blocknrs we have atomically dirtied bitmap
+       block of true bitmap, containing bit, that corresponds to
+       p_s_new_bh->b_blocknr. Tree balance contains 1 bit per each
+       bitmap block. Set there bit corresponding to dirtied bitmap */
+    set_bit (*p_n_blocknr / (p_s_new_bh->b_size * 8), DIRTY_BITMAP_MAP (p_s_tb));
+  }
+
+  return n_repeat;
+}
+
+
+/* Get free space of the left neighbor,
+ * which is stored in the parent node of the left neighbor.
+ */
+static int get_lfree (struct tree_balance * tb, int h)
+{
+  struct buffer_head * l, * f;
+  int order;
+
+  if ((f = PATH_H_PPARENT (tb->tb_path, h)) == 0 || (l = tb->FL[h]) == 0)
+    return 0;
+
+  if (f == l)
+    order = PATH_H_B_ITEM_ORDER (tb->tb_path, h) - 1;
+  else {
+      order = B_BLK_HEAD(l)->blk_nr_item;
+      f = l;
+  }
+
+  return (MAX_CHILD_SIZE(f) - B_N_CHILD(f,order)->dc_size);
+}
+
+
+/* Get free space of the right neighbor,
+ * which is stored in the parent node of the right neighbor.
+ */
+static int get_rfree (struct tree_balance * tb, int h)
+{
+  struct buffer_head * r, * f;
+  int order;
+
+  if ((f = PATH_H_PPARENT (tb->tb_path, h)) == 0 || (r = tb->FR[h]) == 0)
+    return 0;
+
+  if (f == r)
+      order = PATH_H_B_ITEM_ORDER (tb->tb_path, h) + 1;
+  else {
+      order = 0;
+      f = r;
+  }
+
+  return (MAX_CHILD_SIZE(f) - B_N_CHILD(f,order)->dc_size);
+
+}
+
+
+/* Check whether left neighbor is in memory. */
+static int  is_left_neighbor_in_cache(
+              struct tree_balance * p_s_tb,
+              int                   n_h
+            ) {
+  struct buffer_head  * p_s_father;
+  struct super_block  * p_s_sb = p_s_tb->tb_sb;
+  unsigned long         n_left_neighbor_blocknr;
+  int                   n_left_neighbor_position;
+
+  if ( ! p_s_tb->FL[n_h] ) /* Father of the left neighbor does not exist. */
+    return 0;
+
+  /* Calculate father of the node to be balanced. */
+  p_s_father = PATH_H_PBUFFER(p_s_tb->tb_path, n_h + 1);
+
+#ifdef REISERFS_CHECK
+  if ( ! p_s_father || ! B_IS_IN_TREE (p_s_father) || ! B_IS_IN_TREE (p_s_tb->FL[n_h]) ||
+       ! buffer_uptodate (p_s_father) || ! buffer_uptodate (p_s_tb->FL[n_h]) ) {
+    reiserfs_panic (p_s_sb, "vs-8165: is_left_neighbor_in_cache: F[h] (%b) or FL[h] (%b) is invalid",
+		    p_s_father, p_s_tb->FL[n_h]);
+  }
+#endif
+
+
+  /* Get position of the pointer to the left neighbor into the left father. */
+  n_left_neighbor_position = ( p_s_father == p_s_tb->FL[n_h] ) ?
+                      p_s_tb->lkey[n_h] : B_BLK_HEAD(p_s_tb->FL[n_h])->blk_nr_item;
+  /* Get left neighbor block number. */
+  n_left_neighbor_blocknr = B_N_CHILD_NUM(p_s_tb->FL[n_h], n_left_neighbor_position);
+  /* Look for the left neighbor in the cache. */
+  if ( (p_s_father = find_buffer(p_s_sb->s_dev, n_left_neighbor_blocknr, p_s_sb->s_blocksize)) ) {
+
+#ifdef REISERFS_CHECK
+    if ( buffer_uptodate (p_s_father) && ! B_IS_IN_TREE(p_s_father) ) {
+      reiserfs_panic(p_s_sb, "vs-8170: is_left_neighbor_in_cache: left neighbor (%b %z) is not in the tree",
+		     p_s_father, p_s_father);
+    }
+#endif
+
+    return 1;
+  }
+
+  return 0;
+}
+
+
+#define LEFT_PARENTS  'l'
+#define RIGHT_PARENTS 'r'
+
+
+
+
+void init_path (struct path * path)
+{
+  path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;
+}
+
+
+/* Calculate far left/right parent of the left/right neighbor of the current node, that
+ * is calculate the left/right (FL[h]/FR[h]) neighbor of the parent F[h].
+ * Calculate left/right common parent of the current node and L[h]/R[h].
+ * Calculate left/right delimiting key position.
+ * Returns:	PATH_INCORRECT   - path in the tree is not correct;
+ 		SCHEDULE_OCCURRED - schedule occured while the function worked;
+ *	        CARRY_ON         - schedule didn't occur while the function worked;
+ */
+static int  get_far_parent(
+              struct tree_balance *   p_s_tb,
+              int                     n_h,
+              struct buffer_head  **  pp_s_father,
+              struct buffer_head  **  pp_s_com_father,
+              char                    c_lr_par
+            ) {
+  struct buffer_head  * p_s_parent;
+  struct path         	s_path_to_neighbor_father,
+    		      * p_s_path = p_s_tb->tb_path;
+  struct key		s_lr_father_key;
+  int                   n_counter,
+                        n_position = MAX_INT,
+    			n_repeat,
+                        n_first_last_position = 0,
+                        n_path_offset = PATH_H_PATH_OFFSET(p_s_path, n_h);
+
+  /* Starting from F[n_h] go upwards in the tree, and look for the common
+      ancestor of F[n_h], and its neighbor l/r, that should be obtained. */
+
+  n_counter = n_path_offset;
+
+#ifdef REISERFS_CHECK
+  if ( n_counter < FIRST_PATH_ELEMENT_OFFSET )
+    reiserfs_panic(p_s_tb->tb_sb, "PAP-8180: get_far_parent: invalid path length");
+#endif
+
+  
+  for ( ; n_counter > FIRST_PATH_ELEMENT_OFFSET; n_counter--  )  {
+    /* Check whether parent of the current buffer in the path is really parent in the tree. */
+    if ( ! B_IS_IN_TREE(p_s_parent = PATH_OFFSET_PBUFFER(p_s_path, n_counter - 1)) )
+      return PATH_INCORRECT;
+    /* Check whether position in the parent is correct. */
+    if ( (n_position = PATH_OFFSET_POSITION(p_s_path, n_counter - 1)) > B_NR_ITEMS(p_s_parent) )
+      return PATH_INCORRECT;
+    /* Check whether parent at the path really points to the child. */
+    if ( B_N_CHILD_NUM(p_s_parent, n_position) !=
+                                          PATH_OFFSET_PBUFFER(p_s_path, n_counter)->b_blocknr )
+      return PATH_INCORRECT;
+    /* Return delimiting key if position in the parent is not equal to first/last one. */
+    if ( c_lr_par == RIGHT_PARENTS )
+      n_first_last_position = B_BLK_HEAD(p_s_parent)->blk_nr_item;
+    if ( n_position != n_first_last_position ) {
+      (*pp_s_com_father = p_s_parent)->b_count++;
+      break;
+    }
+  }
+
+  /* Hopefully we are in the root of the tree. */
+  if ( n_counter == FIRST_PATH_ELEMENT_OFFSET ) {
+    /* Check whether first buffer in the path is the root of the tree. */
+    if ( PATH_OFFSET_PBUFFER(p_s_tb->tb_path, FIRST_PATH_ELEMENT_OFFSET)->b_blocknr ==
+                                            p_s_tb->tb_sb->u.reiserfs_sb.s_rs->s_root_block ) {
+      *pp_s_father = *pp_s_com_father = NULL;
+      return CARRY_ON;
+    }
+    return PATH_INCORRECT;
+  }
+
+#ifdef REISERFS_CHECK
+  if ( B_BLK_HEAD(*pp_s_com_father)->blk_level <= DISK_LEAF_NODE_LEVEL ) {
+    reiserfs_panic(p_s_tb->tb_sb, "PAP-8185: get_far_parent: (%b %z) level too small", *pp_s_com_father, *pp_s_com_father);
+  }
+#endif
+
+  /* Check whether the common parent is locked. */
+  if ( test_and_wait_on_buffer(*pp_s_com_father) == SCHEDULE_OCCURRED ) {
+    decrement_bcount(*pp_s_com_father);
+    return SCHEDULE_OCCURRED; /* schedule() occured */
+  }
+
+  /* So, we got common parent of the current node and its left/right neighbor.
+     Now we are geting the parent of the left/right neighbor. */
+
+  /* Form key to get parent of the left/right neighbor. */
+  copy_key(&s_lr_father_key, B_N_PDELIM_KEY(*pp_s_com_father, ( c_lr_par == LEFT_PARENTS ) ?
+     (p_s_tb->lkey[n_h - 1] = n_position - 1) : (p_s_tb->rkey[n_h - 1] = n_position)));
+
+  if ( c_lr_par == LEFT_PARENTS )
+    decrement_key(&s_lr_father_key);
+
+  init_path (&s_path_to_neighbor_father);
+
+  search_by_key(p_s_tb->tb_sb, &s_lr_father_key, &s_path_to_neighbor_father, &n_repeat, n_h + 1, READ_BLOCKS);
+
+  if ( n_repeat != CARRY_ON ) {
+    decrement_counters_in_path(&s_path_to_neighbor_father);
+    decrement_bcount(*pp_s_com_father);
+    return n_repeat;
+  }
+
+  *pp_s_father = PATH_PLAST_BUFFER(&s_path_to_neighbor_father);
+
+#ifdef REISERFS_CHECK
+  if ( B_BLK_HEAD(*pp_s_father)->blk_level != n_h + 1 ) {
+    reiserfs_panic(p_s_tb->tb_sb, "PAP-8190: get_far_parent: (%b %z) level too small", *pp_s_father, *pp_s_father);
+  }
+  
+  if ( s_path_to_neighbor_father.path_length < FIRST_PATH_ELEMENT_OFFSET )
+    reiserfs_panic(0, "PAP-8192: get_far_parent: path length is too small");
+
+#endif
+
+  s_path_to_neighbor_father.path_length--;
+  decrement_counters_in_path(&s_path_to_neighbor_father);
+  return CARRY_ON;
+}
+
+
+/* Get parents of neighbors of node in the path(S[n_path_offset]) and common parents of
+ * S[n_path_offset] and L[n_path_offset]/R[n_path_offset]: F[n_path_offset], FL[n_path_offset],
+ * FR[n_path_offset], CFL[n_path_offset], CFR[n_path_offset].
+ * Calculate numbers of left and right delimiting keys position: lkey[n_path_offset], rkey[n_path_offset].
+ * Returns:	SCHEDULE_OCCURRED - schedule occured while the function worked;
+ *	        CARRY_ON - schedule didn't occur while the function worked;
+ */
+static int  get_parents(
+              struct tree_balance * p_s_tb,
+              int                   n_h
+            ) {
+  struct path         * p_s_path = p_s_tb->tb_path;
+  int                   n_position,
+                        n_ret_value,
+                        n_path_offset = PATH_H_PATH_OFFSET(p_s_tb->tb_path, n_h);
+  struct buffer_head  * p_s_curf,
+                      * p_s_curcf;
+
+  /* Current node is the root of the tree or will be root of the tree */
+  if ( n_path_offset <= FIRST_PATH_ELEMENT_OFFSET ) {
+  /* The root can not have parents.
+      Release nodes which previously were obtained as parents of the current node neighbors. */
+    decrement_bcount(p_s_tb->FL[n_h]);
+    decrement_bcount(p_s_tb->CFL[n_h]);
+    decrement_bcount(p_s_tb->FR[n_h]);
+    decrement_bcount(p_s_tb->CFR[n_h]);
+    p_s_tb->FL[n_h] = p_s_tb->CFL[n_h] = p_s_tb->FR[n_h] = p_s_tb->CFR[n_h] = NULL;
+    return CARRY_ON;
+  }
+  
+  /* Get parent FL[n_path_offset] of L[n_path_offset]. */
+  if ( (n_position = PATH_OFFSET_POSITION(p_s_path, n_path_offset - 1)) )  {
+    /* Current node is not the first child of its parent. */
+    (p_s_curf = p_s_curcf = PATH_OFFSET_PBUFFER(p_s_path, n_path_offset - 1))->b_count += 2;
+    p_s_tb->lkey[n_h] = n_position - 1;
+  }
+  else  {
+  /* Calculate current parent of L[n_path_offset], which is the left neighbor of the current node.
+     Calculate current common parent of L[n_path_offset] and the current node. Note that
+     CFL[n_path_offset] not equal FL[n_path_offset] and CFL[n_path_offset] not equal F[n_path_offset].
+     Calculate lkey[n_path_offset]. */
+    if ( (n_ret_value = get_far_parent(p_s_tb, n_h + 1, &p_s_curf,
+				       &p_s_curcf, LEFT_PARENTS)) != CARRY_ON )
+      return n_ret_value; /*schedule() occured or path is not correct*/
+  }
+
+ decrement_bcount(p_s_tb->FL[n_h]);	
+ p_s_tb->FL[n_h] = p_s_curf; /* New initialization of FL[n_h]. */
+ 
+ decrement_bcount(p_s_tb->CFL[n_h]);
+ p_s_tb->CFL[n_h] = p_s_curcf; /* New initialization of CFL[n_h]. */
+
+#ifdef REISERFS_CHECK
+ if ((p_s_curf && !B_IS_IN_TREE (p_s_curf)) || (p_s_curcf && !B_IS_IN_TREE (p_s_curcf))) {
+   reiserfs_panic (p_s_tb->tb_sb, "PAP-8195: get_parents: FL (%b) or CFL (%b) is invalid", p_s_curf, p_s_curcf);
+ }
+#endif
+
+/* Get parent FR[n_h] of R[n_h]. */
+
+/* Current node is the last child of F[n_h]. FR[n_h] != F[n_h]. */
+ if ( n_position == B_BLK_HEAD(PATH_H_PBUFFER(p_s_path, n_h + 1))->blk_nr_item ) {
+/* Calculate current parent of R[n_h], which is the right neighbor of F[n_h].
+   Calculate current common parent of R[n_h] and current node. Note that CFR[n_h]
+   not equal FR[n_path_offset] and CFR[n_h] not equal F[n_h]. */
+   if ( (n_ret_value = get_far_parent(p_s_tb, n_h + 1, &p_s_curf,  &p_s_curcf, RIGHT_PARENTS)) != CARRY_ON )
+     return n_ret_value; /*schedule() occured while get_far_parent() worked.*/
+ }
+ else {
+/* Current node is not the last child of its parent F[n_h]. */
+   (p_s_curf = p_s_curcf = PATH_OFFSET_PBUFFER(p_s_path, n_path_offset - 1))->b_count += 2;
+   p_s_tb->rkey[n_h] = n_position;
+ }	
+
+ decrement_bcount(p_s_tb->FR[n_h]);
+ p_s_tb->FR[n_h] = p_s_curf; /* New initialization of FR[n_path_offset]. */
+
+ decrement_bcount(p_s_tb->CFR[n_h]);
+ p_s_tb->CFR[n_h] = p_s_curcf; /* New initialization of CFR[n_path_offset]. */
+
+#ifdef REISERFS_CHECK
+ if (n_h == 0 && p_s_tb->CFR[n_h] && COMP_KEYS (B_PRIGHT_DELIM_KEY (PATH_H_PBUFFER(p_s_path, n_h)), 
+						B_N_PDELIM_KEY (p_s_tb->CFR[n_h], p_s_tb->rkey[n_h]))) {
+   reiserfs_panic (p_s_tb->tb_sb, "PAP-8200: get_parents: rdkey in S0 %k, rdkey in CFR0 %k do not match",
+		   B_PRIGHT_DELIM_KEY (PATH_H_PBUFFER(p_s_path, n_h)), B_N_PDELIM_KEY (p_s_tb->CFR[n_h], p_s_tb->rkey[n_h]));
+ }
+ if ((p_s_curf && !B_IS_IN_TREE (p_s_curf)) || (p_s_curcf && !B_IS_IN_TREE (p_s_curcf))) {
+   reiserfs_panic (p_s_tb->tb_sb, "PAP-8205: get_parents: FR (%b) or CFR (%b) is invalid", p_s_curf, p_s_curcf);
+ }
+#endif
+
+ return CARRY_ON; /* schedule not occured while get_parents() worked. */
+}
+
+
+/* it is possible to remove node as result of shiftings to
+   neighbors even when we insert or paste item. */
+static inline int can_node_be_removed (int mode, int lfree, int sfree, int rfree, struct tree_balance * tb, int h)
+{
+  struct buffer_head * Sh = PATH_H_PBUFFER (tb->tb_path, h);
+  int levbytes = tb->insert_size[h];
+  struct item_head * ih;
+  struct item_head * r_ih = NULL;
+  
+  ih = B_N_PITEM_HEAD (Sh, 0);
+  if ( tb->CFR[h] )
+    r_ih = (struct item_head *)B_N_PDELIM_KEY(tb->CFR[h],tb->rkey[h]);
+  
+  if (
+      lfree + rfree + sfree < MAX_CHILD_SIZE(Sh) + levbytes
+      /* shifting may merge items which might save space */
+#ifdef REISERFS_FSCK
+      - (( ! h && is_left_mergeable (tb->tb_sb, tb->tb_path) == 1 ) ? IH_SIZE : 0)
+      - (( ! h && r_ih && is_right_mergeable (tb->tb_sb, tb->tb_path) == 1 ) ? IH_SIZE : 0)
+#else
+      - (( ! h && is_left_mergeable (ih, Sh->b_size) ) ? IH_SIZE : 0)
+      - (( ! h && r_ih && is_left_mergeable (r_ih, Sh->b_size) ) ? IH_SIZE : 0)
+#endif
+      + (( h ) ? KEY_SIZE : 0))
+    {
+      /* node can not be removed */
+      if (sfree >= levbytes ) /* new item fits into node S[h] without any shifting */
+	{
+	  if ( ! h )
+	    tb->s0num = B_NR_ITEMS(Sh) + ((mode == M_INSERT ) ? 1 : 0);
+	  set_parameters (tb, h, 0, 0, 1, NULL, -1, -1);
+	  return NO_BALANCING_NEEDED;
+	}
+    }
+  return !NO_BALANCING_NEEDED;
+}
+
+
+
+/* Check whether current node S[h] is balanced when increasing its size by
+ * Inserting or Pasting.
+ * Calculate parameters for balancing for current level h.
+ * Parameters:
+ *	tb	tree_balance structure;
+ *	h	current level of the node;
+ *	inum	item number in S[h];
+ *	mode	i - insert, p - paste;
+ * Returns:	1 - schedule occured; 
+ *	        0 - balancing for higher levels needed;
+ *	       -1 - no balancing for higher levels needed;
+ *	       -2 - no disk space.
+ */
+/* ip means Inserting or Pasting */
+static int ip_check_balance (struct reiserfs_transaction_handle *th, struct tree_balance * tb, int h)
+{
+  struct virtual_node * vn = tb->tb_vn;
+  int levbytes,  /* Number of bytes that must be inserted into (value
+		    is negative if bytes are deleted) buffer which
+		    contains node being balanced.  The mnemonic is
+		    that the attempted change in node space used level
+		    is levbytes bytes. */
+    n_ret_value;
+
+  int lfree, sfree, rfree /* free space in L, S and R */;
+
+  /* nver is short for number of vertixes, and lnver is the number if
+     we shift to the left, rnver is the number if we shift to the
+     right, and lrnver is the number if we shift in both directions.
+     The goal is to minimize first the number of vertixes, and second,
+     the number of vertixes whose contents are changed by shifting,
+     and third the number of uncached vertixes whose contents are
+     changed by shifting and must be read from disk.  */
+  int nver, lnver, rnver, lrnver;
+
+  /* used at leaf level only, S0 = S[0] is the node being balanced,
+     sInum [ I = 0,1,2 ] is the number of items that will
+     remain in node SI after balancing.  S1 and S2 are new
+     nodes that might be created. */
+  
+  /* we perform 8 calls to get_num_ver().  For each call we calculate five parameters.
+     where 4th parameter is s1bytes and 5th - s2bytes
+  */
+  short snum012[40] = {0,};	/* s0num, s1num, s2num for 8 cases 
+				   0,1 - do not shift and do not shift but bottle
+				   2 - shift only whole item to left
+				   3 - shift to left and bottle as much as possible
+				   4,5 - shift to right	(whole items and as much as possible
+				   6,7 - shift to both directions (whole items and as much as possible)
+				   */
+
+  /* Sh is the node whose balance is currently being checked */
+  struct buffer_head * Sh;
+  
+#ifdef REISERFS_FSCK
+  /* special mode for insert pointer to the most low internal node */
+  if (h == 0 && vn->vn_mode == M_INTERNAL) {
+    /* blk_num == 2 is to get pointer inserted to the next level */
+    set_parameters (tb, h, 0, 0, 2, NULL, -1, -1);
+    return 0;
+  }
+#endif
+
+  Sh = PATH_H_PBUFFER (tb->tb_path, h);
+  levbytes = tb->insert_size[h];
+  
+     /* Calculate balance parameters for creating new root. */
+  if ( ! Sh )  {
+    if ( ! h )
+      reiserfs_panic (tb->tb_sb, "vs-8210: ip_check_balance: S[0] can not be 0");
+    switch ( n_ret_value = get_empty_nodes (th, tb, h) )  {
+    case CARRY_ON:
+      set_parameters (tb, h, 0, 0, 1, NULL, -1, -1);
+      return NO_BALANCING_NEEDED; /* no balancing for higher levels needed */
+
+    case NO_DISK_SPACE:
+    case SCHEDULE_OCCURRED:
+      return n_ret_value;
+    default:   
+      reiserfs_panic(tb->tb_sb, "vs-8215: ip_check_balance: incorrect return value of get_empty_nodes");
+    }
+  }
+  
+  if ( (n_ret_value = get_parents (tb, h)) != CARRY_ON ) /* get parents of S[h] neighbors. */
+    return n_ret_value;
+  
+     sfree = B_BLK_HEAD(Sh)->blk_free_space;
+
+     /* get free space of neighbors */
+     rfree = get_rfree (tb, h);
+     lfree = get_lfree (tb, h);
+
+     if (can_node_be_removed (vn->vn_mode, lfree, sfree, rfree, tb, h) == NO_BALANCING_NEEDED)
+       /* and new item fits into node S[h] without any shifting */
+       return NO_BALANCING_NEEDED;
+     
+     create_virtual_node (tb, h);
+
+     /*	
+	determine maximal number of items we can shift to the left neighbor (in tb structure)
+	and the maximal number of bytes that can flow to the left neighbor
+	from the left most liquid item that cannot be shifted from S[0] entirely (returned value)
+	*/
+     check_left (tb, h, lfree);
+
+     /*
+        determine maximal number of items we can shift to the right neighbor (in tb structure)
+	and the maximal number of bytes that can flow to the right neighbor
+	from the right most liquid item that cannot be shifted from S[0] entirely (returned value)
+	*/
+     check_right (tb, h, rfree);
+
+
+     /* all contents of internal node S[h] can be moved into its
+        neighbors, S[h] will be removed after balancing */
+     if (h && (tb->rnum[h] + tb->lnum[h] >= vn->vn_nr_item + 1)) {
+       int to_r; 
+       
+       /* Since we are working on internal nodes, and our internal
+	  nodes have fixed size entries, then we can balance by the
+	  number of items rather than the space they consume.  In this
+	  routine we set the left node equal to the right node,
+	  allowing a difference of less than or equal to 1 child
+	  pointer. */
+       to_r = ((MAX_NR_KEY(Sh)<<1)+2-tb->lnum[h]-tb->rnum[h]+vn->vn_nr_item+1)/2 - 
+	 (MAX_NR_KEY(Sh) + 1 - tb->rnum[h]);
+       set_parameters (tb, h, vn->vn_nr_item + 1 - to_r, to_r, 0, NULL, -1, -1);
+       return CARRY_ON;
+     }
+
+#ifdef REISERFS_CHECK
+     /* this checks balance condition, that any two neighboring nodes can not fit in one node */
+     if ( h && ( tb->lnum[h] >= vn->vn_nr_item + 1 || tb->rnum[h] >= vn->vn_nr_item + 1) )
+       reiserfs_panic (tb->tb_sb, "vs-8220: ip_check_balance: tree is not balanced on internal level");
+
+     if ( ! h && ((tb->lnum[h] >= vn->vn_nr_item && (tb->lbytes == -1)) ||
+		  (tb->rnum[h] >= vn->vn_nr_item && (tb->rbytes == -1)) ))
+       reiserfs_panic(tb->tb_sb, "vs-8225: ip_check_balance: tree is not balanced on leaf level");
+#endif
+
+     /* all contents of S[0] can be moved into its neighbors
+	S[0] will be removed after balancing. */
+     if (!h && is_leaf_removable (tb))
+       return CARRY_ON;
+
+
+     /* why do we perform this check here rather than earlier??
+        Answer: we can win 1 node in some cases above. Moreover we
+        checked it above, when we checked, that S[0] is not removable
+        in principle */
+     if (sfree >= levbytes) { /* new item fits into node S[h] without any shifting */
+       if ( ! h )
+	 tb->s0num = vn->vn_nr_item;
+       set_parameters (tb, h, 0, 0, 1, NULL, -1, -1);
+       return NO_BALANCING_NEEDED;
+     }
+
+
+     {
+       int lpar, rpar, nset, lset, rset, lrset;
+     /* 
+      * regular overflowing of the node
+      */
+
+     /* get_num_ver works in 2 modes (FLOW & NO_FLOW) 
+	lpar, rpar - number of items we can shift to left/right neighbor (including splitting item)
+	nset, lset, rset, lrset - shows, whether flowing items give better packing 
+	*/
+#define FLOW 1
+#define NO_FLOW 0	/* do not any splitting */
+
+     /* we choose one the following */
+#define NOTHING_SHIFT_NO_FLOW	0
+#define NOTHING_SHIFT_FLOW	5
+#define LEFT_SHIFT_NO_FLOW	10
+#define LEFT_SHIFT_FLOW		15
+#define RIGHT_SHIFT_NO_FLOW	20
+#define RIGHT_SHIFT_FLOW	25
+#define LR_SHIFT_NO_FLOW	30
+#define LR_SHIFT_FLOW		35
+
+
+       lpar = tb->lnum[h];
+       rpar = tb->rnum[h];
+
+
+     /* calculate number of blocks S[h] must be split into when
+	nothing is shifted to the neighbors,
+	as well as number of items in each part of the split node (s012 numbers),
+	and number of bytes (s1bytes) of the shared drop which flow to S1 if any */
+     nset = NOTHING_SHIFT_NO_FLOW;
+     nver = get_num_ver (vn->vn_mode, tb, h,
+			 0, -1, h?vn->vn_nr_item:0, -1, 
+			 snum012, NO_FLOW);
+
+     if (!h)
+       {
+	 int nver1;
+
+	 /* note, that in this case we try to bottle between S[0] and S1 (S1 - the first new node) */
+	 nver1 = get_num_ver (vn->vn_mode, tb, h, 
+			      0, -1, 0, -1, 
+			      snum012 + NOTHING_SHIFT_FLOW, FLOW);
+	 if (nver > nver1)
+	   nset = NOTHING_SHIFT_FLOW, nver = nver1;
+       }
+       
+ 
+     /* calculate number of blocks S[h] must be split into when
+	l_shift_num first items and l_shift_bytes of the right most
+	liquid item to be shifted are shifted to the left neighbor,
+	as well as number of items in each part of the splitted node (s012 numbers),
+	and number of bytes (s1bytes) of the shared drop which flow to S1 if any
+	*/
+     lset = LEFT_SHIFT_NO_FLOW;
+     lnver = get_num_ver (vn->vn_mode, tb, h, 
+			  lpar - (( h || tb->lbytes == -1 ) ? 0 : 1), -1, h ? vn->vn_nr_item:0, -1,
+			  snum012 + LEFT_SHIFT_NO_FLOW, NO_FLOW);
+     if (!h)
+       {
+	 int lnver1;
+
+	 lnver1 = get_num_ver (vn->vn_mode, tb, h, 
+			       lpar - ((tb->lbytes != -1) ? 1 : 0), tb->lbytes, 0, -1,
+			       snum012 + LEFT_SHIFT_FLOW, FLOW);
+	 if (lnver > lnver1)
+	   lset = LEFT_SHIFT_FLOW, lnver = lnver1;
+       }
+
+
+     /* calculate number of blocks S[h] must be split into when
+	r_shift_num first items and r_shift_bytes of the left most
+	liquid item to be shifted are shifted to the right neighbor,
+	as well as number of items in each part of the splitted node (s012 numbers),
+	and number of bytes (s1bytes) of the shared drop which flow to S1 if any
+	*/
+     rset = RIGHT_SHIFT_NO_FLOW;
+     rnver = get_num_ver (vn->vn_mode, tb, h, 
+			  0, -1, h ? (vn->vn_nr_item-rpar) : (rpar - (( tb->rbytes != -1 ) ? 1 : 0)), -1, 
+			  snum012 + RIGHT_SHIFT_NO_FLOW, NO_FLOW);
+     if (!h)
+       {
+	 int rnver1;
+
+	 rnver1 = get_num_ver (vn->vn_mode, tb, h, 
+			       0, -1, (rpar - ((tb->rbytes != -1) ? 1 : 0)), tb->rbytes, 
+			       snum012 + RIGHT_SHIFT_FLOW, FLOW);
+
+	 if (rnver > rnver1)
+	   rset = RIGHT_SHIFT_FLOW, rnver = rnver1;
+       }
+
+
+     /* calculate number of blocks S[h] must be split into when
+	items are shifted in both directions,
+	as well as number of items in each part of the splitted node (s012 numbers),
+	and number of bytes (s1bytes) of the shared drop which flow to S1 if any
+	*/
+     lrset = LR_SHIFT_NO_FLOW;
+     lrnver = get_num_ver (vn->vn_mode, tb, h, 
+			   lpar - ((h || tb->lbytes == -1) ? 0 : 1), -1, h ? (vn->vn_nr_item-rpar):(rpar - ((tb->rbytes != -1) ? 1 : 0)), -1,
+			   snum012 + LR_SHIFT_NO_FLOW, NO_FLOW);
+     if (!h)
+       {
+	 int lrnver1;
+
+	 lrnver1 = get_num_ver (vn->vn_mode, tb, h, 
+				lpar - ((tb->lbytes != -1) ? 1 : 0), tb->lbytes, (rpar - ((tb->rbytes != -1) ? 1 : 0)), tb->rbytes,
+				snum012 + LR_SHIFT_FLOW, FLOW);
+	 if (lrnver > lrnver1)
+	   lrset = LR_SHIFT_FLOW, lrnver = lrnver1;
+       }
+
+
+
+     /* Our general shifting strategy is:
+	1) to minimized number of new nodes;
+	2) to minimized number of neighbors involved in shifting;
+	3) to minimized number of disk reads; */
+
+     /* we can win TWO or ONE nodes by shifting in both directions */
+     if (lrnver < lnver && lrnver < rnver)
+       {
+#ifdef REISERFS_CHECK
+	 if (h && (tb->lnum[h] != 1 || tb->rnum[h] != 1 || lrnver != 1 || rnver != 2 || lnver != 2 || h != 1))
+	   reiserfs_panic (0, "vs-8230: check_balance: bad h");
+#endif
+	 if (lrset == LR_SHIFT_FLOW)
+	   set_parameters (tb, h, tb->lnum[h], tb->rnum[h], lrnver, snum012 + lrset,
+			   tb->lbytes, tb->rbytes);
+	 else
+ 	   set_parameters (tb, h, tb->lnum[h] - ((tb->lbytes == -1) ? 0 : 1), 
+			   tb->rnum[h] - ((tb->rbytes == -1) ? 0 : 1), lrnver, snum012 + lrset, -1, -1);
+
+	 return CARRY_ON;
+       }
+
+     /* if shifting doesn't lead to better packing then don't shift */
+     if (nver == lrnver)
+       {
+	 set_parameters (tb, h, 0, 0, nver, snum012 + nset, -1, -1);
+	 return CARRY_ON;
+       }
+
+
+     /* now we know that for better packing shifting in only one
+	direction either to the left or to the right is required */
+
+     /*  if shifting to the left is better than shifting to the right */
+     if (lnver < rnver)
+       {
+	 SET_PAR_SHIFT_LEFT;
+	 return CARRY_ON;
+       }
+
+     /* if shifting to the right is better than shifting to the left */
+     if (lnver > rnver)
+       {
+	 SET_PAR_SHIFT_RIGHT;
+	 return CARRY_ON;
+       }
+
+
+     /* now shifting in either direction gives the same number
+	of nodes and we can make use of the cached neighbors */
+     if (is_left_neighbor_in_cache (tb,h))
+       {
+	 SET_PAR_SHIFT_LEFT;
+	 return CARRY_ON;
+       }
+
+     /* shift to the right independently on whether the right neighbor in cache or not */
+     SET_PAR_SHIFT_RIGHT;
+     return CARRY_ON;
+     }
+}
+
+
+/* Check whether current node S[h] is balanced when Decreasing its size by
+ * Deleting or Cutting for INTERNAL node of S+tree.
+ * Calculate parameters for balancing for current level h.
+ * Parameters:
+ *	tb	tree_balance structure;
+ *	h	current level of the node;
+ *	inum	item number in S[h];
+ *	mode	i - insert, p - paste;
+ * Returns:	1 - schedule occured; 
+ *	        0 - balancing for higher levels needed;
+ *	       -1 - no balancing for higher levels needed;
+ *	       -2 - no disk space.
+ *
+ * Note: Items of internal nodes have fixed size, so the balance condition for
+ * the internal part of S+tree is as for the B-trees.
+ */
+static int dc_check_balance_internal (struct tree_balance * tb, int h)
+{
+  struct virtual_node * vn = tb->tb_vn;
+
+  /* Sh is the node whose balance is currently being checked,
+     and Fh is its father.  */
+  struct buffer_head * Sh, * Fh;
+  int maxsize,
+      n_ret_value;
+  int lfree, rfree /* free space in L and R */;
+
+  Sh = PATH_H_PBUFFER (tb->tb_path, h); 
+  Fh = PATH_H_PPARENT (tb->tb_path, h); 
+
+  maxsize = MAX_CHILD_SIZE(Sh); 
+
+/*   using tb->insert_size[h], which is negative in this case, create_virtual_node calculates: */
+/*   new_nr_item = number of items node would have if operation is */
+/* 	performed without balancing (new_nr_item); */
+  create_virtual_node (tb, h);
+
+  if ( ! Fh )
+    {   /* S[h] is the root. */
+      if ( vn->vn_nr_item > 0 )
+	{
+	  set_parameters (tb, h, 0, 0, 1, NULL, -1, -1);
+	  return NO_BALANCING_NEEDED; /* no balancing for higher levels needed */
+	}
+      /* new_nr_item == 0.
+       * Current root will be deleted resulting in
+       * decrementing the tree height. */
+      set_parameters (tb, h, 0, 0, 0, NULL, -1, -1);
+      return CARRY_ON;
+    }
+
+  if ( (n_ret_value = get_parents(tb,h)) != CARRY_ON )
+    return n_ret_value;
+
+
+  /* get free space of neighbors */
+  rfree = get_rfree (tb, h);
+  lfree = get_lfree (tb, h);
+		
+  /* determine maximal number of items we can fit into neighbors */
+  check_left (tb, h, lfree);
+  check_right (tb, h, rfree);
+
+
+  if ( vn->vn_nr_item >= MIN_NR_KEY(Sh) )
+    { /* Balance condition for the internal node is valid.
+       * In this case we balance only if it leads to better packing. */ 
+      if ( vn->vn_nr_item == MIN_NR_KEY(Sh) )
+	{ /* Here we join S[h] with one of its neighbors,
+	   * which is impossible with greater values of new_nr_item. */
+	  if ( tb->lnum[h] >= vn->vn_nr_item + 1 )
+	    {
+	      /* All contents of S[h] can be moved to L[h]. */
+	      int n;
+	      int order_L;
+	      
+	      order_L = ((n=PATH_H_B_ITEM_ORDER(tb->tb_path, h))==0) ? B_NR_ITEMS(tb->FL[h]) : n - 1;
+	      n = B_N_CHILD(tb->FL[h],order_L)->dc_size / (DC_SIZE + KEY_SIZE);
+	      set_parameters (tb, h, -n-1, 0, 0, NULL, -1, -1);
+	      return CARRY_ON;
+	    }
+
+	  if ( tb->rnum[h] >= vn->vn_nr_item + 1 )
+	    {
+	      /* All contents of S[h] can be moved to R[h]. */
+	      int n;
+	      int order_R;
+	    
+	      order_R = ((n=PATH_H_B_ITEM_ORDER(tb->tb_path, h))==B_NR_ITEMS(Fh)) ? 0 : n + 1;
+	      n = B_N_CHILD(tb->FR[h],order_R)->dc_size / (DC_SIZE + KEY_SIZE);
+	      set_parameters (tb, h, 0, -n-1, 0, NULL, -1, -1);
+	      return CARRY_ON;   
+	    }
+	}
+
+      if (tb->rnum[h] + tb->lnum[h] >= vn->vn_nr_item + 1)
+	{
+	  /* All contents of S[h] can be moved to the neighbors (L[h] & R[h]). */
+	  int to_r;
+
+	  to_r = ((MAX_NR_KEY(Sh)<<1)+2-tb->lnum[h]-tb->rnum[h]+vn->vn_nr_item+1)/2 - 
+	    (MAX_NR_KEY(Sh) + 1 - tb->rnum[h]);
+	  set_parameters (tb, h, vn->vn_nr_item + 1 - to_r, to_r, 0, NULL, -1, -1);
+	  return CARRY_ON;
+	}
+
+      /* Balancing does not lead to better packing. */
+      set_parameters (tb, h, 0, 0, 1, NULL, -1, -1);
+      return NO_BALANCING_NEEDED;
+    }
+
+  /* Current node contain insufficient number of items. Balancing is required. */	
+  /* Check whether we can merge S[h] with left neighbor. */
+  if (tb->lnum[h] >= vn->vn_nr_item + 1)
+    if (is_left_neighbor_in_cache (tb,h) || tb->rnum[h] < vn->vn_nr_item + 1 || !tb->FR[h])
+      {
+	int n;
+	int order_L;
+	      
+	order_L = ((n=PATH_H_B_ITEM_ORDER(tb->tb_path, h))==0) ? B_NR_ITEMS(tb->FL[h]) : n - 1;
+	n = B_N_CHILD(tb->FL[h],order_L)->dc_size / (DC_SIZE + KEY_SIZE);
+	set_parameters (tb, h, -n-1, 0, 0, NULL, -1, -1);
+	return CARRY_ON;
+      }
+
+  /* Check whether we can merge S[h] with right neighbor. */
+  if (tb->rnum[h] >= vn->vn_nr_item + 1)
+    {
+      int n;
+      int order_R;
+	    
+      order_R = ((n=PATH_H_B_ITEM_ORDER(tb->tb_path, h))==B_NR_ITEMS(Fh)) ? 0 : (n + 1);
+      n = B_N_CHILD(tb->FR[h],order_R)->dc_size / (DC_SIZE + KEY_SIZE);
+      set_parameters (tb, h, 0, -n-1, 0, NULL, -1, -1);
+      return CARRY_ON;   
+    }
+
+  /* All contents of S[h] can be moved to the neighbors (L[h] & R[h]). */
+  if (tb->rnum[h] + tb->lnum[h] >= vn->vn_nr_item + 1)
+    {
+      int to_r;
+	    
+      to_r = ((MAX_NR_KEY(Sh)<<1)+2-tb->lnum[h]-tb->rnum[h]+vn->vn_nr_item+1)/2 - 
+	(MAX_NR_KEY(Sh) + 1 - tb->rnum[h]);
+      set_parameters (tb, h, vn->vn_nr_item + 1 - to_r, to_r, 0, NULL, -1, -1);
+      return CARRY_ON;
+    }
+
+  /* For internal nodes try to borrow item from a neighbor */
+#ifdef REISERFS_CHECK
+  if (!tb->FL[h] && !tb->FR[h])
+    reiserfs_panic (0, "vs-8235: dc_check_balance_internal: trying to borrow for root");
+#endif
+
+  /* Borrow one or two items from caching neighbor */
+  if (is_left_neighbor_in_cache (tb,h) || !tb->FR[h])
+    {
+      int from_l;
+		
+      from_l = (MAX_NR_KEY(Sh) + 1 - tb->lnum[h] + vn->vn_nr_item + 1) / 2 -  (vn->vn_nr_item + 1);
+      set_parameters (tb, h, -from_l, 0, 1, NULL, -1, -1);
+      return CARRY_ON;
+    }
+
+  set_parameters (tb, h, 0, -((MAX_NR_KEY(Sh)+1-tb->rnum[h]+vn->vn_nr_item+1)/2-(vn->vn_nr_item+1)), 1, 
+		  NULL, -1, -1);
+  return CARRY_ON;
+}
+
+
+/* Check whether current node S[h] is balanced when Decreasing its size by
+ * Deleting or Truncating for LEAF node of S+tree.
+ * Calculate parameters for balancing for current level h.
+ * Parameters:
+ *	tb	tree_balance structure;
+ *	h	current level of the node;
+ *	inum	item number in S[h];
+ *	mode	i - insert, p - paste;
+ * Returns:	1 - schedule occured; 
+ *	        0 - balancing for higher levels needed;
+ *	       -1 - no balancing for higher levels needed;
+ *	       -2 - no disk space.
+ */
+static int dc_check_balance_leaf (struct tree_balance * tb, int h)
+{
+  struct virtual_node * vn = tb->tb_vn;
+
+  /* Number of bytes that must be deleted from
+     (value is negative if bytes are deleted) buffer which
+     contains node being balanced.  The mnemonic is that the
+     attempted change in node space used level is levbytes bytes. */
+  int levbytes;
+  /* the maximal item size */
+  int maxsize,
+      n_ret_value;
+  /* S0 is the node whose balance is currently being checked,
+     and F0 is its father.  */
+  struct buffer_head * S0, * F0;
+  int lfree, rfree /* free space in L and R */;
+
+  S0 = PATH_H_PBUFFER (tb->tb_path, 0);
+  F0 = PATH_H_PPARENT (tb->tb_path, 0);
+
+  levbytes = tb->insert_size[h];
+
+  maxsize = MAX_CHILD_SIZE(S0); 	/* maximal possible size of an item */
+
+  if ( ! F0 )
+    {  /* S[0] is the root now. */
+
+#ifdef REISERFS_CHECK
+      if ( -levbytes >= maxsize - B_BLK_HEAD(S0)->blk_free_space )
+	reiserfs_panic (tb->tb_sb, "vs-8240: dc_check_balance_leaf: attempt to create empty buffer tree");
+#endif
+
+      set_parameters (tb, h, 0, 0, 1, NULL, -1, -1);
+      return NO_BALANCING_NEEDED;
+    }
+
+  if ( (n_ret_value = get_parents(tb,h)) != CARRY_ON )
+    return n_ret_value;
+
+  /* get free space of neighbors */
+  rfree = get_rfree (tb, h);
+  lfree = get_lfree (tb, h);		
+
+  create_virtual_node (tb, h);
+
+  /* if 3 leaves can be merge to one, set parameters and return */
+  if (are_leaves_removable (tb, lfree, rfree))
+    return CARRY_ON;
+
+  /* determine maximal number of items we can shift to the left/right  neighbor
+     and the maximal number of bytes that can flow to the left/right neighbor
+     from the left/right most liquid item that cannot be shifted from S[0] entirely
+     */
+  check_left (tb, h, lfree);
+  check_right (tb, h, rfree);   
+
+  /* check whether we can merge S with left neighbor. */
+  if (tb->lnum[0] >= vn->vn_nr_item && tb->lbytes == -1)
+    if (is_left_neighbor_in_cache (tb,h) ||
+	((tb->rnum[0] - ((tb->rbytes == -1) ? 0 : 1)) < vn->vn_nr_item) || /* S can not be merged with R */
+	!tb->FR[h]) {
+      
+#ifdef REISERFS_CHECK
+      if (!tb->FL[h])
+	reiserfs_panic (0, "vs-8245: dc_check_balance_leaf: FL[h] must exist");
+#endif
+
+      /* set parameter to merge S[0] with its left neighbor */
+      set_parameters (tb, h, -1, 0, 0, NULL, -1, -1);
+      return CARRY_ON;
+    }
+
+  /* check whether we can merge S[0] with right neighbor. */
+  if (tb->rnum[0] >= vn->vn_nr_item && tb->rbytes == -1) {
+    set_parameters (tb, h, 0, -1, 0, NULL, -1, -1);
+    return CARRY_ON;
+  }
+  
+  /* All contents of S[0] can be moved to the neighbors (L[0] & R[0]). Set parameters and return */
+  if (is_leaf_removable (tb))
+    return CARRY_ON;
+  
+  /* Balancing is not required. */
+  tb->s0num = vn->vn_nr_item;
+  set_parameters (tb, h, 0, 0, 1, NULL, -1, -1);
+  return NO_BALANCING_NEEDED;
+}
+
+
+
+/* Check whether current node S[h] is balanced when Decreasing its size by
+ * Deleting or Cutting.
+ * Calculate parameters for balancing for current level h.
+ * Parameters:
+ *	tb	tree_balance structure;
+ *	h	current level of the node;
+ *	inum	item number in S[h];
+ *	mode	d - delete, c - cut.
+ * Returns:	1 - schedule occured; 
+ *	        0 - balancing for higher levels needed;
+ *	       -1 - no balancing for higher levels needed;
+ *	       -2 - no disk space.
+ */
+static int dc_check_balance (struct tree_balance * tb, int h)
+{
+
+#ifdef REISERFS_CHECK
+ if ( ! (PATH_H_PBUFFER (tb->tb_path, h)) )
+   reiserfs_panic(tb->tb_sb, "vs-8250: dc_check_balance: S is not initialized");
+#endif
+
+ if ( h )
+   return dc_check_balance_internal (tb, h);
+ else
+   return dc_check_balance_leaf (tb, h);
+}
+
+
+
+/* Check whether current node S[h] is balanced.
+ * Calculate parameters for balancing for current level h.
+ * Parameters:
+ *
+ *	tb	tree_balance structure:
+ *
+ *              tb is a large structure that must be read about in the header file
+ *              at the same time as this procedure if the reader is to successfully
+ *              understand this procedure
+ *
+ *	h	current level of the node;
+ *	inum	item number in S[h];
+ *	mode	i - insert, p - paste, d - delete, c - cut.
+ * Returns:	1 - schedule occured; 
+ *	        0 - balancing for higher levels needed;
+ *	       -1 - no balancing for higher levels needed;
+ *	       -2 - no disk space.
+ */
+static int check_balance (struct reiserfs_transaction_handle *th, 
+   			  int mode, 
+			  struct tree_balance * tb,
+			  int h, 
+			  int inum,
+			  int pos_in_item,
+			  struct item_head * ins_ih
+			  )
+{
+  struct virtual_node * vn;
+
+  vn = tb->tb_vn = (struct virtual_node *)(tb->vn_buf + ROUND_UP(SB_BMAP_NR (tb->tb_sb) * 2 / 8 + 1, 4));
+  vn->vn_free_ptr = (char *)(tb->tb_vn + 1);
+  vn->vn_mode = mode;
+  vn->vn_affected_item_num = inum;
+  vn->vn_pos_in_item = pos_in_item;
+  vn->vn_ins_ih = ins_ih;
+
+#ifdef REISERFS_CHECK
+  if (mode == M_INSERT && !vn->vn_ins_ih)
+    reiserfs_panic (0, "vs-8255: check_balance: ins_ih can not be 0 in insert mode");
+#endif
+
+ if ( tb->insert_size[h] > 0 )
+   /* Calculate balance parameters when size of node is increasing. */
+   return ip_check_balance (th, tb, h);
+
+ /* Calculate balance parameters when  size of node is decreasing. */
+ return dc_check_balance (tb, h);
+}
+
+
+
+/* Check whether parent at the path is the really parent of the current node.*/
+static int  get_direct_parent(
+              struct tree_balance * p_s_tb,
+              int                   n_h
+            ) {
+  struct buffer_head  * p_s_bh;
+  struct path         * p_s_path      = p_s_tb->tb_path;
+  int                   n_position,
+    			n_path_offset = PATH_H_PATH_OFFSET(p_s_tb->tb_path, n_h);
+
+  /* We are in the root or in the new root. */
+  if ( n_path_offset <= FIRST_PATH_ELEMENT_OFFSET ) {
+
+#ifdef REISERFS_CHECK
+    if ( n_path_offset < FIRST_PATH_ELEMENT_OFFSET - 1 )
+      reiserfs_panic(p_s_tb->tb_sb, "PAP-8260: get_direct_parent: illegal offset in the path");
+#endif
+
+    if ( PATH_OFFSET_PBUFFER(p_s_path, FIRST_PATH_ELEMENT_OFFSET)->b_blocknr ==
+                                      p_s_tb->tb_sb->u.reiserfs_sb.s_rs->s_root_block ) {
+      /* Root is not changed. */
+      PATH_OFFSET_PBUFFER(p_s_path, n_path_offset - 1) = NULL;
+	    PATH_OFFSET_POSITION(p_s_path, n_path_offset - 1) = 0;
+      return CARRY_ON;
+    }
+    return PATH_INCORRECT; /* Root is changed and we must recalculate the path. */
+  }
+
+  if ( ! B_IS_IN_TREE(p_s_bh = PATH_OFFSET_PBUFFER(p_s_path, n_path_offset - 1)) )
+    return PATH_INCORRECT; /* Parent in the path is not in the tree. */
+
+  if ( (n_position = PATH_OFFSET_POSITION(p_s_path, n_path_offset - 1)) > B_NR_ITEMS(p_s_bh) )
+    return PATH_INCORRECT;
+
+  if ( B_N_CHILD_NUM(p_s_bh, n_position) != PATH_OFFSET_PBUFFER(p_s_path, n_path_offset)->b_blocknr )
+     /* Parent in the path is not parent of the current node in the tree. */
+    return PATH_INCORRECT;
+
+  if ( test_and_wait_on_buffer(p_s_bh) == SCHEDULE_OCCURRED ) /* Buffer was locked. */
+    return SCHEDULE_OCCURRED;
+
+  return CARRY_ON; /* Parent in the path is unlocked and really parent of the current node.  */
+}
+
+
+/* Using lnum[n_h] and rnum[n_h] we should determine what neighbors
+ * of S[n_h] we
+ * need in order to balance S[n_h], and get them if necessary.
+ * Returns:	SCHEDULE_OCCURRED - schedule occured while the function worked;
+ *	        CARRY_ON - schedule didn't occur while the function worked;
+ */
+static int  get_neighbors(
+	            struct tree_balance * p_s_tb,
+	            int 		  n_h
+	          ) {
+  int		 	n_child_position,
+    			n_repeat,
+          		n_path_offset = PATH_H_PATH_OFFSET(p_s_tb->tb_path, n_h + 1);
+  unsigned long		n_son_number;
+  struct super_block  *	p_s_sb = p_s_tb->tb_sb;
+  struct buffer_head  * p_s_bh;
+  struct virtual_node * vn = p_s_tb->tb_vn;/*(struct virtual_node *)(p_s_tb->vn_buf);*/
+
+  if ( p_s_tb->lnum[n_h] ||
+      ( ! n_h && ! vn->vn_affected_item_num && (vn->vn_mode == M_DELETE ||
+						(vn->vn_mode == M_CUT && ! vn->vn_pos_in_item)
+#ifdef REISERFS_FSCK
+						|| (vn->vn_mode == M_PASTE && ! vn->vn_pos_in_item)
+#endif
+						)) ) {
+
+#ifdef REISERFS_CHECK
+   if ( ! p_s_tb->lnum[n_h] && vn->vn_mode == M_CUT &&
+	! (vn->vn_vi[0].vi_type & VI_TYPE_DIRECTORY) )
+     reiserfs_panic (p_s_tb->tb_sb, "PAP-8265: get_neighbors: item must be directory item");
+#endif
+
+   /* We need left neighbor to balance S[n_h]. */
+   p_s_bh = PATH_OFFSET_PBUFFER(p_s_tb->tb_path, n_path_offset);
+
+#ifdef REISERFS_CHECK
+   if ( p_s_bh == p_s_tb->FL[n_h] && ! PATH_OFFSET_POSITION(p_s_tb->tb_path, n_path_offset) )
+       reiserfs_panic (p_s_tb->tb_sb, "PAP-8270: get_neighbors: invalid position in the parent");
+#endif
+
+   n_child_position = ( p_s_bh == p_s_tb->FL[n_h] ) ? p_s_tb->lkey[n_h] : B_BLK_HEAD(p_s_tb->FL[n_h])->blk_nr_item;
+   n_son_number = B_N_CHILD_NUM(p_s_tb->FL[n_h], n_child_position);
+   n_repeat = CARRY_ON;
+   p_s_bh = reiserfs_bread(p_s_sb->s_dev, n_son_number, p_s_sb->s_blocksize, &n_repeat);
+   if (!p_s_bh)
+     return IO_ERROR;
+   if ( n_repeat != CARRY_ON ) {
+     decrement_bcount(p_s_bh);
+
+#ifdef REISERFS_INFO
+   if ( ! p_s_tb->lnum[n_h] )
+     printk("Schedule occured in case when we need left neighbor just to update right delimiting key\n");
+#endif
+
+     return SCHEDULE_OCCURRED;
+   }
+
+#ifdef REISERFS_CHECK
+    if ( ! B_IS_IN_TREE(p_s_tb->FL[n_h]) || n_child_position > B_NR_ITEMS(p_s_tb->FL[n_h]) ||
+	 B_N_CHILD_NUM(p_s_tb->FL[n_h], n_child_position) != p_s_bh->b_blocknr )
+      reiserfs_panic (p_s_tb->tb_sb, "PAP-8275: get_neighbors: invalid parent");
+    if ( ! B_IS_IN_TREE(p_s_bh) )
+      reiserfs_panic (p_s_tb->tb_sb, "PAP-8280: get_neighbors: invalid child");
+
+    if ( ! n_h && COMP_KEYS(B_PRIGHT_DELIM_KEY(p_s_bh), B_N_PDELIM_KEY(p_s_tb->CFL[0], p_s_tb->lkey[0])) ) {
+      print_block(p_s_bh, 0, -1, -1);
+      print_block(p_s_tb->CFL[0], 0, -1, -1);
+      reiserfs_panic (p_s_tb->tb_sb, "PAP-8285: get_neighbors: invalid rdkey");
+    }
+    if (! n_h && B_BLK_HEAD (p_s_bh)->blk_free_space != MAX_CHILD_SIZE (p_s_bh) - B_N_CHILD (p_s_tb->FL[0],n_child_position)->dc_size) {
+      reiserfs_panic (p_s_tb->tb_sb, "PAP-8290: get_neighbors: invalid child size of left neighbor");
+    }
+#endif
+
+   decrement_bcount(p_s_tb->L[n_h]);
+   p_s_tb->L[n_h] = p_s_bh;
+ }
+
+ if ( p_s_tb->rnum[n_h] ) { /* We need right neighbor to balance S[n_path_offset]. */
+   p_s_bh = PATH_OFFSET_PBUFFER(p_s_tb->tb_path, n_path_offset);
+
+#ifdef REISERFS_CHECK
+   if ( p_s_bh == p_s_tb->FR[n_h] && PATH_OFFSET_POSITION(p_s_tb->tb_path, n_path_offset) >= B_NR_ITEMS(p_s_bh) )
+       reiserfs_panic (p_s_tb->tb_sb, "PAP-8295: get_neighbors: invalid position in the parent");
+#endif
+
+   n_child_position = ( p_s_bh == p_s_tb->FR[n_h] ) ? p_s_tb->rkey[n_h] + 1 : 0;
+   n_son_number = B_N_CHILD_NUM(p_s_tb->FR[n_h], n_child_position);
+   n_repeat = CARRY_ON;
+   p_s_bh = reiserfs_bread(p_s_sb->s_dev, n_son_number, p_s_sb->s_blocksize, &n_repeat);
+   if (!p_s_bh)
+     return IO_ERROR;
+   if ( n_repeat != CARRY_ON ) {
+     decrement_bcount(p_s_bh);
+     return SCHEDULE_OCCURRED;
+   }
+   decrement_bcount(p_s_tb->R[n_h]);
+   p_s_tb->R[n_h] = p_s_bh;
+
+#ifdef REISERFS_CHECK
+    if (! n_h && B_BLK_HEAD (p_s_bh)->blk_free_space != MAX_CHILD_SIZE (p_s_bh) - B_N_CHILD (p_s_tb->FR[0],n_child_position)->dc_size) {
+      reiserfs_panic (p_s_tb->tb_sb, "PAP-8300: get_neighbors: invalid child size of right neighbor (%d != %d - %d)",
+		      B_BLK_HEAD (p_s_bh)->blk_free_space, MAX_CHILD_SIZE (p_s_bh), B_N_CHILD (p_s_tb->FR[0],n_child_position)->dc_size);
+    }
+#endif
+
+ }
+ return CARRY_ON;
+}
+
+
+void * reiserfs_kmalloc (size_t size, int flags, struct super_block * s)
+{
+  void * vp;
+  static size_t malloced;
+
+
+  vp = kmalloc (size, flags);
+  if (vp) {
+    s->u.reiserfs_sb.s_kmallocs += size;
+    if (s->u.reiserfs_sb.s_kmallocs > malloced + 200000) {
+      reiserfs_warning ("vs-8301: reiserfs_kmalloc: allocated memory %d\n", s->u.reiserfs_sb.s_kmallocs);
+      malloced = s->u.reiserfs_sb.s_kmallocs;
+    }
+  }
+/*printk ("malloc : size %d, allocated %d\n", size, s->u.reiserfs_sb.s_kmallocs);*/
+  return vp;
+}
+
+void reiserfs_kfree (const void * vp, size_t size, struct super_block * s)
+{
+  kfree (vp);
+  
+  s->u.reiserfs_sb.s_kmallocs -= size;
+  if (s->u.reiserfs_sb.s_kmallocs < 0)
+    reiserfs_warning ("vs-8302: reiserfs_kfree: allocated memory %d\n", s->u.reiserfs_sb.s_kmallocs);
+
+}
+
+
+int get_virtual_node_size (struct super_block * sb, struct buffer_head * bh)
+{
+  int size = sizeof (struct virtual_item); /* for new item in case of insert */
+  int i, nr_items;
+  struct item_head * ih;
+
+
+  size = sizeof (struct virtual_node) + sizeof (struct virtual_item);
+  ih = B_N_PITEM_HEAD (bh, 0);
+  nr_items = B_NR_ITEMS (bh);
+  for (i = 0; i < nr_items; i ++, ih ++) {
+    /* each item occupies some space in virtual node */
+    size += sizeof (struct virtual_item);
+    if (I_IS_DIRECTORY_ITEM (ih))
+      /* each entry and new one occupeis 2 byte in the virtual node */
+      size += (I_ENTRY_COUNT (ih) + 1) * sizeof (__u16);
+  }
+  
+  /* 1 bit for each bitmap block to note whether bitmap block was
+     dirtied in the operation */
+  size += (SB_BMAP_NR (sb) * 2 / 8 + 4);
+  return size;
+}
+
+int get_mem_for_virtual_node (struct tree_balance * tb)
+{
+  int retval = CARRY_ON;
+  int size;
+  char * buf;
+
+  size = get_virtual_node_size (tb->tb_sb, PATH_PLAST_BUFFER(tb->tb_path));
+
+  if (size > tb->vn_buf_size) {
+    /* we have to allocate more memory for virtual node */
+    if (tb->vn_buf) {
+      /* free memory allocated before */
+      reiserfs_kfree (tb->vn_buf, tb->vn_buf_size, tb->tb_sb);
+      /* this is not needed if kfree is atomic */
+      retval |= SCHEDULE_OCCURRED;
+    }
+
+    tb->vn_buf_size = size;
+    /* get memory for virtual item */
+    buf = reiserfs_kmalloc(size, GFP_ATOMIC, tb->tb_sb);
+    if ( ! buf ) {
+      buf = reiserfs_kmalloc(size, GFP_KERNEL, tb->tb_sb);
+      if ( !buf ) {
+	    tb->vn_buf_size = 0;
+	    reiserfs_warning ("vs-8345: get_mem_for_virtual_node: kmalloc failed.  There were %d allocations\n",
+			  tb->tb_sb->u.reiserfs_sb.s_kmallocs);
+      }
+      retval |= SCHEDULE_OCCURRED;
+    }
+    tb->vn_buf = buf;
+  }
+
+  return retval;
+}
+
+/* Prepare for balancing, that is
+ *	get all necessary parents, and neighbors;
+ *	analyze what and where should be moved;
+ *	get sufficient number of new nodes;
+ * Balancing will start only after all resources will be collected at a time.
+ * 
+ * When ported to SMP kernels, only at the last moment after all needed nodes
+ * are collected in cache, will the resources be locked using the usual
+ * textbook ordered lock acquisition algorithms.  Note that ensuring that
+ * this code neither write locks what it does not need to write lock nor locks out of order
+ * will be a pain in the butt that could have been avoided.  Grumble grumble. -Hans
+ * 
+ * fix is meant in the sense of render unchanging
+ * 
+ * Latency might be improved by first gathering a list of what buffers are needed
+ * and then getting as many of them in parallel as possible? -Hans
+ *
+ * Parameters:
+ *	op_mode	i - insert, d - delete, c - cut (truncate), p - paste (append)
+ *	tb	tree_balance structure;
+ *	inum	item number in S[h];
+ *      pos_in_item - comment this if you can
+ *      ins_ih & ins_sd are used when inserting
+ * Returns:	1 - schedule occurred while the function worked;
+ *	        0 - schedule didn't occur while the function worked;
+ *             -1 - if no_disk_space 
+ */
+
+
+int fix_nodes (
+	    struct reiserfs_transaction_handle *th,
+	    int				n_op_mode,
+	    struct tree_balance * 	p_s_tb,
+	    int 		  	n_pos_in_item, 
+	    struct item_head    * 	p_s_ins_ih
+    ) {
+  int	n_ret_value,
+    	n_h,
+    	n_item_num = PATH_LAST_POSITION(p_s_tb->tb_path);
+  struct buffer_head  * p_s_tbS0 = PATH_PLAST_BUFFER(p_s_tb->tb_path);
+
+  /* if it possible in indirect_to_direct conversion */
+  if (buffer_locked (p_s_tbS0)) {
+    return SCHEDULE_OCCURRED;
+  }
+
+  /*
+if ( p_s_tbS0->b_count > 1)
+  {
+    reiserfs_warning ("Fix_nodes: S0: %b\n", p_s_tbS0);
+    if (p_s_tbS0->b_blocknr == 100)
+      *(int *)0 = 0;
+  }
+  */
+#ifdef REISERFS_CHECK_ONE_PROCESS
+  if ( p_s_tbS0->b_count > 1 || (p_s_tb->L[0] && p_s_tb->L[0]->b_count > 1) ||
+       (p_s_tb->R[0] && p_s_tb->R[0]->b_count > 1) ) {
+    printk ("mode=%c, insert_size=%d\n", n_op_mode, p_s_tb->insert_size[0]);
+    print_tb(0, 0, 0, p_s_tb, "first three parameters are invalid");
+    reiserfs_panic (p_s_tb->tb_sb, "PAP-8310: fix_nodes: all buffers must be hold once in one thread processing");
+  }
+#endif
+
+#ifdef REISERFS_CHECK
+  if ( cur_tb ) {
+    print_tb (n_op_mode, n_item_num, n_pos_in_item, cur_tb,"fix_nodes");
+    reiserfs_panic(p_s_tb->tb_sb,"PAP-8305: fix_nodes:  there is pending do_balance");
+  }
+
+  if (!buffer_uptodate (p_s_tbS0) || !B_IS_IN_TREE (p_s_tbS0)) {
+    reiserfs_panic (p_s_tb->tb_sb, "PAP-8320: fix_nodes: S[0] (%b %z) is not uptodate "
+		    "at the beginning of fix_nodes or not in tree (mode %c)", p_s_tbS0, p_s_tbS0, n_op_mode);
+  }
+
+  /* Check parameters. */
+  switch (n_op_mode) {
+#ifdef REISERFS_FSCK
+    case M_INTERNAL:
+      break;
+    case M_INSERT:
+      if ( n_item_num < 0 || n_item_num > B_NR_ITEMS(p_s_tbS0) )
+	reiserfs_panic(p_s_tb->tb_sb,"PAP-8325: fix_nodes: Incorrect item number %d (in S0 - %d) in case of insert",
+		       n_item_num, B_NR_ITEMS(p_s_tbS0));
+#else
+    case M_INSERT:
+      if ( n_item_num <= 0 || n_item_num > B_NR_ITEMS(p_s_tbS0) )
+	reiserfs_panic(p_s_tb->tb_sb,"PAP-8330: fix_nodes: Incorrect item number %d (in S0 - %d) in case of insert",
+		       n_item_num, B_NR_ITEMS(p_s_tbS0));
+#endif
+      break;
+    case M_PASTE:
+    case M_DELETE:
+    case M_CUT:
+      if ( n_item_num < 0 || n_item_num >= B_NR_ITEMS(p_s_tbS0) ) {
+	print_block (p_s_tbS0, 0, -1, -1);
+	printk("mode = %c insert_size = %d\n", n_op_mode, p_s_tb->insert_size[0]);
+	reiserfs_panic(p_s_tb->tb_sb,"PAP-8335: fix_nodes: Incorrect item number(%d)", n_item_num);
+      }
+      break;
+    default:
+      reiserfs_panic(p_s_tb->tb_sb,"PAP-8340: fix_nodes: Incorrect mode of operation");
+  }
+#endif
+
+  if (! p_s_tb->vn_buf)
+    p_s_tb->tb_sb->u.reiserfs_sb.lock_preserve ++;
+
+  if (get_mem_for_virtual_node (p_s_tb) == SCHEDULE_OCCURRED) {
+    return SCHEDULE_OCCURRED;
+  }
+
+#if 0
+  /* get two empty nodes those will be used for preserving of shifted items */
+  if  ( (n_ret_value = ready_preserve_list (p_s_tb, p_s_tbS0)) != CARRY_ON ) {
+    return n_ret_value; /* No disk space, or schedule occurred */
+  }
+#endif
+
+  /* Starting from the leaf level; for all levels n_h of the tree. */
+  for ( n_h = 0; n_h < MAX_HEIGHT && p_s_tb->insert_size[n_h]; n_h++ ) { 
+    if ( (n_ret_value = get_direct_parent(p_s_tb, n_h)) != CARRY_ON ) {
+      return n_ret_value;
+    }
+
+    if ( (n_ret_value = check_balance (th, n_op_mode, p_s_tb, n_h, n_item_num,
+				       n_pos_in_item, p_s_ins_ih)) != CARRY_ON ) {
+      if ( n_ret_value == NO_BALANCING_NEEDED ) {
+        /* No balancing for higher levels needed. */
+	if ( (n_ret_value = get_neighbors(p_s_tb, n_h)) != CARRY_ON ) {
+	  return n_ret_value;
+	}
+        if ( n_h != MAX_HEIGHT - 1 )  
+	   p_s_tb->insert_size[n_h + 1] = 0;
+	/* ok, analysis and resource gathering are complete */
+        break;
+      }
+
+      return n_ret_value;
+    }
+
+    if ( (n_ret_value = get_neighbors(p_s_tb, n_h)) != CARRY_ON ) {
+      return n_ret_value;
+    }
+
+    if ( (n_ret_value = get_empty_nodes(th, p_s_tb, n_h)) != CARRY_ON ) {
+      return n_ret_value; /* No disk space, or schedule occurred and
+			     analysis may be invalid and needs to be redone. */
+    }
+    
+    if ( ! PATH_H_PBUFFER(p_s_tb->tb_path, n_h) ) {
+      /* We have a positive insert size but no nodes exist on this
+	 level, this means that we are creating a new root. */
+
+#ifdef REISERFS_CHECK
+      if ( p_s_tb->blknum[n_h] != 1 )
+        reiserfs_panic(p_s_tb->tb_sb,"PAP-8350: fix_nodes: creating new empty root");
+#endif /* REISERFS_CHECK */
+
+      if ( n_h < MAX_HEIGHT - 1 )
+	      p_s_tb->insert_size[n_h + 1] = 0;
+    }
+    else
+      if ( ! PATH_H_PBUFFER(p_s_tb->tb_path, n_h + 1) ) {
+        if ( p_s_tb->blknum[n_h] > 1 ) {
+	  /* The tree needs to be grown, so this node S[n_h]
+	     which is the root node is split into two nodes, and
+	     a new node (S[n_h+1]) will be created to become the root node.  */
+	  
+#ifdef REISERFS_CHECK
+	  if ( n_h == MAX_HEIGHT - 1 )
+            reiserfs_panic(p_s_tb->tb_sb, "PAP-8355: fix_nodes: attempt to create too high of a tree");
+#endif /* REISERFS_CHECK */
+
+          p_s_tb->insert_size[n_h + 1] = (DC_SIZE + KEY_SIZE) * (p_s_tb->blknum[n_h] - 1) + DC_SIZE;
+        }
+        else
+	  if ( n_h < MAX_HEIGHT - 1 )
+	    p_s_tb->insert_size[n_h + 1] = 0;
+      }
+      else
+        p_s_tb->insert_size[n_h + 1] = (DC_SIZE + KEY_SIZE) * (p_s_tb->blknum[n_h] - 1);
+  }
+
+  return CARRY_ON; /* schedule did not occur */
+}
+
+
+void unfix_nodes(
+		 struct reiserfs_transaction_handle *th,
+		 struct tree_balance * p_s_tb
+		 ) {
+  struct path * p_s_path = p_s_tb->tb_path;
+  int		n_counter;
+  int i, j;
+  struct buffer_head * bh;
+
+#ifdef REISERFS_CHECK
+  if ( ! p_s_tb->vn_buf )
+    reiserfs_panic (p_s_tb->tb_sb,
+		    "PAP-16050: unfix_nodes: pointer to the virtual node is NULL");
+  if (p_s_tb->tb_sb->u.reiserfs_sb.lock_preserve == 0)
+    reiserfs_panic (p_s_tb->tb_sb, "vs-16052: unfix_nodes: lock_preserve is 0");
+#endif
+
+  p_s_tb->tb_sb->u.reiserfs_sb.lock_preserve --;
+
+
+  /* Release new root if it is. */
+/*  brelse(PATH_OFFSET_PBUFFER(p_s_path, ILLEGAL_PATH_ELEMENT_OFFSET));*/
+
+
+  /*
+  if (PATH_PLAST_BUFFER(p_s_path)->b_count > 1) {
+    reiserfs_warning ("unfix_nodes: S0: %b\n", PATH_PLAST_BUFFER(p_s_path));
+    if (PATH_PLAST_BUFFER(p_s_path)->b_blocknr == 100)
+      *(int *)0 = 0;
+  }
+  */
+
+  /* Release path buffers. */
+  pathrelse(p_s_path);
+
+
+  for ( n_counter = 0; n_counter < MAX_HEIGHT; n_counter++ ) {
+    /* Release fathers and neighbors. */
+    brelse(p_s_tb->L[n_counter]);
+    brelse(p_s_tb->R[n_counter]);
+    brelse(p_s_tb->FL[n_counter]);
+    brelse(p_s_tb->FR[n_counter]);
+    brelse(p_s_tb->CFL[n_counter]);
+    brelse(p_s_tb->CFR[n_counter]);
+  }
+
+  /* Could be optimized. Will be done by PAP someday */
+  for ( n_counter = 0; n_counter < MAX_FEB_SIZE; n_counter++ ) {
+    if ( p_s_tb->FEB[n_counter] ) {
+      /* release what was not used */
+      reiserfs_free_block(th, p_s_tb->tb_sb, p_s_tb->FEB[n_counter]->b_blocknr);
+      COMPLETE_BITMAP_DIRTING_AFTER_FREEING(p_s_tb->tb_sb, p_s_tb->FEB[n_counter]->b_blocknr / (p_s_tb->tb_sb->s_blocksize * 8));
+
+      bforget(p_s_tb->FEB[n_counter]);
+      /* tree balance bitmap of bitmaps has bit set already */
+    }
+    /* release used as new nodes including a new root */
+    brelse (p_s_tb->used[n_counter]);
+  }
+
+  /* free nodes which had to be used in preserving, but are left unused */
+  for (n_counter = 0; n_counter < MAX_PRESERVE_NODES; n_counter ++) {
+    if (p_s_tb->tb_nodes_for_preserving[n_counter]) {
+      reiserfs_free_block(th, p_s_tb->tb_sb, p_s_tb->tb_nodes_for_preserving[n_counter]->b_blocknr);
+      COMPLETE_BITMAP_DIRTING_AFTER_FREEING(p_s_tb->tb_sb, 
+					    p_s_tb->tb_nodes_for_preserving[n_counter]->b_blocknr / (p_s_tb->tb_sb->s_blocksize * 8));
+      bforget(p_s_tb->tb_nodes_for_preserving[n_counter]);
+      /* tree balance bitmap of bitmaps has bit set already */
+    }
+    /* release buffers containing preserved nodes */
+    brelse (p_s_tb->preserved[n_counter]);
+  }
+
+  /* if any of bitmaps was dirtied atomically, then DIRTY_BITMAP_MAP
+     has corresponding bit set. If so, do b_count++ and brelse for the
+     buffer. It will refile_buffer to the correct list */
+  for (i = 0, j = 0; i < SB_BMAP_NR (p_s_tb->tb_sb); i ++) {
+    if (test_bit (i, DIRTY_BITMAP_MAP (p_s_tb))) {
+      bh = SB_AP_BITMAP (p_s_tb->tb_sb)[i];
+      bh->b_count ++;
+      brelse (bh);
+      j ++;
+    }
+  }
+
+  reiserfs_kfree (DIRTY_BITMAP_MAP (p_s_tb), p_s_tb->vn_buf_size, p_s_tb->tb_sb);
+
+  if (j) {
+    /* super block was dirtied atomically in reiserfs_free_block, or
+       in reiserfs_new_blocknrs. Make sure it is refiled */
+    SB_BUFFER_WITH_SB (p_s_tb->tb_sb)->b_count ++;
+    brelse (SB_BUFFER_WITH_SB (p_s_tb->tb_sb));
+  }
+} 
+
+
+
+
+
+
Index: empeg/kernel/fs/reiserfs/ibalance.c
diff -u /dev/null empeg/kernel/fs/reiserfs/ibalance.c:1.1
--- /dev/null	Wed Oct 17 16:36:05 2001
+++ empeg/kernel/fs/reiserfs/ibalance.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,1159 @@
+/*
+ * Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
+ */
+
+#ifdef __KERNEL__
+
+#include <asm/uaccess.h>
+#include <linux/string.h>
+#include <linux/sched.h>
+#include <linux/reiserfs_fs.h>
+
+#else
+
+#include "nokernel.h"
+
+#endif
+
+
+/* this is one and only function that is used outside (do_balance.c) */
+int	balance_internal (
+			  struct reiserfs_transaction_handle *th,
+			  struct tree_balance * ,
+			  int,
+			  int,
+			  struct item_head * ,
+			  struct buffer_head ** 
+			  );
+#ifdef REISERFS_CHECK
+extern struct buffer_head *buffers[MAX_HEIGHT];
+#endif
+
+/* modes of internal_shift_left, internal_shift_right and internal_insert_childs */
+#define INTERNAL_SHIFT_FROM_S_TO_L 0
+#define INTERNAL_SHIFT_FROM_R_TO_S 1
+#define INTERNAL_SHIFT_FROM_L_TO_S 2
+#define INTERNAL_SHIFT_FROM_S_TO_R 3
+#define INTERNAL_INSERT_TO_S 4
+#define INTERNAL_INSERT_TO_L 5
+#define INTERNAL_INSERT_TO_R 6
+
+static void	internal_define_dest_src_infos (
+						int shift_mode,
+						struct tree_balance * tb,
+						int h,
+						struct buffer_info * dest_bi,
+						struct buffer_info * src_bi,
+						int * d_key,
+						struct buffer_head ** cf
+						)
+{
+#ifdef REISERFS_CHECK
+  memset (dest_bi, 0, sizeof (struct buffer_info));
+  memset (src_bi, 0, sizeof (struct buffer_info));
+#endif
+  /* define dest, src, dest parent, dest position */
+  switch (shift_mode) {
+  case INTERNAL_SHIFT_FROM_S_TO_L:	/* used in internal_shift_left */
+    src_bi->bi_bh = PATH_H_PBUFFER (tb->tb_path, h);
+    src_bi->bi_parent = PATH_H_PPARENT (tb->tb_path, h);
+    src_bi->bi_position = PATH_H_POSITION (tb->tb_path, h + 1);
+    dest_bi->bi_bh = tb->L[h];
+    dest_bi->bi_parent = tb->FL[h];
+    dest_bi->bi_position = get_left_neighbor_position (tb, h);
+    *d_key = tb->lkey[h];
+    *cf = tb->CFL[h];
+    break;
+  case INTERNAL_SHIFT_FROM_L_TO_S:
+    src_bi->bi_bh = tb->L[h];
+    src_bi->bi_parent = tb->FL[h];
+    src_bi->bi_position = get_left_neighbor_position (tb, h);
+    dest_bi->bi_bh = PATH_H_PBUFFER (tb->tb_path, h);
+    dest_bi->bi_parent = PATH_H_PPARENT (tb->tb_path, h);
+    dest_bi->bi_position = PATH_H_POSITION (tb->tb_path, h + 1); /* dest position is analog of dest->b_item_order */
+    *d_key = tb->lkey[h];
+    *cf = tb->CFL[h];
+    break;
+
+  case INTERNAL_SHIFT_FROM_R_TO_S:	/* used in internal_shift_left */
+    src_bi->bi_bh = tb->R[h];
+    src_bi->bi_parent = tb->FR[h];
+    src_bi->bi_position = get_right_neighbor_position (tb, h);
+    dest_bi->bi_bh = PATH_H_PBUFFER (tb->tb_path, h);
+    dest_bi->bi_parent = PATH_H_PPARENT (tb->tb_path, h);
+    dest_bi->bi_position = PATH_H_POSITION (tb->tb_path, h + 1);
+    *d_key = tb->rkey[h];
+    *cf = tb->CFR[h];
+    break;
+  case INTERNAL_SHIFT_FROM_S_TO_R:
+    src_bi->bi_bh = PATH_H_PBUFFER (tb->tb_path, h);
+    src_bi->bi_parent = PATH_H_PPARENT (tb->tb_path, h);
+    src_bi->bi_position = PATH_H_POSITION (tb->tb_path, h + 1);
+    dest_bi->bi_bh = tb->R[h];
+    dest_bi->bi_parent = tb->FR[h];
+    dest_bi->bi_position = get_right_neighbor_position (tb, h);
+    *d_key = tb->rkey[h];
+    *cf = tb->CFR[h];
+    break;
+
+  case INTERNAL_INSERT_TO_L:
+    dest_bi->bi_bh = tb->L[h];
+    dest_bi->bi_parent = tb->FL[h];
+    dest_bi->bi_position = get_left_neighbor_position (tb, h);
+    break;
+
+  case INTERNAL_INSERT_TO_S:
+    dest_bi->bi_bh = PATH_H_PBUFFER (tb->tb_path, h);
+    dest_bi->bi_parent = PATH_H_PPARENT (tb->tb_path, h);
+    dest_bi->bi_position = PATH_H_POSITION (tb->tb_path, h + 1);
+    break;
+
+  case INTERNAL_INSERT_TO_R:
+    dest_bi->bi_bh = tb->R[h];
+    dest_bi->bi_parent = tb->FR[h];
+    dest_bi->bi_position = get_right_neighbor_position (tb, h);
+    break;
+
+  default:
+    reiserfs_panic (tb->tb_sb, "internal_define_dest_src_infos", "shift type is unknown (%d)", shift_mode);
+  }
+}
+
+
+
+/* Insert count node pointers into buffer cur before position to + 1.
+ * Insert count items into buffer cur before position to.
+ * Items and node pointers are specified by inserted and bh respectively.
+ */ 
+static void	internal_insert_childs (
+					struct reiserfs_transaction_handle *th, 
+					struct buffer_info * cur_bi,
+					/*	struct buffer_head * prev_cur,*/
+					int to, int count,
+					struct item_head * inserted,
+					struct buffer_head ** bh
+					)
+{
+  struct buffer_head * cur = cur_bi->bi_bh;
+  struct block_head * blkh;
+  int nr;
+  struct key * ih;
+  struct disk_child new_dc[2];
+  struct disk_child * dc;
+  struct super_block *s ;
+  int i;
+
+  if (count <= 0)
+    return;
+
+  nr = (blkh = B_BLK_HEAD(cur))->blk_nr_item;
+
+#ifdef REISERFS_CHECK
+  if (count > 2)
+    reiserfs_panic (0, "internal_insert_childs", "too many children (%d) are to be inserted", count);
+  if (blkh->blk_free_space < count * (KEY_SIZE + DC_SIZE))
+    reiserfs_panic (0, "internal_insert_childs", "no enough free space (%d), needed %d bytes", 
+		    blkh->blk_free_space, count * (KEY_SIZE + DC_SIZE));
+#endif /* REISERFS_CHECK */
+
+  /* prepare space for count disk_child */
+  dc = B_N_CHILD(cur,to+1);
+
+  memmove (dc + count, dc, (nr+1-(to+1)) * DC_SIZE);
+
+  /* copy to_be_insert disk children */
+  for (i = 0; i < count; i ++) {
+    new_dc[i].dc_size =
+      MAX_CHILD_SIZE(bh[i]) - B_BLK_HEAD(bh[i])->blk_free_space;
+    new_dc[i].dc_block_number = bh[i]->b_blocknr;
+  }
+  memcpy (dc, new_dc, DC_SIZE * count);
+
+  
+  /* prepare space for count items  */
+  ih = B_N_PDELIM_KEY (cur, ((to == -1) ? 0 : to));
+
+  memmove (ih + count, ih, (nr - to) * KEY_SIZE + (nr + 1 + count) * DC_SIZE);
+
+  /* copy item headers (keys) */
+  memcpy (ih, inserted, KEY_SIZE);
+  if ( count > 1 )
+    memcpy (ih + 1, inserted + 1, KEY_SIZE);
+
+  /* sizes, item number */
+  blkh->blk_nr_item += count;
+  blkh->blk_free_space -= count * (DC_SIZE + KEY_SIZE);
+
+  /* reiserfs_mark_buffer_dirty(cur,0);	journal victim */ /* not preserved, internal */
+  s = th->t_super ;
+  journal_mark_dirty(th, s, cur);/* not preserved, internal */
+
+
+  if (cur_bi->bi_parent) {
+    B_N_CHILD (cur_bi->bi_parent,cur_bi->bi_position)->dc_size += count * (DC_SIZE + KEY_SIZE);
+    /* reiserfs_mark_buffer_dirty(cur_bi->bi_parent,0); journal victim */	/* not preserved, internal */
+    journal_mark_dirty(th, s, cur_bi->bi_parent);	/* not preserved, internal */
+  }
+
+}
+
+
+/* Delete del_num items and node pointers from buffer cur starting from *
+ * the first_i'th item and first_p'th pointers respectively.		*/
+static void	internal_delete_pointers_items (
+						struct reiserfs_transaction_handle *th,
+						struct buffer_info * cur_bi,
+						int first_p, 
+						int first_i, 
+						int del_num
+						)
+{
+  struct buffer_head * cur = cur_bi->bi_bh;
+  int nr;
+  struct block_head * blkh;
+  struct key * key;
+  struct disk_child * dc;
+  struct super_block *s ;
+
+#ifdef REISERFS_CHECK
+  if (cur == NULL)
+    reiserfs_panic (0, "internal_delete_pointers_items1: buffer is 0");
+	
+  if (del_num < 0)
+    reiserfs_panic (0, "internal_delete_pointers_items2",
+		    "negative number of items (%d) can not be deleted", del_num);
+
+  if (first_p < 0 || first_p + del_num > B_NR_ITEMS (cur) + 1 || first_i < 0)
+    reiserfs_panic (0, "internal_delete_pointers_items3",
+		    "first pointer order (%d) < 0 or "
+		    "no so many pointers (%d), only (%d) or "
+		    "first key order %d < 0", first_p, 
+		    first_p + del_num, B_NR_ITEMS (cur) + 1, first_i);
+#endif /* REISERFS_CHECK */
+  if ( del_num == 0 )
+    return;
+
+  nr = (blkh = B_BLK_HEAD(cur))->blk_nr_item;
+
+  if ( first_p == 0 && del_num == nr + 1 ) {
+#ifdef REISERFS_CHECK
+    if ( first_i != 0 )
+      reiserfs_panic (0, "internal_delete_pointers_items5",
+		      "first deleted key must have order 0, not %d", first_i);
+#endif /* REISERFS_CHECK */
+    make_empty_node (cur_bi);
+    return;
+  }
+
+#ifdef REISERFS_CHECK
+  if (first_i + del_num > B_NR_ITEMS (cur)) {
+    printk("first_i = %d del_num = %d\n",first_i,del_num);
+    reiserfs_panic (0, "internal_delete_pointers_items4: :"
+		    "no so many keys (%d) in the node (%b)(%z)", first_i + del_num, cur, cur);
+  }
+#endif /* REISERFS_CHECK */
+
+
+  /* deleting */
+  dc = B_N_CHILD (cur, first_p);
+
+  memmove (dc, dc + del_num, (nr + 1 - first_p - del_num) * DC_SIZE);
+  key = B_N_PDELIM_KEY (cur, first_i);
+  memmove (key, key + del_num, (nr - first_i - del_num) * KEY_SIZE + (nr + 1 - del_num) * DC_SIZE);
+
+
+  /* sizes, item number */
+  blkh->blk_nr_item -= del_num;
+  blkh->blk_free_space += del_num * (KEY_SIZE +  DC_SIZE);
+
+  s = th->t_super ;
+  /* reiserfs_mark_buffer_dirty (cur, 0); journal victim */
+  journal_mark_dirty (th, s, cur);
+
+ 
+  if (cur_bi->bi_parent) {
+    B_N_CHILD (cur_bi->bi_parent, cur_bi->bi_position)->dc_size -= del_num * (KEY_SIZE +  DC_SIZE);
+    /* reiserfs_mark_buffer_dirty(cur_bi->bi_parent,0); journal victim */	/* not preserved, internal */
+    journal_mark_dirty(th, s, cur_bi->bi_parent);	/* not preserved, internal */
+  }
+}
+
+
+/* delete n node pointers and items starting from given position */
+static void	internal_delete_childs (
+					struct reiserfs_transaction_handle *th,
+					struct buffer_info * cur_bi, 
+					int from, 
+					int n
+					)
+{
+  int i_from;
+
+  i_from = (from == 0) ? from : from - 1;
+
+  /* delete n pointers starting from `from' position in CUR;
+     delete n keys starting from 'i_from' position in CUR;
+     */
+  internal_delete_pointers_items (th, cur_bi, from, i_from, n);
+}
+
+
+/* copy cpy_num node pointers and cpy_num - 1 items from buffer src to buffer dest
+* last_first == FIRST_TO_LAST means, that we copy first items from src to tail of dest
+ * last_first == LAST_TO_FIRST means, that we copy last items from src to head of dest 
+ */
+static void internal_copy_pointers_items (
+					  struct reiserfs_transaction_handle *th,
+					  struct buffer_info * dest_bi,
+					  struct buffer_head * src,
+					  int last_first, int cpy_num
+					  )
+{
+  /* ATTENTION! Number of node pointers in DEST is equal to number of items in DEST *
+   * as delimiting key have already inserted to buffer dest.*/
+  struct buffer_head * dest = dest_bi->bi_bh;
+  int nr_dest, nr_src;
+  int dest_order, src_order;
+  struct block_head * blkh;
+  struct key * key;
+  struct disk_child * dc;
+  struct super_block *s ;
+
+  nr_src = B_NR_ITEMS (src);
+
+#ifdef REISERFS_CHECK
+  if ( dest == NULL || src == NULL )
+    reiserfs_panic (0, "internal_copy_pointers_items", "src (%p) or dest (%p) buffer is 0", src, dest);
+
+  if (last_first != FIRST_TO_LAST && last_first != LAST_TO_FIRST)
+    reiserfs_panic (0, "internal_copy_pointers_items",
+		    "invalid last_first parameter (%d)", last_first);
+
+  if ( nr_src < cpy_num - 1 )
+    reiserfs_panic (0, "internal_copy_pointers_items", "no so many items (%d) in src (%d)", cpy_num, nr_src);
+
+  if ( cpy_num < 0 )
+    reiserfs_panic (0, "internal_copy_pointers_items", "cpy_num less than 0 (%d)", cpy_num);
+
+  if (cpy_num - 1 + B_NR_ITEMS(dest) > (int)MAX_NR_KEY(dest))
+    reiserfs_panic (0, "internal_copy_pointers_items",
+		    "cpy_num (%d) + item number in dest (%d) can not be more than MAX_NR_KEY(%d)",
+		    cpy_num, B_NR_ITEMS(dest), MAX_NR_KEY(dest));
+#endif
+
+  if ( cpy_num == 0 )
+    return;
+
+	/* coping */
+  nr_dest = (blkh = B_BLK_HEAD(dest))->blk_nr_item;
+
+  /*dest_order = (last_first == LAST_TO_FIRST) ? 0 : nr_dest;*/
+  /*src_order = (last_first == LAST_TO_FIRST) ? (nr_src - cpy_num + 1) : 0;*/
+  (last_first == LAST_TO_FIRST) ?	(dest_order = 0, src_order = nr_src - cpy_num + 1) :
+    (dest_order = nr_dest, src_order = 0);
+
+  /* prepare space for cpy_num pointers */
+  dc = B_N_CHILD (dest, dest_order);
+
+  memmove (dc + cpy_num, dc, (nr_dest - dest_order) * DC_SIZE);
+
+	/* insert pointers */
+  memcpy (dc, B_N_CHILD (src, src_order), DC_SIZE * cpy_num);
+
+
+  /* prepare space for cpy_num - 1 item headers */
+  key = B_N_PDELIM_KEY(dest, dest_order);
+  memmove (key + cpy_num - 1, key,
+	   KEY_SIZE * (nr_dest - dest_order) + DC_SIZE * (nr_dest + cpy_num));
+
+
+  /* insert headers */
+  memcpy (key, B_N_PDELIM_KEY (src, src_order), KEY_SIZE * (cpy_num - 1));
+
+  /* sizes, item number */
+  blkh->blk_nr_item += cpy_num - 1;
+  blkh->blk_free_space -= KEY_SIZE * (cpy_num - 1) + DC_SIZE * cpy_num;
+
+  s = th->t_super ;
+  /* reiserfs_mark_buffer_dirty(dest,0); journal victim */
+  journal_mark_dirty(th, s, dest);
+  if (dest_bi->bi_parent) {
+    B_N_CHILD(dest_bi->bi_parent,dest_bi->bi_position)->dc_size +=
+      KEY_SIZE * (cpy_num - 1) + DC_SIZE * cpy_num;
+
+    /* not preserved, preserves are in balance_leaf() and  balance_leaf_when_delete() */
+    /* reiserfs_mark_buffer_dirty (dest_bi->bi_parent,0); journal victim */	
+    journal_mark_dirty(th, s, dest_bi->bi_parent);	
+  }
+
+}
+
+
+/* Copy cpy_num node pointers and cpy_num - 1 items from buffer src to buffer dest.
+ * Delete cpy_num - del_par items and node pointers from buffer src.
+ * last_first == FIRST_TO_LAST means, that we copy/delete first items from src.
+ * last_first == LAST_TO_FIRST means, that we copy/delete last items from src.
+ */
+static void	internal_move_pointers_items (
+					      struct reiserfs_transaction_handle *th,
+					      struct buffer_info * dest_bi, 
+					      struct buffer_info * src_bi, 
+					      int last_first, int cpy_num, int del_par
+					      )
+{
+  int first_pointer;
+  int first_item;
+
+  internal_copy_pointers_items (th, dest_bi, src_bi->bi_bh, last_first, cpy_num);
+
+
+  if (last_first == FIRST_TO_LAST) {	/* shift_left occurs */
+    first_pointer = 0;
+    first_item = 0;
+    /* delete cpy_num - del_par pointers and keys starting for pointers with first_pointer, 
+       for key - with first_item */
+    internal_delete_pointers_items (th, src_bi, first_pointer, first_item, cpy_num - del_par);
+  } else {			/* shift_right occurs */
+    int i, j;
+
+    i = ( cpy_num - del_par == ( j = B_NR_ITEMS(src_bi->bi_bh)) + 1 ) ? 0 : j - cpy_num + del_par;
+
+    internal_delete_pointers_items (th, src_bi, j + 1 - cpy_num + del_par, i, cpy_num - del_par);
+  }
+}
+
+/* Insert n_src'th key of buffer src before n_dest'th key of buffer dest. */
+static void internal_insert_key (
+				 struct reiserfs_transaction_handle *th,
+				 struct buffer_info * dest_bi, 
+				 int dest_position_before,                 /* insert key before key with n_dest number */
+				 struct buffer_head * src, 
+				 int src_position
+				 )
+{
+  struct buffer_head * dest = dest_bi->bi_bh;
+  int nr;
+  struct block_head * blkh;
+  struct key * key;
+  struct super_block *s ;
+
+#ifdef REISERFS_CHECK
+  if (dest == NULL || src == NULL)
+    reiserfs_panic (0, "internal_insert_key", "sourse(%p) or dest(%p) buffer is 0", src, dest);
+
+  if (dest_position_before < 0 || src_position < 0)
+    reiserfs_panic (0, "internal_insert_key", "source(%d) or dest(%d) key number less than 0", 
+		    src_position, dest_position_before);
+
+  if (dest_position_before > B_NR_ITEMS (dest) || src_position >= B_NR_ITEMS(src))
+    reiserfs_panic (0, "internal_insert_key", 
+		    "invalid position in dest (%d (key number %d)) or in src (%d (key number %d))",
+		    dest_position_before, B_NR_ITEMS (dest), src_position, B_NR_ITEMS(src));
+
+  if (B_BLK_HEAD(dest)->blk_free_space < KEY_SIZE)
+    reiserfs_panic (0, "internal_insert_key", 
+		    "no enough free space (%d) in dest buffer", B_BLK_HEAD(dest)->blk_free_space);
+#endif
+
+  nr = (blkh=B_BLK_HEAD(dest))->blk_nr_item;
+
+  /* prepare space for inserting key */
+  key = B_N_PDELIM_KEY (dest, dest_position_before);
+  memmove (key + 1, key, (nr - dest_position_before) * KEY_SIZE + (nr + 1) * DC_SIZE);
+
+  /* insert key */
+  memcpy (key, B_N_PDELIM_KEY(src, src_position), KEY_SIZE);
+
+  /* Change dirt, free space, item number fields. */
+  blkh->blk_nr_item ++;
+  blkh->blk_free_space -= KEY_SIZE;
+
+  s = th->t_super ;
+  journal_mark_dirty(th, s, dest);
+
+  if (dest_bi->bi_parent) {
+    B_N_CHILD(dest_bi->bi_parent,dest_bi->bi_position)->dc_size += KEY_SIZE;
+    journal_mark_dirty(th, s, dest_bi->bi_parent); /* not preserved, preserves are in balance_leaf() and 
+    							balance_leaf_when_delete() */
+  }
+}
+
+
+
+/* Insert d_key'th (delimiting) key from buffer cfl to tail of dest. 
+ * Copy pointer_amount node pointers and pointer_amount - 1 items from buffer src to buffer dest.
+ * Replace  d_key'th key in buffer cfl.
+ * Delete pointer_amount items and node pointers from buffer src.
+ */
+/* this can be invoked both to shift from S to L and from R to S */
+static void	internal_shift_left (
+				     struct reiserfs_transaction_handle *th,
+				     int mode,	/* INTERNAL_FROM_S_TO_L | INTERNAL_FROM_R_TO_S */
+				     struct tree_balance * tb,
+				     int h,
+				     int pointer_amount
+				     )
+{
+  struct buffer_info dest_bi, src_bi;
+  struct buffer_head * cf;
+  int d_key_position;
+
+  internal_define_dest_src_infos (mode, tb, h, &dest_bi, &src_bi, &d_key_position, &cf);
+
+  /*printk("pointer_amount = %d\n",pointer_amount);*/
+
+  if (pointer_amount) {
+    /* insert delimiting key from common father of dest and src to node dest into position B_NR_ITEM(dest) */
+    internal_insert_key (th, &dest_bi, B_NR_ITEMS(dest_bi.bi_bh), cf, d_key_position);
+
+    if (B_NR_ITEMS(src_bi.bi_bh) == pointer_amount - 1) {
+      if (src_bi.bi_position/*src->b_item_order*/ == 0)
+	replace_key (th, cf, d_key_position, src_bi.bi_parent/*src->b_parent*/, 0);
+    } else
+      replace_key (th, cf, d_key_position, src_bi.bi_bh, pointer_amount - 1);
+  }
+  /* last parameter is del_parameter */
+  internal_move_pointers_items (th, &dest_bi, &src_bi, FIRST_TO_LAST, pointer_amount, 0);
+
+}
+
+/* Insert delimiting key to L[h].
+ * Copy n node pointers and n - 1 items from buffer S[h] to L[h].
+ * Delete n - 1 items and node pointers from buffer S[h].
+ */
+/* it always shifts from S[h] to L[h] */
+static void	internal_shift1_left (
+				      struct reiserfs_transaction_handle *th,
+				      struct tree_balance * tb, 
+				      int h, 
+				      int pointer_amount
+				      )
+{
+  struct buffer_info dest_bi, src_bi;
+  struct buffer_head * cf;
+  int d_key_position;
+
+  internal_define_dest_src_infos (INTERNAL_SHIFT_FROM_S_TO_L, tb, h, &dest_bi, &src_bi, &d_key_position, &cf);
+
+  if ( pointer_amount > 0 ) /* insert lkey[h]-th key  from CFL[h] to left neighbor L[h] */
+    internal_insert_key (th, &dest_bi, B_NR_ITEMS(dest_bi.bi_bh), cf, d_key_position);
+  /*		internal_insert_key (tb->L[h], B_NR_ITEM(tb->L[h]), tb->CFL[h], tb->lkey[h]);*/
+
+  /* last parameter is del_parameter */
+  internal_move_pointers_items (th, &dest_bi, &src_bi, FIRST_TO_LAST, pointer_amount, 1);
+  /*	internal_move_pointers_items (tb->L[h], tb->S[h], FIRST_TO_LAST, pointer_amount, 1);*/
+}
+
+
+/* Insert d_key'th (delimiting) key from buffer cfr to head of dest. 
+ * Copy n node pointers and n - 1 items from buffer src to buffer dest.
+ * Replace  d_key'th key in buffer cfr.
+ * Delete n items and node pointers from buffer src.
+ */
+static void internal_shift_right (
+				  struct reiserfs_transaction_handle *th,
+				  int mode,	/* INTERNAL_FROM_S_TO_R | INTERNAL_FROM_L_TO_S */
+				  struct tree_balance * tb,
+				  int h,
+				  int pointer_amount
+				  )
+{
+  struct buffer_info dest_bi, src_bi;
+  struct buffer_head * cf;
+  int d_key_position;
+  int nr;
+
+
+  internal_define_dest_src_infos (mode, tb, h, &dest_bi, &src_bi, &d_key_position, &cf);
+
+  nr = B_NR_ITEMS (src_bi.bi_bh);
+
+  if (pointer_amount > 0) {
+    /* insert delimiting key from common father of dest and src to dest node into position 0 */
+    internal_insert_key (th, &dest_bi, 0, cf, d_key_position);
+    if (nr == pointer_amount - 1) {
+#ifdef REISERFS_CHECK
+      if ( src_bi.bi_bh != PATH_H_PBUFFER (tb->tb_path, h)/*tb->S[h]*/ || dest_bi.bi_bh != tb->R[h])
+	reiserfs_panic (tb->tb_sb, "internal_shift_right", "src (%p) must be == tb->S[h](%p) when it disappears",
+			src_bi.bi_bh, PATH_H_PBUFFER (tb->tb_path, h));
+#endif
+      /* when S[h] disappers replace left delemiting key as well */
+      if (tb->CFL[h])
+	replace_key(th, cf, d_key_position, tb->CFL[h], tb->lkey[h]);
+    } else
+      replace_key(th, cf, d_key_position, src_bi.bi_bh, nr - pointer_amount);
+  }      
+
+  /* last parameter is del_parameter */
+  internal_move_pointers_items (th, &dest_bi, &src_bi, LAST_TO_FIRST, pointer_amount, 0);
+}
+
+/* Insert delimiting key to R[h].
+ * Copy n node pointers and n - 1 items from buffer S[h] to R[h].
+ * Delete n - 1 items and node pointers from buffer S[h].
+ */
+/* it always shift from S[h] to R[h] */
+static void	internal_shift1_right (
+				       struct reiserfs_transaction_handle *th,
+				       struct tree_balance * tb, 
+				       int h, 
+				       int pointer_amount
+				       )
+{
+  struct buffer_info dest_bi, src_bi;
+  struct buffer_head * cf;
+  int d_key_position;
+
+  internal_define_dest_src_infos (INTERNAL_SHIFT_FROM_S_TO_R, tb, h, &dest_bi, &src_bi, &d_key_position, &cf);
+
+  if (pointer_amount > 0) /* insert rkey from CFR[h] to right neighbor R[h] */
+    internal_insert_key (th, &dest_bi, 0, cf, d_key_position);
+  /*		internal_insert_key (tb->R[h], 0, tb->CFR[h], tb->rkey[h]);*/
+	
+  /* last parameter is del_parameter */
+  internal_move_pointers_items (th, &dest_bi, &src_bi, LAST_TO_FIRST, pointer_amount, 1);
+  /*	internal_move_pointers_items (tb->R[h], tb->S[h], LAST_TO_FIRST, pointer_amount, 1);*/
+}
+
+
+/* Delete insert_num node pointers together with their left items
+ * and balance current node.*/
+static void	balance_internal_when_delete (
+					      struct reiserfs_transaction_handle *th,
+					      struct tree_balance * tb, 
+					      int h, 
+					      int child_pos
+					      )
+{
+  int insert_num;
+  int n;
+  struct buffer_head * tbSh = PATH_H_PBUFFER (tb->tb_path, h);
+  struct buffer_info bi;
+
+  insert_num = tb->insert_size[h] / ((int)(DC_SIZE + KEY_SIZE));
+  
+  /* delete child-node-pointer(s) together with their left item(s) */
+  bi.bi_bh = tbSh;
+
+  bi.bi_parent = PATH_H_PPARENT (tb->tb_path, h);
+
+  bi.bi_position = PATH_H_POSITION (tb->tb_path, h + 1);
+
+
+  internal_delete_childs (th, &bi, child_pos, -insert_num);
+
+#ifdef REISERFS_CHECK
+  if ( tb->blknum[h] > 1 )
+    reiserfs_panic (tb->tb_sb, "balance_internal_when_delete", "tb->blknum[%d]=%d when insert_size < 0",
+		    h, tb->blknum[h]);
+#endif /* REISERFS_CHECK */
+
+  n = B_NR_ITEMS(tbSh);
+
+  if ( tb->lnum[h] == 0 && tb->rnum[h] == 0 ) {
+    if ( tb->blknum[h] == 0 ) {
+      /* node S[h] (root of the tree) is empty now */
+      struct buffer_head *new_root;
+
+#ifdef REISERFS_CHECK
+      if (n || B_BLK_HEAD (tbSh)->blk_free_space != MAX_CHILD_SIZE(tbSh) - DC_SIZE)
+	reiserfs_panic (tb->tb_sb, "balance_internal_when_delete", "buffer must have only 0 keys (%d)",
+			n);
+
+      if (bi.bi_parent)
+	reiserfs_panic (tb->tb_sb, "balance_internal_when_delete", "root has parent (%p)", bi.bi_parent);
+#endif /* REISERFS_CHECK */
+		
+      /* choose a new root */
+      if ( ! tb->L[h-1] || ! B_NR_ITEMS(tb->L[h-1]) )
+	new_root = tb->R[h-1];
+      else
+	new_root = tb->L[h-1];
+      /* switch super block's tree root block number to the new value */
+      tb->tb_sb->u.reiserfs_sb.s_rs->s_root_block = new_root->b_blocknr;
+      tb->tb_sb->u.reiserfs_sb.s_rs->s_tree_height --;
+
+      /* reiserfs_mark_buffer_dirty(tb->tb_sb->u.reiserfs_sb.s_sbh,1); journal victim */	/* not preserved, super_block */
+      journal_mark_dirty(th, tb->tb_sb, tb->tb_sb->u.reiserfs_sb.s_sbh);	/* not preserved, super_block */
+      tb->tb_sb->s_dirt = 1;
+
+      /* mark buffer S[h] not uptodate and put it in free list */
+      reiserfs_invalidate_buffer(th, tb, tbSh, 1); /* preserve not needed, internal */
+      return;
+    }
+    return;
+  }
+
+  if ( tb->L[h] && tb->lnum[h] == -B_NR_ITEMS(tb->L[h]) - 1 ) { /* join S[h] with L[h] */
+
+#ifdef REISERFS_CHECK
+    if ( tb->rnum[h] != 0 )
+      reiserfs_panic (tb->tb_sb, "balance_internal_when_delete", "invalid tb->rnum[%d]==%d when joining S[h] with L[h]",
+		      h, tb->rnum[h]);
+#endif /* REISERFS_CHECK */
+
+    internal_shift_left (th, INTERNAL_SHIFT_FROM_S_TO_L, tb, h, n + 1);/*tb->L[h], tb->CFL[h], tb->lkey[h], tb->S[h], n+1);*/
+    reiserfs_invalidate_buffer(th, tb, tbSh, 1); /* preserve not needed, internal, 1 mean free block */
+
+    return;
+  }
+
+  if ( tb->R[h] &&  tb->rnum[h] == -B_NR_ITEMS(tb->R[h]) - 1 ) { /* join S[h] with R[h] */
+#ifdef REISERFS_CHECK
+    if ( tb->lnum[h] != 0 )
+      reiserfs_panic (tb->tb_sb, "balance_internal_when_delete", "invalid tb->lnum[%d]==%d when joining S[h] with R[h]",
+		      h, tb->lnum[h]);
+#endif /* REISERFS_CHECK */
+    /*internal_shift_right (tb, h, tb->S[h], tb->CFR[h], tb->rkey[h], tb->R[h], n+1);*/
+    internal_shift_right (th, INTERNAL_SHIFT_FROM_S_TO_R, tb, h, n + 1);
+    reiserfs_invalidate_buffer(th, tb,tbSh, 1);/* preserve not needed, internal */
+    return;
+  }
+
+  if ( tb->lnum[h] < 0 ) { /* borrow from left neighbor L[h] */
+#ifdef REISERFS_CHECK
+    if ( tb->rnum[h] != 0 )
+      reiserfs_panic (tb->tb_sb, "balance_internal_when_delete", "invalid tb->rnum[%d]==%d when borrow from L[h]",
+		      h, tb->rnum[h]);
+#endif /* REISERFS_CHECK */
+    /*internal_shift_right (tb, h, tb->L[h], tb->CFL[h], tb->lkey[h], tb->S[h], -tb->lnum[h]);*/
+    internal_shift_right (th, INTERNAL_SHIFT_FROM_L_TO_S, tb, h, -tb->lnum[h]);
+    return;
+  }
+
+  if ( tb->rnum[h] < 0 ) { /* borrow from right neighbor R[h] */
+#ifdef REISERFS_CHECK
+    if ( tb->lnum[h] != 0 )
+      reiserfs_panic (tb->tb_sb, "balance_internal_when_delete", "invalid tb->lnum[%d]==%d when borrow from R[h]",
+		      h, tb->lnum[h]);
+#endif /* REISERFS_CHECK */
+    internal_shift_left (th, INTERNAL_SHIFT_FROM_R_TO_S, tb, h, -tb->rnum[h]);/*tb->S[h], tb->CFR[h], tb->rkey[h], tb->R[h], -tb->rnum[h]);*/
+    return;
+  }
+
+  if ( tb->lnum[h] > 0 ) { /* split S[h] into two parts and put them into neighbors */
+#ifdef REISERFS_CHECK
+    if ( tb->rnum[h] == 0 || tb->lnum[h] + tb->rnum[h] != n + 1 )
+      reiserfs_panic (tb->tb_sb, "balance_internal_when_delete", 
+		      "invalid tb->lnum[%d]==%d or tb->rnum[%d]==%d when S[h](item number == %d) is split between them",
+		      h, tb->lnum[h], h, tb->rnum[h], n);
+#endif /* REISERFS_CHECK */
+
+    internal_shift_left (th, INTERNAL_SHIFT_FROM_S_TO_L, tb, h, tb->lnum[h]);/*tb->L[h], tb->CFL[h], tb->lkey[h], tb->S[h], tb->lnum[h]);*/
+    /*internal_shift_right (tb, h, tb->S[h], tb->CFR[h], tb->rkey[h], tb->R[h], tb->rnum[h]);*/
+    internal_shift_right (th, INTERNAL_SHIFT_FROM_S_TO_R, tb, h, tb->rnum[h]);
+    reiserfs_invalidate_buffer (th, tb, tbSh, 1);/* preserve not needed, internal */
+
+    return;
+  }
+  reiserfs_panic (tb->tb_sb, "balance_internal_when_delete", "unexpected tb->lnum[%d]==%d or tb->rnum[%d]==%d",
+		  h, tb->lnum[h], h, tb->rnum[h]);
+}
+
+/* Replace delimiting key of buffers L[h] and S[h] by the given key.*/
+void	replace_lkey (
+		      struct reiserfs_transaction_handle *th,
+		      struct tree_balance * tb,
+		      int h,
+		      struct item_head * key
+		      )
+{
+#ifdef REISERFS_CHECK
+  if (tb->L[h] == NULL || tb->CFL[h] == NULL)
+    reiserfs_panic (tb->tb_sb, "replace_lkey: 12255: "
+		    "L[h](%p) and CFL[h](%p) must exist in replace_lkey", tb->L[h], tb->CFL[h]);
+#endif
+
+  if (B_NR_ITEMS(PATH_H_PBUFFER(tb->tb_path, h)) == 0)
+    return;
+
+  memcpy (B_N_PDELIM_KEY(tb->CFL[h],tb->lkey[h]), key, KEY_SIZE);
+
+  journal_mark_dirty(th,  tb->tb_sb, tb->CFL[h]);	/* not preserved, preserves are in balance_leaf() and  balance_leaf_when_delete() */
+}
+
+
+/* Replace delimiting key of buffers S[h] and R[h] by the given key.*/
+void	replace_rkey (
+		      struct reiserfs_transaction_handle *th,
+		      struct tree_balance * tb,
+		      int h,
+		      struct item_head * key
+		      )
+{
+#ifdef REISERFS_CHECK
+  if (tb->R[h] == NULL || tb->CFR[h] == NULL)
+    reiserfs_panic (tb->tb_sb, "replace_rkey: 12260: "
+		    "R[h](%p) and CFR[h](%p) must exist in replace_rkey", tb->R[h], tb->CFR[h]);
+
+  if (B_NR_ITEMS(tb->R[h]) == 0)
+    reiserfs_panic (tb->tb_sb, "replace_rkey: 12265: "
+		    "R[h] can not be empty if it exists (item number=%d)", B_NR_ITEMS(tb->R[h]));
+#endif
+
+  memcpy (B_N_PDELIM_KEY(tb->CFR[h],tb->rkey[h]), key, KEY_SIZE);
+
+  journal_mark_dirty(th, tb->tb_sb, tb->CFR[h]);	/* not preserved, preserves are in balance_leaf() and  
+  							   balance_leaf_when_delete() */
+}
+
+
+
+int	balance_internal (
+			  struct reiserfs_transaction_handle *th,
+			  struct tree_balance * tb,			/* tree_balance structure 		*/
+			  int h,					/* level of the tree 			*/
+			  int child_pos,
+			  struct item_head * insert_key,		/* key for insertion on higher level   	*/
+			  struct buffer_head ** insert_ptr	/* node for insertion on higher level*/
+			  )
+  /* if inserting/pasting
+   {
+   child_pos is the position of the node-pointer in S[h] that	 *
+   pointed to S[h-1] before balancing of the h-1 level;		 *
+   this means that new pointers and items must be inserted AFTER *
+   child_pos
+   }
+   else 
+   {
+   it is the position of the leftmost pointer that must be deleted (together with
+   its corresponding key to the left of the pointer)
+   as a result of the previous level's balancing.
+   }
+*/
+{
+  struct buffer_head * tbSh = PATH_H_PBUFFER (tb->tb_path, h);
+  struct buffer_info bi;
+  int order;		/* we return this: it is 0 if there is no S[h], else it is tb->S[h]->b_item_order */
+  int insert_num, n, k;
+  struct buffer_head * S_new;
+  struct item_head new_insert_key;
+  struct buffer_head * new_insert_ptr = NULL;
+  struct item_head * new_insert_key_addr = insert_key;
+
+#ifdef REISERFS_CHECK
+  if ( h < 1 )      
+    reiserfs_panic (tb->tb_sb, "balance_internal", "h (%d) can not be < 1 on internal level", h);
+#endif /* REISERFS_CHECK */
+
+  order = ( tbSh ) ? PATH_H_POSITION (tb->tb_path, h + 1)/*tb->S[h]->b_item_order*/ : 0;
+
+  /* Using insert_size[h] calculate the number insert_num of items
+     that must be inserted to or deleted from S[h]. */
+  insert_num = tb->insert_size[h]/((int)(KEY_SIZE + DC_SIZE));
+
+  /* Check whether insert_num is proper **/
+#ifdef REISERFS_CHECK
+  if ( insert_num < -2  ||  insert_num > 2 )
+    reiserfs_panic (tb->tb_sb, "balance_internal",
+		    "incorrect number of items inserted to the internal node (%d)", insert_num);
+
+  if ( h > 1  && (insert_num > 1 || insert_num < -1) )
+    reiserfs_panic (tb->tb_sb, "balance_internal",
+		    "incorrect number of items (%d) inserted to the internal node on a level (h=%d) higher than last internal level", 
+		    insert_num, h);
+#endif /* REISERFS_CHECK */
+
+  /* Make balance in case insert_num < 0 */
+  if ( insert_num < 0 ) {
+    balance_internal_when_delete (th, tb, h, child_pos);
+    return order;
+  }
+ 
+  k = 0;
+  if ( tb->lnum[h] > 0 ) {
+    /* shift lnum[h] items from S[h] to the left neighbor L[h].
+       check how many of new items fall into L[h] or CFL[h] after shifting */
+    n = B_BLK_HEAD(tb->L[h])->blk_nr_item; /* number of items in L[h] */
+    if ( tb->lnum[h] <= child_pos ) {
+      /* new items don't fall into L[h] or CFL[h] */
+      internal_shift_left (th, INTERNAL_SHIFT_FROM_S_TO_L, tb, h, tb->lnum[h]);
+      /*internal_shift_left (tb->L[h],tb->CFL[h],tb->lkey[h],tbSh,tb->lnum[h]);*/
+      child_pos -= tb->lnum[h];
+    } else if ( tb->lnum[h] > child_pos + insert_num ) {
+      /* all new items fall into L[h] */
+      internal_shift_left (th, INTERNAL_SHIFT_FROM_S_TO_L, tb, h, tb->lnum[h] - insert_num);
+      /*			internal_shift_left(th, tb->L[h],tb->CFL[h],tb->lkey[h],tbSh,
+				tb->lnum[h]-insert_num);
+				*/
+      /* insert insert_num keys and node-pointers into L[h] */
+      bi.bi_bh = tb->L[h];
+      bi.bi_parent = tb->FL[h];
+      bi.bi_position = get_left_neighbor_position (tb, h);
+      internal_insert_childs (th, &bi,/*tb->L[h], tb->S[h-1]->b_next*/ n + child_pos + 1,
+			      insert_num,insert_key,insert_ptr);
+
+      insert_num = 0; 
+    } else {
+      struct disk_child * dc;
+
+      /* some items fall into L[h] or CFL[h], but some don't fall */
+      internal_shift1_left(th, tb,h,child_pos+1);
+      /* calculate number of new items that fall into L[h] */
+      k = tb->lnum[h] - child_pos - 1;
+
+      bi.bi_bh = tb->L[h];
+      bi.bi_parent = tb->FL[h];
+      bi.bi_position = get_left_neighbor_position (tb, h);
+      internal_insert_childs (th, &bi,/*tb->L[h], tb->S[h-1]->b_next,*/ n + child_pos + 1,k,
+			      insert_key,insert_ptr);
+
+      replace_lkey(th, tb,h,insert_key + k);
+
+      /* replace the first node-ptr in S[h] by node-ptr to insert_ptr[k] */
+      (dc = B_N_CHILD(tbSh, 0))->dc_size =
+	MAX_CHILD_SIZE(insert_ptr[k]) -
+	B_BLK_HEAD(insert_ptr[k])->blk_free_space;
+      dc->dc_block_number = insert_ptr[k]->b_blocknr; 
+
+      /* reiserfs_mark_buffer_dirty(tbSh, 0); journal_victim */ /* no need to preserve, internal */
+      journal_mark_dirty(th, tb->tb_sb, tbSh); /* no need to preserve, internal */
+
+      k++;
+      insert_key += k;
+      insert_ptr += k;
+      insert_num -= k;
+      child_pos = 0;
+    }
+  }	/* tb->lnum[h] > 0 */
+
+  if ( tb->rnum[h] > 0 ) {
+    /*shift rnum[h] items from S[h] to the right neighbor R[h]*/
+    /* check how many of new items fall into R or CFR after shifting */
+    n = B_BLK_HEAD (tbSh)->blk_nr_item; /* number of items in S[h] */
+    if ( n - tb->rnum[h] >= child_pos )
+      /* new items fall into S[h] */
+      /*internal_shift_right(tb,h,tbSh,tb->CFR[h],tb->rkey[h],tb->R[h],tb->rnum[h]);*/
+      internal_shift_right (th, INTERNAL_SHIFT_FROM_S_TO_R, tb, h, tb->rnum[h]);
+    else
+      if ( n + insert_num - tb->rnum[h] < child_pos )
+	{
+	  /* all new items fall into R[h] */
+	  /*internal_shift_right(tb,h,tbSh,tb->CFR[h],tb->rkey[h],tb->R[h],
+	    tb->rnum[h] - insert_num);*/
+	  internal_shift_right (th, INTERNAL_SHIFT_FROM_S_TO_R, tb, h, tb->rnum[h] - insert_num);
+
+	  /* insert insert_num keys and node-pointers into R[h] */
+	  bi.bi_bh = tb->R[h];
+	  bi.bi_parent = tb->FR[h];
+	  bi.bi_position = get_right_neighbor_position (tb, h);
+	  internal_insert_childs (th, &bi, /*tb->R[h],tb->S[h-1]->b_next*/ child_pos - n - insert_num + tb->rnum[h] - 1,
+				  insert_num,insert_key,insert_ptr);
+	  insert_num = 0;
+	}
+      else
+	{
+	  struct disk_child * dc;
+
+	  /* one of the items falls into CFR[h] */
+	  internal_shift1_right(th, tb,h,n - child_pos + 1);
+	  /* calculate number of new items that fall into R[h] */
+	  k = tb->rnum[h] - n + child_pos - 1;
+
+	  bi.bi_bh = tb->R[h];
+	  bi.bi_parent = tb->FR[h];
+	  bi.bi_position = get_right_neighbor_position (tb, h);
+	  internal_insert_childs (th, &bi, /*tb->R[h], tb->R[h]->b_child,*/ 0, k, insert_key + 1, insert_ptr + 1);
+
+	  replace_rkey(th, tb,h,insert_key + insert_num - k - 1);
+
+	  /* replace the first node-ptr in R[h] by node-ptr insert_ptr[insert_num-k-1]*/
+	  (dc = B_N_CHILD(tb->R[h], 0))->dc_size =
+	    MAX_CHILD_SIZE(insert_ptr[insert_num-k-1]) -
+	    B_BLK_HEAD(insert_ptr[insert_num-k-1])->blk_free_space;
+	  dc->dc_block_number = insert_ptr[insert_num-k-1]->b_blocknr;
+
+	  /* reiserfs_mark_buffer_dirty(tb->R[h],0); journal victim *//* no need to preserve, internal */
+	  journal_mark_dirty(th, tb->tb_sb, tb->R[h]);/* no need to preserve, internal */
+
+	  /*
+	    insert_ptr[insert_num-k-1]->b_item_order = 0;
+	    insert_ptr[insert_num-k-1]->b_parent = tb->R[h];
+	    reiserfs_insert_into_child_list(insert_ptr[insert_num-k-1],tb->R[h]->b_child);
+	    */
+			
+	  insert_num -= (k + 1);
+	}
+  }
+
+  /** Fill new node that appears instead of S[h] **/
+#ifdef REISERFS_CHECK
+  if ( tb->blknum[h] > 2 )
+    reiserfs_panic(0, "balance_internal", "blknum can not be > 2 for internal level");
+  if ( tb->blknum[h] < 0 )
+    reiserfs_panic(0, "balance_internal", "blknum can not be < 0");
+#endif /* REISERFS_CHECK */
+
+  if ( ! tb->blknum[h] )
+    { /* node S[h] is empty now */
+#ifdef REISERFS_CHECK
+      if ( ! tbSh )
+	reiserfs_panic(0,"balance_internal", "S[h] is equal NULL");
+#endif /* REISERFS_CHECK */
+
+      /* Mark buffer as invalid and put it to head of free list. */
+      reiserfs_invalidate_buffer(th, tb,tbSh, 1);/* do not preserve, internal node*/
+      return order;
+    }
+
+  if ( ! tbSh ) {
+    /* create new root */
+    struct disk_child  * dc;
+    struct buffer_head * tbSh_1 = PATH_H_PBUFFER (tb->tb_path, h - 1);
+
+
+    if ( tb->blknum[h] != 1 )
+      reiserfs_panic(0, "balance_internal", "One new node required for creating the new root");
+    /* S[h] = empty buffer from the list FEB. */
+    tbSh = get_FEB (tb);
+    B_BLK_HEAD(tbSh)->blk_level = h + 1;
+
+    /* Put the unique node-pointer to S[h] that points to S[h-1]. */
+
+    (dc = B_N_CHILD(tbSh, 0))->dc_block_number = tbSh_1->b_blocknr;
+    dc->dc_size = MAX_CHILD_SIZE (tbSh_1) - B_BLK_HEAD(tbSh_1)->blk_free_space;
+
+    tb->insert_size[h] -= DC_SIZE;
+    B_BLK_HEAD(tbSh)->blk_free_space -= DC_SIZE;
+
+    /* reiserfs_mark_buffer_dirty(tbSh,0); journal victim *//* no need to preserve, internal */
+    journal_mark_dirty(th, tb->tb_sb, tbSh);/* no need to preserve, internal */
+    
+    /* put new root into path structure */
+    PATH_OFFSET_PBUFFER(tb->tb_path, ILLEGAL_PATH_ELEMENT_OFFSET) = tbSh;
+
+    /* Change root in structure super block. */
+    tb->tb_sb->u.reiserfs_sb.s_rs->s_root_block = tbSh->b_blocknr;
+    tb->tb_sb->u.reiserfs_sb.s_rs->s_tree_height ++;
+    /* reiserfs_mark_buffer_dirty(tb->tb_sb->u.reiserfs_sb.s_sbh, 1); journal victim *//* no need to preserve, super */	
+    journal_mark_dirty(th, tb->tb_sb, tb->tb_sb->u.reiserfs_sb.s_sbh);/* no need to preserve, super */	
+    tb->tb_sb->s_dirt = 1;
+  }
+	
+  if ( tb->blknum[h] == 2 ) {
+    int snum;
+    struct buffer_info dest_bi, src_bi;
+
+
+    /* S_new = free buffer from list FEB */
+    S_new = get_FEB(tb);
+
+#ifdef REISERFS_CHECK
+    buffers[h] = S_new;
+#endif
+
+    B_BLK_HEAD(S_new)->blk_level = h + 1;
+    
+
+    dest_bi.bi_bh = S_new;
+    dest_bi.bi_parent = 0;
+    dest_bi.bi_position = 0;
+    src_bi.bi_bh = tbSh;
+    src_bi.bi_parent = PATH_H_PPARENT (tb->tb_path, h);
+    src_bi.bi_position = PATH_H_POSITION (tb->tb_path, h + 1);
+		
+    n = B_BLK_HEAD(tbSh)->blk_nr_item; /* number of items in S[h] */
+    snum = (insert_num + n + 1)/2;
+    if ( n - snum >= child_pos ) {
+      /* new items don't fall into S_new */
+      /*	store the delimiting key for the next level */
+      /* new_insert_key = (n - snum)'th key in S[h] */
+      memcpy (&new_insert_key,B_N_PDELIM_KEY(tbSh,n - snum),
+	      KEY_SIZE);
+      /* last parameter is del_par */
+      internal_move_pointers_items (th, &dest_bi, &src_bi, LAST_TO_FIRST, snum, 0);
+      /*            internal_move_pointers_items(S_new, tbSh, LAST_TO_FIRST, snum, 0);*/
+    } else if ( n + insert_num - snum < child_pos ) {
+      /* all new items fall into S_new */
+      /*	store the delimiting key for the next level */
+      /* new_insert_key = (n + insert_item - snum)'th key in S[h] */
+      memcpy(&new_insert_key,B_N_PDELIM_KEY(tbSh,n + insert_num - snum),
+	     KEY_SIZE);
+      /* last parameter is del_par */
+      internal_move_pointers_items (th, &dest_bi, &src_bi, LAST_TO_FIRST, snum - insert_num, 0);
+      /*			internal_move_pointers_items(S_new,tbSh,1,snum - insert_num,0);*/
+
+      /* insert insert_num keys and node-pointers into S_new */
+      internal_insert_childs (th, &dest_bi, /*S_new,tb->S[h-1]->b_next,*/child_pos - n - insert_num + snum - 1,
+			      insert_num,insert_key,insert_ptr);
+
+      insert_num = 0;
+    } else {
+      struct disk_child * dc;
+
+      /* some items fall into S_new, but some don't fall */
+      /* last parameter is del_par */
+      internal_move_pointers_items (th, &dest_bi, &src_bi, LAST_TO_FIRST, n - child_pos + 1, 1);
+      /*			internal_move_pointers_items(S_new,tbSh,1,n - child_pos + 1,1);*/
+      /* calculate number of new items that fall into S_new */
+      k = snum - n + child_pos - 1;
+
+      internal_insert_childs (th, &dest_bi, /*S_new,*/ 0, k, insert_key + 1, insert_ptr+1);
+
+      /* new_insert_key = insert_key[insert_num - k - 1] */
+      memcpy(&new_insert_key,insert_key + insert_num - k - 1,
+	     KEY_SIZE);
+      /* replace first node-ptr in S_new by node-ptr to insert_ptr[insert_num-k-1] */
+
+      (dc = B_N_CHILD(S_new,0))->dc_size =
+	MAX_CHILD_SIZE(insert_ptr[insert_num-k-1]) -
+	B_BLK_HEAD(insert_ptr[insert_num-k-1])->blk_free_space;
+      dc->dc_block_number =	insert_ptr[insert_num-k-1]->b_blocknr; 
+
+      /* reiserfs_mark_buffer_dirty(S_new,0); journal victim *//* no need to preserve, new */
+      journal_mark_dirty(th, tb->tb_sb, S_new);/* no need to preserve, new */
+			
+      insert_num -= (k + 1);
+    }
+    /* new_insert_ptr = node_pointer to S_new */
+    new_insert_ptr = S_new;
+
+#ifdef REISERFS_CHECK
+    if ( buffer_locked(S_new) )
+      reiserfs_panic (tb->tb_sb, "balance_internal", "locked buffer S_new[]");
+    if (S_new->b_count != 1)
+      if (!(buffer_journaled(S_new) && S_new->b_count == 2)) {
+	printk ("REISERFS: balance_internal: S_new->b_count != 1 (%u)\n", S_new->b_count);
+      }
+#endif /* REISERFS_CHECK */
+
+    /*
+      S_new->b_count --;
+      */
+    /*brelse(S_new);*/
+  }
+
+  n = B_BLK_HEAD(tbSh)->blk_nr_item; /*number of items in S[h] */
+
+#ifdef REISERFS_FSCK
+  if ( -1 <= child_pos && child_pos <= n && insert_num > 0 ) {
+#else
+  if ( 0 <= child_pos && child_pos <= n && insert_num > 0 ) {
+#endif
+    bi.bi_bh = tbSh;
+    bi.bi_parent = PATH_H_PPARENT (tb->tb_path, h);
+    bi.bi_position = PATH_H_POSITION (tb->tb_path, h + 1);
+#ifdef REISERFS_FSCK
+    if (child_pos == -1) {
+      /* this is a little different from original do_balance: 
+	 here we insert the minimal keys in the tree, that has never happened when file system works */
+      if (tb->CFL[h-1] || insert_num != 1 || h != 1)
+	die ("balance_internal: invalid child_pos");
+/*      insert_child (tb->S[h], tb->S[h-1], child_pos, insert_num, B_N_ITEM_HEAD(tb->S[0],0), insert_ptr);*/
+      internal_insert_childs (th, &bi, child_pos, insert_num, B_N_PITEM_HEAD (PATH_PLAST_BUFFER (tb->tb_path), 0), insert_ptr);
+    } else
+#endif
+    internal_insert_childs (th, 
+			    &bi,/*tbSh,*/
+			    /*		( tb->S[h-1]->b_parent == tb->S[h] ) ? tb->S[h-1]->b_next :  tb->S[h]->b_child->b_next,*/
+			    child_pos,insert_num,insert_key,insert_ptr
+			    );
+  }
+
+
+  memcpy (new_insert_key_addr,&new_insert_key,KEY_SIZE);
+  insert_ptr[0] = new_insert_ptr;
+
+  return order;
+}
+
Index: empeg/kernel/fs/reiserfs/inode.c
diff -u /dev/null empeg/kernel/fs/reiserfs/inode.c:1.2
--- /dev/null	Wed Oct 17 16:36:05 2001
+++ empeg/kernel/fs/reiserfs/inode.c	Fri Oct 20 16:48:39 2000
@@ -0,0 +1,903 @@
+/*
+ * Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
+ */
+#ifdef __KERNEL__
+
+#include <linux/sched.h>
+#include <linux/reiserfs_fs.h>
+#include <linux/locks.h>
+#include <asm/uaccess.h>
+
+#else
+
+#include "nokernel.h"
+int reiserfs_notify_change(struct dentry * dentry, struct iattr * attr){return 0;}
+
+#endif
+
+
+void reiserfs_delete_inode (struct inode * inode)
+{
+  int writers_to_wait_for ;
+  int jbegin_count = JOURNAL_PER_BALANCE_CNT * 2; 
+  int windex ;
+  struct reiserfs_transaction_handle th ;
+
+  writers_to_wait_for = 1; 
+  journal_begin(&th, inode->i_sb, jbegin_count) ;
+  windex = push_journal_writer("delete_inode") ;
+  reiserfs_update_inode_transaction(inode) ;
+
+  /* The = 0 happens when we abort creating a new inode for some reason like lack of space.. */
+  if (INODE_PKEY(inode)->k_objectid != 0) {
+    reiserfs_delete_object (&th, inode);
+    reiserfs_release_objectid (&th, inode->i_ino, inode->i_sb);
+  } else {
+    /* no object items are in the tree */
+    ;
+  }
+  pop_journal_writer(windex) ;
+  journal_end(&th, inode->i_sb, jbegin_count) ;
+  clear_inode (inode); /* note this must go after the journal_end to prevent deadlock */
+}
+
+#if 0
+static void copy_data_blocks_to_inode (struct inode * inode, struct item_head * ih, __u32 * ind_item)
+{
+  int first_log_block = (ih->ih_key.k_offset - 1) / inode->i_sb->s_blocksize; /* first log block addressed by indirect item */
+  int i, j;
+  
+  for (i = first_log_block, j = 0; i < REISERFS_N_BLOCKS && j < I_UNFM_NUM (ih); i ++, j ++) {
+#ifdef REISERFS_CHECK
+    if (inode->u.reiserfs_i.i_data [i] && inode->u.reiserfs_i.i_data [i] != ind_item [j])
+      reiserfs_panic (inode->i_sb, "vs-13000: reiserfs_bmap: log block %d, data block %d is seet and doe not match to unfmptr %d",
+		      i, inode->u.reiserfs_i.i_data [i], ind_item [j]);
+#endif
+    inode->u.reiserfs_i.i_data [i] = ind_item [j];
+  }
+}
+#endif/*0*/
+
+/* convert logical file block to appropriate unformatted node. */
+int reiserfs_bmap (struct inode * inode, int block)
+{
+  struct key offset_key;
+  struct path path_to_blocknr;
+  int pos_in_item;
+  int repeat;
+  struct buffer_head * bh;
+  struct item_head * ih;
+  int blocknr;
+
+  offset_key.k_offset = block * inode->i_sb->s_blocksize + 1;
+  if (INODE_OFFSET_IN_DIRECT (inode, offset_key.k_offset)) {
+    return 0;
+  }
+
+  /*
+  if (block < REISERFS_N_BLOCKS && inode->u.reiserfs_i.i_data [block]) {
+    inode->i_sb->u.reiserfs_sb.s_bmaps_without_search ++;
+    return inode->u.reiserfs_i.i_data [block];
+  }
+  */
+
+
+  copy_short_key (&offset_key, INODE_PKEY (inode));
+  offset_key.k_uniqueness = TYPE_INDIRECT;
+
+  init_path (&path_to_blocknr);
+  if (search_for_position_by_key (inode->i_sb, &offset_key, &path_to_blocknr, &pos_in_item, &repeat) == POSITION_NOT_FOUND) {
+    /*reiserfs_warning ("vs-13020: reiserfs_bmap: there is no required byte (%k) in the file of size %ld. Found item \n%h\n", 
+      &offset_key, inode->i_size, PATH_PITEM_HEAD (&path_to_blocknr));*/
+    pathrelse (&path_to_blocknr);
+    return 0;
+  }
+
+  bh = PATH_PLAST_BUFFER (&path_to_blocknr);
+  ih = B_N_PITEM_HEAD (bh, PATH_LAST_POSITION (&path_to_blocknr));
+
+  if (I_IS_INDIRECT_ITEM (ih)) {
+    __u32 * ind_item = (__u32 *)B_I_PITEM (bh, ih);
+
+    /*
+    copy_data_blocks_to_inode (inode, ih, ind_item);
+    */
+    blocknr = ind_item [pos_in_item];
+    pathrelse (&path_to_blocknr);
+    inode->i_sb->u.reiserfs_sb.s_bmaps ++;
+    return blocknr;
+  }
+
+  reiserfs_warning ("vs-13030: reiserfs_bmap: found item \n%h\n is not indirect one\n", ih);
+  pathrelse (&path_to_blocknr);
+  return 0;
+}
+
+
+#define has_tail(inode) ((inode)->u.reiserfs_i.i_first_direct_byte != NO_BYTES_IN_DIRECT_ITEM)
+#define tail_offset(inode) ((inode)->u.reiserfs_i.i_first_direct_byte - 1)
+
+/* "we are reading into the page cache, not into any process's virtual
+   memory". Stephen C. Tweedie, therefore no need for local buffer */
+static int read_file_tail (struct inode * inode, loff_t offset, char * buf, int size)
+{
+  struct key key;
+  int repeat, pos_in_item;
+  struct path path;
+  struct item_head * ih;
+  char * p;
+  int chars, left, read;
+  struct buffer_head * bh;
+  int block;
+  struct buffer_head * pbh[PAGE_SIZE / 512];
+  int i, j;
+
+  p = buf;
+  left = size;
+  read = 0;
+
+  /* read unformatted nodes first */
+  i = 0;
+  while (offset < tail_offset (inode)) {
+    block = offset >> inode->i_sb->s_blocksize_bits;
+    block = inode->i_op->bmap(inode, block);
+    pbh[i] = getblk (inode->i_dev, block, inode->i_sb->s_blocksize);
+    offset += inode->i_sb->s_blocksize;
+    i ++;
+  }
+  
+  if (i)
+    ll_rw_block (READ, i, pbh);
+
+  p = buf;
+  for (j = 0; j < i; j ++) {
+    wait_on_buffer (pbh[j]);
+    memcpy (p, pbh[j]->b_data, pbh[j]->b_size);
+    read += pbh[j]->b_size;
+    left -= pbh[j]->b_size;
+    p += pbh[j]->b_size;
+    brelse (pbh[j]);
+  }
+
+
+  /* read direct item(s) */
+
+  if (offset != tail_offset (inode)) {
+#ifdef REISERFS_CHECK
+    reiserfs_warning ("vs-18010: read_file_tail: given offset (%d) is not stored in direct item. \
+Inode's first direct byte %d\n", offset, inode->u.reiserfs_i.i_first_direct_byte);
+#endif
+    return 0;
+  }
+
+  init_path (&path);
+
+  copy_short_key (&key, INODE_PKEY(inode));
+  key.k_offset = offset + 1;
+  key.k_uniqueness = TYPE_DIRECT;
+
+  while (left) {
+    if (search_for_position_by_key (inode->i_sb, &key, &path, &pos_in_item, &repeat) == POSITION_NOT_FOUND) {
+      break;
+    }
+
+    bh = PATH_PLAST_BUFFER (&path);
+    ih = B_N_PITEM_HEAD (bh, PATH_LAST_POSITION (&path));
+
+    chars = ih->ih_item_len - pos_in_item;
+    if (chars > left)
+      chars = left;
+
+    memcpy (p, B_I_PITEM (bh, ih) + pos_in_item, chars);
+    key.k_offset += chars;
+    read += chars;
+    left -= chars;
+    p += chars;
+    if (PATH_LAST_POSITION (&path) != B_NR_ITEMS (bh) - 1)
+      /* that was last direct item of the tail */
+      break;
+  }
+
+  pathrelse (&path);
+  return read;
+}
+
+
+int reiserfs_readpage (struct file * file, struct page * page) 
+{
+  struct inode * inode;
+
+				/* If you get this from the page it is one less indirection -Hans */
+  inode = file->f_dentry->d_inode;
+
+  if (has_tail (inode) && tail_offset (inode) < page->offset + PAGE_SIZE) {
+    /* there is a tail and it is in this page */
+    memset ((char *)page_address (page), 0, PAGE_SIZE);
+    read_file_tail (inode, page->offset, (char *)page_address (page), PAGE_SIZE);
+    set_bit (PG_uptodate, &page->flags);
+    return 0;
+  }  else {
+    return generic_readpage (file, page);
+  }
+}
+
+/* Iget accepts only super block and inode number as it hashes inodes
+   using device identifier and inode number. If iget could not find
+   required inode in its hash queues, then it calls
+   reiserfs_read_inode passing to it only inode
+   number. Reiserfs_read_inode must know the key. That is why we keep
+   key in global array before iget.
+   */
+
+#define KEY_ARRAY_SIZE 100
+
+static struct {
+  unsigned long objectid;
+  unsigned long dirid;
+  kdev_t dev ;
+} g_key_array [KEY_ARRAY_SIZE] = {{0,},};
+
+
+static unsigned long look_for_key  (struct super_block *s, unsigned long objectid)
+{
+  int i;
+
+  for (i = 0; i < sizeof (g_key_array) / sizeof (g_key_array[0]); i ++) {
+    if (g_key_array[i].objectid == objectid && 
+        g_key_array[i].dev == s->s_dev)
+      return g_key_array[i].dirid;
+  }
+  return (unsigned long)-1;
+}
+
+
+/* looks for stat data in the tree, and fills up the fields of in-core
+   inode stat data fields */
+void reiserfs_read_inode (struct inode * inode)
+{
+  struct path path_to_sd;
+  struct stat_data * sd;
+  struct item_head *ih ;
+  int repeat;
+
+  init_path (&path_to_sd);
+
+  inode->i_op = NULL;
+  inode->i_mode = 0;
+
+  /* form key of the stat data */
+  inode->u.reiserfs_i.i_key[0] = look_for_key (inode->i_sb, inode->i_ino);
+  inode->u.reiserfs_i.i_key[1] = inode->i_ino;
+  inode->u.reiserfs_i.i_key[2] = SD_OFFSET;
+  inode->u.reiserfs_i.i_key[3] = TYPE_STAT_DATA;
+  if (inode->u.reiserfs_i.i_key[0] == (unsigned long)-1) {
+#ifdef REISERFS_CHECK
+    reiserfs_warning ("vs-13040: reiserfs_read_inode: could not find k_dir_id (objectid = %lu)\n",
+		    inode->i_ino);
+#endif
+    /* VERY slow search through all possible packing localities. */
+    if (search_by_objectid(inode->i_sb, INODE_PKEY (inode), &path_to_sd, &repeat, DISK_LEAF_NODE_LEVEL, READ_BLOCKS) != ITEM_FOUND) {
+      pathrelse (&path_to_sd);
+      make_bad_inode(inode) ;
+      return ;
+    }
+
+    /* ok, the search found our item.  Pull the packing locality from 
+    ** the path it returned
+    */
+    ih = PATH_PITEM_HEAD(&path_to_sd) ;
+    inode->u.reiserfs_i.i_key[0] = ih->ih_key.k_dir_id ;
+  }
+
+  /* look for the object stat data */
+  if (search_by_key (inode->i_sb, INODE_PKEY (inode), &path_to_sd, &repeat, DISK_LEAF_NODE_LEVEL, READ_BLOCKS) == ITEM_NOT_FOUND) {
+    pathrelse (&path_to_sd);
+    make_bad_inode(inode) ;
+    return;
+  }
+
+  sd = B_N_STAT_DATA (PATH_PLAST_BUFFER (&path_to_sd), PATH_LAST_POSITION (&path_to_sd));
+  inode->i_mode = le16_to_cpu (sd->sd_mode);
+  inode->i_uid = le16_to_cpu (sd->sd_uid);
+  inode->i_gid = le16_to_cpu (sd->sd_gid);
+  inode->i_nlink = le16_to_cpu (sd->sd_nlink);
+  inode->i_size = le32_to_cpu (sd->sd_size);
+  inode->i_mtime = le32_to_cpu (sd->sd_mtime);
+  inode->i_atime = le32_to_cpu (sd->sd_atime);
+  inode->i_ctime = le32_to_cpu (sd->sd_ctime);
+  inode->i_blksize = inode->i_sb->s_blocksize;
+  /* for regular files we calculate any tail as full block */
+  /* inode->i_blocks = (sd->sd_first_direct_byte == NO_BYTES_IN_DIRECT_ITEM) ? (inode->i_size / 512) : 
+    ((sd->sd_first_direct_byte - 1) / 512 + inode->i_blksize / 512); */
+
+  if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))
+    inode->i_rdev = le32_to_cpu (sd->u.sd_rdev);
+  else {
+    inode->i_blocks = le32_to_cpu (sd->u.sd_blocks);
+    if (inode->i_blocks == 0) { /* compatibility for 3.5.16 and before */
+      /* for regular files we calculate any tail as full block */
+      inode->i_blocks = (sd->sd_first_direct_byte == 
+                         NO_BYTES_IN_DIRECT_ITEM) ? (inode->i_size / 512) : 
+			((sd->sd_first_direct_byte - 1) / 512 + 
+			inode->i_blksize / 512); 
+    }
+  }
+  inode->u.reiserfs_i.i_first_direct_byte=le32_to_cpu(sd->sd_first_direct_byte);
+  pathrelse (&path_to_sd);
+
+  if (S_ISREG (inode->i_mode))
+    inode->i_op = &reiserfs_file_inode_operations;
+  else if (S_ISDIR (inode->i_mode)) {
+    inode->i_op = &reiserfs_dir_inode_operations;
+    inode->i_blocks = inode->i_size / 512 + ((inode->i_size % 512) ? 1 : 0);
+  } else if (S_ISLNK (inode->i_mode))
+    inode->i_op = &reiserfs_symlink_inode_operations;
+  else if (S_ISCHR (inode->i_mode))
+    inode->i_op = &chrdev_inode_operations;
+  else if (S_ISBLK (inode->i_mode))
+    inode->i_op = &blkdev_inode_operations;
+  else if (S_ISFIFO (inode->i_mode))
+    init_fifo (inode);
+  inode->u.reiserfs_i.i_pack_on_close = 0 ;
+
+}
+
+
+void store_key (struct super_block *s, struct key * key)
+{
+  int i;
+
+  for (i = 0; i < sizeof (g_key_array) / sizeof (g_key_array[0]); i ++) {
+    if (g_key_array[i].objectid == 0) {
+      g_key_array[i].dirid = key->k_dir_id;
+      g_key_array[i].objectid = key->k_objectid;
+      g_key_array[i].dev = s->s_dev ;
+      return;
+    }
+  }
+  reiserfs_warning ("vs-13042: store_key: table of keys is full\n");
+}
+
+void forget_key (struct super_block *s, struct key * key)
+{
+  int i;
+
+  for (i = 0; i < sizeof (g_key_array) / sizeof (g_key_array[0]); i ++) {
+    if (g_key_array[i].objectid == key->k_objectid &&
+        g_key_array[i].dev == s->s_dev) {
+      g_key_array[i].objectid = 0;
+      return;
+    }
+  }
+  reiserfs_warning ("vs-13045: forget_key: could not find key in the table [%k]\n", key);
+}
+
+
+struct inode * reiserfs_iget (struct super_block * s, struct key * key)
+{
+  struct inode * inode;
+
+  store_key (s, key);
+  inode = iget (s, key->k_objectid);
+  if (comp_short_keys (INODE_PKEY (inode), key)) {
+    reiserfs_warning ("vs-13048: reiserfs_iget: key in inode %k and key in entry %k do not match\n",
+		      INODE_PKEY (inode), key);
+    iput (inode);
+    inode = 0;
+  }
+  forget_key (s, key);
+  return inode;
+}
+
+
+static struct buffer_head * reiserfs_update_inode (struct reiserfs_transaction_handle *th, struct inode * inode, 
+                  			           struct path * path_to_sd, int read_blocks)
+{
+  struct stat_data * sd;
+  int repeat;
+  struct buffer_head * bh;
+
+
+  init_path (path_to_sd);
+
+  /* look for the object */
+  if (search_by_key (inode->i_sb, INODE_PKEY (inode), path_to_sd, &repeat, DISK_LEAF_NODE_LEVEL, read_blocks) == ITEM_NOT_FOUND) {
+    if (read_blocks == DONT_READ_BLOCKS) {
+      /* this is called from if_in_ram_update_sd */
+      /*printk ("reiserfs: stat data not found in memory\n");*/
+      return 0;
+    }
+    if (inode->i_nlink == 0) {
+#ifdef REISERFS_CHECK 
+      printk ("vs-13050: reiserfs_update_inode: i_nlink == 0, stat data not found\n");
+#endif
+      return 0;
+    }
+    print_block (PATH_PLAST_BUFFER (path_to_sd), PRINT_LEAF_ITEMS, -1, -1);
+    reiserfs_panic(inode->i_sb, "vs-13060: reiserfs_update_inode: stat data of object %k (nlink == %d) not found (pos %d)\n", 
+		   INODE_PKEY (inode), inode->i_nlink, PATH_LAST_POSITION (path_to_sd));
+  }
+  bh = PATH_PLAST_BUFFER (path_to_sd);
+  sd = B_N_STAT_DATA (bh, PATH_LAST_POSITION (path_to_sd));
+  sd->sd_mode = cpu_to_le16 (inode->i_mode);
+  sd->sd_uid = cpu_to_le16 (inode->i_uid);
+  sd->sd_gid = cpu_to_le16 (inode->i_gid);
+  sd->sd_nlink = cpu_to_le16 (inode->i_nlink);
+  sd->sd_size = cpu_to_le32 (inode->i_size);
+  sd->sd_atime = cpu_to_le32 (inode->i_atime);
+  sd->sd_ctime = cpu_to_le32 (inode->i_ctime);
+  sd->sd_mtime = cpu_to_le32 (inode->i_mtime);
+  if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))
+    sd->u.sd_rdev = cpu_to_le32 (inode->i_rdev);
+  else sd->u.sd_blocks = cpu_to_le32 (inode->i_blocks);
+  sd->sd_first_direct_byte = cpu_to_le32 (inode->u.reiserfs_i.i_first_direct_byte);
+  /* reiserfs_mark_buffer_dirty (bh, 1); journal victim */
+  reiserfs_update_inode_transaction(inode) ;
+  journal_mark_dirty(th, inode->i_sb, bh);
+  return bh;
+}
+
+/* looks for stat data, then copies fields to it, marks the buffer
+   containing stat data as dirty */
+void reiserfs_write_inode (struct inode * inode)
+{
+  struct path path_to_sd;
+  int windex ;
+  struct reiserfs_transaction_handle th ;
+  int jbegin_count = JOURNAL_PER_BALANCE_CNT * 3; 
+
+  journal_begin(&th, inode->i_sb, jbegin_count) ;
+  windex = push_journal_writer("write_inode") ;
+  reiserfs_update_inode_transaction(inode) ;
+  reiserfs_update_inode (&th, inode, &path_to_sd, READ_BLOCKS);
+  pathrelse (&path_to_sd);
+  pop_journal_writer(windex) ;
+  journal_end(&th, inode->i_sb, jbegin_count) ;
+}
+
+
+int reiserfs_sync_inode (struct reiserfs_transaction_handle *th, struct inode * inode)
+{
+  int err = 0;
+  struct path path_to_sd;
+  struct buffer_head * bh;
+
+  bh = reiserfs_update_inode (th, inode, &path_to_sd, READ_BLOCKS);
+#if 0
+  if (bh && buffer_dirty (bh)) {
+    ll_rw_block(WRITE, 1, &bh);
+    wait_on_buffer(bh);
+    if (buffer_req(bh) && !buffer_uptodate(bh)) {
+      printk ("reiserfs_sync_inode: IO error syncing reiserfs stat data ["
+	      "device:\"%s\", object:[%u %u]], blocknr:%lu\n",
+	      kdevname(inode->i_dev), inode->u.reiserfs_i.i_key[0], inode->u.reiserfs_i.i_key[1],
+	      bh->b_blocknr);
+      err = -1;
+    }
+  } else {
+    if (bh == 0)
+      err = -1;
+  }
+#endif
+  pathrelse (&path_to_sd);
+  return err;
+}
+
+
+/* stat data of object has been inserted, this inserts the item
+   containing "." and ".." entries */
+static int reiserfs_new_directory (struct reiserfs_transaction_handle *th, 
+			           struct super_block * sb, struct item_head * ih, struct path * path, const struct inode * dir)
+{
+  char empty_dir [EMPTY_DIR_SIZE];
+  struct reiserfs_de_head * deh;
+  char * body;
+  int repeat;
+	
+  /* item head of empty directory item */
+  ih->ih_key.k_offset = DOT_OFFSET;
+  ih->ih_key.k_uniqueness = DIRENTRY_UNIQUENESS;
+  ih->u.ih_entry_count = 2;
+  ih->ih_item_len = EMPTY_DIR_SIZE;
+
+  body = empty_dir;
+  deh = (struct reiserfs_de_head *)body;
+
+#ifdef REISERFS_ALIGNED
+  deh[0].deh_location = ih->ih_item_len - 4;
+#else
+  deh[0].deh_location = ih->ih_item_len - strlen (".");
+#endif
+  deh[0].deh_offset = DOT_OFFSET;
+  deh[0].deh_dir_id = ih->ih_key.k_dir_id;
+  deh[0].deh_objectid = ih->ih_key.k_objectid;
+  mark_de_without_sd (&(deh[0]));
+  mark_de_visible (&(deh[0]));
+#ifdef REISERFS_ALIGNED
+  strncpy( body + deh[0].deh_location, ".", 4 );
+#else
+  body[deh[0].deh_location] = '.';
+#endif
+
+#ifdef REISERFS_ALIGNED
+  deh[1].deh_location = deh[0].deh_location - 4;
+#else
+  deh[1].deh_location = deh[0].deh_location - strlen ("..");
+#endif
+  deh[1].deh_offset = DOT_DOT_OFFSET;
+
+  /* objectid of ".." directory */
+  deh[1].deh_dir_id = INODE_PKEY (dir)->k_dir_id;
+  deh[1].deh_objectid = INODE_PKEY (dir)->k_objectid;
+  mark_de_without_sd (&(deh[1]));
+  mark_de_visible (&(deh[1]));
+#ifdef REISERFS_ALIGNED
+  strncpy( body + deh[1].deh_location, "..", 4 );
+#else
+  body[deh[1].deh_location] = '.';
+  body[deh[1].deh_location + 1] = '.';
+#endif
+
+  /* look for place in the tree for new item */
+  if (search_by_key (sb, &ih->ih_key,  path, &repeat, DISK_LEAF_NODE_LEVEL, READ_BLOCKS) == ITEM_FOUND)
+    reiserfs_panic (sb, "vs-13070: reiserfs_new_directory: object with this key exists [%lu %lu %lu %lu]",
+		    ih->ih_key.k_dir_id, ih->ih_key.k_objectid, ih->ih_key.k_offset, ih->ih_key.k_uniqueness);
+
+  /* insert item, that is empty directory item */
+  return reiserfs_insert_item (th, sb, path, ih, body, REISERFS_KERNEL_MEM, 0, NOTHING_SPECIAL);
+}
+
+
+/* stat data of object has been inserted, this inserts the item
+   containing the body of symlink */
+static int reiserfs_new_symlink (struct reiserfs_transaction_handle *th, 
+                                 struct super_block * sb, struct item_head * ih, struct path * path, const char * symname)
+{
+  int repeat;
+
+  /* item head of the body of symlink */
+  ih->ih_key.k_offset = 1;
+  ih->ih_key.k_uniqueness = TYPE_DIRECT;
+  ih->ih_item_len = strlen (symname);
+
+  /* look for place in the tree for new item */
+  if (search_by_key (sb, &ih->ih_key, path, &repeat, DISK_LEAF_NODE_LEVEL, READ_BLOCKS) == ITEM_FOUND)
+    reiserfs_panic (sb, "vs-13080: reiserfs_new_symlink: object with this key exists [%lu %lu %lu %lu]",
+		    ih->ih_key.k_dir_id, ih->ih_key.k_objectid, ih->ih_key.k_offset, ih->ih_key.k_uniqueness);
+
+  /* insert item, that is body of symlink */
+  return reiserfs_insert_item (th, sb, path, ih, symname, REISERFS_KERNEL_MEM, 0, NOTHING_SPECIAL);
+}
+
+
+/* inserts the stat data into the tree, and then calls reiserfs_new_directory
+   (to insert ".", ".." item if new object is directory) or
+   reiserfs_new_symlink (to insert symlink body if new object is
+   symlink) or nothing (if new object is regular file) */
+struct inode * reiserfs_new_inode (struct reiserfs_transaction_handle *th,
+				   const struct inode * dir, int mode, const char * symname, 
+				   struct dentry *dentry, struct inode *inode, int * err)
+{
+    struct super_block * sb;
+    /* struct inode * inode; */
+    struct path path_to_key;
+    struct item_head ih;
+    struct stat_data sd;
+    int retvalue;
+    int repeat;
+
+    init_path (&path_to_key);
+
+    /* if (!dir || !(inode = get_empty_inode())) journal victim */
+    if (!dir || !dir->i_nlink) { 
+	iput(inode) ;
+	*err = -EPERM;
+	return NULL;
+    } 
+    sb = dir->i_sb;
+    inode->i_sb = sb;
+    inode->i_flags = inode->i_sb->s_flags;
+
+    ih.ih_key.k_dir_id = INODE_PKEY (dir)->k_objectid;
+    ih.ih_key.k_objectid = reiserfs_get_unused_objectid (th, dir->i_sb);
+    ih.ih_key.k_offset = SD_OFFSET;
+    ih.ih_key.k_uniqueness = TYPE_STAT_DATA;
+    ih.u.ih_free_space = MAX_US_INT;
+    ih.ih_item_len = SD_SIZE;
+
+    /* free preserve list if we should */
+/*    maybe_free_preserve_list (dir->i_sb);*/
+
+    /* find proper place for inserting of stat data */
+    if (search_by_key (sb, &ih.ih_key, &path_to_key, &repeat, DISK_LEAF_NODE_LEVEL, READ_BLOCKS) == ITEM_FOUND) {
+	pathrelse (&path_to_key);
+	iput (inode);
+	*err = -EEXIST;
+	return 0;
+    }
+
+    /* fill stat data */
+    sd.sd_mode = inode->i_mode = mode;
+    if (mode & S_IFDIR) {
+	sd.sd_nlink = inode->i_nlink = 2;
+	sd.sd_size = inode->i_size = EMPTY_DIR_SIZE;
+	inode->i_blocks = EMPTY_DIR_SIZE / 512 + ((EMPTY_DIR_SIZE % 512) ? 1 : 0);
+    } else {
+	sd.sd_nlink = inode->i_nlink = 1;
+	sd.sd_size = inode->i_size = 0;
+    }
+    sd.sd_uid = inode->i_uid = current->fsuid;
+    sd.sd_gid = inode->i_gid = (dir->i_mode & S_ISGID) ? dir->i_gid : current->fsgid;
+  
+    sd.sd_mtime = sd.sd_atime = sd.sd_ctime = inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
+    if ((mode & S_IFCHR) || (mode & S_IFBLK))
+		sd.u.sd_rdev = 0;
+    else sd.u.sd_blocks = inode->i_blocks = 0;
+
+    sd.sd_first_direct_byte = inode->u.reiserfs_i.i_first_direct_byte = S_ISLNK(mode) ? 1 : NO_BYTES_IN_DIRECT_ITEM;
+    
+    /* insert the stat data into the tree */
+    retvalue = reiserfs_insert_item (th, sb, &path_to_key, &ih, (char *)(&sd), REISERFS_KERNEL_MEM, 0, NOTHING_SPECIAL);
+    if (retvalue == NO_DISK_SPACE) {
+	iput (inode);
+	*err = -ENOSPC;
+	return 0;
+    }
+
+    if (S_ISDIR(mode)) {
+	/* insert item with "." and ".." */
+	retvalue = reiserfs_new_directory (th, sb, &ih, &path_to_key, dir);
+    }
+
+    if (S_ISLNK(mode)) {
+	/* insert body of symlink */
+	retvalue = reiserfs_new_symlink (th, sb, &ih, &path_to_key, symname);
+    }
+    if (retvalue == NO_DISK_SPACE) {
+	/* we must delete stat data here */
+	memcpy (INODE_PKEY (inode), &(ih.ih_key), SHORT_KEY_SIZE);
+	iput (inode);
+	*err = -ENOSPC;
+	return 0;
+    }
+
+    inode->i_dev = sb->s_dev;
+    inode->i_ino = ih.ih_key.k_objectid;
+    inode->i_op = NULL;
+    inode->i_blocks = 0;
+    inode->i_blksize = sb->s_blocksize;
+
+    memcpy (INODE_PKEY (inode), &(ih.ih_key), SHORT_KEY_SIZE);
+    insert_inode_hash (inode);
+/*  mark_inode_dirty (inode);*/
+    return inode;
+}
+
+
+extern spinlock_t inode_lock;
+
+                                /* This is the problem we are trying to solve: with reiserfs it is a bad thing to defer
+                                an update of stat data if the buffer holding the stat data is in RAM. If we defer it,
+                                then when we later do the update, the buffer might not still be in RAM.  Consider that
+                                inodes have a longer lifetime in RAM, and you can see that this is especially important.
+
+                                Unfortunately, sometimes we need to pass an inode, sometimes an iattr, sometimes just
+                                one field, to the function that updates the stat data.  Umpteen different functions that
+                                do essentially the same thing.  For now I implement just a straight replacement for
+                                mark_inode_dirty -Hans */
+                                /* This function is inefficient if only one field of the inode was changed. 
+                                 This function can cause schedule.  */
+void if_in_ram_update_sd (struct reiserfs_transaction_handle *th, struct inode * inode)
+{
+  struct path path_to_sd;
+
+  reiserfs_update_inode (th, inode, &path_to_sd, READ_BLOCKS);
+  pathrelse (&path_to_sd);
+  return ;
+
+#ifdef DIRTY_LATER
+  mark_inode_dirty(inode);
+  return;
+#else /* DIRTY_LATER */
+
+  struct path path_to_sd;
+  extern struct list_head inode_in_use;
+
+
+  init_path (&path_to_sd);
+  
+  if (!inode->i_nlink || (S_ISFIFO (inode->i_mode))) { 
+    mark_inode_dirty(inode);    /* let us deferr the update since in this case we always follow this with an iput which
+                                   will do the update (that is to say, the removal) of the stat data */
+    return;
+  }
+
+#ifdef REISERFS_CHECK
+  if (inode->i_sb) {
+#endif /* REISERFS_CHECK */
+
+    /* wait until inode is not locked and then lock it */
+    while ((inode->i_state & I_LOCK)) {
+      __wait_on_inode(inode);
+    }
+    inode->i_state |=  I_LOCK;
+
+    if (reiserfs_update_inode (th, inode, &path_to_sd, DONT_READ_BLOCKS)) {
+      spin_lock(&inode_lock);   /* locks inode lists (not the inode) */
+      if ((inode->i_state & I_DIRTY)) {
+        struct list_head *insert = &inode_in_use;
+
+        /* mark inode clean and take it off dirty list */
+        inode->i_state &= ~I_DIRTY;
+#ifdef REISERFS_CHECK
+        /* Only add valid (ie hashed) inodes to the in_use list */
+        if (!list_empty(&inode->i_hash)) {
+#endif /* REISERFS_CHECK */
+          list_del(&inode->i_list);
+          list_add(&inode->i_list, insert);
+#ifdef REISERFS_CHECK
+        } 
+        else 
+          printk("reiser-1805: if_in_ram_update_sd: a dirty inode was not on any inode list\n");
+#endif /* REISERFS_CHECK */
+      }
+      spin_unlock(&inode_lock);
+      /*mark_buffer_dirty (bh, 1);*/
+    } else {   /* stat data item for this inode no longer in RAM */
+      /* if stat data was not found then it must be because it is no longer in RAM, so just mark it
+	 dirty for now, and let somebody else write it */
+      mark_inode_dirty(inode); 
+    }  
+    inode->i_state &= ~I_LOCK;
+    wake_up(&inode->i_wait);
+    pathrelse(&path_to_sd);
+#ifdef REISERFS_CHECK
+  }
+  else
+    printk("reiser-1804: if_in_ram_update_sd: !sb, should not happen\n");
+#endif /* REISERFS_CHECK */
+
+#endif /* ! DIRTY_LATER */
+}
+
+
+#ifdef __KERNEL__
+/* this generates little if any speedup compared to if_in_ram_update_sd(), might not be worthwhile
+   code, probably search_by_key dominates cpu consumption */
+void if_in_ram_update_some_sd (struct reiserfs_transaction_handle *th, struct inode * inode,  struct iattr * attr)
+{
+  struct stat_data * sd;
+  struct path path_to_sd;
+  int repeat;
+  struct buffer_head * bh;
+  extern struct list_head inode_in_use;
+  unsigned int ia_valid = attr->ia_valid;
+
+  init_path (&path_to_sd);
+
+  if (!inode->i_nlink || (S_ISFIFO (inode->i_mode))) { /* Vladimir, what do you think, is the S_FIFO needed here?-Hans */
+    mark_inode_dirty(inode);    /* let us deferr the update since in this case we always follow this with an iput which
+                                   will do the update (that is to say, the removal) of the stat data */
+    return;
+  }
+
+#ifdef REISERFS_CHECK
+  if (inode->i_sb) {
+#endif /* REISERFS_CHECK */
+
+                                /* wait until inode is not locked and then lock it */
+    while ((inode->i_state & I_LOCK)) {
+      __wait_on_inode(inode);
+    }
+    inode->i_state |=  I_LOCK;  /* depends on interrupts never locking inodes, I suppose it is correct.... */
+
+    /* look for the stat data item, if we find it in RAM, sync to it now, else put the inode on the list of dirty inodes
+       to be synced someday using mark_inode_dirty and perhaps the sync will happen when the buffer is back in RAM or
+       after a bunch of other changes to it have been successfully cached by deferring the I/O */
+    if (search_by_key (inode->i_sb, INODE_PKEY (inode), &path_to_sd, &repeat, DISK_LEAF_NODE_LEVEL, DONT_READ_BLOCKS) == ITEM_FOUND) {
+                                /* all of these branches are very inefficient, but the search_by_key is probably the
+                                   worst of it */
+      bh = PATH_PLAST_BUFFER (&path_to_sd);
+      sd = B_N_STAT_DATA (bh, PATH_LAST_POSITION (&path_to_sd));
+        if (ia_valid & ATTR_MODE)
+          sd->sd_mode = cpu_to_le16 (inode->i_mode);
+        if (ia_valid & ATTR_UID)
+          sd->sd_uid = cpu_to_le16 (inode->i_uid);
+        if (ia_valid & ATTR_GID)
+          sd->sd_gid = cpu_to_le16 (inode->i_gid);
+        if (ia_valid & ATTR_SIZE)
+          sd->sd_size = cpu_to_le32 (inode->i_size);
+        if (ia_valid & ATTR_MTIME)
+          sd->sd_mtime = cpu_to_le32 (inode->i_mtime);
+        if (ia_valid & ATTR_CTIME)
+          sd->sd_ctime = cpu_to_le32 (inode->i_ctime);
+      spin_lock(&inode_lock);   /* locks inode lists (not the inode) */
+      if ((inode->i_state & I_DIRTY)) {
+        struct list_head *insert = &inode_in_use;
+
+        /*      mark inode clean and take it off dirty list */
+        inode->i_state &= ~I_DIRTY;
+#ifdef REISERFS_CHECK
+        /* Only add valid (ie hashed) inodes to the in_use list */
+        if (!list_empty(&inode->i_hash)) {
+#endif /* REISERFS_CHECK */
+          list_del(&inode->i_list);
+          list_add(&inode->i_list, insert);
+#ifdef REISERFS_CHECK
+        }
+        else 
+          printk("reiser-1806: if_in_ram_update_some_sd: a dirty inode was not on any inode list, maybe a pipe?");
+#endif /* REISERFS_CHECK */
+      }
+      spin_unlock(&inode_lock);
+      /* mark_buffer_dirty (bh, 1); journal victim */
+      journal_mark_dirty (th, inode->i_sb, bh);
+    } else {   /* stat data item for this inode no longer in RAM */
+      inode->i_state &= ~I_LOCK; /* probably should combine two lines that unlock inode by postponing the unlock.... */
+                                /* if inode was not found then it must be because it is no longer in RAM, so just
+                                   mark it dirty for now, and let somebody else write it */
+      mark_inode_dirty(inode); 
+    }  
+    inode->i_state &= ~I_LOCK;
+    wake_up(&inode->i_wait);
+    pathrelse(&path_to_sd);
+#ifdef REISERFS_CHECK
+  }
+  else
+    printk("reiser-1807: if_in_ram_update_some_sd: !sb, should not happen");
+#endif /* REISERFS_CHECK */
+}
+
+
+void inline reiserfs_inode_setattr(struct reiserfs_transaction_handle *th, struct inode * inode, struct iattr * attr)
+{
+        unsigned int ia_valid = attr->ia_valid;
+	/* struct path path_to_sd; */
+
+        if (ia_valid & ATTR_UID)
+                inode->i_uid = attr->ia_uid;
+        if (ia_valid & ATTR_GID)
+                inode->i_gid = attr->ia_gid;
+        if (ia_valid & ATTR_SIZE)
+                inode->i_size = attr->ia_size;
+        if (ia_valid & ATTR_ATIME)
+                inode->i_atime = attr->ia_atime;
+        if (ia_valid & ATTR_MTIME)
+                inode->i_mtime = attr->ia_mtime;
+        if (ia_valid & ATTR_CTIME)
+                inode->i_ctime = attr->ia_ctime;
+        if (ia_valid & ATTR_MODE) {
+                inode->i_mode = attr->ia_mode;
+                if (!in_group_p(inode->i_gid) && !capable(CAP_FSETID))
+                        inode->i_mode &= ~S_ISGID;
+        }
+#ifdef DIRTY_LATER
+        mark_inode_dirty(inode) ;  
+	/* reiserfs_update_inode (inode, &path_to_sd, READ_BLOCKS); 
+	pathrelse (&path_to_sd); */
+#else /* note, this code is broken and MUST not be used */
+        if_in_ram_update_some_sd (th, inode, attr);
+#endif
+}
+
+
+int reiserfs_notify_change(struct dentry * dentry, struct iattr * attr)
+{
+        struct inode *inode = dentry->d_inode;
+	struct reiserfs_transaction_handle th ;
+        int error;
+
+	/* I'm cheating here.  reiserfs_inode_setattr does not make journal calls with
+	** dirty later turned on.  Dirty later must be on for now, so I'm not doing
+	** a journal_begin here.
+	*/
+	th.t_trans_id = 0 ; 
+        error = inode_change_ok(inode, attr);
+        if (!error)
+          reiserfs_inode_setattr(&th, inode, attr);
+        return error;
+}
+
+/* I believe that further optimizing this code is best done by optimizing search_by_key.. */
+
+#endif /* __KERNEL__ */
Index: empeg/kernel/fs/reiserfs/journal.c
diff -u /dev/null empeg/kernel/fs/reiserfs/journal.c:1.1
--- /dev/null	Wed Oct 17 16:36:05 2001
+++ empeg/kernel/fs/reiserfs/journal.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,2553 @@
+/*
+** This code is released under the same license as the rest of reiserfs.  It can be changed, modified or reused
+** as stated in reiserfs/README.
+**
+** write ahead logging implementation by Chris Mason (clmsys@rit.edu)
+**
+*/
+
+
+/*
+** The background commits make this code very interelated, and overly complex.  I need to 
+** rethink things a bit....The major players:
+**
+** journal_begin -- call with the number of blocks you expect to log.  If the current transaction is too
+** 		    old, it will block until the current transaction is finished, and then start a new one.
+**		    Usually, your transaction will get joined in with previous ones for speed.
+**
+** journal_join  -- same as journal_begin, but won't block on the current transaction regardless of age.  Don't ever call
+**                  this.  Ever.  There are only two places it should be called from, and they are both inside this file.
+**
+** journal_mark_dirty_nolog -- if the block is in the current transaction or might get overwritten by a log replay, 
+**                             calls journal_mark_dirty.  Otherwise, just mark it dirty and move on.
+**
+** journal_mark_dirty -- adds blocks into this transaction.  clears any flags that might make them get sent to disk
+**                       and then marks them BH_JDirty.  Puts the buffer head into the current transaction hash.  If
+**		         it was already in the hash, the old one is removed first to keep the replay order correct.
+**
+** journal_end -- if the current transaction is batchable, it does nothing
+**                   otherwise, it could do an async/synchronous commit, or
+**                   a full flush of all log and real blocks in the 
+**                   transaction.
+**
+** flush_old_commits -- if the current transaction is too old, it is ended and commit blocks are sent to disk.  
+**			Forces commit blocks to disk for all backgrounded commits that have been around too long.
+**		     -- Note, if you call this as an immediate flush from 
+**		        from within kupdate, it will ignore the immediate flag
+**
+** The commit thread -- a writer process for async commits.  It allows a 
+**                      a process to request a log flush on a task queue.
+**                      the commit will happen once the commit thread wakes up.
+**                      The benefit here is the writer (with whatever
+**                      related locks it has) doesn't have to wait for the
+**                      log blocks to hit disk if it doesn't want to.
+*/
+
+#ifdef __KERNEL__
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+
+#include <linux/sched.h>
+
+#include <linux/vmalloc.h>
+#include <linux/reiserfs_fs.h>
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/fcntl.h>
+#include <linux/locks.h>
+#include <linux/stat.h>
+#include <linux/string.h>
+#include <linux/smp_lock.h>
+
+#else
+
+#include "nokernel.h"
+
+#endif
+
+#define JOURNAL_MBUF_COUNT 128 	/* number of buffer heads for logs block to keep in ram */
+#define JOURNAL_TRANS_HALF 1018   /* must be correct to keep the desc and commit structs at 4k */
+
+/* cnode stat bits.  Move these into reiserfs_fs.h */
+
+#define BLOCK_FREED 2		/* this block was freed, and can't be written.  */
+#define BLOCK_FREED_HOLDER 3    /* this block was freed during this transaction, and can't be written */
+
+/* flags for do_journal_end */
+#define FLUSH_ALL   1		/* flush commit and real blocks */
+#define COMMIT_NOW  2		/* end and commit this transaction */
+#define WAIT        4		/* wait for the log blocks to hit the disk*/
+
+static int do_journal_end(struct reiserfs_transaction_handle *,struct super_block *,unsigned long nblocks,int flags) ;
+static void dirty_journal_list(struct super_block *p_s_sb, struct reiserfs_journal_list *jl) ;
+static int flush_journal_list(struct super_block *s, struct reiserfs_journal_list *jl, int old_only,int flushall) ;
+static int flush_commit_list(struct super_block *s, struct reiserfs_journal_list *jl, int flushall)  ;
+
+#if 0 /* see this in reiserfs_fs.h */
+
+#define JOURNAL_TRANS_HALF 1018   /* must be correct to keep the desc and commit structs at 4k */
+
+/* first block written in a commit.  BUG, not 64bit safe */
+struct reiserfs_journal_desc {
+  unsigned long j_trans_id ;			/* id of commit */
+  unsigned long j_len ;			/* length of commit. len +1 is the commit block */
+  unsigned long j_mount_id ;				/* mount id of this trans*/
+  unsigned long j_realblock[JOURNAL_TRANS_HALF] ; /* real locations for each block */
+  char j_magic[12] ;
+} ;
+
+/* last block written in a commit BUG, not 64bit safe */
+struct reiserfs_journal_commit {
+  unsigned long j_trans_id ;			/* must match j_trans_id from the desc block */
+  unsigned long j_len ;			/* ditto */
+  unsigned long j_realblock[JOURNAL_TRANS_HALF] ; /* real locations for each block */
+  char j_digest[16] ;			/* md5 sum of all the blocks involved, including desc and commit. not used, kill it */
+} ;
+
+/* this header block gets written whenever a transaction is considered fully flushed, and is more recent than the
+** last fully flushed transaction.  fully flushed means all the log blocks and all the real blocks are on disk,
+** and this transaction does not need to be replayed.
+*/
+struct reiserfs_journal_header {
+  unsigned long j_last_flush_trans_id ;		/* id of last fully flushed transaction */
+  unsigned long j_first_unflushed_offset ;      /* offset in the log of where to start replay after a crash */
+  unsigned long j_mount_id ;
+} ;
+#endif /* see this in reiserfs_fs.h */
+
+static void init_journal_hash(struct super_block *p_s_sb) {
+  memset(SB_JOURNAL(p_s_sb)->j_hash_table, 0, JOURNAL_HASH_SIZE * sizeof(struct reiserfs_journal_cnode *)) ;
+}
+
+/*
+** clears BH_Dirty and sticks the buffer on the clean list.  Called because I can't allow refile_buffer to
+** make schedule happen after I've freed a block.  Look at remove_from_transaction and journal_mark_freed for
+** more details.
+*/
+static int reiserfs_clean_and_file_buffer(struct buffer_head *bh) {
+  if (bh) {
+    clear_bit(BH_Dirty, &bh->b_state) ;
+    if (bh->b_list != BUF_CLEAN) {
+      reiserfs_file_buffer(bh, BUF_CLEAN) ;
+    }
+  }
+  return 0 ;
+}
+
+/*
+** only call this on FS unmount.
+*/
+static int free_list_bitmaps(struct super_block *p_s_sb) {
+  int i ;
+  struct reiserfs_list_bitmap *jb ;
+  for (i = 0 ; i < JOURNAL_NUM_BITMAPS ; i++) {
+    jb = SB_JOURNAL(p_s_sb)->j_list_bitmap + i ;
+    jb->journal_list = NULL ;
+    vfree(jb->bitmap) ;
+  }
+  return 0;
+}
+
+/*
+** get memory for JOURNAL_NUM_BITMAPS worth of bitmaps.  ick.
+*/
+static int allocate_list_bitmaps(struct super_block *p_s_sb) {
+  int i ;
+  int failed = 0 ;
+  struct reiserfs_list_bitmap *jb ;
+  for (i = 0 ; i < JOURNAL_NUM_BITMAPS ; i++) {
+    jb = SB_JOURNAL(p_s_sb)->j_list_bitmap + i ;
+    jb->journal_list = NULL ;
+    jb->bitmap = vmalloc( ((SB_BLOCK_COUNT(p_s_sb) / 8) + 1) * sizeof(char)) ;
+    if (!jb->bitmap) {
+      reiserfs_warning("clm-2000, unable to allocate bitmaps for journal lists\n") ;
+      failed = 1;   
+      break ;
+    }
+    memset(jb->bitmap, 0, ((SB_BLOCK_COUNT(p_s_sb) / 8) + 1) * sizeof(char)) ;
+  }
+  if (failed) {
+    free_list_bitmaps(p_s_sb) ;
+    return -1 ;
+  }
+  return 0 ;
+}
+
+/*
+** find an available list bitmap.  If you can't find one, flush a commit list and try again
+*/
+static struct reiserfs_list_bitmap *get_list_bitmap(struct super_block *p_s_sb, struct reiserfs_journal_list *jl) {
+  int i,j ; 
+  struct reiserfs_list_bitmap *jb = NULL ;
+
+  for (j = 0 ; j < (JOURNAL_NUM_BITMAPS * 3) ; j++) {
+    i = SB_JOURNAL(p_s_sb)->j_list_bitmap_index ;
+    SB_JOURNAL(p_s_sb)->j_list_bitmap_index = (i + 1) % JOURNAL_NUM_BITMAPS ;
+    jb = SB_JOURNAL(p_s_sb)->j_list_bitmap + i ;
+    if (SB_JOURNAL(p_s_sb)->j_list_bitmap[i].journal_list) {
+      flush_commit_list(p_s_sb, SB_JOURNAL(p_s_sb)->j_list_bitmap[i].journal_list, 1) ;
+      if (!SB_JOURNAL(p_s_sb)->j_list_bitmap[i].journal_list) {
+	break ;
+      }
+    } else {
+      break ;
+    }
+  }
+  if (jb->journal_list) { /* double check to make sure if flushed correctly */
+    return NULL ;
+  }
+  memset(jb->bitmap, 0, ((SB_BLOCK_COUNT(p_s_sb) / 8) + 1) * sizeof(char)) ;
+  jb->journal_list = jl ;
+  return jb ;
+}
+
+/* 
+** allocates a new chunk of X nodes, and links them all together as a list.
+** Uses the cnode->next and cnode->prev pointers
+** returns NULL on failure
+*/
+static struct reiserfs_journal_cnode *allocate_cnodes(int num_cnodes) {
+  struct reiserfs_journal_cnode *head ;
+  int i ;
+  if (num_cnodes <= 0) {
+    return NULL ;
+  }
+  head = vmalloc(num_cnodes * sizeof(struct reiserfs_journal_cnode)) ;
+  if (!head) {
+    return NULL ;
+  }
+  memset(head, 0, num_cnodes * sizeof(struct reiserfs_journal_cnode)) ;
+  head[0].prev = NULL ;
+  head[0].next = head + 1 ;
+  for (i = 1 ; i < num_cnodes; i++) {
+    head[i].prev = head + (i - 1) ;
+    head[i].next = head + (i + 1) ; /* if last one, overwrite it after the if */
+  }
+  head[num_cnodes -1].next = NULL ;
+  return head ;
+}
+
+/*
+** pulls a cnode off the free list, or returns NULL on failure 
+*/
+static struct reiserfs_journal_cnode *get_cnode(struct super_block *p_s_sb) {
+  struct reiserfs_journal_cnode *cn ;
+  if (SB_JOURNAL(p_s_sb)->j_cnode_free <= 0) {
+    return NULL ;
+  }
+  SB_JOURNAL(p_s_sb)->j_cnode_used++ ;
+  SB_JOURNAL(p_s_sb)->j_cnode_free-- ;
+  cn = SB_JOURNAL(p_s_sb)->j_cnode_free_list ;
+  if (!cn) {
+    return cn ;
+  }
+  if (cn->next) {
+    cn->next->prev = NULL ;
+  }
+  SB_JOURNAL(p_s_sb)->j_cnode_free_list = cn->next ;
+  memset(cn, 0, sizeof(struct reiserfs_journal_cnode)) ;
+  return cn ;
+}
+
+/*
+** returns a cnode to the free list 
+*/
+static void free_cnode(struct super_block *p_s_sb, struct reiserfs_journal_cnode *cn) {
+  SB_JOURNAL(p_s_sb)->j_cnode_used-- ;
+  SB_JOURNAL(p_s_sb)->j_cnode_free++ ;
+  /* memset(cn, 0, sizeof(struct reiserfs_journal_cnode)) ; */
+  cn->next = SB_JOURNAL(p_s_sb)->j_cnode_free_list ;
+  if (SB_JOURNAL(p_s_sb)->j_cnode_free_list) {
+    SB_JOURNAL(p_s_sb)->j_cnode_free_list->prev = cn ;
+  }
+  cn->prev = NULL ; /* not needed with the memset, but I might kill the memset, and forget to do this */
+  SB_JOURNAL(p_s_sb)->j_cnode_free_list = cn ;
+}
+
+
+/* buffer is in current transaction */
+inline int buffer_journaled(struct buffer_head *bh) {
+  if (bh)
+    return test_bit(BH_JDirty, &bh->b_state) ;
+  else
+    return 0 ;
+}
+
+/* disk block was taken off free list before being in a finished transation, or written to disk
+** journal_new blocks can be reused immediately, for any purpose
+*/ 
+inline int buffer_journal_new(struct buffer_head *bh) {
+  if (bh) 
+    return test_bit(BH_JNew, &bh->b_state) ;
+  else
+    return 0 ;
+}
+
+inline int mark_buffer_journal_new(struct buffer_head *bh) {
+  if (bh) {
+    set_bit(BH_JNew, &bh->b_state) ;
+  }
+  return 0 ;
+}
+
+inline int mark_buffer_not_journaled(struct buffer_head *bh) {
+  if (bh) 
+    clear_bit(BH_JDirty, &bh->b_state) ;
+  return 0 ;
+}
+
+/* return a cnode with same dev, block number and size in table, or null if not found */
+static inline struct reiserfs_journal_cnode *get_journal_hash_dev(struct reiserfs_journal_cnode **table,
+                                   				  kdev_t dev,long bl,int size) {
+  struct reiserfs_journal_cnode *cn ;
+  cn = journal_hash(table, dev, bl) ;
+  while(cn) {
+    if ((cn->blocknr == bl) && (cn->dev == dev))
+      return cn ;
+    cn = cn->hnext ;
+  }
+  return (struct reiserfs_journal_cnode *)0 ;
+}
+
+/* returns a cnode with same size, block number and dev as bh in the current transaction hash.  NULL if not found */
+static inline struct reiserfs_journal_cnode *get_journal_hash(struct super_block *p_s_sb, struct buffer_head *bh) {
+  struct reiserfs_journal_cnode *cn ;
+  if (bh) {
+    cn =  get_journal_hash_dev(SB_JOURNAL(p_s_sb)->j_hash_table, bh->b_dev, bh->b_blocknr, bh->b_size) ;
+  }
+  else {
+    return (struct reiserfs_journal_cnode *)0 ;
+  }
+  return cn ;
+}
+
+/*
+** once upon a time, the journal would deadlock.  a lot.  Now, which REISERFS_CHECK, anytime someone enters a
+** transaction, it pushes itself into this ugly static list, and pops itself off before calling journal_end.
+** I made a SysRq key to dump the list, and tell me what the writers are when I'm deadlocked.
+*/
+static char *journal_writers[512] ;
+int push_journal_writer(char *s) {
+#ifdef REISERFS_CHECK
+  int i ;
+  for (i = 0 ; i < 512 ; i++) {
+    if (!journal_writers[i]) {
+      journal_writers[i] = s ;
+      return i ;
+    }
+  }
+  return -1 ;
+#else
+  return 0 ;
+#endif
+}
+int pop_journal_writer(int index) {
+#ifdef REISERFS_CHECK
+  if (index >= 0) {
+    journal_writers[index] = NULL ;
+  }
+#endif
+  return 0 ;
+}
+int dump_journal_writers(void) {
+  int i ;
+  for (i = 0 ; i < 512 ; i++) {
+    if (journal_writers[i]) {
+      printk("%d: %s\n", i, journal_writers[i]) ;
+    }
+  }
+  return 0 ;
+}
+
+/*
+** this actually means 'can this block be reallocated yet?'.  If you set search_all, a block can only be allocated
+** if it is not in the current transaction, was not freed by the current transaction, and has no chance of ever
+** being overwritten by a replay after crashing.
+**
+** If you don't set search_all, a block can only be allocated if it is not in the current transaction.  Since deleting
+** a block removes it from the current transaction, this case should never happen.  If you don't set search_all, make
+** sure you never write the block without logging it.
+**
+** next_zero_bit is a suggestion about the next block to try for find_forward.
+** when bl is rejected because it is set in a journal list bitmap, we search
+** for the next zero bit in the bitmap that rejected bl.  Then, we return that
+** through next_zero_bit for find_forward to try.
+**
+** Just because we return something in next_zero_bit does not mean we won't
+** reject it on the next call to reiserfs_in_journal
+**
+*/
+int reiserfs_in_journal(struct super_block *p_s_sb, kdev_t dev, unsigned long bl, int size, int search_all, unsigned long *next_zero_bit) {
+  struct reiserfs_journal_cnode *cn ;
+  struct reiserfs_list_bitmap *jb ;
+  int i ;
+
+  *next_zero_bit = 0 ; /* always start this at zero. */
+
+  /* If we aren't doing a search_all, this is a metablock, and it will be logged before use.
+  ** if we crash before the transaction that freed it commits,  this transaction won't
+  ** have committed either, and the block will never be written
+  */
+  if (search_all) {
+    for (i = 0 ; i < JOURNAL_NUM_BITMAPS ; i++) {
+      jb = SB_JOURNAL(p_s_sb)->j_list_bitmap + i ;
+      if (jb->journal_list && test_bit(bl, jb->bitmap)) {
+	*next_zero_bit = find_next_zero_bit((unsigned long *)(jb->bitmap),
+	                                   SB_BLOCK_COUNT(p_s_sb), bl+1) ; 
+	return 1 ;
+      }
+    }
+  }
+
+  /* is it in any old transactions? */
+  if (search_all && (cn = get_journal_hash_dev(SB_JOURNAL(p_s_sb)->j_list_hash_table, dev,bl,size))) {
+    return 1; 
+  }
+
+  /* is it in the current transaction.  This should never happen */
+  if ((cn = get_journal_hash_dev(SB_JOURNAL(p_s_sb)->j_hash_table, dev,bl,size))) {
+    return 1; 
+  }
+
+  /* safe for reuse */
+  return 0 ;
+}
+
+/* insert cn into table
+*/
+inline void insert_journal_hash(struct reiserfs_journal_cnode **table, struct reiserfs_journal_cnode *cn) {
+  struct reiserfs_journal_cnode *cn_orig ;
+
+  cn_orig = journal_hash(table, cn->dev, cn->blocknr) ;
+  cn->hnext = cn_orig ;
+  cn->hprev = NULL ;
+  if (cn_orig) {
+    cn_orig->hprev = cn ;
+  }
+  journal_hash(table, cn->dev, cn->blocknr) =  cn ;
+}
+
+/* lock the current transaction */
+inline static void lock_journal(struct super_block *p_s_sb) {
+  while(atomic_read(&(SB_JOURNAL(p_s_sb)->j_wlock)) > 0) {
+    sleep_on(&(SB_JOURNAL(p_s_sb)->j_wait)) ;
+  }
+  atomic_set(&(SB_JOURNAL(p_s_sb)->j_wlock), 1) ;
+}
+
+/* unlock the current transaction */
+inline static void unlock_journal(struct super_block *p_s_sb) {
+  atomic_dec(&(SB_JOURNAL(p_s_sb)->j_wlock)) ;
+  wake_up(&(SB_JOURNAL(p_s_sb)->j_wait)) ;
+}
+
+/*
+** this used to be much more involved, and I'm keeping it just in case things get ugly again.
+** it gets called by flush_commit_list, and cleans up any data stored about blocks freed during a
+** transaction.
+*/
+static void cleanup_freed_for_journal_list(struct super_block *p_s_sb, struct reiserfs_journal_list *jl) {
+
+  jl->j_list_bitmap->journal_list = NULL ;
+  jl->j_list_bitmap = NULL ;
+}
+
+/*
+** if this journal list still has commit blocks unflushed, send them to disk.
+**
+** log areas must be flushed in order (transaction 2 can't commit before transaction 1)
+** Before the commit block can by written, every other log block must be safely on disk
+**
+*/
+static int flush_commit_list(struct super_block *s, struct reiserfs_journal_list *jl, int flushall) {
+  int i, count ;
+  int index = 0 ;
+  int bn ;
+  int retry_count = 0 ;
+  int orig_commit_left = 0 ;
+  struct buffer_head **tbh ;
+  struct reiserfs_journal_list *other_jl ;
+  struct buffer_head *local_bh[32] ; /* if we have fewer than 32 commit blocks left, use this instead of a kmalloc */
+
+  if (atomic_read(&jl->j_older_commits_done)) {
+    return 0 ;
+  }
+
+  /* before we can put our commit blocks on disk, we have to make sure everyone older than
+  ** us is on disk too
+  */
+  if (jl->j_len <= 0) {
+    return 0 ;
+  }
+  if (flushall) {
+    /* we _must_ make sure the transactions are committed in order.  Start with the
+    ** index after this one, wrap all the way around 
+    */
+    index = (jl - SB_JOURNAL_LIST(s)) + 1 ;
+    for (i = 0 ; i < JOURNAL_LIST_COUNT ; i++) {
+      other_jl = SB_JOURNAL_LIST(s) + ( (index + i) % JOURNAL_LIST_COUNT) ;
+      if (other_jl && other_jl != jl && other_jl->j_len > 0 && other_jl->j_trans_id > 0 && 
+          other_jl->j_trans_id <= jl->j_trans_id && (atomic_read(&(jl->j_older_commits_done)) == 0)) {
+        flush_commit_list(s, other_jl, 0) ;
+      }
+    }
+  }
+
+  count = 0 ;
+  /* don't flush the commit list for the current transactoin */
+  if (jl == ((SB_JOURNAL_LIST(s) + SB_JOURNAL_LIST_INDEX(s)))) {
+    return 0 ;
+  }
+
+  /* make sure nobody is trying to flush this one at the same time */
+  if (atomic_read(&(jl->j_commit_flushing))) {
+    sleep_on(&(jl->j_commit_wait)) ;
+    if (flushall) {
+      atomic_set(&(jl->j_older_commits_done), 1) ;
+    }
+    return 0 ;
+  }
+  
+  /* this commit is done, exit */
+  if (atomic_read(&(jl->j_commit_left)) <= 0) {
+    if (flushall) {
+      atomic_set(&(jl->j_older_commits_done), 1) ;
+    }
+    return 0 ;
+  }
+  atomic_set(&(jl->j_commit_flushing), 1) ; /* keeps end_io from doing anything with commit_bh, and 
+                                            others from flushing while we are flushing */
+
+
+  if (jl->j_len > JOURNAL_TRANS_MAX) {
+    reiserfs_panic(s, "clm-2001: flush_commit_list: length is %lu, list number %d\n", jl->j_len, jl - SB_JOURNAL_LIST(s)) ;
+    return 0 ;
+  }
+
+  orig_commit_left = atomic_read(&(jl->j_commit_left)) ; /* why? as log blocks get written j_commit_left goes 
+                                                            down without us knowing */
+
+  /* Ugh, need to make a buffer pool or something */
+  if (orig_commit_left > 30) { /* have 32, but 2 are for the commit and desc */
+    tbh = kmalloc((2 + orig_commit_left) * sizeof(struct buffer_head *), GFP_KERNEL) ; /* + 2 for commit and desc block */
+  } else {
+    tbh = local_bh ;
+  }
+  /* start by checking all the commit blocks in this transaction.  
+  ** Add anyone not on disk into tbh.  Stop checking once commit_left <= 1, because that means we
+  ** only have the commit block left 
+  */
+retry:
+  count = 0 ;
+  for (i = 0 ; atomic_read(&(jl->j_commit_left)) > 1 && i < (jl->j_len + 1) ; i++) {  /* everything but commit_bh */
+    bn = SB_JOURNAL_BLOCK(s) + (jl->j_start + i) % JOURNAL_BLOCK_COUNT  ;
+
+    /* BUG, I use get hash table under the assumption that if it is not in the hash, it has gotten to disk
+    ** and been relsed.  This OK?
+    */
+    tbh[count] = get_hash_table(s->s_dev, bn, s->s_blocksize) ;
+
+/* kill this sanity check */
+if (count > (orig_commit_left + 2)) {
+reiserfs_panic(s, "clm-2002: flush_commit_list: BAD count(%d) > orig_commit_left(%d)!\n", count, orig_commit_left) ;
+}
+    if (tbh[count]) {
+      if (buffer_locked(tbh[count])) { /* wait on it, redo it just to make sure */
+	wait_on_buffer(tbh[count]) ;
+	if (!buffer_uptodate(tbh[count])) {
+	  reiserfs_panic(s, "clm-2003, buffer write failed\n") ;
+	}
+      } 
+      if (buffer_dirty(tbh[count])) {
+	printk("clm-2004: flush_commit_list, block already dirty!\n") ;
+      } else {				
+	mark_buffer_dirty(tbh[count], 0) ; 
+      }
+      tbh[count]->b_end_io = reiserfs_journal_end_io ; /* not needed */
+      ll_rw_block(WRITE, 1, tbh + count) ;
+      count++ ;
+    } 
+  }
+
+  /* wait on everyone in tbh before writing commit block*/
+  for(i = 0 ; i < count ; i++) {
+    wait_on_buffer(tbh[i]) ;
+    if (!buffer_uptodate(tbh[i])) {
+      reiserfs_panic(s, "clm-2005, buffer write failed\n") ;
+    }
+    tbh[i]->b_count-- ; /* once for our get_hash */
+    brelse(tbh[i]) ;    /* once due to original getblk in do_journal_end */
+    atomic_dec(&(jl->j_commit_left)) ;
+  }
+
+  if (atomic_read(&(jl->j_commit_left)) != 1) { /* just the commit_bh left, flush it without calling getblk for everyone */
+    if (retry_count < 2) {
+      printk("clm-2006: flush_commit_list, not all log blocks on disk yet, trying again\n") ;
+      retry_count++ ;
+      goto retry;
+    }
+    reiserfs_panic(s, "clm-2007: flush_commit_list: BAD, j_commit_left is %lu, should be 1\n", 
+                       atomic_read(&(jl->j_commit_left)));
+  }
+
+  mark_buffer_dirty(jl->j_commit_bh,0) ; 
+  ll_rw_block(WRITE, 1, &(jl->j_commit_bh)) ;
+  wait_on_buffer(jl->j_commit_bh) ;
+  if (!buffer_uptodate(jl->j_commit_bh)) {
+    reiserfs_panic(s, "clm-2008: buffer write failed\n") ;
+  }
+  atomic_dec(&(jl->j_commit_left)) ;
+  brelse(jl->j_commit_bh) ;
+
+  /* now, every commit block is on the disk.  It is safe to allow blocks freed during this transaction to be reallocated */
+  cleanup_freed_for_journal_list(s, jl) ;
+
+  /* and it is safe to dirty/release all the real buffer heads */
+  dirty_journal_list(s, jl) ;
+
+  if (tbh != local_bh) { /* only free if we kmalloc'd */
+    kfree(tbh) ;
+  }
+  if (flushall) {
+    atomic_set(&(jl->j_older_commits_done), 1) ;
+  }
+  atomic_set(&(jl->j_commit_flushing), 0) ;
+  wake_up(&(jl->j_commit_wait)) ;
+  return 0 ;
+}
+
+/*
+** flush_journal_list frequently needs to find a newer transaction for a given block.  This does that, or 
+** returns NULL if it can't find anything 
+*/
+static struct reiserfs_journal_list *find_newer_jl_for_cn(struct reiserfs_journal_cnode *cn) {
+  kdev_t dev = cn->dev;
+  unsigned long blocknr = cn->blocknr ;
+
+  cn = cn->hprev ;
+  while(cn) {
+    if (cn->dev == dev && cn->blocknr == blocknr && cn->jlist) {
+      return cn->jlist ;
+    }
+    cn = cn->hprev ;
+  }
+  return NULL ;
+}
+
+
+/*
+** once all the real blocks have been flushed, it is safe to remove them from the
+** journal list for this transaction.  Aside from freeing the cnode, this also allows the
+** block to be reallocated for data blocks if it had been deleted.
+*/
+static void remove_all_from_journal_list(struct super_block *p_s_sb, struct reiserfs_journal_list *jl, int debug) {
+  struct buffer_head fake_bh ;
+  struct reiserfs_journal_cnode *cn, *last ;
+  cn = jl->j_realblock ;
+
+  /* which is better, to lock once around the whole loop, or
+  ** to lock for each call to remove_from_journal_list?
+  */
+  while(cn) {
+    if (cn->blocknr != 0) {
+      if (debug) {
+        printk("block %lu, bh is %d, state %d\n", cn->blocknr, cn->bh ? 1: 0, 
+	        cn->state) ;
+      }
+      fake_bh.b_blocknr = cn->blocknr ;
+      fake_bh.b_dev = cn->dev ;
+      cn->state = 0 ;
+      remove_from_journal_list(p_s_sb, jl, &fake_bh, 1) ;
+    }
+    last = cn ;
+    cn = cn->next ;
+    free_cnode(p_s_sb, last) ;
+  }
+  jl->j_realblock = NULL ;
+}
+
+/*
+** if this timestamp is greater than the timestamp we wrote last to the header block, write it to the header block.
+** once this is done, I can safely say the log area for this transaction won't ever be replayed, and I can start
+** releasing blocks in this transaction for reuse as data blocks.
+** called by flush_journal_list, before it calls remove_all_from_journal_list
+**
+*/
+static int update_journal_header_block(struct super_block *p_s_sb, unsigned long offset, unsigned long trans_id) {
+  struct reiserfs_journal_header *jh ;
+  if (trans_id >= SB_JOURNAL(p_s_sb)->j_last_flush_trans_id) {
+    if (buffer_locked((SB_JOURNAL(p_s_sb)->j_header_bh)))  {
+      wait_on_buffer((SB_JOURNAL(p_s_sb)->j_header_bh)) ;
+      if (!buffer_uptodate(SB_JOURNAL(p_s_sb)->j_header_bh)) {
+        reiserfs_panic(p_s_sb, "clm-2009: buffer write failed\n") ;
+      }
+    }
+    SB_JOURNAL(p_s_sb)->j_last_flush_trans_id = trans_id ;
+    SB_JOURNAL(p_s_sb)->j_first_unflushed_offset = offset ;
+    jh = (struct reiserfs_journal_header *)(SB_JOURNAL(p_s_sb)->j_header_bh->b_data) ;
+    jh->j_last_flush_trans_id = trans_id ;
+    jh->j_first_unflushed_offset = offset ;
+    jh->j_mount_id = SB_JOURNAL(p_s_sb)->j_mount_id ;
+    set_bit(BH_Dirty, &(SB_JOURNAL(p_s_sb)->j_header_bh->b_state)) ;
+    ll_rw_block(WRITE, 1, &(SB_JOURNAL(p_s_sb)->j_header_bh)) ;
+    wait_on_buffer((SB_JOURNAL(p_s_sb)->j_header_bh)) ; 
+    if (!buffer_uptodate(SB_JOURNAL(p_s_sb)->j_header_bh)) {
+      reiserfs_panic(p_s_sb, "clm-2010: buffer write failed\n") ;
+    }
+  }
+  return 0 ;
+}
+
+/*
+** returns 1 if all older journal lists have been flushed
+*/
+static int older_journal_lists_are_flushed(struct super_block *p_s_sb, unsigned long trans_id) {
+  int i ;
+  struct reiserfs_journal_list *jl ;
+  for (i = 0 ; i < JOURNAL_LIST_COUNT ; i++) {
+    jl = SB_JOURNAL_LIST(p_s_sb) + i ;
+    if (jl && jl->j_len > 0 && jl->j_trans_id < trans_id && atomic_read(&(jl->j_nonzerolen)) > 0) {
+      return 0 ;
+    }
+  }
+  return 1 ;
+}
+
+/* 
+** flush any and all journal lists older than you are 
+** can only be called from flush_journal_list
+*/
+static int flush_older_journal_lists(struct super_block *p_s_sb, struct reiserfs_journal_list *jl, unsigned long trans_id) {
+  int i, index ;
+  struct reiserfs_journal_list *other_jl ;
+
+  index = jl - SB_JOURNAL_LIST(p_s_sb) ;
+  for (i = 0 ; i < JOURNAL_LIST_COUNT ; i++) {
+    other_jl = SB_JOURNAL_LIST(p_s_sb) + ((index + i) % JOURNAL_LIST_COUNT) ;
+    if (other_jl && other_jl->j_len > 0 && 
+        other_jl->j_trans_id > 0 && 
+	other_jl->j_trans_id < trans_id && 
+	other_jl != jl) {
+
+      /* not old only, not flush all */
+      flush_journal_list(p_s_sb, other_jl, 0, 0) ; 
+
+    }
+  }
+  return 0 ;
+}
+
+/* flush a journal list, both commit and real blocks
+** set old_only to one if you only want to touch journal_lists that are fully flushed and done with.  This allows
+** you to free the memory they are using
+**
+** always set flushall to 1, unless you are flushing all of them, or you are calling from inside
+** flush_journal_list
+**
+** IMPORTANT.  This can only be called while there are no journal writers, and the journal is locked.  That means
+** it can only be called from do_journal_end.  If you set old_only, you can call from other places.  journal_release
+** can call this because there aren't any writers then.
+*/
+static int flush_journal_list(struct super_block *s, struct reiserfs_journal_list *jl, int old_only, int flushall) {
+  /* struct buffer_head *pbh[JOURNAL_TRANS_MAX] ; */
+  struct buffer_head **pbh ;
+  struct reiserfs_journal_list *pjl ;
+  struct reiserfs_journal_cnode *cn, *last ;
+  int i, count ;
+  int was_jwait = 0 ;
+  int was_dirty = 0 ;
+  struct buffer_head *saved_bh ; /* inc'd to keep the buffer head from going away while we flush it */
+  unsigned long j_len_saved = jl->j_len ;
+
+  if (j_len_saved <= 0) {
+    return 0 ;
+  }
+  /* pretest to avoid the locking */
+  if (old_only && (atomic_read(&(jl->j_nonzerolen)) > 0 || 
+                   atomic_read(&(jl->j_flushing)))) {
+    return 0 ;
+  }
+  while (atomic_read(&(jl->j_commit_flushing)) && !old_only) { /* if someone is getting the commit list, we must wait for them */
+    sleep_on(&(jl->j_commit_wait)) ;
+  }
+  /* if someone is flushing this list, we must wait for them */
+  while (atomic_read(&(jl->j_flushing))) {
+    sleep_on(&(jl->j_flush_wait)) ;
+  }
+
+  /* this list is now ours, we can change anything we want */
+  atomic_set(&(jl->j_flushing), 1) ;
+
+  count = 0 ;
+  if (j_len_saved > JOURNAL_TRANS_MAX) {
+    reiserfs_panic(s, "clm-2011: flush_journal_list, length is %lu, list number %d\n", j_len_saved, jl - SB_JOURNAL_LIST(s)) ;
+    atomic_dec(&(jl->j_flushing)) ;
+    return 0 ;
+  }
+
+  /* if all the work is already done, get out of here */
+  if (atomic_read(&(jl->j_nonzerolen)) <= 0 && atomic_read(&(jl->j_commit_left)) <= 0) {
+    if (flushall) {
+      flush_older_journal_lists(s, jl, jl->j_trans_id) ;
+    } else if (old_only && !older_journal_lists_are_flushed(s, jl->j_trans_id)) { /* only flush if we were called old_only */
+      atomic_dec(&(jl->j_flushing)) ;
+      wake_up(&(jl->j_flush_wait)) ;
+      return 0 ;
+    } 
+    update_journal_header_block(s, (jl->j_start + jl->j_len + 2) % JOURNAL_BLOCK_COUNT, jl->j_trans_id) ;
+    remove_all_from_journal_list(s, jl, 0) ;
+    jl->j_len = 0 ;
+    jl->j_start = 0 ;
+    jl->j_commit_bh = NULL ;
+    jl->j_trans_id = 0 ;
+    atomic_dec(&(jl->j_flushing)) ;
+    wake_up(&(jl->j_flush_wait)) ;
+    return 0 ;
+  } 
+
+  /* if we were called old_only, we're done. */
+  if (old_only) { 
+    atomic_dec(&(jl->j_flushing)) ;
+    wake_up(&(jl->j_flush_wait)) ;
+    return 0 ;
+  }
+
+  /* not old only, start by putting the commit list on disk.  This will also flush the commit lists of any
+  ** olders transactions, which is important
+  */
+  flush_commit_list(s, jl, 1) ;
+
+  /* are we done now? */
+  if (atomic_read(&(jl->j_nonzerolen)) <= 0 && atomic_read(&(jl->j_commit_left)) <= 0) {
+    if (flushall) {
+      flush_older_journal_lists(s, jl, jl->j_trans_id) ;
+    } 
+    update_journal_header_block(s, (jl->j_start + jl->j_len + 2) % JOURNAL_BLOCK_COUNT, jl->j_trans_id) ;
+    remove_all_from_journal_list(s, jl, 0) ;
+    jl->j_len = 0 ;
+    jl->j_start = 0 ;
+    jl->j_commit_bh = NULL ;
+    jl->j_trans_id = 0 ;
+    atomic_dec(&(jl->j_flushing)) ;
+    wake_up(&(jl->j_flush_wait)) ;
+    return 0 ;
+  }
+
+  /* ugh, find a better way */
+  pbh = kmalloc(jl->j_len * sizeof(struct buffer_head *), GFP_KERNEL) ;
+  if (!pbh) {
+    reiserfs_panic(s, "Unable to kmalloc %d bytes", jl->j_len * sizeof(struct buffer_head *)) ;
+  }
+  /* loop through each cnode, see if we need to write it, or wait on a more recent transaction, or just ignore it */
+  i = 0 ;  
+  if (atomic_read(&(SB_JOURNAL(s)->j_wcount)) != 0) {
+    reiserfs_panic(s, "clm-2012: panic journal list is flushing, wcount is not 0\n") ;
+  }
+  cn = jl->j_realblock ;
+  while(cn) {
+    was_jwait = 0 ;
+    was_dirty = 0 ;
+    saved_bh = NULL ;
+    /* blocknr of 0 is no longer in the hash, ignore it */
+    if (cn->blocknr == 0) {
+      goto free_cnode ;
+    }
+    pjl = find_newer_jl_for_cn(cn) ;
+    /* the order is important here.  We check pjl to make sure we
+    ** don't clear BH_JDirty_wait if we aren't the one writing this
+    ** block to disk
+    */
+    if (!pjl && cn->bh) {
+      saved_bh = cn->bh ;
+      saved_bh->b_count++ ;  /* we do this to make sure nobody releases 
+                                the buffer while we are working with it */
+      if (buffer_journal_dirty(saved_bh)) {
+        was_jwait = 1 ;
+	mark_buffer_notjournal_dirty(saved_bh) ;
+	saved_bh->b_count-- ; /* brelse the inc from journal_mark_dirty */
+      }
+      if (buffer_dirty(saved_bh)) {
+        was_dirty = 1 ;
+      }
+    }
+
+    /* if someone has this block in a newer transaction, just make
+    ** sure they are commited, and don't try writing it to disk
+    */
+    if (pjl) {
+      flush_commit_list(s, pjl, 1) ;
+      goto free_cnode ;
+    }
+
+    /* bh == NULL when the block got to disk on its own, OR, the block got freed in a future transaction */
+    if (saved_bh == NULL) {
+      goto free_cnode ;
+    }
+
+    pbh[i] = saved_bh ;
+
+    /* the end_io task might not have run the buffer yet, so it is possible 
+    ** to have jwait buffer that isn't dirty.  It is not possible to have 
+    ** a buffer here that isn't mark BH_JDirty_wait
+    */
+
+    if ((!was_jwait) && !buffer_locked(pbh[i])) {
+printk("clm-2013: BAD! buffer %lu %cdirty %cjwait, not in a newer tranasction\n", pbh[i]->b_blocknr,
+        was_dirty ? ' ' : '!', was_jwait ? ' ' : '!') ;
+    }
+    /* if it is locked, we wait on it so the end_io handler does not clobber something we are doing
+    ** we'll clear it out of the hash at the end with remove_all
+    */
+    if (buffer_locked(pbh[i])) {
+      wait_on_buffer(pbh[i]) ;
+      if (!buffer_uptodate(pbh[i])) {
+        reiserfs_panic(s, "clm-2014: buffer write failed\n") ;
+      }
+      goto free_cnode ;
+    } else if (buffer_dirty(pbh[i])) { /* it is still dirty, leave in the pbh array */
+      pbh[i]->b_count++ ;  /* we inc again because saved_bh gets decremented at free_cnode */
+      i++ ;
+    } 
+free_cnode:
+    last = cn ;
+    cn = cn->next ;
+    if (saved_bh) {
+      saved_bh->b_count-- ; /* we incremented this to keep others from taking the buffer head away */
+      if (saved_bh->b_count < 0) {
+        printk("clm-2015: saved_bh->b_count < 0") ;
+      }
+    }
+  }
+
+  /* finally, we can write out our array, and wait for them all to finish */
+  if (i > 0) {
+    ll_rw_block(WRITE, i, pbh) ;
+    for (count = 0 ; count < i ; count++) {
+      wait_on_buffer(pbh[count]) ;
+      if (!buffer_uptodate(pbh[count])) {
+        reiserfs_panic(s, "clm-2016: buffer write failed\n") ;
+      }
+      brelse(pbh[count]) ;   /* once for the time we incremented it */
+    }
+  }
+  /* before we can update the journal header block, we _must_ flush all real blocks from all older transactions to disk */
+  if (flushall) {
+    flush_older_journal_lists(s, jl, jl->j_trans_id) ;
+  } 
+  
+  /* before we can remove everything from the hash tables for this transaction, we must make sure it can
+  ** never be replayed
+  */
+  update_journal_header_block(s, (jl->j_start + jl->j_len + 2) % JOURNAL_BLOCK_COUNT, jl->j_trans_id) ;
+  remove_all_from_journal_list(s, jl, 0) ;
+  jl->j_len = 0 ;
+  atomic_set(&(jl->j_nonzerolen), 0) ;
+  jl->j_start = 0 ;
+  jl->j_realblock = NULL ;
+  jl->j_commit_bh = NULL ;
+  jl->j_trans_id = 0 ;
+  kfree(pbh) ;
+  atomic_dec(&(jl->j_flushing)) ;
+  wake_up(&(jl->j_flush_wait)) ;
+  return 0 ;
+} 
+
+
+/*
+** removes any nodes in table with name block and dev as bh.
+** only touchs the hnext and hprev pointers.
+*/
+void remove_journal_hash(struct reiserfs_journal_cnode **table, struct reiserfs_journal_list *jl,struct buffer_head *bh,
+                         int remove_freed){
+  struct reiserfs_journal_cnode *cur ;
+  struct reiserfs_journal_cnode **head ;
+
+  if (!bh)
+    return ;
+
+  head= &(journal_hash(table, bh->b_dev, bh->b_blocknr)) ;
+  if (!head) {
+    return ;
+  }
+  cur = *head ;
+  while(cur) {
+    if (cur->blocknr == bh->b_blocknr && cur->dev == bh->b_dev && (jl == NULL || jl == cur->jlist) && 
+        (!test_bit(BLOCK_FREED, &cur->state) || remove_freed)) {
+      if (cur->hnext) {
+        cur->hnext->hprev = cur->hprev ;
+      }
+      if (cur->hprev) {
+	cur->hprev->hnext = cur->hnext ;
+      } else {
+	*head = cur->hnext ;
+      }
+      cur->blocknr = 0 ;
+      cur->dev = 0 ;
+      cur->state = 0 ;
+      if (cur->bh && cur->jlist) /* anybody who clears the cur->bh will also dec the nonzerolen */
+	atomic_dec(&(cur->jlist->j_nonzerolen)) ;
+      cur->bh = NULL ;
+      cur->jlist = NULL ;
+    } 
+    cur = cur->hnext ;
+  }
+}
+/*
+** call on unmount.  Only set error to 1 if you haven't made your way out
+** of read_super() yet.  Any other caller must keep error at 0.
+*/
+static int do_journal_release(struct reiserfs_transaction_handle *th, struct super_block *p_s_sb, int error) {
+  struct reiserfs_transaction_handle myth ;
+
+  /* we only want to flush out transactions if we were called with error == 0
+  */
+  if (!error) {
+    /* end the current trans */
+    do_journal_end(th, p_s_sb,10, FLUSH_ALL) ;
+
+    /* make sure something gets logged to force our way into the flush code */
+    journal_join(&myth, p_s_sb, 1) ;
+    journal_mark_dirty(&myth, p_s_sb, SB_BUFFER_WITH_SB(p_s_sb)) ;
+    do_journal_end(&myth, p_s_sb,1, FLUSH_ALL) ;
+  }
+
+  SB_JOURNAL(p_s_sb)->j_state |= JOURNAL_UNMOUNTING ;
+  wake_up(&(SB_JOURNAL(p_s_sb)->j_commit_thread_wait)) ;
+  sleep_on(&(SB_JOURNAL(p_s_sb)->j_commit_thread_done)) ;
+  schedule() ; /* clear out any remaining tasks in the schedule queue */
+  vfree(SB_JOURNAL(p_s_sb)->j_cnode_free_orig) ;
+  free_list_bitmaps(p_s_sb) ;
+  brelse(SB_JOURNAL(p_s_sb)->j_header_bh) ;
+  vfree(SB_JOURNAL(p_s_sb)) ;
+
+  return 0 ;
+}
+
+/*
+** call on unmount.  flush all journal trans, release all alloc'd ram
+*/
+int journal_release(struct reiserfs_transaction_handle *th, struct super_block *p_s_sb) {
+  return do_journal_release(th, p_s_sb, 0) ;
+}
+/*
+** only call from an error condition inside reiserfs_read_super!
+*/
+int journal_release_error(struct reiserfs_transaction_handle *th, struct super_block *p_s_sb) {
+  return do_journal_release(th, p_s_sb, 1) ;
+}
+
+/* compares description block with commit block.  returns 1 if they differ, 0 if they are the same */
+static int journal_compare_desc_commit(struct super_block *p_s_sb, struct reiserfs_journal_desc *desc, 
+			               struct reiserfs_journal_commit *commit) {
+  if (commit->j_trans_id != desc->j_trans_id || commit->j_len != desc->j_len || commit->j_len > JOURNAL_TRANS_MAX || 
+      commit->j_len <= 0 
+  ) {
+    return 1 ;
+  }
+  return 0 ;
+}
+/* returns 0 if it did not find a description block  
+** returns -1 if it found a corrupt commit block
+** returns 1 if both desc and commit were valid 
+*/
+static int journal_transaction_is_valid(struct super_block *p_s_sb, struct buffer_head *d_bh, unsigned long *oldest_invalid_trans_id, unsigned long *newest_mount_id) {
+  struct reiserfs_journal_desc *desc ;
+  struct reiserfs_journal_commit *commit ;
+  struct reiserfs_super_block *rs = SB_DISK_SUPER_BLOCK(p_s_sb) ;
+  struct buffer_head *c_bh ;
+  unsigned long offset ;
+
+  desc = (struct reiserfs_journal_desc *)d_bh->b_data ;
+  if (desc->j_len > 0 && !memcmp(desc->j_magic, JOURNAL_DESC_MAGIC, 8)) {
+    if (oldest_invalid_trans_id && *oldest_invalid_trans_id && 
+        desc->j_trans_id > *oldest_invalid_trans_id) {
+#ifdef REISERFS_CHECK
+	printk("clm-2017: transaction is valid returning because trans_id %lu is greater than oldest_invalid %lu\n", desc->j_trans_id, *oldest_invalid_trans_id) ;
+#endif
+      return 0 ;
+    }
+    if (newest_mount_id && *newest_mount_id > desc->j_mount_id) {
+#ifdef REISERFS_CHECK 
+      printk("clm-2018: transaction is valid returning because mount_id %lu is less than newest_mount_id %lu\n", desc->j_mount_id, *newest_mount_id) ;
+#endif
+      return -1 ;
+    }
+    offset = d_bh->b_blocknr - rs->s_journal_block ;
+
+    /* ok, we have a journal description block, lets see if the 
+    ** transaction was valid 
+    */
+    c_bh = bread(p_s_sb->s_dev, rs->s_journal_block + 
+                 ((offset + desc->j_len + 1) % JOURNAL_BLOCK_COUNT), 
+    		  p_s_sb->s_blocksize) ;
+    if (!c_bh)
+      return 0 ;
+
+    commit = (struct reiserfs_journal_commit *)c_bh->b_data ;
+    if (journal_compare_desc_commit(p_s_sb, desc, commit)) {
+#ifdef REISERFS_CHECK
+      printk("clm-2059: journal_transaction_is_valid, commit offset %ld had bad time %ld or length %ld\n", c_bh->b_blocknr - rs->s_journal_block,commit->j_trans_id, commit->j_len);
+#endif
+      brelse(c_bh) ;
+      if (oldest_invalid_trans_id)
+        *oldest_invalid_trans_id = desc->j_trans_id ;
+#ifdef REISERFS_CHECK 
+	printk("clm-2019: transaction_is_valid setting oldest invalid trans_id to %lu\n", desc->j_trans_id) ;
+#endif
+      return -1; 
+    }
+    brelse(c_bh) ;
+#ifdef REISERFS_CHECK 
+    printk("clm-2020: found valid transaction start offset %lu, len %lu id %lu\n", d_bh->b_blocknr - rs->s_journal_block , desc->j_len, desc->j_trans_id) ;
+#endif
+    return 1 ;
+  } else {
+    return 0 ;
+  }
+}
+
+static void brelse_array(struct buffer_head **heads, int num) {
+  int i ;
+  for (i = 0 ; i < num ; i++) {
+    brelse(heads[i]) ;
+  }
+}
+
+/*
+** given the start, and values for the oldest acceptable transactions,
+** this either reads in a replays a transaction, or returns because the transaction
+** is invalid, or too old.
+*/
+static int journal_read_transaction(struct super_block *p_s_sb, unsigned long cur_dblock, unsigned long oldest_start, 
+				    unsigned long oldest_trans_id, unsigned long newest_mount_id) {
+  struct reiserfs_journal_desc *desc ;
+  struct reiserfs_journal_commit *commit ;
+  struct reiserfs_super_block *rs = SB_DISK_SUPER_BLOCK(p_s_sb) ;
+  unsigned long trans_id = 0 ;
+  struct buffer_head *c_bh ;
+  struct buffer_head *d_bh ;
+  struct buffer_head **log_blocks = NULL ;
+  struct buffer_head **real_blocks = NULL ;
+  unsigned long trans_offset ;
+  int i;
+
+  d_bh = bread(p_s_sb->s_dev, cur_dblock, p_s_sb->s_blocksize) ;
+  if (!d_bh)
+    return 1 ;
+  desc = (struct reiserfs_journal_desc *)d_bh->b_data ;
+  trans_offset = d_bh->b_blocknr - rs->s_journal_block ;
+
+#ifdef REISERFS_CHECK 
+  printk("clm-2021: journal_read_transaction, offset %lu, len %lu mount_id %lu\n", d_bh->b_blocknr - rs->s_journal_block, desc->j_len, desc->j_mount_id) ;
+#endif
+
+  if (desc->j_trans_id < oldest_trans_id) {
+
+#ifdef REISERFS_CHECK 
+    printk("clm-2022: journal_read_trans skipping because %lu is too old\n", cur_dblock - rs->s_journal_block) ;
+#endif
+
+    brelse(d_bh) ;
+    return 1 ;
+  }
+  if (desc->j_mount_id != newest_mount_id) {
+#ifdef REISERFS_CHECK
+    printk("clm-2023: journal_read_trans skipping because %lu is != newest_mount_id %lu\n", desc->j_mount_id, newest_mount_id) ;
+#endif
+    brelse(d_bh) ;
+    return 1 ;
+  }
+  c_bh = bread(p_s_sb->s_dev, rs->s_journal_block + ((trans_offset + desc->j_len + 1) % JOURNAL_BLOCK_COUNT), 
+    		p_s_sb->s_blocksize) ;
+  if (!c_bh) {
+    brelse(d_bh) ;
+    return 1 ;
+  }
+  commit = (struct reiserfs_journal_commit *)c_bh->b_data ;
+  if (journal_compare_desc_commit(p_s_sb, desc, commit)) {
+#ifdef REISERFS_CHECK
+    printk("clm-2024: journal_read_transaction, commit offset %ld had bad time %ld or length %ld\n", c_bh->b_blocknr - rs->s_journal_block,commit->j_trans_id, commit->j_len);
+#endif
+    brelse(c_bh) ;
+    brelse(d_bh) ;
+    return 1; 
+  }
+  trans_id = desc->j_trans_id ;
+  /* now we know we've got a good transaction, and it was inside the valid time ranges */
+  log_blocks = kmalloc(desc->j_len * sizeof(struct buffer_head *), GFP_KERNEL) ;
+  real_blocks = kmalloc(desc->j_len * sizeof(struct buffer_head *), GFP_KERNEL) ;
+  if (!log_blocks  || !real_blocks) {
+    brelse(c_bh) ;
+    brelse(d_bh) ;
+    kfree(log_blocks) ;
+    kfree(real_blocks) ;
+    reiserfs_warning("clm-2025: kmalloc failed, unable to mount FS\n") ;
+    return -1 ;
+  }
+  /* get all the buffer heads */
+  for(i = 0 ; i < desc->j_len ; i++) {
+    log_blocks[i] = getblk(p_s_sb->s_dev, rs->s_journal_block + (trans_offset + 1 + i) % JOURNAL_BLOCK_COUNT, p_s_sb->s_blocksize);
+    if (i < JOURNAL_TRANS_HALF) {
+      real_blocks[i] = getblk(p_s_sb->s_dev, desc->j_realblock[i], p_s_sb->s_blocksize) ;
+    } else {
+      real_blocks[i] = getblk(p_s_sb->s_dev, commit->j_realblock[i - JOURNAL_TRANS_HALF], p_s_sb->s_blocksize) ;
+    }
+    if (real_blocks[i]->b_blocknr >= rs->s_journal_block &&
+        real_blocks[i]->b_blocknr < (rs->s_journal_block+JOURNAL_BLOCK_COUNT)) {
+      reiserfs_warning("clm-2026: REPLAY FAILURE fsck required! Trying to replay onto a log block\n") ;
+      brelse_array(log_blocks, i) ;
+      brelse_array(real_blocks, i) ;
+      brelse(c_bh) ;
+      brelse(d_bh) ;
+      kfree(log_blocks) ;
+      kfree(real_blocks) ;
+      return -1 ;
+    }
+  }
+  /* read in the log blocks, memcpy to the corresponding real block */
+  ll_rw_block(READ, desc->j_len, log_blocks) ;
+  for (i = 0 ; i < desc->j_len ; i++) {
+    wait_on_buffer(log_blocks[i]) ;
+    if (!buffer_uptodate(log_blocks[i])) {
+      reiserfs_warning("clm-2027: REPLAY FAILURE fsck required! buffer write failed\n") ;
+      brelse_array(log_blocks + i, desc->j_len - i) ;
+      brelse_array(real_blocks, desc->j_len) ;
+      brelse(c_bh) ;
+      brelse(d_bh) ;
+      kfree(log_blocks) ;
+      kfree(real_blocks) ;
+      return -1 ;
+    }
+    memcpy(real_blocks[i]->b_data, log_blocks[i]->b_data, real_blocks[i]->b_size) ;
+    mark_buffer_uptodate(real_blocks[i], 1) ;
+    brelse(log_blocks[i]) ;
+  }
+  /* flush out the real blocks */
+  for (i = 0 ; i < desc->j_len ; i++) {
+    set_bit(BH_Dirty, &(real_blocks[i]->b_state)) ;
+    ll_rw_block(WRITE, 1, real_blocks + i) ;
+  }
+  for (i = 0 ; i < desc->j_len ; i++) {
+    wait_on_buffer(real_blocks[i]) ; 
+    if (!buffer_uptodate(real_blocks[i])) {
+      reiserfs_warning("clm-2028: REPLAY FAILURE, fsck required! buffer write failed\n") ;
+      brelse_array(real_blocks + i, desc->j_len - i) ;
+      brelse(c_bh) ;
+      brelse(d_bh) ;
+      kfree(log_blocks) ;
+      kfree(real_blocks) ;
+      return -1 ;
+    }
+    brelse(real_blocks[i]) ;
+  }
+  cur_dblock = rs->s_journal_block + ((trans_offset + desc->j_len + 2) % JOURNAL_BLOCK_COUNT) ;
+
+#ifdef REISERFS_CHECK
+    printk("clm-2029: setting journal start to offset %ld\n", cur_dblock - rs->s_journal_block) ;
+#endif
+
+  /* init starting values for the first transaction, in case this is the last transaction to be replayed. */
+  SB_JOURNAL(p_s_sb)->j_start = cur_dblock - rs->s_journal_block ;
+  SB_JOURNAL(p_s_sb)->j_last_flush_trans_id = trans_id ;
+  SB_JOURNAL(p_s_sb)->j_trans_id = trans_id + 1;
+  brelse(c_bh) ;
+  brelse(d_bh) ;
+  kfree(log_blocks) ;
+  kfree(real_blocks) ;
+  return 0 ;
+}
+
+/*
+** read and replay the log
+** on a clean unmount, the journal header's next unflushed pointer will be to an invalid
+** transaction.  This tests that before finding all the transactions in the log, whic makes normal mount times fast.
+**
+** After a crash, this starts with the next unflushed transaction, and replays until it finds one too old, or invalid.
+**
+** On exit, it sets things up so the first transaction will work correctly.
+*/
+static int journal_read(struct super_block *p_s_sb) {
+  struct reiserfs_super_block *rs = SB_DISK_SUPER_BLOCK(p_s_sb) ;
+  struct reiserfs_journal_desc *desc ;
+  unsigned long last_flush_trans_id = 0 ;
+  unsigned long oldest_trans_id = 0;
+  unsigned long oldest_invalid_trans_id = 0 ;
+  time_t start ;
+  unsigned long last_flush_start = 0;
+  unsigned long oldest_start = 0;
+  unsigned long cur_dblock = 0 ;
+  unsigned long newest_mount_id = 9 ;
+  struct buffer_head *d_bh ;
+  struct reiserfs_journal_header *jh ;
+  int valid_journal_header = 0 ;
+  int replay_count = 0 ;
+  int continue_replay = 1 ;
+  int ret ;
+
+  cur_dblock = rs->s_journal_block ;
+#ifdef REISERFS_CHECK
+  printk("clm-2030: reading through journal entries\n") ;
+#else
+  printk("Checking ReiserFS transaction log (device %s) ...\n", 
+          kdevname(p_s_sb->s_dev)) ;
+#endif
+  start = CURRENT_TIME ;
+
+  /* step 1, read in the journal header block.  Check the transaction is says is the first unflushed,
+  ** and if that transaction is not valid, replay is done
+  */
+  SB_JOURNAL(p_s_sb)->j_header_bh = bread(p_s_sb->s_dev, rs->s_journal_block + JOURNAL_BLOCK_COUNT, p_s_sb->s_blocksize) ;
+  if (!SB_JOURNAL(p_s_sb)->j_header_bh) {
+    return 1 ;
+  }
+  jh = (struct reiserfs_journal_header *)(SB_JOURNAL(p_s_sb)->j_header_bh->b_data) ;
+  if (jh->j_first_unflushed_offset >= 0 && jh->j_first_unflushed_offset < JOURNAL_BLOCK_COUNT &&
+      jh->j_last_flush_trans_id > 0) {
+    last_flush_start = rs->s_journal_block + jh->j_first_unflushed_offset ;
+    last_flush_trans_id = jh->j_last_flush_trans_id ;
+#ifdef REISERFS_CHECK
+    printk("clm-2031: found in header: first_unflushed_offset %lu, last_flushed_trans_id %lu\n", jh->j_first_unflushed_offset, last_flush_trans_id) ;
+#endif
+    valid_journal_header = 1 ;
+
+    /* now, we try to read the first unflushed offset.  If it is not valid, there is nothing more we can do,
+    ** and it makes no sense to read through the whole log.
+    */
+    d_bh = bread(p_s_sb->s_dev, rs->s_journal_block + jh->j_first_unflushed_offset, p_s_sb->s_blocksize) ;
+    ret = journal_transaction_is_valid(p_s_sb, d_bh, NULL, NULL) ;
+    if (!ret) {
+      continue_replay = 0 ;
+    }
+    brelse(d_bh) ;
+  }
+
+  /* ok, there are transactions that need to be replayed.  start with the first log block, find
+  ** all the valid transactions, and pick out the oldest.
+  */
+  while(continue_replay && cur_dblock < (rs->s_journal_block + JOURNAL_BLOCK_COUNT)) {
+    d_bh = bread(p_s_sb->s_dev, cur_dblock, p_s_sb->s_blocksize) ;
+    ret = journal_transaction_is_valid(p_s_sb, d_bh, &oldest_invalid_trans_id, &newest_mount_id) ;
+    if (ret == 1) {
+      desc = (struct reiserfs_journal_desc *)d_bh->b_data ;
+      if (oldest_start == 0) { /* init all oldest_ values */
+        oldest_trans_id = desc->j_trans_id ;
+	oldest_start = d_bh->b_blocknr ;
+	newest_mount_id = desc->j_mount_id ;
+#ifdef REISERFS_CHECK
+	printk("clm-2032: Setting oldest_start to offset %lu, trans_id %lu\n", 
+	        oldest_start - rs->s_journal_block, oldest_trans_id) ;
+#endif
+      } else if (oldest_trans_id > desc->j_trans_id) { /* one just read was older */
+        oldest_trans_id = desc->j_trans_id ;
+	oldest_start = d_bh->b_blocknr ;
+#ifdef REISERFS_CHECK
+	printk("clm-2033: Resetting oldest_start to offset %lu, trans_id %lu\n",
+		oldest_start - rs->s_journal_block, oldest_trans_id) ;
+#endif
+      }
+      if (newest_mount_id < desc->j_mount_id) {
+        newest_mount_id = desc->j_mount_id ;
+#ifdef REISERFS_CHECK
+	printk("clm-2034: Setting newest_mount_id to %lu\n", desc->j_mount_id) ;
+#endif
+      }
+      cur_dblock += desc->j_len + 2 ;
+    } 
+    else {
+      cur_dblock++ ;
+    }
+    brelse(d_bh) ;
+  }
+  /* step three, starting at the oldest transaction, replay */
+  if (last_flush_start > 0) {
+    oldest_start = last_flush_start ;
+    oldest_trans_id = last_flush_trans_id ;
+  } 
+  cur_dblock = oldest_start ;
+
+#ifdef REISERFS_CHECK
+  if (oldest_trans_id)  {
+    printk("clm-2035: Starting replay from offset %lu, trans_id %lu\n", cur_dblock - rs->s_journal_block, oldest_trans_id) ;
+  }
+#endif
+
+  replay_count = 0 ;
+  while(continue_replay && oldest_trans_id > 0) {
+    ret = journal_read_transaction(p_s_sb, cur_dblock, oldest_start, oldest_trans_id, newest_mount_id) ;
+    if (ret < 0) {
+      return ret ;
+    } else if (ret != 0) {
+      break ;
+    }
+    cur_dblock = rs->s_journal_block + SB_JOURNAL(p_s_sb)->j_start ;
+    replay_count++ ;
+  }
+
+#ifdef REISERFS_CHECK
+  if (oldest_trans_id == 0) {
+    printk("clm-2036: No valid transactions found\n") ;
+  }
+#endif
+
+  /* j_start does not get set correctly if we don't replay any transactions.
+  ** if we had a valid journal_header, set j_start to the first unflushed transaction value,
+  ** copy the trans_id from the header
+  */
+  if (valid_journal_header && replay_count == 0) { 
+    SB_JOURNAL(p_s_sb)->j_start = jh->j_first_unflushed_offset ;
+    SB_JOURNAL(p_s_sb)->j_trans_id = jh->j_last_flush_trans_id + 1 ;
+    SB_JOURNAL(p_s_sb)->j_last_flush_trans_id = jh->j_last_flush_trans_id ;
+    SB_JOURNAL(p_s_sb)->j_mount_id = jh->j_mount_id + 1;
+  } else {
+    SB_JOURNAL(p_s_sb)->j_mount_id = newest_mount_id + 1 ;
+  }
+  SB_JOURNAL(p_s_sb)->j_first_unflushed_offset = SB_JOURNAL(p_s_sb)->j_start ; 
+
+#ifdef REISERFS_CHECK
+  printk("clm-2038: Replayed %d transactions in %lu seconds, mount_id now %lu\n", replay_count, CURRENT_TIME - start, SB_JOURNAL(p_s_sb)->j_mount_id) ;
+#else
+  printk("Replayed %d transactions in %lu seconds\n", 
+          replay_count, CURRENT_TIME - start) ;
+#endif
+
+  update_journal_header_block(p_s_sb, SB_JOURNAL(p_s_sb)->j_start, SB_JOURNAL(p_s_sb)->j_last_flush_trans_id) ;
+  return 0 ;
+}
+
+
+struct reiserfs_journal_commit_task {
+  struct super_block *p_s_sb ;
+  int jindex ;
+  int wake_on_finish ; /* if this is one, we wake the task_done queue, if it
+                       ** is zero, we free the whole struct on finish
+		       */
+  struct reiserfs_journal_commit_task *self ;
+  struct wait_queue *task_done ;
+  struct tq_struct task ;
+} ;
+
+static void reiserfs_journal_commit_task_func(struct reiserfs_journal_commit_task *ct) {
+
+  flush_commit_list(ct->p_s_sb, SB_JOURNAL_LIST(ct->p_s_sb) + ct->jindex, 1) ; 
+  kfree(ct->self) ;
+}
+
+static void setup_commit_task_arg(struct reiserfs_journal_commit_task *ct,
+                                  struct super_block *p_s_sb, 
+				  int jindex) {
+  if (!ct) {
+    reiserfs_panic(NULL, "clm-2039: setup_commit_task_arg called with NULL struct\n") ;
+  }
+  ct->p_s_sb = p_s_sb ;
+  ct->jindex = jindex ;
+  ct->task_done = NULL ;
+  ct->task.next = NULL ;
+  ct->task.sync = 0 ;
+  ct->task.routine = (void *)(void *)reiserfs_journal_commit_task_func ; 
+  ct->self = ct ;
+  ct->task.data = (void *)ct ;
+}
+
+static void commit_flush_async(struct super_block *p_s_sb, int jindex) {
+  struct reiserfs_journal_commit_task *ct ;
+  ct = kmalloc(sizeof(struct reiserfs_journal_commit_task), GFP_KERNEL) ;
+  setup_commit_task_arg(ct, p_s_sb, jindex) ;
+  queue_task(&(ct->task), &(SB_JOURNAL(p_s_sb)->j_commit_thread_tq));
+  wake_up(&(SB_JOURNAL(p_s_sb)->j_commit_thread_wait)) ;
+}
+
+/*
+** this is the commit thread.  It is started with kernel_thread on
+** FS mount, and journal_release() waits for it to exit.
+**
+** It could do a periodic commit, but there is a lot code for that
+** elsewhere right now, and I only wanted to implement this little
+** piece for starters.
+**
+** All we do here is sleep on the j_commit_thread_wait wait queue, and
+** then run the per filesystem commit task queue when we wakeup.
+*/
+static int reiserfs_journal_commit_thread(struct super_block *p_s_sb) {
+
+  lock_kernel() ;
+  exit_files(current);
+  exit_mm(current);
+
+  spin_lock_irq(&current->sigmask_lock);
+  sigfillset(&current->blocked);
+  recalc_sigpending(current);
+  spin_unlock_irq(&current->sigmask_lock);
+
+  current->session = 1;
+  current->pgrp = 1;
+  sprintf(current->comm, "kreiserfsd") ;
+  while(1) {
+/* printk("commit thread awake\n") ;  */
+    run_task_queue(&(SB_JOURNAL(p_s_sb)->j_commit_thread_tq)) ;
+    if (SB_JOURNAL(p_s_sb)->j_state & JOURNAL_UNMOUNTING) {
+      /* just in case */
+      schedule() ;
+      run_task_queue(&(SB_JOURNAL(p_s_sb)->j_commit_thread_tq)) ;
+      break ;
+    }
+    interruptible_sleep_on(&(SB_JOURNAL(p_s_sb)->j_commit_thread_wait)) ;
+  }
+  wake_up(&(SB_JOURNAL(p_s_sb)->j_commit_thread_done)) ;
+  schedule() ;
+  unlock_kernel() ;
+/* printk("commit thread exiting\n") ;  */
+  return 0 ;
+}
+
+/*
+** must be called once on fs mount.  calls journal_read for you
+*/
+int journal_init(struct super_block *p_s_sb) {
+  int num_cnodes = JOURNAL_BLOCK_COUNT * 2 ;
+
+  if (sizeof(struct reiserfs_journal_commit) != 4096 ||
+      sizeof(struct reiserfs_journal_desc) != 4096
+     ) {
+    printk("clm-2040: commit or desc struct not 4096 %d %d\n", sizeof(struct reiserfs_journal_commit), 
+        sizeof(struct reiserfs_journal_desc)) ;
+    return 1 ;
+  }
+  /* sanity check to make sure they don't overflow the journal */
+  if (JOURNAL_BLOCK_COUNT > SB_DISK_SUPER_BLOCK(p_s_sb)->s_orig_journal_size) {
+    printk("clm-2041: current JOURNAL_BLOCK_COUNT (%d) is too big.  This FS was created with a journal size of %d blocks\n",
+            JOURNAL_BLOCK_COUNT, SB_DISK_SUPER_BLOCK(p_s_sb)->s_orig_journal_size) ;
+    return 1 ;
+  }
+  SB_JOURNAL(p_s_sb) = vmalloc(sizeof (struct reiserfs_journal)) ;
+
+  if (!SB_JOURNAL(p_s_sb)) {
+    printk("clm-2042: unable to get memory for journal structure\n") ;
+    return 1 ;
+  }
+  memset(SB_JOURNAL(p_s_sb), 0, sizeof(struct reiserfs_journal)) ;
+  SB_JOURNAL(p_s_sb)->j_list_bitmap_index = 0 ;
+  SB_JOURNAL_LIST_INDEX(p_s_sb) = -10000 ; /* make sure flush_old_commits does not try to flush a list while replay is on */
+  memset(SB_JOURNAL_LIST(p_s_sb), 0, sizeof(struct reiserfs_journal_list) * JOURNAL_LIST_COUNT) ; 
+  memset(SB_JOURNAL(p_s_sb)->j_list_hash_table, 0, JOURNAL_LIST_HASH_SIZE * sizeof(struct reiserfs_journal_cnode *)) ;
+  memset(journal_writers, 0, sizeof(char *) * 512) ; /* debug code */
+  spin_lock_init(&(SB_JOURNAL(p_s_sb)->j_list_hash_lock)) ;
+  spin_lock_init(&(SB_JOURNAL(p_s_sb)->j_hash_lock)) ;
+  spin_lock_init(&(SB_JOURNAL(p_s_sb)->j_cnode_lock)) ;
+
+  allocate_list_bitmaps(p_s_sb) ;
+  SB_JOURNAL(p_s_sb)->j_start = 0 ;
+  SB_JOURNAL(p_s_sb)->j_len = 0 ;
+  SB_JOURNAL(p_s_sb)->j_len_alloc = 0 ;
+  atomic_set(&(SB_JOURNAL(p_s_sb)->j_wcount), 0) ;
+  SB_JOURNAL(p_s_sb)->j_bcount = 0 ;	  
+  SB_JOURNAL(p_s_sb)->j_trans_start_time = 0 ;	  
+  SB_JOURNAL(p_s_sb)->j_last = NULL ;	  
+  SB_JOURNAL(p_s_sb)->j_first = NULL ;     
+  SB_JOURNAL(p_s_sb)->j_join_wait = NULL ; 
+  SB_JOURNAL(p_s_sb)->j_commit_thread_wait = NULL ; 
+  SB_JOURNAL(p_s_sb)->j_commit_thread_done = NULL ; 
+  SB_JOURNAL(p_s_sb)->j_commit_thread_tq = NULL ; 
+  SB_JOURNAL(p_s_sb)->j_wait = NULL ; 
+  SB_JOURNAL(p_s_sb)->j_trans_id = 10 ; 
+  SB_JOURNAL(p_s_sb)->j_mount_id = 10 ; 
+  SB_JOURNAL(p_s_sb)->j_state = 0 ;
+  SB_JOURNAL(p_s_sb)->j_dobalance_wait = NULL ; 
+  atomic_set(&(SB_JOURNAL(p_s_sb)->j_jlock), 0) ;
+  SB_JOURNAL(p_s_sb)->j_dobalance_lock = 0 ; 
+  atomic_set(&(SB_JOURNAL(p_s_sb)->j_wlock), 0) ;
+  SB_JOURNAL(p_s_sb)->j_cnode_free_list = allocate_cnodes(num_cnodes) ;
+  SB_JOURNAL(p_s_sb)->j_cnode_free_orig = SB_JOURNAL(p_s_sb)->j_cnode_free_list ;
+  SB_JOURNAL(p_s_sb)->j_cnode_free = SB_JOURNAL(p_s_sb)->j_cnode_free_list ? num_cnodes : 0 ;
+  SB_JOURNAL(p_s_sb)->j_cnode_used = 0 ;
+  SB_JOURNAL(p_s_sb)->j_must_wait = 0 ;
+  init_journal_hash(p_s_sb) ;
+  SB_JOURNAL_LIST(p_s_sb)[0].j_list_bitmap = get_list_bitmap(p_s_sb, SB_JOURNAL_LIST(p_s_sb)) ;
+  if (!(SB_JOURNAL_LIST(p_s_sb)[0].j_list_bitmap)) {
+    reiserfs_warning("clm-2043, get_list_bitmap failed for journal list 0\n") ;
+    return 1 ;
+  }
+  if (journal_read(p_s_sb) < 0) {
+    reiserfs_warning("Replay Failure, unable to mount\n") ;
+    return 1 ;
+  }
+  SB_JOURNAL_LIST_INDEX(p_s_sb) = 0 ; /* once the read is done, we can set this where it belongs */
+  kernel_thread((void *)(void *)reiserfs_journal_commit_thread, (void *)p_s_sb, CLONE_FS | CLONE_FILES | CLONE_VM) ;
+  return 0 ;
+}
+
+
+/* lock and unlock for dobalance.  I'm not convinced these work.  They are locked after fix_node returns
+** CARRY_ON, and unlocked after do_balance returns.
+*/
+int journal_lock_dobalance(struct super_block *p_s_sb) {
+  return 0 ;
+#if 0
+  while(SB_JOURNAL(p_s_sb)->j_dobalance_lock) {
+    sleep_on(&(SB_JOURNAL(p_s_sb)->j_dobalance_wait)) ;
+  }
+  SB_JOURNAL(p_s_sb)->j_dobalance_lock = 1 ;
+  return 0 ;
+#endif
+}
+
+int journal_unlock_dobalance(struct super_block *p_s_sb) {
+  return 0 ;
+#if 0
+  SB_JOURNAL(p_s_sb)->j_dobalance_lock = 0 ;
+  wake_up(&(SB_JOURNAL(p_s_sb)->j_dobalance_wait)) ;
+  return 0 ;
+#endif
+}
+
+/*
+** test for a polite end of the current transaction.  Used by file_write, and should
+** be used by delete to make sure they don't write more than can fit inside a single
+** transaction
+*/
+int journal_transaction_should_end(struct reiserfs_transaction_handle *th, int new_alloc) {
+  time_t now = CURRENT_TIME ;
+  if ( SB_JOURNAL(th->t_super)->j_must_wait > 0 ||
+       (SB_JOURNAL(th->t_super)->j_len_alloc + new_alloc) >= JOURNAL_MAX_BATCH || 
+       atomic_read(&(SB_JOURNAL(th->t_super)->j_jlock)) ||
+      (now - SB_JOURNAL(th->t_super)->j_trans_start_time) > JOURNAL_MAX_TRANS_AGE ||
+       SB_JOURNAL(th->t_super)->j_cnode_free < (JOURNAL_TRANS_MAX * 3)) { 
+    return 1 ;
+  }
+  return 0 ;
+}
+
+/* join == true if you must join an existing transaction.
+** join == false if you can deal with waiting for others to finish
+**
+** this will block until the transaction is joinable.  send the number of blocks you
+** expect to use in nblocks.
+*/
+static int do_journal_begin_r(struct reiserfs_transaction_handle *th, struct super_block * p_s_sb,unsigned long nblocks,int join) {
+  time_t now = CURRENT_TIME ;
+  int windex  ;
+  int old_trans_id  ;
+
+  lock_journal(p_s_sb) ;
+
+  /* if there is no room in the journal OR
+  ** if this transaction is too old, and we weren't called joinable, wait for it to finish before beginning 
+  ** we don't sleep if there aren't other writers
+  */
+
+  if (  (!join && SB_JOURNAL(p_s_sb)->j_must_wait > 0) ||
+     ( !join && (SB_JOURNAL(p_s_sb)->j_len_alloc + nblocks + 2) >= JOURNAL_MAX_BATCH) || 
+     (!join && atomic_read(&(SB_JOURNAL(p_s_sb)->j_wcount)) > 0 && SB_JOURNAL(p_s_sb)->j_trans_start_time > 0 && 
+      (now - SB_JOURNAL(p_s_sb)->j_trans_start_time) > JOURNAL_MAX_TRANS_AGE) ||
+     (!join && atomic_read(&(SB_JOURNAL(p_s_sb)->j_jlock)) ) ||
+     (!join && SB_JOURNAL(p_s_sb)->j_cnode_free < (JOURNAL_TRANS_MAX * 3))) {
+
+    unlock_journal(p_s_sb) ; /* allow others to finish this transaction */
+
+    /* if writer count is 0, we can just force this transaction to end, and start
+    ** a new one afterwards.
+    */
+    if (atomic_read(&(SB_JOURNAL(p_s_sb)->j_wcount)) <= 0) {
+      struct reiserfs_transaction_handle myth ;
+      journal_join(&myth, p_s_sb, 1) ;
+      windex = push_journal_writer("journal_begin") ;
+      journal_mark_dirty(&myth, p_s_sb, SB_BUFFER_WITH_SB(p_s_sb)) ;
+      pop_journal_writer(windex) ;
+      do_journal_end(&myth, p_s_sb,1,COMMIT_NOW) ;
+    } else {
+      /* but if the writer count isn't zero, we have to wait for the current writers to finish.
+      ** They won't batch on transaction end once we set j_jlock
+      */
+      atomic_set(&(SB_JOURNAL(p_s_sb)->j_jlock), 1) ;
+      old_trans_id = SB_JOURNAL(p_s_sb)->j_trans_id ;
+      while(atomic_read(&(SB_JOURNAL(p_s_sb)->j_jlock)) &&
+            SB_JOURNAL(p_s_sb)->j_trans_id == old_trans_id) {
+	sleep_on(&(SB_JOURNAL(p_s_sb)->j_join_wait)) ;
+      }
+    }
+    lock_journal(p_s_sb) ; /* relock to continue */
+  }
+
+  if (SB_JOURNAL(p_s_sb)->j_trans_start_time == 0) { /* we are the first writer, set trans_id */
+    SB_JOURNAL(p_s_sb)->j_trans_start_time = now ;
+  }
+  atomic_inc(&(SB_JOURNAL(p_s_sb)->j_wcount)) ;
+  SB_JOURNAL(p_s_sb)->j_len_alloc += nblocks ;
+  th->t_blocks_logged = 0 ;
+  th->t_blocks_allocated = nblocks ;
+  th->t_super = p_s_sb ;
+  th->t_trans_id = SB_JOURNAL(p_s_sb)->j_trans_id ;
+  th->t_caller = "Unknown" ;
+  unlock_journal(p_s_sb) ;
+  p_s_sb->s_dirt = 1; 
+  return 0 ;
+}
+
+
+int journal_join(struct reiserfs_transaction_handle *th, struct super_block *p_s_sb, unsigned long nblocks) {
+  return do_journal_begin_r(th, p_s_sb, nblocks, 1) ;
+}
+
+int journal_begin(struct reiserfs_transaction_handle *th, struct super_block  * p_s_sb, unsigned long nblocks) {
+  return do_journal_begin_r(th, p_s_sb, nblocks, 0) ;
+}
+
+/* not used at all */
+int journal_prepare(struct super_block  * p_s_sb, struct buffer_head *bh) {
+  return 0 ;
+}
+
+/*
+** puts bh into the current transaction.  If it was already there, reorders removes the
+** old pointers from the hash, and puts new ones in (to make sure replay happen in the right order).
+**
+** if it was dirty, cleans and files onto the clean list.  I can't let it be dirty again until the
+** transaction is committed.
+** 
+** if j_len, is bigger than j_len_alloc, it pushes j_len_alloc to 10 + j_len.
+*/
+int journal_mark_dirty(struct reiserfs_transaction_handle *th, struct super_block *p_s_sb, struct buffer_head *bh) {
+  struct reiserfs_journal_cnode *cn = NULL;
+  int count_already_incd = 0 ;
+
+  if (th->t_trans_id != SB_JOURNAL(p_s_sb)->j_trans_id) {
+    reiserfs_panic(th->t_super, "clm-2044: handle trans id %d != current trans id %d\n", 
+                   th->t_trans_id, SB_JOURNAL(p_s_sb)->j_trans_id);
+  }
+
+  p_s_sb->s_dirt = 1 ;
+  /* already in this transaction, we are done */
+  if (buffer_journaled(bh)) {
+    return 0 ;
+  }
+  if (atomic_read(&(SB_JOURNAL(p_s_sb)->j_wcount)) <= 0) {
+    printk("clm-2045: journal_mark_dirty returning because j_wcount was %d\n", atomic_read(&(SB_JOURNAL(p_s_sb)->j_wcount))) ;
+    return 1 ;
+  }
+  /* this error means I've screwed up, and we've overflowed the transaction.  Nothing can be done here, except make the
+  ** FS readonly or panic.
+  */ 
+  if (SB_JOURNAL(p_s_sb)->j_len >= JOURNAL_TRANS_MAX) { 
+    reiserfs_panic(th->t_super, "clm-2046: journal_mark_dirty: j_len (%lu) is too big\n", SB_JOURNAL(p_s_sb)->j_len) ;
+  }
+
+  if (buffer_journal_dirty(bh)) {
+    count_already_incd = 1 ;
+    mark_buffer_notjournal_dirty(bh) ;
+  }
+
+  if (buffer_dirty(bh)) {
+    clear_bit(BH_Dirty, &bh->b_state) ;
+  }
+
+  if (buffer_journaled(bh)) { /* must double check after getting lock */
+    goto done ;
+  }
+
+  if (SB_JOURNAL(p_s_sb)->j_len > SB_JOURNAL(p_s_sb)->j_len_alloc) {
+    SB_JOURNAL(p_s_sb)->j_len_alloc = SB_JOURNAL(p_s_sb)->j_len + JOURNAL_PER_BALANCE_CNT ;
+  }
+
+  set_bit(BH_JDirty, &bh->b_state) ;
+
+  /* now put this guy on the end */
+  if (!cn) {
+    cn = get_cnode(p_s_sb) ;
+    if (!cn) {
+      reiserfs_panic(p_s_sb, "get_cnode failed!\n"); 
+    }
+
+    if (th->t_blocks_logged == th->t_blocks_allocated) {
+      th->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT ;
+      SB_JOURNAL(p_s_sb)->j_len_alloc += JOURNAL_PER_BALANCE_CNT ;
+    }
+    th->t_blocks_logged++ ;
+    SB_JOURNAL(p_s_sb)->j_len++ ;
+
+    cn->bh = bh ;
+    cn->blocknr = bh->b_blocknr ;
+    cn->dev = bh->b_dev ;
+    cn->jlist = NULL ;
+    insert_journal_hash(SB_JOURNAL(p_s_sb)->j_hash_table, cn) ;
+    if (!count_already_incd) {
+      bh->b_count++ ;
+    }
+  }
+  cn->next = NULL ;
+  cn->prev = SB_JOURNAL(p_s_sb)->j_last ;
+  cn->bh = bh ;
+  if (SB_JOURNAL(p_s_sb)->j_last) {
+    SB_JOURNAL(p_s_sb)->j_last->next = cn ;
+    SB_JOURNAL(p_s_sb)->j_last = cn ;
+  } else {
+    SB_JOURNAL(p_s_sb)->j_first = cn ;
+    SB_JOURNAL(p_s_sb)->j_last = cn ;
+  }
+done:
+  return 0 ;
+}
+
+/*
+** if buffer already in current transaction, do a journal_mark_dirty
+** otherwise, just mark it dirty and move on.  Used for writes to meta blocks
+** that don't need journaling
+*/
+int journal_mark_dirty_nolog(struct reiserfs_transaction_handle *th, struct super_block *p_s_sb, struct buffer_head *bh) {
+  if (buffer_journaled(bh) || buffer_journal_dirty(bh)) {
+    return journal_mark_dirty(th, p_s_sb, bh) ;
+  }
+  if (get_journal_hash_dev(SB_JOURNAL(p_s_sb)->j_list_hash_table, bh->b_dev,bh->b_blocknr,bh->b_size)) {
+    return journal_mark_dirty(th, p_s_sb, bh) ;
+  }
+  mark_buffer_dirty(bh , 0) ;
+  return 0 ;
+}
+
+int journal_end(struct reiserfs_transaction_handle *th, struct super_block *p_s_sb, unsigned long nblocks) {
+  return do_journal_end(th, p_s_sb, nblocks, 0) ;
+}
+
+/* removes from the current transaction, relsing and descrementing any counters.  
+** also files the removed buffer directly onto the clean list
+**
+** called by journal_mark_freed when a block has been deleted
+**
+** returns 1 if it cleaned and relsed the buffer. 0 otherwise
+*/
+int remove_from_transaction(struct super_block *p_s_sb, unsigned long blocknr, int already_cleaned) {
+  struct buffer_head *bh ;
+  struct reiserfs_journal_cnode *cn ;
+  int ret = 0;
+
+  cn = get_journal_hash_dev(SB_JOURNAL(p_s_sb)->j_hash_table, p_s_sb->s_dev, blocknr, p_s_sb->s_blocksize) ;
+  if (!cn || !cn->bh) {
+    return ret ;
+  }
+  bh = cn->bh ;
+  if (cn->prev) {
+    cn->prev->next = cn->next ;
+  }
+  if (cn->next) {
+    cn->next->prev = cn->prev ;
+  }
+  if (cn == SB_JOURNAL(p_s_sb)->j_first) {
+    SB_JOURNAL(p_s_sb)->j_first = cn->next ;  
+  }
+  if (cn == SB_JOURNAL(p_s_sb)->j_last) {
+    SB_JOURNAL(p_s_sb)->j_last = cn->prev ;
+  }
+  remove_journal_hash(SB_JOURNAL(p_s_sb)->j_hash_table, NULL, bh, 0) ; 
+  mark_buffer_not_journaled(bh) ; /* don't log this one */
+
+  if (!already_cleaned) {
+    mark_buffer_notjournal_dirty(bh) ; 
+    bh->b_count-- ;
+    if (bh->b_count < 0) {
+      printk("clm-2047: remove from trans, b_count < 0\n") ;
+    }
+    if (!buffer_locked) reiserfs_clean_and_file_buffer(bh) ; 
+    ret = 1 ;
+  }
+  SB_JOURNAL(p_s_sb)->j_len-- ;
+  SB_JOURNAL(p_s_sb)->j_len_alloc-- ;
+  free_cnode(p_s_sb, cn) ;
+  return ret ;
+}
+
+/* removes from a specific journal list hash */
+int remove_from_journal_list(struct super_block *s, struct reiserfs_journal_list *jl, struct buffer_head *bh, int remove_freed) {
+  remove_journal_hash(SB_JOURNAL(s)->j_list_hash_table, jl, bh, remove_freed) ;
+  return 0 ;
+}
+
+/*
+** for any cnode in a journal list, it can only be dirtied of all the
+** transactions that include it are commited to disk.
+** this checks through each transaction, and returns 1 if you are allowed to dirty,
+** and 0 if you aren't
+**
+** it is called by dirty_journal_list, which is called after flush_commit_list has gotten all the log
+** blocks for a given transaction on disk
+**
+*/
+static int can_dirty(struct reiserfs_journal_cnode *cn) {
+  kdev_t dev = cn->dev ;
+  unsigned long blocknr = cn->blocknr  ;
+  struct reiserfs_journal_cnode *cur = cn->hprev ;
+  int can_dirty = 1 ;
+  
+  /* first test backwards */
+  while(cur && can_dirty) {
+    if (cur->jlist && cur->jlist->j_len > 0 && atomic_read(&(cur->jlist->j_commit_left)) > 0 && cur->bh && cur->blocknr && 
+        cur->dev == dev && cur->blocknr == blocknr 
+    ) {
+      can_dirty = 0 ;
+    }
+    cur = cur->hprev ;
+  }
+  /* then test fowards */
+  cur = cn->hnext ;
+  while(cur && can_dirty) {
+    if (cur->jlist && cur->jlist->j_len > 0 && atomic_read(&(cur->jlist->j_commit_left)) > 0 && cur->bh && cur->blocknr && 
+        cur->dev == dev && cur->blocknr == blocknr 
+    ) {
+      can_dirty = 0 ;
+    }
+    cur = cur->hnext ;
+  }
+  return can_dirty ;
+}
+
+/*
+** Whereever possible, this dirties and releases the real blocks associated with a transaction
+** 
+** called by flush_commit_list, after all the log blocks for a transaction are on
+** disk.  
+*/
+static void dirty_journal_list(struct super_block *p_s_sb, struct reiserfs_journal_list *jl) {
+  struct buffer_head *tbh ;
+  struct reiserfs_journal_cnode *cn ;
+  int dirty_it  ;
+
+  cn = jl->j_realblock ;
+  while(cn) {
+    /* remove_from_journal_list invalidates the bh in j_realblock, must copy it first */
+    tbh = cn->bh ;
+
+    /* default to dirty the block */
+    dirty_it = 1 ;
+    if (cn->blocknr && tbh) {
+      /* we only want to dirty the block if all the log blocks in all his transactions are on disk */
+      dirty_it = can_dirty(cn) ;
+      if (dirty_it) {
+	if (buffer_journal_dirty(tbh)) {
+	  mark_buffer_dirty(tbh, 0) ;
+	} 
+      }
+    }
+    cn = cn->next ;
+  }
+}
+
+/* syncs the commit blocks, but does not force the real buffers to disk
+** will wait until the current transaction is done/commited before returning 
+*/
+int journal_end_sync(struct reiserfs_transaction_handle *th, struct super_block *p_s_sb, unsigned long nblocks) {
+  if (SB_JOURNAL(p_s_sb)->j_len <= 0) {
+    journal_mark_dirty(th, th->t_super, SB_BUFFER_WITH_SB(p_s_sb)) ;
+  }
+  return do_journal_end(th, p_s_sb, nblocks, COMMIT_NOW | WAIT) ;
+}
+
+#if 0
+#ifdef __KERNEL__
+int show_reiserfs_locks(void) {
+  struct super_block *p_s_sb = NULL ;
+
+  p_s_sb = sb_entry(super_blocks.next);
+  while (p_s_sb != sb_entry(&super_blocks)) {
+    if (reiserfs_is_super(p_s_sb)) {
+printk("journal lock is %d, join lock is %d, dobalance lock is %d writers %d must wait is %d\n", 
+        atomic_read(&(SB_JOURNAL(p_s_sb)->j_wlock)),
+        atomic_read(&(SB_JOURNAL(p_s_sb)->j_jlock)),
+	SB_JOURNAL(p_s_sb)->j_dobalance_lock, atomic_read(&(SB_JOURNAL(p_s_sb)->j_wcount)),
+	SB_JOURNAL(p_s_sb)->j_must_wait) ;
+    }
+    p_s_sb = sb_entry(p_s_sb->s_list.next);
+  }
+  dump_journal_writers() ;
+  return 0 ;
+}
+#endif /* __KERNEL__ */
+#endif /* 0 */
+
+/*
+** used to get memory back from async commits that are floating around
+** and to reclaim any blocks deleted but unusable because their commits
+** haven't hit disk yet.  called from bitmap.c
+**
+** if it starts flushing things, it ors SCHEDULE_OCCURRED into repeat.
+** note, this is just if schedule has a chance of occuring.  I need to 
+** change flush_commit_lists to have a repeat parameter too.
+**
+*/
+void flush_async_commits(struct super_block *p_s_sb, int *repeat) {
+  int i ;
+  int windex ;
+
+  if (SB_JOURNAL(p_s_sb)->j_dobalance_lock) { /* don't flush while do_balance is running! */
+    return ;
+  }
+  (*repeat) |= SCHEDULE_OCCURRED ;
+  windex = push_journal_writer("flush_async_commits") ;
+  for (i = 0 ; i < JOURNAL_LIST_COUNT ; i++) {
+    if (i != SB_JOURNAL_LIST_INDEX(p_s_sb)) {
+      flush_commit_list(p_s_sb, SB_JOURNAL_LIST(p_s_sb) + i, 1) ; 
+    }
+  }
+  pop_journal_writer(windex) ;
+}
+
+/*
+** flushes any old transactions to disk
+** ends the current transaction if it is too old
+**
+** also calls flush_journal_list with old_only == 1, which allows me to reclaim
+** memory and such from the journal lists whose real blocks are all on disk.
+**
+** called by sync_dev_journal from buffer.c
+*/
+int flush_old_commits(struct super_block *p_s_sb, int immediate) {
+  int i ;
+  int count = 0;
+  int start ; 
+  time_t now ; 
+  int windex ;
+  int keep_dirty = 0 ;
+  struct reiserfs_transaction_handle th ; 
+
+  start =  SB_JOURNAL_LIST_INDEX(p_s_sb) ;
+  now = CURRENT_TIME ;
+
+  /* safety check so we don't flush while we are replaying the log during mount */
+  if (SB_JOURNAL_LIST_INDEX(p_s_sb) < 0) {
+    return 0  ;
+  }
+  if (!strcmp(current->comm, "kupdate")) {
+    immediate = 0 ;
+    keep_dirty = 1 ;
+  }
+  /* starting with oldest, loop until we get to the start */
+  i = (SB_JOURNAL_LIST_INDEX(p_s_sb) + 1) % JOURNAL_LIST_COUNT ;
+  while(i != start) {
+    if (SB_JOURNAL_LIST(p_s_sb)[i].j_len > 0 && ((now - SB_JOURNAL_LIST(p_s_sb)[i].j_timestamp) > JOURNAL_MAX_COMMIT_AGE ||
+       immediate)) {
+      /* we have to check again to be sure the current transaction did not change */
+      if (i != SB_JOURNAL_LIST_INDEX(p_s_sb))  {
+	flush_commit_list(p_s_sb, SB_JOURNAL_LIST(p_s_sb) + i, 1) ;
+      }
+    }
+    /* now we free ram used by the old journal lists */
+    if (SB_JOURNAL_LIST(p_s_sb)[i].j_len > 0 && i != SB_JOURNAL_LIST_INDEX(p_s_sb))  {
+      flush_journal_list(p_s_sb, SB_JOURNAL_LIST(p_s_sb) + i, 1, 0) ; /* old_only, and don't flush all, 
+      					                                 we only want to reclaim nodes if it will be fast */
+    }
+    i = (i + 1) % JOURNAL_LIST_COUNT ;
+    count++ ;
+  }
+  /* now, check the current transaction.  If there are no writers, and it is too old, finish it, and
+  ** force the commit blocks to disk
+  */
+  if (!immediate && atomic_read(&(SB_JOURNAL(p_s_sb)->j_wcount)) <= 0 &&  
+     SB_JOURNAL(p_s_sb)->j_trans_start_time > 0 && 
+     SB_JOURNAL(p_s_sb)->j_len > 0 && 
+     (now - SB_JOURNAL(p_s_sb)->j_trans_start_time) > JOURNAL_MAX_TRANS_AGE) {
+    journal_join(&th, p_s_sb, 1) ;
+    windex = push_journal_writer("flush_old_commits") ;
+    journal_mark_dirty(&th, p_s_sb, SB_BUFFER_WITH_SB(p_s_sb)) ;
+    pop_journal_writer(windex) ;
+    do_journal_end(&th, p_s_sb,1, COMMIT_NOW) ;
+    keep_dirty = 0 ;
+  } else if (immediate) { /* belongs above, but I wanted this to be very explicit as a special case.  If they say to 
+                             flush, we must be sure old transactions hit the disk too. */
+    journal_join(&th, p_s_sb, 1) ;
+    journal_mark_dirty(&th, p_s_sb, SB_BUFFER_WITH_SB(p_s_sb)) ;
+    do_journal_end(&th, p_s_sb,1, COMMIT_NOW | WAIT) ;
+  }
+  return keep_dirty ;
+}
+
+/*
+** returns 0 if do_journal_end should return right away, returns 1 if do_journal_end should finish the commit
+** 
+** if the current transaction is too old, but still has writers, this will wait on j_join_wait until all 
+** the writers are done.  By the time it wakes up, the transaction it was called has already ended, so it just
+** flushes the commit list and returns 0.
+**
+** Won't batch when flush or commit_now is set.  Also won't batch when others are waiting on j_join_wait.
+** 
+** Note, we can't allow the journal_end to proceed while there are still writers in the log.
+*/
+static int check_journal_end(struct reiserfs_transaction_handle *th, struct super_block  * p_s_sb, 
+                             unsigned long nblocks, int flags) {
+
+  time_t now ;
+  int flush = flags & FLUSH_ALL ;
+  int commit_now = flags & COMMIT_NOW ;
+  int wait_on_commit = flags & WAIT ;
+
+  if (th->t_trans_id != SB_JOURNAL(p_s_sb)->j_trans_id) {
+    reiserfs_panic(th->t_super, "clm-2049: handle trans id %d != current trans id %d\n", 
+                   th->t_trans_id, SB_JOURNAL(p_s_sb)->j_trans_id);
+  }
+
+  SB_JOURNAL(p_s_sb)->j_len_alloc -= (th->t_blocks_allocated - th->t_blocks_logged) ;
+  if (atomic_read(&(SB_JOURNAL(p_s_sb)->j_wcount)) > 0) { /* <= 0 is allowed.  unmounting might not call begin */
+    atomic_dec(&(SB_JOURNAL(p_s_sb)->j_wcount)) ;
+  }
+
+  /* BUG, deal with case where j_len is 0, but people previously freed blocks need to be released 
+  ** will be dealt with by next transaction that actually writes something, but should be taken
+  ** care of in this trans
+  */
+  if (SB_JOURNAL(p_s_sb)->j_len == 0) {
+    int wcount = atomic_read(&(SB_JOURNAL(p_s_sb)->j_wcount)) ;
+    unlock_journal(p_s_sb) ;
+    if (atomic_read(&(SB_JOURNAL(p_s_sb)->j_jlock))  > 0 && wcount <= 0) {
+      atomic_dec(&(SB_JOURNAL(p_s_sb)->j_jlock)) ;
+      wake_up(&(SB_JOURNAL(p_s_sb)->j_join_wait)) ;
+    }
+    return 0 ;
+  }
+  /* if wcount > 0, and we are called to with flush or commit_now,
+  ** we wait on j_join_wait.  We will wake up when the last writer has
+  ** finished the transaction, and started it on its way to the disk.
+  ** Then, we flush the commit or journal list, and just return 0 
+  ** because the rest of journal end was already done for this transaction.
+  */
+  if (atomic_read(&(SB_JOURNAL(p_s_sb)->j_wcount)) > 0) {
+    if (flush || commit_now) {
+      int orig_jindex = SB_JOURNAL_LIST_INDEX(p_s_sb) ;
+      atomic_set(&(SB_JOURNAL(p_s_sb)->j_jlock), 1) ;
+      if (flush) {
+        SB_JOURNAL(p_s_sb)->j_next_full_flush = 1 ;
+      }
+      unlock_journal(p_s_sb) ;
+      /* sleep while the current transaction is still j_jlocked */
+      while(atomic_read(&(SB_JOURNAL(p_s_sb)->j_jlock)) && 
+            SB_JOURNAL(p_s_sb)->j_trans_id == th->t_trans_id) {
+	sleep_on(&(SB_JOURNAL(p_s_sb)->j_join_wait)) ;
+      }
+      if (commit_now) {
+	if (wait_on_commit) {
+	  flush_commit_list(p_s_sb,  SB_JOURNAL_LIST(p_s_sb) + orig_jindex, 1) ;
+	} else {
+	  commit_flush_async(p_s_sb, orig_jindex) ; 
+	}
+      }
+      return 0 ;
+    } 
+    unlock_journal(p_s_sb) ;
+    return 0 ;
+  }
+
+  /* deal with old transactions where we are the last writers */
+  now = CURRENT_TIME ;
+  if ((now - SB_JOURNAL(p_s_sb)->j_trans_start_time) > JOURNAL_MAX_TRANS_AGE) {
+    commit_now = 1 ;
+    SB_JOURNAL(p_s_sb)->j_next_async_flush = 1 ;
+  }
+  /* don't batch when someone is waiting on j_join_wait */
+  /* don't batch when syncing the commit or flushing the whole trans */
+  if (!(SB_JOURNAL(p_s_sb)->j_must_wait > 0) && !(atomic_read(&(SB_JOURNAL(p_s_sb)->j_jlock))) && !flush && !commit_now && 
+      (SB_JOURNAL(p_s_sb)->j_len < JOURNAL_MAX_BATCH)  && 
+      SB_JOURNAL(p_s_sb)->j_len_alloc < JOURNAL_MAX_BATCH && SB_JOURNAL(p_s_sb)->j_cnode_free > (JOURNAL_TRANS_MAX * 3)) {
+    SB_JOURNAL(p_s_sb)->j_bcount++ ;
+    unlock_journal(p_s_sb) ;
+    return 0 ;
+  }
+
+  if (SB_JOURNAL(p_s_sb)->j_start > JOURNAL_BLOCK_COUNT) {
+    reiserfs_panic(p_s_sb, "clm-2050: journal_end: j_start (%d) is too high\n", SB_JOURNAL(p_s_sb)->j_start) ;
+  }
+  return 1 ;
+}
+
+/*
+** Does all the work that makes deleting blocks safe.
+** when deleting a block mark BH_JNew, just remove it from the current transaction, clean it's buffer_head and move on.
+** 
+** otherwise:
+** set a bit for the block in the journal bitmap.  That will prevent it from being allocated for unformatted nodes
+** before this transaction has finished.
+**
+** mark any cnodes for this block as BLOCK_FREED, and clear their bh pointers.  That will prevent any old transactions with
+** this block from trying to flush to the real location.  Since we aren't removing the cnode from the journal_list_hash,
+** the block can't be reallocated yet.
+**
+** Then remove it from the current transaction, decrementing any counters and filing it on the clean list.
+*/
+int journal_mark_freed(struct reiserfs_transaction_handle *th, struct super_block *p_s_sb, unsigned long blocknr) {
+  struct reiserfs_journal_cnode *cn = NULL ;
+  struct buffer_head *bh = NULL ;
+  struct reiserfs_list_bitmap *jb = NULL ;
+  int cleaned = 0 ;
+  
+  bh = get_hash_table(p_s_sb->s_dev, blocknr, p_s_sb->s_blocksize) ;
+  /* if it is journal new, we just remove it from this transaction */
+  if (bh && buffer_journal_new(bh)) {
+    cleaned = remove_from_transaction(p_s_sb, blocknr, cleaned) ;
+  } else {
+    /* set the bit for this block in the journal bitmap for this transaction */
+    jb = SB_JOURNAL_LIST(p_s_sb)[SB_JOURNAL_LIST_INDEX(p_s_sb)].j_list_bitmap ;
+    if (!jb) {
+      reiserfs_panic(p_s_sb, "clm-2051: journal_mark_freed, journal_list_bitmap is NULL\n") ;
+    }
+    set_bit(blocknr, jb->bitmap) ;
+
+    /* we must keep the lock the whole time here.  We can't allow anyone to add/remove cnodes into
+    ** this hash bucket while we are processing it.  Note, the entire while loop is not allowed
+    ** the schedule.
+    */
+
+    cleaned = remove_from_transaction(p_s_sb, blocknr, cleaned) ;
+
+    /* find all older transactions with this block, make sure they don't try to write it out */
+    cn = get_journal_hash_dev(SB_JOURNAL(p_s_sb)->j_list_hash_table, p_s_sb->s_dev, blocknr, p_s_sb->s_blocksize) ;
+    while (cn) {
+      if (p_s_sb->s_dev == cn->dev && blocknr == cn->blocknr) {
+	set_bit(BLOCK_FREED, &cn->state) ;
+	if (cn->bh) {
+	  if (!cleaned) {
+	    /* remove_from_transaction will brelse the buffer if it was 
+	    ** in the current trans
+	    */
+	    mark_buffer_notjournal_dirty(cn->bh) ;
+	    if (!buffer_locked(cn->bh)) {
+	      reiserfs_clean_and_file_buffer(cn->bh) ;
+	    }
+	    cleaned = 1 ;
+	    cn->bh->b_count-- ;
+	    if (cn->bh->b_count < 0) {
+	      printk("clm-2052: cn->bh->b_count < 0\n") ;
+	    }
+	  }
+	  if (cn->jlist) { /* since we are clearing the bh, we MUST dec nonzerolen */
+	    atomic_dec(&(cn->jlist->j_nonzerolen)) ;
+	  }
+	  cn->bh = NULL ; 
+	} 
+      }
+      cn = cn->hnext ;
+    }
+  }
+
+  if (bh) {
+    bh->b_count-- ; /* get_hash incs this */
+    if (bh->b_count < 0) {
+      printk("clm-2053: bh->b_count < 0\n") ;
+    }
+  }
+  return 0 ;
+}
+
+void reiserfs_update_inode_transaction(struct inode *p_s_inode) {
+  
+  p_s_inode->u.reiserfs_i.i_transaction_index =
+            SB_JOURNAL_LIST_INDEX(p_s_inode->i_sb);
+
+  p_s_inode->u.reiserfs_i.i_transaction_id = 
+            SB_JOURNAL(p_s_inode->i_sb)->j_trans_id ;
+}
+
+int reiserfs_inode_in_this_transaction(struct inode *p_s_inode) {
+  if (p_s_inode->u.reiserfs_i.i_transaction_id ==
+      SB_JOURNAL(p_s_inode->i_sb)->j_trans_id || 
+      p_s_inode->u.reiserfs_i.i_transaction_id == 0) {
+    return 1; 
+  } 
+  return 0 ;
+}
+
+void reiserfs_commit_for_inode(struct inode *p_s_inode) {
+  struct reiserfs_journal_list *jl ;
+  struct reiserfs_transaction_handle th ;
+
+  jl = SB_JOURNAL_LIST(p_s_inode->i_sb) + 
+       p_s_inode->u.reiserfs_i.i_transaction_index ;
+
+  /* is it from the current transaction, or from an unknown transaction? */
+  if (reiserfs_inode_in_this_transaction(p_s_inode)) {
+    journal_join(&th, p_s_inode->i_sb, 1) ;
+    journal_end_sync(&th, p_s_inode->i_sb,1) ;
+  } else if (jl->j_trans_id == p_s_inode->u.reiserfs_i.i_transaction_id) {
+    flush_commit_list(p_s_inode->i_sb, jl, 1) ;
+  }
+  /* if the transaction id does not match, this list is long since flushed */
+}
+
+/*
+** long and ugly.  If flush, will not return until all commit
+** blocks and all real buffers in the trans are on disk.
+** If no_async, won't return until all commit blocks are on disk.
+**
+** keep reading, there are comments as you go along
+*/
+static int do_journal_end(struct reiserfs_transaction_handle *th, struct super_block  * p_s_sb, unsigned long nblocks, 
+		          int flags) {
+  struct reiserfs_journal_cnode *cn, *next, *jl_cn; 
+  struct reiserfs_journal_cnode *last_cn = NULL;
+  struct reiserfs_journal_desc *desc ; 
+  struct reiserfs_journal_commit *commit ; 
+  struct buffer_head *c_bh ; /* commit bh */
+  struct buffer_head *d_bh ; /* desc bh */
+  int cur_write_start = 0 ; /* start index of current log write */
+  int cur_blocks_left = 0 ; /* number of journal blocks left to write */
+  int old_start ;
+  int i ;
+  int jindex ;
+  int orig_jindex ;
+  int flush = flags & FLUSH_ALL ;
+  int commit_now = flags & COMMIT_NOW ;
+  int wait_on_commit = flags & WAIT ;
+  struct reiserfs_super_block *rs ; 
+
+  lock_journal(p_s_sb) ;
+  if (SB_JOURNAL(p_s_sb)->j_next_full_flush) {
+    flags |= FLUSH_ALL ;
+    flush = 1 ;
+  }
+  if (SB_JOURNAL(p_s_sb)->j_next_async_flush) {
+    flags |= COMMIT_NOW ;
+    commit_now = 1 ;
+  }
+
+  /* check_journal_end locks the journal, and unlocks if it does not return 1 
+  ** it tells us if we should continue with the journal_end, or just return
+  */
+  if (!check_journal_end(th, p_s_sb, nblocks, flags)) {
+    return 0 ;
+  }
+  /* check_journal_end might set these, check again */
+  if (SB_JOURNAL(p_s_sb)->j_next_full_flush) {
+    flush = 1 ;
+  }
+  if (SB_JOURNAL(p_s_sb)->j_next_async_flush) {
+    commit_now = 1 ;
+  }
+  /*
+  ** j must wait means we have to flush the log blocks, and the real blocks for
+  ** this transaction
+  */
+  if (SB_JOURNAL(p_s_sb)->j_must_wait > 0) {
+    flush = 1 ;
+  }
+
+  rs = SB_DISK_SUPER_BLOCK(p_s_sb) ;
+  /* setup description block */
+  d_bh = getblk(p_s_sb->s_dev, rs->s_journal_block + SB_JOURNAL(p_s_sb)->j_start, p_s_sb->s_blocksize) ; 
+  mark_buffer_uptodate(d_bh, 1) ;
+  desc = (struct reiserfs_journal_desc *)(d_bh)->b_data ;
+  memset(desc, 0, sizeof(struct reiserfs_journal_desc)) ;
+  memcpy(desc->j_magic, JOURNAL_DESC_MAGIC, 8) ;
+  desc->j_trans_id = SB_JOURNAL(p_s_sb)->j_trans_id ;
+
+  /* setup commit block.  Don't write (keep it clean too) this one until after everyone else is written */
+  c_bh = getblk(p_s_sb->s_dev,  rs->s_journal_block + 
+  				        ((SB_JOURNAL(p_s_sb)->j_start + SB_JOURNAL(p_s_sb)->j_len + 1) % JOURNAL_BLOCK_COUNT), 
+					 p_s_sb->s_blocksize) ;
+  d_bh->b_end_io = reiserfs_journal_end_io ;
+  c_bh->b_end_io = reiserfs_journal_end_io ; 
+  commit = (struct reiserfs_journal_commit *)c_bh->b_data ;
+  memset(commit, 0, sizeof(struct reiserfs_journal_commit)) ;
+  commit->j_trans_id = SB_JOURNAL(p_s_sb)->j_trans_id ;
+  mark_buffer_uptodate(c_bh, 1) ;
+
+  /* init this journal list */
+  atomic_set(&(SB_JOURNAL_LIST(p_s_sb)[SB_JOURNAL_LIST_INDEX(p_s_sb)].j_older_commits_done), 0) ;
+  SB_JOURNAL_LIST(p_s_sb)[SB_JOURNAL_LIST_INDEX(p_s_sb)].j_trans_id = SB_JOURNAL(p_s_sb)->j_trans_id ;
+  SB_JOURNAL_LIST(p_s_sb)[SB_JOURNAL_LIST_INDEX(p_s_sb)].j_timestamp = SB_JOURNAL(p_s_sb)->j_trans_start_time ;
+  SB_JOURNAL_LIST(p_s_sb)[SB_JOURNAL_LIST_INDEX(p_s_sb)].j_commit_bh = c_bh ;
+  SB_JOURNAL_LIST(p_s_sb)[SB_JOURNAL_LIST_INDEX(p_s_sb)].j_start = SB_JOURNAL(p_s_sb)->j_start ;
+  SB_JOURNAL_LIST(p_s_sb)[SB_JOURNAL_LIST_INDEX(p_s_sb)].j_len = SB_JOURNAL(p_s_sb)->j_len ;  
+  atomic_set(&(SB_JOURNAL_LIST(p_s_sb)[SB_JOURNAL_LIST_INDEX(p_s_sb)].j_nonzerolen), SB_JOURNAL(p_s_sb)->j_len) ;
+  atomic_set(&(SB_JOURNAL_LIST(p_s_sb)[SB_JOURNAL_LIST_INDEX(p_s_sb)].j_commit_left), SB_JOURNAL(p_s_sb)->j_len + 2);
+  SB_JOURNAL_LIST(p_s_sb)[SB_JOURNAL_LIST_INDEX(p_s_sb)].j_realblock = NULL ;
+  atomic_set(&(SB_JOURNAL_LIST(p_s_sb)[SB_JOURNAL_LIST_INDEX(p_s_sb)].j_commit_flushing), 1) ;
+  atomic_set(&(SB_JOURNAL_LIST(p_s_sb)[SB_JOURNAL_LIST_INDEX(p_s_sb)].j_flushing), 1) ;
+
+  /* which is faster, locking/unlocking at the start and end of the for
+  ** or locking once per iteration around the insert_journal_hash?
+  ** eitherway, we are write locking insert_journal_hash.  The ENTIRE FOR
+  ** LOOP MUST not cause schedule to occur.
+  */
+
+  /* for each real block, add it to the journal list hash,
+  ** copy into real block index array in the commit or desc block
+  */
+  for (i = 0, cn = SB_JOURNAL(p_s_sb)->j_first ; cn ; cn = cn->next, i++) {
+    if (test_bit(BH_JDirty, &cn->bh->b_state) ) {
+      jl_cn = get_cnode(p_s_sb) ;
+      if (!jl_cn) {
+        reiserfs_panic(p_s_sb, "clm-2054, get_cnode returned NULL\n") ;
+      }
+      if (i == 0) {
+        SB_JOURNAL_LIST(p_s_sb)[SB_JOURNAL_LIST_INDEX(p_s_sb)].j_realblock = jl_cn ;
+      }
+      jl_cn->prev = last_cn ;
+      jl_cn->next = NULL ;
+      if (last_cn) {
+        last_cn->next = jl_cn ;
+      }
+      last_cn = jl_cn ;
+      if (cn->bh->b_blocknr >= rs->s_journal_block &&
+          cn->bh->b_blocknr < (rs->s_journal_block + JOURNAL_BLOCK_COUNT)) {
+        reiserfs_panic(p_s_sb, "clm-2055: Trying to log block %lu, which is a log block\n", cn->bh->b_blocknr) ;
+      }
+      jl_cn->blocknr = cn->bh->b_blocknr ; 
+      jl_cn->state = 0 ;
+      jl_cn->dev = cn->bh->b_dev ; 
+      jl_cn->bh = cn->bh ;
+      jl_cn->jlist = SB_JOURNAL_LIST(p_s_sb) + SB_JOURNAL_LIST_INDEX(p_s_sb) ;
+      insert_journal_hash(SB_JOURNAL(p_s_sb)->j_list_hash_table, jl_cn) ; 
+      if (i < JOURNAL_TRANS_HALF) {
+	desc->j_realblock[i] = cn->bh->b_blocknr ;
+      } else {
+	commit->j_realblock[i - JOURNAL_TRANS_HALF] = cn->bh->b_blocknr ;
+      }
+    } else {
+      i-- ;
+    }
+  }
+
+  desc->j_len = SB_JOURNAL(p_s_sb)->j_len  ;
+  desc->j_mount_id = SB_JOURNAL(p_s_sb)->j_mount_id ;
+  desc->j_trans_id = SB_JOURNAL(p_s_sb)->j_trans_id ;
+  commit->j_len = SB_JOURNAL(p_s_sb)->j_len  ;
+
+  /* special check in case all buffers in the journal were marked for not logging */
+  if (desc->j_len == 0) {
+    brelse(d_bh) ;
+    brelse(c_bh) ;
+    unlock_journal(p_s_sb) ;
+printk("clm-2056: do_journal_end: BAD desc->j_len is ZERO\n") ;
+    atomic_set(&(SB_JOURNAL(p_s_sb)->j_jlock), 0) ;
+    wake_up(&(SB_JOURNAL(p_s_sb)->j_join_wait)) ;
+    return 0 ;
+  }
+
+  /* first data block is j_start + 1, so add one to cur_write_start wherever you use it */
+  cur_write_start = SB_JOURNAL(p_s_sb)->j_start ;
+  cur_blocks_left = SB_JOURNAL(p_s_sb)->j_len  ;
+  cn = SB_JOURNAL(p_s_sb)->j_first ;
+  jindex = 1 ; /* start at one so we don't get the desc again */
+  while(cur_blocks_left > 0) {
+    /* copy all the real blocks into log area.  dirty log blocks */
+    if (test_bit(BH_JDirty, &cn->bh->b_state)) {
+      struct buffer_head *tmp_bh ;
+      tmp_bh = getblk(p_s_sb->s_dev, rs->s_journal_block + 
+		     ((cur_write_start + jindex) % JOURNAL_BLOCK_COUNT), 
+				       p_s_sb->s_blocksize) ;
+      tmp_bh->b_end_io = reiserfs_journal_end_io ;
+      mark_buffer_uptodate(tmp_bh, 1) ;
+      memcpy(tmp_bh->b_data, cn->bh->b_data, cn->bh->b_size) ;  
+      jindex++ ;
+    } else {
+      /* JDirty cleared sometime during transaction.  don't log this one */
+      printk("clm-2057: do_journal_end: BAD, buffer in journal hash, but not JDirty!\n") ;
+    }
+    cn = cn->next ;
+    cur_blocks_left-- ;
+  }
+
+  /* we are done  with both the c_bh and d_bh, but
+  ** c_bh must be written after all other commit blocks,
+  ** so we dirty/relse c_bh in journal_end_io, with commit_left <= 1.
+  */
+  set_writetime(c_bh, 1);
+  /*
+  mark_buffer_dirty(d_bh, 1) ;
+  brelse(d_bh) ;
+  */
+
+  /* now loop through and mark all buffers from this transaction as JDirty_wait
+  ** clear the JDirty bit, clear BH_JNew too.  
+  ** if they weren't JDirty, they weren't logged, just relse them and move on
+  */
+  cn = SB_JOURNAL(p_s_sb)->j_first ; 
+  while(cn) {
+    clear_bit(BH_JNew, &(cn->bh->b_state)) ;
+    if (test_bit(BH_JDirty, &(cn->bh->b_state))) {
+      set_bit(BH_JDirty_wait, &(cn->bh->b_state)) ; 
+      clear_bit(BH_JDirty, &(cn->bh->b_state)) ;
+    } else {
+      brelse(cn->bh) ;
+    }
+    next = cn->next ;
+    free_cnode(p_s_sb, cn) ;
+    cn = next ;
+  }
+
+  /* unlock the journal list for committing and flushing */
+  atomic_set(&(SB_JOURNAL_LIST(p_s_sb)[SB_JOURNAL_LIST_INDEX(p_s_sb)].j_commit_flushing), 0) ;
+  atomic_set(&(SB_JOURNAL_LIST(p_s_sb)[SB_JOURNAL_LIST_INDEX(p_s_sb)].j_flushing), 0) ;
+
+  orig_jindex = SB_JOURNAL_LIST_INDEX(p_s_sb) ;
+  jindex = (SB_JOURNAL_LIST_INDEX(p_s_sb) + 1) % JOURNAL_LIST_COUNT ; 
+  SB_JOURNAL_LIST_INDEX(p_s_sb) = jindex ;
+
+  /* honor the flush and async wishes from the caller */
+  if (flush) {
+    flush_commit_list(p_s_sb, SB_JOURNAL_LIST(p_s_sb) + orig_jindex, 1) ;
+    flush_journal_list(p_s_sb,  SB_JOURNAL_LIST(p_s_sb) + orig_jindex , 0, 1) ;  /* flush all */
+  } else if (commit_now) {
+    if (wait_on_commit) {
+      flush_commit_list(p_s_sb, SB_JOURNAL_LIST(p_s_sb) + orig_jindex, 1) ;
+    } else {
+      commit_flush_async(p_s_sb, orig_jindex) ; 
+    }
+  }
+  /* reset journal values for the next transaction */
+  old_start = SB_JOURNAL(p_s_sb)->j_start ;
+  SB_JOURNAL(p_s_sb)->j_start = (SB_JOURNAL(p_s_sb)->j_start + SB_JOURNAL(p_s_sb)->j_len + 2) % JOURNAL_BLOCK_COUNT;
+  atomic_set(&(SB_JOURNAL(p_s_sb)->j_wcount), 0) ;
+  SB_JOURNAL(p_s_sb)->j_bcount = 0 ;
+  SB_JOURNAL(p_s_sb)->j_last = NULL ;
+  SB_JOURNAL(p_s_sb)->j_first = NULL ;
+  SB_JOURNAL(p_s_sb)->j_len = 0 ;
+  SB_JOURNAL(p_s_sb)->j_trans_start_time = 0 ;
+  SB_JOURNAL(p_s_sb)->j_trans_id++ ;
+  SB_JOURNAL(p_s_sb)->j_must_wait = 0 ;
+  SB_JOURNAL(p_s_sb)->j_len_alloc = 0 ;
+  SB_JOURNAL(p_s_sb)->j_next_full_flush = 0 ;
+  SB_JOURNAL(p_s_sb)->j_next_async_flush = 0 ;
+  init_journal_hash(p_s_sb) ; 
+
+  /* if the next transaction has any chance of wrapping, flush 
+  ** transactions that might get overwritten.  If any journal lists are very 
+  ** old flush them as well.  Since data will get to disk every 30 seconds or
+  ** so, any list that has unflushed members after 2 minutes was a victim to
+  ** memory shortages during the end_io handler.  Clean things up for them
+  **
+  */
+  for (i =0 ; i < JOURNAL_LIST_COUNT ; i++) {
+    jindex = i ;
+    if (SB_JOURNAL_LIST(p_s_sb)[jindex].j_len > 0 && SB_JOURNAL(p_s_sb)->j_start <= SB_JOURNAL_LIST(p_s_sb)[jindex].j_start) {
+      if ((SB_JOURNAL(p_s_sb)->j_start + JOURNAL_TRANS_MAX + 1) >= SB_JOURNAL_LIST(p_s_sb)[jindex].j_start) {
+	flush_journal_list(p_s_sb, SB_JOURNAL_LIST(p_s_sb) + jindex, 0, 1) ; /* do flush all */
+      }
+    } else if (SB_JOURNAL_LIST(p_s_sb)[jindex].j_len > 0 && 
+              (SB_JOURNAL(p_s_sb)->j_start + JOURNAL_TRANS_MAX + 1) > JOURNAL_BLOCK_COUNT) {
+      if (((SB_JOURNAL(p_s_sb)->j_start + JOURNAL_TRANS_MAX + 1) % JOURNAL_BLOCK_COUNT) >= 
+            SB_JOURNAL_LIST(p_s_sb)[jindex].j_start) {
+	flush_journal_list(p_s_sb, SB_JOURNAL_LIST(p_s_sb) + jindex, 0,1 ) ; /* do flush all */
+      }
+    } else if (SB_JOURNAL_LIST(p_s_sb)[jindex].j_len > 0 && 
+              SB_JOURNAL_LIST(p_s_sb)[jindex].j_timestamp < 
+	      (CURRENT_TIME - (JOURNAL_MAX_TRANS_AGE * 4))) {
+	flush_journal_list(p_s_sb, SB_JOURNAL_LIST(p_s_sb) + jindex, 0,1 ) ; 
+    }
+  }
+
+  /* if the next journal_list is still in use, flush it */
+  if (SB_JOURNAL_LIST(p_s_sb)[SB_JOURNAL_LIST_INDEX(p_s_sb)].j_len != 0) {
+    flush_journal_list(p_s_sb, SB_JOURNAL_LIST(p_s_sb) + SB_JOURNAL_LIST_INDEX(p_s_sb), 0, 1) ; /* do flush all */
+  }
+
+  /* we don't want anyone flushing the new transaction's list */
+  atomic_set(&(SB_JOURNAL_LIST(p_s_sb)[SB_JOURNAL_LIST_INDEX(p_s_sb)].j_commit_flushing), 1) ;
+  atomic_set(&(SB_JOURNAL_LIST(p_s_sb)[SB_JOURNAL_LIST_INDEX(p_s_sb)].j_flushing), 1) ;
+  SB_JOURNAL_LIST(p_s_sb)[SB_JOURNAL_LIST_INDEX(p_s_sb)].j_list_bitmap = get_list_bitmap(p_s_sb, SB_JOURNAL_LIST(p_s_sb) + 
+											 SB_JOURNAL_LIST_INDEX(p_s_sb)) ;
+
+  if (!(SB_JOURNAL_LIST(p_s_sb)[SB_JOURNAL_LIST_INDEX(p_s_sb)].j_list_bitmap)) {
+    reiserfs_panic(p_s_sb, "clm-2058: do_journal_end, could not get a list bitmap\n") ;
+  }
+  unlock_journal(p_s_sb) ;
+  atomic_set(&(SB_JOURNAL(p_s_sb)->j_jlock), 0) ;
+  /* wake up any body waiting to join. */
+  wake_up(&(SB_JOURNAL(p_s_sb)->j_join_wait)) ;
+
+  return 0 ;
+}
Index: empeg/kernel/fs/reiserfs/lbalance.c
diff -u /dev/null empeg/kernel/fs/reiserfs/lbalance.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/lbalance.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,1378 @@
+/*
+ * Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
+ */
+
+#ifdef __KERNEL__
+
+#include <asm/uaccess.h>
+#include <linux/string.h>
+#include <linux/sched.h>
+#include <linux/reiserfs_fs.h>
+
+#else
+
+#include "nokernel.h"
+
+#endif
+
+/* these are used in do_balance.c */
+
+/* leaf_move_items
+   leaf_shift_left
+   leaf_shift_right
+   leaf_delete_items
+   leaf_insert_into_buf
+   leaf_paste_in_buffer
+   leaf_cut_from_buffer
+   leaf_paste_entries
+   */
+
+
+extern struct tree_balance init_tb;
+extern int init_item_pos;
+extern int init_pos_in_item;
+extern int init_mode;
+
+
+
+
+/* copy copy_count entries from source directory item to dest buffer (creating new item if needed) */
+static void leaf_copy_dir_entries (struct reiserfs_transaction_handle *th, 
+			           struct buffer_info * dest_bi, struct buffer_head * source, 
+				   int last_first, int item_num, int from, int copy_count)
+{
+  struct buffer_head * dest = dest_bi->bi_bh;
+  int item_num_in_dest;		/* either the number of target item,
+				   or if we must create a new item,
+				   the number of the item we will
+				   create it next to */
+  struct item_head * ih;
+  struct reiserfs_de_head * deh;
+  int copy_records_len;			/* length of all records in item to be copied */
+  char * records;
+
+  ih = B_N_PITEM_HEAD (source, item_num);
+
+#ifdef REISERFS_CHECK
+  if (!I_IS_DIRECTORY_ITEM (ih))
+    reiserfs_panic(0, "vs-10000: leaf_copy_dir_entries: item must be directory item");
+#endif
+
+  /* length of all record to be copied and first byte of the last of them */
+  deh = B_I_DEH (source, ih);
+  if (copy_count) {
+    copy_records_len = (from ? deh[from - 1].deh_location : ih->ih_item_len) - 
+      deh[from + copy_count - 1].deh_location;
+    records = source->b_data + ih->ih_item_location + deh[from + copy_count - 1].deh_location;
+  } else {
+    copy_records_len = 0;
+    records = 0;
+  }
+
+  /* when copy last to first, dest buffer can contain 0 items */
+  item_num_in_dest = (last_first == LAST_TO_FIRST) ? (( B_NR_ITEMS(dest) ) ? 0 : -1) : (B_NR_ITEMS(dest) - 1);
+
+  /* if there are no items in dest or the first/last item in dest is not item of the same directory */
+  if ( (item_num_in_dest == - 1) ||
+#ifdef REISERFS_FSCK
+       (last_first == FIRST_TO_LAST && are_items_mergeable (B_N_PITEM_HEAD (dest, item_num_in_dest), ih, dest->b_size) == 0) ||
+       (last_first == LAST_TO_FIRST && are_items_mergeable (ih, B_N_PITEM_HEAD (dest, item_num_in_dest), dest->b_size) == 0)) {
+#else
+       (last_first == FIRST_TO_LAST && ih->ih_key.k_offset == DOT_OFFSET) ||
+       (last_first == LAST_TO_FIRST && COMP_SHORT_KEYS (&ih->ih_key, B_N_PKEY (dest, item_num_in_dest)))) {
+#endif
+    /* create new item in dest */
+    struct item_head new_ih;
+
+    /* form item header */
+    memcpy (&new_ih.ih_key, &ih->ih_key, KEY_SIZE);
+
+    /* calculate item len */
+    new_ih.ih_item_len = DEH_SIZE * copy_count + copy_records_len;
+    I_ENTRY_COUNT(&new_ih) = 0;
+    
+    if (last_first == LAST_TO_FIRST) {
+      /* form key by the following way */
+      if (from < I_ENTRY_COUNT(ih)) {
+	new_ih.ih_key.k_offset = deh[from].deh_offset;
+	new_ih.ih_key.k_uniqueness = DIRENTRY_UNIQUENESS;
+	/*memcpy (&new_ih.ih_key.k_offset, &deh[from].deh_offset, SHORT_KEY_SIZE);*/
+      } else {
+	/* no entries will be copied to this item in this function */
+	new_ih.ih_key.k_offset = MAX_KEY_OFFSET;
+	/* this item is not yet valid, but we want I_IS_DIRECTORY_ITEM to return 1 for it, so we -1 */
+	new_ih.ih_key.k_uniqueness = DIRENTRY_UNIQUENESS/*TYPE_DIRECTORY_MAX*/;
+      }
+    }
+    new_ih.ih_reserved = ih->ih_reserved;
+    
+    /* insert item into dest buffer */
+    leaf_insert_into_buf (th, dest_bi, (last_first == LAST_TO_FIRST) ? 0 : B_NR_ITEMS(dest), &new_ih, NULL, REISERFS_KERNEL_MEM, 0);
+  } else {
+    /* prepare space for entries */
+    leaf_paste_in_buffer (th, dest_bi, (last_first==FIRST_TO_LAST) ? (B_NR_ITEMS(dest) - 1) : 0, MAX_US_INT,
+			  DEH_SIZE * copy_count + copy_records_len, records, REISERFS_KERNEL_MEM, 0
+			  );
+  }
+  
+  item_num_in_dest = (last_first == FIRST_TO_LAST) ? (B_NR_ITEMS(dest)-1) : 0;
+  
+  leaf_paste_entries (dest_bi->bi_bh, item_num_in_dest,
+		      (last_first == FIRST_TO_LAST) ? I_ENTRY_COUNT(B_N_PITEM_HEAD (dest, item_num_in_dest)) : 0,
+		      copy_count, deh + from, records,
+		      DEH_SIZE * copy_count + copy_records_len
+		      );
+}
+
+
+/* Copy the first (if last_first == FIRST_TO_LAST) or last (last_first == LAST_TO_FIRST) item or 
+   part of it or nothing (see the return 0 below) from SOURCE to the end 
+   (if last_first) or beginning (!last_first) of the DEST */
+/* returns 1 if anything was copied, else 0 */
+static int leaf_copy_boundary_item (struct reiserfs_transaction_handle *th, 
+                                    struct buffer_info * dest_bi, struct buffer_head * src, int last_first,
+				    int bytes_or_entries)
+{
+  struct buffer_head * dest = dest_bi->bi_bh;
+  int dest_nr_item, src_nr_item; /* number of items in the source and destination buffers */
+  struct item_head * ih;
+  struct item_head * dih;
+  
+  dest_nr_item = B_NR_ITEMS(dest);
+  
+  if ( last_first == FIRST_TO_LAST ) {
+    /* if ( DEST is empty or first item of SOURCE and last item of DEST are the items of different objects
+       or of different types ) then there is no need to treat this item differently from the other items
+       that we copy, so we return */
+    ih = B_N_PITEM_HEAD (src, 0);
+    dih = B_N_PITEM_HEAD (dest, dest_nr_item - 1);
+#ifdef REISERFS_FSCK
+    if (!dest_nr_item || (are_items_mergeable (dih, ih, src->b_size) == 0))
+#else
+    if (!dest_nr_item || (!is_left_mergeable (ih, src->b_size)))
+#endif
+      /* there is nothing to merge */
+      return 0;
+      
+#ifdef REISERFS_CHECK
+    if ( ! ih->ih_item_len )
+      reiserfs_panic (0, "vs-10010: leaf_copy_boundary_item: item can not have empty dynamic length");
+#endif
+      
+    if ( I_IS_DIRECTORY_ITEM(ih) ) {
+      if ( bytes_or_entries == -1 )
+	/* copy all entries to dest */
+	bytes_or_entries = I_ENTRY_COUNT(ih);
+      leaf_copy_dir_entries (th, dest_bi, src, FIRST_TO_LAST, 0, 0, bytes_or_entries);
+      return 1;
+    }
+      
+    /* copy part of the body of the first item of SOURCE to the end of the body of the last item of the DEST
+       part defined by 'bytes_or_entries'; if bytes_or_entries == -1 copy whole body; don't create new item header
+       */
+    if ( bytes_or_entries == -1 )
+      bytes_or_entries = ih->ih_item_len;
+
+#ifdef REISERFS_CHECK
+    else {
+      if (bytes_or_entries == ih->ih_item_len && I_IS_INDIRECT_ITEM(ih))
+	if (ih->u.ih_free_space)
+	  reiserfs_panic (0, "vs-10020: leaf_copy_boundary_item: "
+			  "last unformatted node must be filled entirely (free_space=%d)",
+			  ih->u.ih_free_space);
+    }
+#endif
+      
+    /* merge first item (or its part) of src buffer with the last
+       item of dest buffer. Both are of the same file */
+    leaf_paste_in_buffer (th, dest_bi,
+			  dest_nr_item - 1, dih->ih_item_len, bytes_or_entries, B_I_PITEM(src,ih), REISERFS_KERNEL_MEM, 0
+			  );
+      
+    if (I_IS_INDIRECT_ITEM(dih)) {
+#ifdef REISERFS_CHECK
+      if (dih->u.ih_free_space)
+	reiserfs_panic (0, "vs-10030: leaf_copy_boundary_item: " 
+			"merge to left: last unformatted node of non-last indirect item must be filled entirely (free_space=%d)",
+			ih->u.ih_free_space);
+#endif
+      if (bytes_or_entries == ih->ih_item_len)
+	dih->u.ih_free_space = ih->u.ih_free_space;
+    }
+    
+    return 1;
+  }
+  
+
+  /* copy boundary item to right (last_first == LAST_TO_FIRST) */
+
+  /* ( DEST is empty or last item of SOURCE and first item of DEST
+     are the items of different object or of different types )
+     */
+  src_nr_item = B_NR_ITEMS (src);
+  ih = B_N_PITEM_HEAD (src, src_nr_item - 1);
+  dih = B_N_PITEM_HEAD (dest, 0);
+
+#ifdef REISERFS_FSCK
+  if (!dest_nr_item || are_items_mergeable (ih, dih, src->b_size) == 0)
+#else
+  if (!dest_nr_item || !is_left_mergeable (dih, src->b_size))
+#endif
+    return 0;
+  
+  if ( I_IS_DIRECTORY_ITEM(ih)) {
+    if ( bytes_or_entries == -1 )
+      /* bytes_or_entries = entries number in last item body of SOURCE */
+      bytes_or_entries = I_ENTRY_COUNT(ih);
+    
+    leaf_copy_dir_entries (th, dest_bi, src, LAST_TO_FIRST, src_nr_item - 1, I_ENTRY_COUNT(ih) - bytes_or_entries, 
+                           bytes_or_entries);
+    return 1;
+  }
+
+  /* copy part of the body of the last item of SOURCE to the begin of the body of the first item of the DEST;
+     part defined by 'bytes_or_entries'; if byte_or_entriess == -1 copy whole body; change first item key of the DEST;
+     don't create new item header
+     */
+  
+#ifdef REISERFS_CHECK  
+  if (I_IS_INDIRECT_ITEM(ih) && ih->u.ih_free_space)
+    reiserfs_panic (0, "vs-10040: leaf_copy_boundary_item: " 
+		    "merge to right: last unformatted node of non-last indirect item must be filled entirely (free_space=%d)",
+		    ih->u.ih_free_space);
+#endif
+
+  if ( bytes_or_entries == -1 ) {
+    /* bytes_or_entries = length of last item body of SOURCE */
+    bytes_or_entries = ih->ih_item_len;
+
+#ifdef REISERFS_CHECK
+    if (dih->ih_key.k_offset != ih->ih_key.k_offset + I_BYTES_NUMBER (ih, src->b_size))/*I_DNM_DATA_LEN(ih))*/
+      reiserfs_panic (0, "vs-10050: leaf_copy_boundary_item: right item offset (%lu) must not be (%lu),it must be %lu",
+		      dih->ih_key.k_offset, ih->ih_key.k_offset + I_BYTES_NUMBER (ih, src->b_size), dih->ih_key.k_offset);
+#endif
+
+    /* change first item key of the DEST */
+    dih->ih_key.k_offset = ih->ih_key.k_offset;
+
+    /* item becomes non-mergeable */
+    /* or mergeable if left item was */
+    dih->ih_key.k_uniqueness = ih->ih_key.k_uniqueness;
+  } else {
+    /* merge to right only part of item */
+#ifdef REISERFS_CHECK
+    if ( ih->ih_item_len <= bytes_or_entries )
+      reiserfs_panic (0, "vs-10060: leaf_copy_boundary_item: no so much bytes %lu (needed %lu)",
+		      ih->ih_item_len, bytes_or_entries);
+#endif
+    
+    /* change first item key of the DEST */
+    if ( I_IS_DIRECT_ITEM(dih) ) {
+#ifdef REISERFS_CHECK
+      if (dih->ih_key.k_offset <= (unsigned long)bytes_or_entries)
+	reiserfs_panic (0, "vs-10070: leaf_copy_boundary_item: dih->ih_key.k_offset(%d) <= bytes_or_entries(%d)", 
+			dih->ih_key.k_offset, bytes_or_entries);
+#endif
+      dih->ih_key.k_offset -= bytes_or_entries;
+    } else {
+#ifdef REISERFS_CHECK
+      if (dih->ih_key.k_offset <=(bytes_or_entries/UNFM_P_SIZE)*dest->b_size )
+	reiserfs_panic (0, "vs-10080: leaf_copy_boundary_item: dih->ih_key.k_offset(%d) <= bytes_or_entries(%d)",
+                    dih->ih_key.k_offset, (bytes_or_entries/UNFM_P_SIZE)*dest->b_size);
+#endif
+      dih->ih_key.k_offset -= ((bytes_or_entries/UNFM_P_SIZE)*dest->b_size);
+    }
+  }
+  
+  leaf_paste_in_buffer (th, dest_bi, 0, 0, bytes_or_entries, B_I_PITEM(src,ih) + ih->ih_item_len - bytes_or_entries, REISERFS_KERNEL_MEM, 0);
+  return 1;
+}
+
+
+/* copy cpy_mun items from buffer src to buffer dest
+ * last_first == FIRST_TO_LAST means, that we copy cpy_num  items beginning from first-th item in src to tail of dest
+ * last_first == LAST_TO_FIRST means, that we copy cpy_num  items beginning from first-th item in src to head of dest
+ */
+static void leaf_copy_items_entirely (struct reiserfs_transaction_handle *th, struct buffer_info * dest_bi, 
+                                      struct buffer_head * src, int last_first,
+				      int first, int cpy_num)
+{
+  struct buffer_head * dest;
+  int nr;
+  int dest_before;
+  int last_loc, last_inserted_loc, location;
+  int i, j;
+  struct block_head * blkh;
+  struct item_head * ih;
+  struct super_block *s ;
+
+#ifdef REISERFS_CHECK
+  if (last_first != LAST_TO_FIRST  && last_first != FIRST_TO_LAST) 
+    reiserfs_panic (0, "vs-10090: leaf_copy_items_entirely: bad last_first parameter %d", last_first);
+
+  if (B_NR_ITEMS (src) - first < cpy_num)
+    reiserfs_panic (0, "vs-10100: leaf_copy_items_entirely: too few items in source %d, required %d from %d",
+		    B_NR_ITEMS(src), cpy_num, first);
+
+  if (cpy_num < 0)
+    reiserfs_panic (0, "vs-10110: leaf_copy_items_entirely: can not copy negative amount of items");
+
+  if ( ! dest_bi )
+    reiserfs_panic (0, "vs-10120: leaf_copy_items_entirely: can not copy negative amount of items");
+#endif
+
+  dest = dest_bi->bi_bh;
+
+#ifdef REISERFS_CHECK
+  if ( ! dest )
+    reiserfs_panic (0, "vs-10130: leaf_copy_items_entirely: can not copy negative amount of items");
+#endif
+
+  if (cpy_num == 0)
+    return;
+
+  nr = (blkh = B_BLK_HEAD(dest))->blk_nr_item;
+  
+  /* we will insert items before 0-th or nr-th item in dest buffer. It depends of last_first parameter */
+  dest_before = (last_first == LAST_TO_FIRST) ? 0 : nr;
+
+  /* location of head of first new item */
+  ih = B_N_PITEM_HEAD (dest, dest_before);
+
+#ifdef REISERFS_CHECK
+  if (blkh->blk_free_space < cpy_num * IH_SIZE) {
+    reiserfs_panic (0, "vs-10140: leaf_copy_items_entirely: not enough free space for headers %d (needed %d)",
+		    blkh->blk_free_space, cpy_num * IH_SIZE);
+  }
+#endif
+
+  /* prepare space for headers */
+  memmove (ih + cpy_num, ih, (nr-dest_before) * IH_SIZE);
+
+  /* copy item headers */
+  memcpy (ih, B_N_PITEM_HEAD (src, first), cpy_num * IH_SIZE);
+
+  blkh->blk_free_space -= IH_SIZE * cpy_num;
+
+  /* location of unmovable item */
+  j = location = (dest_before == 0) ? dest->b_size : (ih-1)->ih_item_location;
+  for (i = dest_before; i < nr + cpy_num; i ++)
+    ih[i-dest_before].ih_item_location =
+      (location -= ih[i-dest_before].ih_item_len);
+
+  /* prepare space for items */
+  last_loc = ih[nr+cpy_num-1-dest_before].ih_item_location;
+  last_inserted_loc = ih[cpy_num-1].ih_item_location;
+
+  /* check free space */
+#ifdef REISERFS_CHECK
+  if (blkh->blk_free_space < j - last_inserted_loc) {
+    reiserfs_panic (0, "vs-10150: leaf_copy_items_entirely: not enough free space for items %d (needed %d)",
+		    blkh->blk_free_space, j - last_inserted_loc);
+  }
+#endif
+
+  memmove (dest->b_data + last_loc,
+	   dest->b_data + last_loc + j - last_inserted_loc,
+	   last_inserted_loc - last_loc);
+
+  /* copy items */
+  memcpy (dest->b_data + last_inserted_loc, B_N_PITEM(src,(first + cpy_num - 1)),
+	  j - last_inserted_loc);
+
+  /* sizes, item number */
+  blkh->blk_nr_item += cpy_num;  
+  blkh->blk_free_space -= j - last_inserted_loc;
+  
+  s = th->t_super ;
+  journal_mark_dirty(th, s, dest);/* no need to preserve, recipient, not sender */
+
+  if (dest_bi->bi_parent) {
+#ifdef REISERFS_CHECK
+    if (B_N_CHILD (dest_bi->bi_parent, dest_bi->bi_position)->dc_block_number != dest->b_blocknr) {
+      reiserfs_panic (0, "vs-10160: leaf_copy_items_entirely: "
+		      "block number in bh does not match to field in disk_child structure %lu and %lu",
+		      dest->b_blocknr, B_N_CHILD (dest_bi->bi_parent, dest_bi->bi_position)->dc_block_number);
+    }
+#endif
+    B_N_CHILD (dest_bi->bi_parent, dest_bi->bi_position)->dc_size +=
+      j - last_inserted_loc + IH_SIZE * cpy_num;
+    
+    /* reiserfs_mark_buffer_dirty (dest_bi->bi_parent, 0); journal victim */	/* no preserve, internal node */
+    journal_mark_dirty(th, s, dest_bi->bi_parent);	/* no preserve, internal node */
+  }
+}
+
+
+/* This function splits the (liquid) item into two items (useful when
+   shifting part of an item into another node.) */
+static void leaf_item_bottle (struct reiserfs_transaction_handle *th, 
+			      struct buffer_info * dest_bi, struct buffer_head * src, int last_first,
+			      int item_num, int cpy_bytes)
+{
+  struct buffer_head * dest = dest_bi->bi_bh;
+  struct item_head * ih;
+  
+#ifdef REISERFS_CHECK  
+  if ( cpy_bytes == -1 ) 
+    reiserfs_panic (0, "vs-10170: leaf_item_bottle: bytes == - 1 means: do not split item");
+#endif
+
+  if ( last_first == FIRST_TO_LAST ) {
+    /* if ( if item in position item_num in buffer SOURCE is directory item ) */
+    if (I_IS_DIRECTORY_ITEM(ih = B_N_PITEM_HEAD(src,item_num)))
+      leaf_copy_dir_entries (th, dest_bi, src, FIRST_TO_LAST, item_num, 0, cpy_bytes);
+    else {
+      struct item_head n_ih;
+      
+      /* copy part of the body of the item number 'item_num' of SOURCE to the end of the DEST 
+	 part defined by 'cpy_bytes'; create new item header; change old item_header (????);
+	 n_ih = new item_header;
+	 */
+      memcpy (&n_ih, ih, IH_SIZE);
+      n_ih.ih_item_len = cpy_bytes;
+      if (I_IS_INDIRECT_ITEM(ih)) {
+#ifdef REISERFS_CHECK
+	if (cpy_bytes == ih->ih_item_len && ih->u.ih_free_space)
+	  reiserfs_panic (0, "vs-10180: leaf_item_bottle: " 
+			  "when whole indirect item is bottle to left neighbor, it must have free_space==0 (not %lu)",
+			  ih->u.ih_free_space);
+#endif
+	n_ih.u.ih_free_space = 0;
+      }
+
+#ifdef REISERFS_CHECK
+      if (is_left_mergeable (ih, src->b_size))
+	reiserfs_panic (0, "vs-10190: leaf_item_bottle: bad mergeability k_offet=%lu, k_uniqueness=%lu",
+			ih->ih_key.k_offset, ih->ih_key.k_uniqueness);
+#endif
+      n_ih.ih_reserved = ih->ih_reserved;;
+      leaf_insert_into_buf (th, dest_bi, B_NR_ITEMS(dest), &n_ih, B_N_PITEM (src, item_num), REISERFS_KERNEL_MEM, 0);
+    }
+  } else {
+    /*  if ( if item in position item_num in buffer SOURCE is directory item ) */
+    if (I_IS_DIRECTORY_ITEM(ih = B_N_PITEM_HEAD (src, item_num)))
+      leaf_copy_dir_entries (th, dest_bi, src, LAST_TO_FIRST, item_num, I_ENTRY_COUNT(ih) - cpy_bytes, cpy_bytes);
+    else {
+      struct item_head n_ih;
+      
+      /* copy part of the body of the item number 'item_num' of SOURCE to the begin of the DEST 
+	 part defined by 'cpy_bytes'; create new item header;
+	 n_ih = new item_header;
+	 */
+      memcpy (&n_ih, ih, SHORT_KEY_SIZE);
+      
+      if (I_IS_DIRECT_ITEM(ih)) {
+	n_ih.ih_key.k_offset = ih->ih_key.k_offset + ih->ih_item_len - cpy_bytes;
+	n_ih.ih_key.k_uniqueness = TYPE_DIRECT;
+	n_ih.u.ih_free_space = MAX_US_INT;
+      } else {
+	/* indirect item */
+#ifdef REISERFS_CHECK
+	if (!cpy_bytes && ih->u.ih_free_space)
+	  reiserfs_panic (0, "vs-10200: leaf_item_bottle: ih->ih_free_space must be 0 when indirect item will be appended");
+#endif
+	n_ih.ih_key.k_offset = ih->ih_key.k_offset + (ih->ih_item_len - cpy_bytes) / UNFM_P_SIZE * dest->b_size;
+	n_ih.ih_key.k_uniqueness = TYPE_INDIRECT;
+	n_ih.u.ih_free_space = ih->u.ih_free_space;
+      }
+      
+      /* set item length */
+      n_ih.ih_item_len = cpy_bytes;
+      n_ih.ih_reserved = ih->ih_reserved;
+      leaf_insert_into_buf (th, dest_bi, 0, &n_ih, B_N_PITEM(src,item_num) + ih->ih_item_len - cpy_bytes,
+			    REISERFS_KERNEL_MEM, 0);
+    }
+  }
+}
+
+
+/* If cpy_bytes equals minus one than copy cpy_num whole items from SOURCE to DEST.
+   If cpy_bytes not equal to minus one than copy cpy_num-1 whole items from SOURCE to DEST.
+   From last item copy cpy_num bytes for regular item and cpy_num directory entries for
+   directory item. */
+static int leaf_copy_items (struct reiserfs_transaction_handle *th,
+                            struct buffer_info * dest_bi, struct buffer_head * src, int last_first, int cpy_num,
+			    int cpy_bytes)
+{
+  struct buffer_head * dest;
+  int pos, i, src_nr_item, bytes;
+
+  dest = dest_bi->bi_bh;
+#ifdef REISERFS_CHECK
+  if (!dest || !src)
+    reiserfs_panic (0, "vs-10210: leaf_copy_items: !dest || !src");
+  
+  if ( last_first != FIRST_TO_LAST && last_first != LAST_TO_FIRST )
+    reiserfs_panic (0, "vs-10220: leaf_copy_items: last_first != FIRST_TO_LAST && last_first != LAST_TO_FIRST");
+
+  if ( B_NR_ITEMS(src) < cpy_num )
+    reiserfs_panic (0, "vs-10230: leaf_copy_items: No enough items: %d, required %d", B_NR_ITEMS(src), cpy_num);
+
+ if ( cpy_num < 0 )
+    reiserfs_panic (0, "vs-10240: leaf_copy_items: cpy_num < 0 (%d)", cpy_num);
+#endif
+
+ if ( cpy_num == 0 )
+   return 0;
+ 
+ if ( last_first == FIRST_TO_LAST ) {
+   /* copy items to left */
+   pos = 0;
+   if ( cpy_num == 1 )
+     bytes = cpy_bytes;
+   else
+     bytes = -1;
+   
+   /* copy the first item or it part or nothing to the end of the DEST (i = leaf_copy_boundary_item(DEST,SOURCE,0,bytes)) */
+   i = leaf_copy_boundary_item (th, dest_bi, src, FIRST_TO_LAST, bytes);
+   cpy_num -= i;
+   if ( cpy_num == 0 )
+     return i;
+   pos += i;
+   if ( cpy_bytes == -1 )
+     /* copy first cpy_num items starting from position 'pos' of SOURCE to end of DEST */
+     leaf_copy_items_entirely(th, dest_bi, src, FIRST_TO_LAST, pos, cpy_num);
+   else {
+     /* copy first cpy_num-1 items starting from position 'pos-1' of the SOURCE to the end of the DEST */
+     leaf_copy_items_entirely(th, dest_bi, src, FIRST_TO_LAST, pos, cpy_num-1);
+	     
+     /* copy part of the item which number is cpy_num+pos-1 to the end of the DEST */
+     leaf_item_bottle (th, dest_bi, src, FIRST_TO_LAST, cpy_num+pos-1, cpy_bytes);
+   } 
+ } else {
+   /* copy items to right */
+   src_nr_item = B_NR_ITEMS (src);
+   if ( cpy_num == 1 )
+     bytes = cpy_bytes;
+   else
+     bytes = -1;
+   
+   /* copy the last item or it part or nothing to the begin of the DEST (i = leaf_copy_boundary_item(DEST,SOURCE,1,bytes)); */
+   i = leaf_copy_boundary_item (th, dest_bi, src, LAST_TO_FIRST, bytes);
+   
+   cpy_num -= i;
+   if ( cpy_num == 0 )
+     return i;
+   
+   pos = src_nr_item - cpy_num - i;
+   if ( cpy_bytes == -1 ) {
+     /* starting from position 'pos' copy last cpy_num items of SOURCE to begin of DEST */
+     leaf_copy_items_entirely(th, dest_bi, src, LAST_TO_FIRST, pos, cpy_num);
+   } else {
+     /* copy last cpy_num-1 items starting from position 'pos+1' of the SOURCE to the begin of the DEST; */
+     leaf_copy_items_entirely(th, dest_bi, src, LAST_TO_FIRST, pos+1, cpy_num-1);
+
+     /* copy part of the item which number is pos to the begin of the DEST */
+     leaf_item_bottle (th, dest_bi, src, LAST_TO_FIRST, pos, cpy_bytes);
+   }
+ }
+ return i;
+}
+
+
+/* there are types of coping: from S[0] to L[0], from S[0] to R[0],
+   from R[0] to L[0]. for each of these we have to define parent and
+   positions of destination and source buffers */
+static void leaf_define_dest_src_infos (int shift_mode, struct tree_balance * tb, struct buffer_info * dest_bi,
+					struct buffer_info * src_bi, int * first_last,
+					struct buffer_head * Snew)
+{
+#ifdef REISERFS_CHECK
+  memset (dest_bi, 0, sizeof (struct buffer_info));
+  memset (src_bi, 0, sizeof (struct buffer_info));
+#endif
+
+  /* define dest, src, dest parent, dest position */
+  switch (shift_mode) {
+  case LEAF_FROM_S_TO_L:    /* it is used in leaf_shift_left */
+    src_bi->bi_bh = PATH_PLAST_BUFFER (tb->tb_path);
+    src_bi->bi_parent = PATH_H_PPARENT (tb->tb_path, 0);
+    src_bi->bi_position = PATH_H_B_ITEM_ORDER (tb->tb_path, 0);	/* src->b_item_order */
+    dest_bi->bi_bh = tb->L[0];
+    dest_bi->bi_parent = tb->FL[0];
+    dest_bi->bi_position = get_left_neighbor_position (tb, 0);
+    *first_last = FIRST_TO_LAST;
+    break;
+
+  case LEAF_FROM_S_TO_R:  /* it is used in leaf_shift_right */
+    src_bi->bi_bh = PATH_PLAST_BUFFER (tb->tb_path);
+    src_bi->bi_parent = PATH_H_PPARENT (tb->tb_path, 0);
+    src_bi->bi_position = PATH_H_B_ITEM_ORDER (tb->tb_path, 0);
+    dest_bi->bi_bh = tb->R[0];
+    dest_bi->bi_parent = tb->FR[0];
+    dest_bi->bi_position = get_right_neighbor_position (tb, 0);
+    *first_last = LAST_TO_FIRST;
+    break;
+
+  case LEAF_FROM_R_TO_L:  /* it is used in balance_leaf_when_delete */
+    src_bi->bi_bh = tb->R[0];
+    src_bi->bi_parent = tb->FR[0];
+    src_bi->bi_position = get_right_neighbor_position (tb, 0);
+    dest_bi->bi_bh = tb->L[0];
+    dest_bi->bi_parent = tb->FL[0];
+    dest_bi->bi_position = get_left_neighbor_position (tb, 0);
+    *first_last = FIRST_TO_LAST;
+    break;
+    
+  case LEAF_FROM_L_TO_R:  /* it is used in balance_leaf_when_delete */
+    src_bi->bi_bh = tb->L[0];
+    src_bi->bi_parent = tb->FL[0];
+    src_bi->bi_position = get_left_neighbor_position (tb, 0);
+    dest_bi->bi_bh = tb->R[0];
+    dest_bi->bi_parent = tb->FR[0];
+    dest_bi->bi_position = get_right_neighbor_position (tb, 0);
+    *first_last = LAST_TO_FIRST;
+    break;
+
+  case LEAF_FROM_S_TO_SNEW:
+    src_bi->bi_bh = PATH_PLAST_BUFFER (tb->tb_path);
+    src_bi->bi_parent = PATH_H_PPARENT (tb->tb_path, 0);
+    src_bi->bi_position = PATH_H_B_ITEM_ORDER (tb->tb_path, 0);
+    dest_bi->bi_bh = Snew;
+    dest_bi->bi_parent = 0;
+    dest_bi->bi_position = 0;
+    *first_last = LAST_TO_FIRST;
+    break;
+    
+  default:
+    reiserfs_panic (0, "vs-10250: leaf_define_dest_src_infos: shift type is unknown (%d)", shift_mode);
+  }
+#ifdef REISERFS_CHECK
+  if (src_bi->bi_bh == 0 || dest_bi->bi_bh == 0) {
+    reiserfs_panic (0, "vs-10260: leaf_define_dest_src_etc: mode==%d, source (%p) or dest (%p) buffer is initialized incorrectly",
+		    shift_mode, src_bi->bi_bh, dest_bi->bi_bh);
+  }
+#endif
+}
+
+
+
+
+/* copy mov_num items and mov_bytes of the (mov_num-1)th item to
+   neighbor. Delete them from source */
+int leaf_move_items (struct reiserfs_transaction_handle *th,
+                     int shift_mode, struct tree_balance * tb, int mov_num, int mov_bytes, struct buffer_head * Snew)
+{
+  int ret_value;
+  struct buffer_info dest_bi, src_bi;
+  int first_last;
+
+  leaf_define_dest_src_infos (shift_mode, tb, &dest_bi, &src_bi, &first_last, Snew);
+
+  ret_value = leaf_copy_items (th, &dest_bi, src_bi.bi_bh, first_last, mov_num, mov_bytes);
+
+  leaf_delete_items (th, &src_bi, first_last, (first_last == FIRST_TO_LAST) ? 0 : 
+                    (B_NR_ITEMS(src_bi.bi_bh) - mov_num), mov_num, mov_bytes);
+
+  
+  return ret_value;
+}
+
+
+/* Shift shift_num items (and shift_bytes of last shifted item if shift_bytes != -1)
+   from S[0] to L[0] and replace the delimiting key */
+int leaf_shift_left (struct reiserfs_transaction_handle *th, struct tree_balance * tb, int shift_num, int shift_bytes)
+{
+  struct buffer_head * S0 = PATH_PLAST_BUFFER (tb->tb_path);
+  int i;
+
+  /* move shift_num (and shift_bytes bytes) items from S[0] to left neighbor L[0] */
+  i = leaf_move_items (th, LEAF_FROM_S_TO_L, tb, shift_num, shift_bytes, 0);
+
+  if ( shift_num ) {
+    if (B_NR_ITEMS (S0) == 0) { /* number of items in S[0] == 0 */
+
+#ifdef REISERFS_CHECK
+      if ( shift_bytes != -1 )
+	reiserfs_panic (tb->tb_sb, "vs-10270: leaf_shift_left: S0 is empty now, but shift_bytes != -1 (%d)", shift_bytes);
+
+      if (init_mode == M_PASTE || init_mode == M_INSERT) {
+	print_tb (init_mode, init_item_pos, init_pos_in_item, &init_tb, "vs-10275");
+	reiserfs_panic (tb->tb_sb, "vs-10275: leaf_shift_left: balance condition corrupted (%c)", init_mode);
+      }
+#endif
+
+      if (PATH_H_POSITION (tb->tb_path, 1) == 0)
+	replace_key(th, tb->CFL[0], tb->lkey[0], PATH_H_PPARENT (tb->tb_path, 0), 0);
+      
+      /* change right_delimiting_key field in L0's block header */
+      copy_key (B_PRIGHT_DELIM_KEY(tb->L[0]), B_PRIGHT_DELIM_KEY (S0));
+
+    } else {     
+      /* replace lkey in CFL[0] by 0-th key from S[0]; */
+      replace_key(th, tb->CFL[0], tb->lkey[0], S0, 0);
+      
+      /* change right_delimiting_key field in L0's block header */
+      copy_key (B_PRIGHT_DELIM_KEY(tb->L[0]), B_N_PKEY (S0, 0));
+#ifdef REISERFS_CHECK
+      if (shift_bytes != -1 && !(I_IS_DIRECTORY_ITEM (B_N_PITEM_HEAD (S0, 0))
+				 && !I_ENTRY_COUNT (B_N_PITEM_HEAD (S0, 0)))) {
+	if (!is_left_mergeable (B_N_PITEM_HEAD (S0, 0), S0->b_size)) {
+	  reiserfs_panic (tb->tb_sb, "vs-10280: leaf_shift_left: item must be mergeable");
+	}
+      }
+#endif
+    }
+  }
+  
+  return i;
+}
+
+
+
+
+
+/* CLEANING STOPPED HERE */
+
+
+
+
+/* Shift shift_num (shift_bytes) items from S[0] to the right neighbor, and replace the delimiting key */
+int	leaf_shift_right(
+		struct reiserfs_transaction_handle *th,
+		struct tree_balance * tb, 
+		int shift_num,
+		int shift_bytes
+	)
+{
+  struct buffer_head * S0 = PATH_PLAST_BUFFER (tb->tb_path);
+  int ret_value;
+
+  /* move shift_num (and shift_bytes) items from S[0] to right neighbor R[0] */
+  ret_value = leaf_move_items (th, LEAF_FROM_S_TO_R, tb, shift_num, shift_bytes, 0);
+
+  /* replace rkey in CFR[0] by the 0-th key from R[0] */
+  if (shift_num) {
+    replace_key(th, tb->CFR[0], tb->rkey[0], tb->R[0], 0);
+
+    /* change right_delimiting_key field in S0's block header */
+    copy_key (B_PRIGHT_DELIM_KEY(S0), B_N_PKEY (tb->R[0], 0));
+  }
+
+  return ret_value;
+}
+
+
+
+static void	leaf_delete_items_entirely (
+				struct reiserfs_transaction_handle *th,
+				struct buffer_info * bi,
+				int first,
+				int del_num
+			);
+/*  If del_bytes == -1, starting from position 'first' delete del_num items in whole in buffer CUR.
+    If not. 
+    If last_first == 0. Starting from position 'first' delete del_num-1 items in whole. Delete part of body of
+    the first item. Part defined by del_bytes. Don't delete first item header
+    If last_first == 1. Starting from position 'first+1' delete del_num-1 items in whole. Delete part of body of
+    the last item . Part defined by del_bytes. Don't delete last item header.
+*/
+void	leaf_delete_items (
+			struct reiserfs_transaction_handle *th,
+			struct buffer_info * cur_bi,
+			int last_first, 
+			int first, int del_num, int del_bytes
+		)
+{
+    struct buffer_head * bh;
+    struct super_block *s ;
+    int item_amount = B_NR_ITEMS (bh = cur_bi->bi_bh);
+
+#ifdef REISERFS_CHECK
+  if ( !bh )
+    reiserfs_panic (0, "leaf_delete_items: 10155: bh is not defined");
+
+  if ( del_num < 0 )
+    reiserfs_panic (0, "leaf_delete_items: 10160: del_num can not be < 0. del_num==%d", del_num);
+
+  if ( first < 0 || first + del_num > item_amount )
+    reiserfs_panic (0, "leaf_delete_items: 10165: invalid number of first item to be deleted (%d) or "
+            "no so much items (%d) to delete (only %d)", first, first + del_num, item_amount);
+#endif
+
+  if ( del_num == 0 )
+    return;
+
+  if ( first == 0 && del_num == item_amount && del_bytes == -1 ) {
+    make_empty_node (cur_bi);
+    s = th->t_super ;
+    journal_mark_dirty(th, s, bh);	/* not preserved, preserves are in balance_leaf() and  balance_leaf_when_delete() */
+    return;
+  }
+
+  if ( del_bytes == -1 )
+    /* delete del_num items beginning from item in position first */
+    leaf_delete_items_entirely (th, cur_bi, first, del_num);
+  else {
+      if ( last_first == FIRST_TO_LAST ) {
+	        /* delete del_num-1 items beginning from item in position first  */
+	      leaf_delete_items_entirely (th, cur_bi, first, del_num-1);
+
+	      /* delete the part of the first item of the bh
+	         do not delete item header
+	         */
+	      leaf_cut_from_buffer (th, cur_bi, 0, 0, del_bytes);
+      } else  {
+	      struct item_head * ih;
+	      int len;
+
+	      /* delete del_num-1 items beginning from item in position first+1  */
+	      leaf_delete_items_entirely (th, cur_bi, first+1, del_num-1);
+
+	      if (I_IS_DIRECTORY_ITEM(ih = B_N_PITEM_HEAD(bh, B_NR_ITEMS(bh)-1))) 	/* the last item is directory  */
+	        /* len = numbers of directory entries in this item */
+	        len = I_ENTRY_COUNT(ih);
+	      else
+	        /* len = body len of item */
+ 	        len = ih->ih_item_len;
+
+	      /* delete the part of the last item of the bh 
+	         do not delete item header
+	         */
+	      leaf_cut_from_buffer (th, cur_bi, B_NR_ITEMS(bh)-1, len - del_bytes, del_bytes);
+	  }
+  }
+}
+
+
+/* insert item into the leaf node in position before */
+void	leaf_insert_into_buf (
+			struct reiserfs_transaction_handle *th,
+			struct buffer_info * bi,
+			int before,
+			struct item_head * inserted_item_ih,
+			const char * inserted_item_body,
+			int mem_mode,
+			int zeros_number
+		)
+{
+	struct buffer_head * bh = bi->bi_bh;
+	int nr;
+	struct block_head * blkh;
+	struct item_head * ih;
+	int i;
+	int last_loc, unmoved_loc;
+	char * to;
+	struct super_block *s ;
+
+
+  nr = (blkh = B_BLK_HEAD (bh))->blk_nr_item;
+
+#ifdef REISERFS_CHECK
+  /* check free space */
+  if (blkh->blk_free_space < inserted_item_ih->ih_item_len + IH_SIZE)
+    reiserfs_panic (0, "leaf_insert_into_buf: 10170: not enough free space: needed %d, available %d",
+		    inserted_item_ih->ih_item_len + IH_SIZE, blkh->blk_free_space);
+  if (zeros_number > inserted_item_ih->ih_item_len)
+    reiserfs_panic (0, "vs-10172: leaf_insert_into_buf: zero number == %d, item length == %d", zeros_number, inserted_item_ih->ih_item_len);
+#endif /* REISERFS_CHECK */
+
+
+  /* get item new item must be inserted before */
+  ih = B_N_PITEM_HEAD (bh, before);
+
+  /* prepare space for the body of new item */
+  last_loc = nr ? ih[nr - before - 1].ih_item_location : bh->b_size;
+  unmoved_loc = before ? (ih-1)->ih_item_location : bh->b_size;
+
+  memmove (bh->b_data + last_loc - inserted_item_ih->ih_item_len, 
+	   bh->b_data + last_loc, unmoved_loc - last_loc);
+
+  to = bh->b_data + unmoved_loc - inserted_item_ih->ih_item_len;
+  memset (to, 0, zeros_number);
+  to += zeros_number;
+
+  /* copy body to prepared space */
+  if (inserted_item_body)
+    if (mem_mode == REISERFS_USER_MEM)
+      copy_from_user (to, inserted_item_body, inserted_item_ih->ih_item_len - zeros_number);
+    else {
+      memmove (to, inserted_item_body, inserted_item_ih->ih_item_len - zeros_number);
+    }
+  else
+      memset(to, '\0', inserted_item_ih->ih_item_len - zeros_number);
+  
+  /* insert item header */
+  memmove (ih + 1, ih, IH_SIZE * (nr - before));
+  memmove (ih, inserted_item_ih, IH_SIZE);
+  
+  /* change locations */
+  for (i = before; i < nr + 1; i ++)
+    ih[i-before].ih_item_location =
+      (unmoved_loc -= ih[i-before].ih_item_len);
+  
+  /* sizes, free space, item number */
+  blkh->blk_nr_item ++;
+  blkh->blk_free_space -= (IH_SIZE + inserted_item_ih->ih_item_len);
+
+  s = th->t_super ;
+  journal_mark_dirty(th, s, bh) ;
+
+  if (bi->bi_parent) { 
+    B_N_CHILD (bi->bi_parent, bi->bi_position)->dc_size += (IH_SIZE + inserted_item_ih->ih_item_len);
+    journal_mark_dirty(th, s, bi->bi_parent) ;
+  }
+
+
+}
+
+
+/* paste paste_size bytes to affected_item_num-th item. 
+   When item is a directory, this only prepare space for new entries */
+void	leaf_paste_in_buffer (
+			struct reiserfs_transaction_handle *th,
+			struct buffer_info * bi,
+			int affected_item_num,
+			int pos_in_item,
+			int paste_size,
+			const char * body,
+			int mem_mode,
+			int zeros_number
+		)
+{
+	struct buffer_head * bh = bi->bi_bh;
+	int nr;
+	struct block_head * blkh;
+	struct item_head * ih;
+	int i;
+	int last_loc, unmoved_loc;
+	struct super_block *s ;
+
+
+  nr = (blkh = B_BLK_HEAD(bh))->blk_nr_item;
+
+#ifdef REISERFS_CHECK
+  /* check free space */
+  if (blkh->blk_free_space < paste_size)
+    reiserfs_panic (0, "leaf_paste_in_buffer: 10175: not enough free space: needed %d, available %d",
+		    paste_size, blkh->blk_free_space);
+  if (zeros_number > paste_size) {
+    print_tb (init_mode, init_item_pos, init_pos_in_item, &init_tb, "10177");
+    reiserfs_panic (0, "vs-10177: leaf_paste_in_buffer: zero number == %d, paste_size == %d", zeros_number, paste_size);
+  }
+#endif /* REISERFS_CHECK */
+
+
+  /* item to be appended */
+  ih = B_N_PITEM_HEAD(bh, affected_item_num);
+
+  last_loc = ih[nr - affected_item_num - 1].ih_item_location;
+  unmoved_loc = affected_item_num ? (ih-1)->ih_item_location : bh->b_size;  
+
+  /* prepare space */
+  memmove (bh->b_data + last_loc - paste_size, bh->b_data + last_loc,
+ 	   unmoved_loc - last_loc);
+
+
+  /* change locations */
+  for (i = affected_item_num; i < nr; i ++)
+    ih[i-affected_item_num].ih_item_location -= paste_size;
+
+  if ( body ) {
+    if (!I_IS_DIRECTORY_ITEM(ih)) {
+      if (mem_mode == REISERFS_USER_MEM) {
+	memset (bh->b_data + unmoved_loc - paste_size, 0, zeros_number);
+	copy_from_user (bh->b_data + unmoved_loc - paste_size + zeros_number, body, paste_size - zeros_number);
+      } else {
+	if (!pos_in_item) {
+	  /* shift data to right */
+	  memmove (bh->b_data + ih->ih_item_location + paste_size, 
+		   bh->b_data + ih->ih_item_location, ih->ih_item_len);
+	  /* paste data in the head of item */
+	  memset (bh->b_data + ih->ih_item_location, 0, zeros_number);
+	  memcpy (bh->b_data + ih->ih_item_location + zeros_number, body, paste_size - zeros_number);
+	} else {
+	  memset (bh->b_data + unmoved_loc - paste_size, 0, zeros_number);
+	  memcpy (bh->b_data + unmoved_loc - paste_size + zeros_number, body, paste_size - zeros_number);
+	}
+      }
+    }
+  }
+  else
+    memset(bh->b_data + unmoved_loc - paste_size,'\0',paste_size);
+
+  ih->ih_item_len += paste_size;
+
+  /* change free space */
+  blkh->blk_free_space -= paste_size;
+
+  s = th->t_super ;
+  journal_mark_dirty(th, s, bh) ;
+
+  if (bi->bi_parent) { 
+    B_N_CHILD (bi->bi_parent, bi->bi_position)->dc_size += paste_size;
+    journal_mark_dirty(th, s, bi->bi_parent); /* no need to preserve, internal node */
+    journal_mark_dirty(th, s, bi->bi_parent) ;
+  }
+}
+
+/* cuts DEL_COUNT entries beginning from FROM-th entry. Directory item
+   does not have free space, so it moves DEHs and remaining records as
+   necessary. Return value is size of removed part of directory item
+   in bytes. */
+static int	leaf_cut_entries (
+				struct buffer_head * bh,
+				struct item_head * ih, 
+				int from, 
+				int del_count
+			)
+{
+  char * item;
+  struct reiserfs_de_head * deh;
+  int prev_record_offset;	/* offset of record, that is (from-1)th */
+  char * prev_record;		/* */
+  int cut_records_len;		/* length of all removed records */
+  int i;
+
+
+#ifdef REISERFS_CHECK
+  /* make sure, that item is directory and there are enough entries to
+     remove */
+  if (!I_IS_DIRECTORY_ITEM (ih))
+    reiserfs_panic (0, "leaf_cut_entries: 10180: item is not directory item");
+
+  if (I_ENTRY_COUNT(ih) < from + del_count)
+    reiserfs_panic (0, "leaf_cut_entries: 10185: item contains not enough entries: entry_cout = %d, from = %d, to delete = %d",
+		    I_ENTRY_COUNT(ih), from, del_count);
+#endif
+
+  if (del_count == 0)
+    return 0;
+
+  /* first byte of item */
+  item = bh->b_data + ih->ih_item_location;
+
+  /* entry head array */
+  deh = B_I_DEH (bh, ih);
+
+  /* first byte of remaining entries, those are BEFORE cut entries
+     (prev_record) and length of all removed records (cut_records_len) */
+  prev_record_offset = (from ? deh[from - 1].deh_location : ih->ih_item_len);
+  cut_records_len = prev_record_offset/*from_record*/ - deh[from + del_count - 1].deh_location;
+  prev_record = item + prev_record_offset;
+
+
+  /* adjust locations of remaining entries */
+  for (i = I_ENTRY_COUNT(ih) - 1; i > from + del_count - 1; i --)
+    deh[i].deh_location -= (DEH_SIZE * del_count);
+
+  for (i = 0; i < from; i ++)
+    deh[i].deh_location -= DEH_SIZE * del_count + cut_records_len;
+
+  I_ENTRY_COUNT(ih) -= del_count;
+
+  /* shift entry head array and entries those are AFTER removed entries */
+  memmove ((char *)(deh + from),
+	   deh + from + del_count, 
+	   prev_record - cut_records_len - (char *)(deh + from + del_count));
+  
+  /* shift records, those are BEFORE removed entries */
+  memmove (prev_record - cut_records_len - DEH_SIZE * del_count,
+	   prev_record, item + ih->ih_item_len - prev_record);
+
+  return DEH_SIZE * del_count + cut_records_len;
+}
+
+
+/*  when cut item is part of regular file
+        pos_in_item - first byte that must be cut
+        cut_size - number of bytes to be cut beginning from pos_in_item
+ 
+   when cut item is part of directory
+        pos_in_item - number of first deleted entry
+        cut_size - count of deleted entries
+    */
+void	leaf_cut_from_buffer (
+			struct reiserfs_transaction_handle *th,
+			struct buffer_info * bi,
+			int cut_item_num,
+			int pos_in_item,
+			int cut_size
+		)
+{
+    int nr;
+    struct buffer_head * bh = bi->bi_bh;
+    struct block_head * blkh;
+    struct item_head * ih;
+    int last_loc, unmoved_loc;
+    int i;
+    struct super_block *s ;
+
+    nr = (blkh = B_BLK_HEAD (bh))->blk_nr_item;
+
+    /* item head of truncated item */
+    ih = B_N_PITEM_HEAD (bh, cut_item_num);
+
+    if (I_IS_DIRECTORY_ITEM (ih)) {
+        /* first cut entry ()*/
+        cut_size = leaf_cut_entries (bh, ih, pos_in_item, cut_size);
+        if (pos_in_item == 0) {
+	        /* change key */
+#ifdef REISERFS_CHECK
+            if (cut_item_num)
+                reiserfs_panic (0, "leaf_cut_from_buffer: 10190: " 
+                    "when 0-th enrty of item is cut, that item must be first in the node, not %d-th", cut_item_num);
+#endif
+            /* change item key by key of first entry in the item */
+	    ih->ih_key.k_offset = B_I_DEH (bh, ih)->deh_offset;
+            /*memcpy (&ih->ih_key.k_offset, &(B_I_DEH (bh, ih)->deh_offset), SHORT_KEY_SIZE);*/
+	    }
+    } else {
+        /* item is direct or indirect */
+#ifdef REISERFS_CHECK
+        if (I_IS_STAT_DATA_ITEM (ih))
+	        reiserfs_panic (0, "leaf_cut_from_buffer: 10195: item is stat data");
+
+        if (pos_in_item && pos_in_item + cut_size != ih->ih_item_len )
+            reiserfs_panic (0, "cut_from_buf: 10200: invalid offset (%lu) or trunc_size (%lu) or ih_item_len (%lu)",
+                pos_in_item, cut_size, ih->ih_item_len);
+#endif
+
+        /* shift item body to left if cut is from the head of item */
+        if (pos_in_item == 0) {
+            memmove (bh->b_data + ih->ih_item_location, bh->b_data + ih->ih_item_location + cut_size,
+                ih->ih_item_len - cut_size);
+
+            /* change key of item */
+            if (I_IS_DIRECT_ITEM(ih))
+                ih->ih_key.k_offset += cut_size;
+            else {
+                ih->ih_key.k_offset += (cut_size / UNFM_P_SIZE) * bh->b_size;
+#ifdef REISERFS_CHECK
+                if ( ih->ih_item_len == cut_size && ih->u.ih_free_space )
+                    reiserfs_panic (0, "leaf_cut_from_buf: 10205: invalid ih_free_space (%lu)", ih->u.ih_free_space);
+#endif
+	        }
+	    }
+    }
+  
+
+    /* location of the last item */
+    last_loc = ih[nr - cut_item_num - 1].ih_item_location;
+
+    /* location of the item, which is remaining at the same place */
+    unmoved_loc = cut_item_num ? (ih-1)->ih_item_location : bh->b_size;
+
+
+    /* shift */
+    memmove (bh->b_data + last_loc + cut_size, bh->b_data + last_loc,
+	       unmoved_loc - last_loc - cut_size);
+
+    /* change item length */
+    ih->ih_item_len -= cut_size;
+  
+    if (I_IS_INDIRECT_ITEM(ih)) {
+        if (pos_in_item)
+            ih->u.ih_free_space = 0;
+    }
+
+    /* change locations */
+    for (i = cut_item_num; i < nr; i ++)
+        ih[i-cut_item_num].ih_item_location += cut_size;
+
+    /* size, free space */
+    blkh->blk_free_space += cut_size;
+
+    s = th->t_super ;
+    /* reiserfs_mark_buffer_dirty (bh, 0); journal victim */	/* should preserve_dirt but not preserve_shifted */
+    journal_mark_dirty(th, s, bh);	/* should preserve_dirt but not preserve_shifted */
+    
+    if (bi->bi_parent) { 
+      B_N_CHILD (bi->bi_parent, bi->bi_position)->dc_size -= cut_size; 
+      /* reiserfs_mark_buffer_dirty (bi->bi_parent, 0); journal victim *//* no need to preserve, internal node */
+      journal_mark_dirty(th, s, bi->bi_parent);/* no need to preserve, internal node */
+    }
+}
+
+
+/* delete del_num items from buffer starting from the first'th item */
+static void	leaf_delete_items_entirely (
+				struct reiserfs_transaction_handle *th,
+				struct buffer_info * bi,
+				int first,
+				int del_num
+			)
+{
+	struct buffer_head * bh = bi->bi_bh;
+    int nr;
+    int i, j;
+    int last_loc, last_removed_loc;
+    struct block_head * blkh;
+    struct item_head * ih;
+    struct super_block *s ;
+
+    s = th->t_super ;
+
+#ifdef REISERFS_CHECK
+  if (bh == NULL)
+    reiserfs_panic (0, "leaf_delete_items_entirely: 10210: buffer is 0");
+
+  if (del_num < 0)
+    reiserfs_panic (0, "leaf_delete_items_entirely: 10215: del_num less than 0 (%d)", del_num);
+#endif /* REISERFS_CHECK */
+
+  if (del_num == 0)
+    return;
+
+  nr = (blkh = B_BLK_HEAD(bh))->blk_nr_item;
+
+#ifdef REISERFS_CHECK
+  if (first < 0 || first + del_num > nr)
+    reiserfs_panic (0, "leaf_delete_items_entirely: 10220: first=%d, number=%d, there is %d items", first, del_num, nr);
+#endif /* REISERFS_CHECK */
+
+  if (first == 0 && del_num == nr) {
+    /* this does not work */
+    make_empty_node (bi);
+    
+    journal_mark_dirty(th, s, bh);	/* not preserved, preserves are in balance_leaf() and  balance_leaf_when_delete() */
+    return;
+  }
+
+  ih = B_N_PITEM_HEAD (bh, first);
+  
+  /* location of unmovable item */
+  j = (first == 0) ? bh->b_size : (ih-1)->ih_item_location;
+      
+  /* delete items */
+  last_loc = ih[nr-1-first].ih_item_location;
+  last_removed_loc = ih[del_num-1].ih_item_location;
+
+  memmove (bh->b_data + last_loc + j - last_removed_loc,
+	   bh->b_data + last_loc, last_removed_loc - last_loc);
+  
+  /* delete item headers */
+  memmove (ih, ih + del_num, (nr - first - del_num) * IH_SIZE);
+  
+  /* change item location */
+  for (i = first; i < nr - del_num; i ++)
+    ih[i-first].ih_item_location += j - last_removed_loc;
+
+  /* sizes, item number */
+  blkh->blk_nr_item -= del_num;
+  blkh->blk_free_space += j - last_removed_loc + IH_SIZE * del_num;
+
+/* not preserved, preserves are in balance_leaf() and  balance_leaf_when_delete() */
+  journal_mark_dirty(th, s, bh);
+  
+  if (bi->bi_parent) {
+    B_N_CHILD (bi->bi_parent, bi->bi_position)->dc_size -= j - last_removed_loc + IH_SIZE * del_num;
+    journal_mark_dirty(th, s, bi->bi_parent); /* not preserved, internal node */
+  }
+}
+
+
+
+
+
+/* paste new_entry_count entries (new_dehs, records) into position before to item_num-th item */
+void    leaf_paste_entries (
+			struct buffer_head * bh,
+			int item_num,
+			int before,
+			int new_entry_count,
+			struct reiserfs_de_head * new_dehs,
+			const char * records,
+			int paste_size
+		)
+{
+    struct item_head * ih;
+    char * item;
+    struct reiserfs_de_head * deh;
+    char * insert_point;
+    int i, old_entry_num;
+
+    if (new_entry_count == 0)
+        return;
+
+    ih = B_N_PITEM_HEAD(bh, item_num);
+
+#ifdef REISERFS_CHECK
+  /* make sure, that item is directory, and there are enough records in it */
+  if (!I_IS_DIRECTORY_ITEM (ih))
+    reiserfs_panic (0, "leaf_paste_entries: 10225: item is not directory item");
+
+  if (I_ENTRY_COUNT (ih) < before)
+    reiserfs_panic (0, "leaf_paste_entries: 10230: there are no entry we paste entries before. entry_count = %d, before = %d",
+		    I_ENTRY_COUNT (ih), before);
+#endif
+
+
+  /* first byte of dest item */
+  item = bh->b_data + ih->ih_item_location;
+
+  /* entry head array */
+  deh = B_I_DEH (bh, ih);
+
+  /* new records will be pasted at this point */
+  insert_point = item + (before ? deh[before - 1].deh_location : (ih->ih_item_len - paste_size));
+
+  /* adjust locations of records that will be AFTER new records */
+  for (i = I_ENTRY_COUNT(ih) - 1; i >= before; i --)
+    deh[i].deh_location += DEH_SIZE * new_entry_count;
+
+  /* adjust locations of records that will be BEFORE new records */
+  for (i = 0; i < before; i ++)
+    deh[i].deh_location += paste_size;
+
+  old_entry_num = I_ENTRY_COUNT(ih);
+  I_ENTRY_COUNT(ih) += new_entry_count;
+
+  /* prepare space for pasted records */
+  memmove (insert_point + paste_size, insert_point, item + (ih->ih_item_len - paste_size) - insert_point);
+
+  /* copy new records */
+  memcpy (insert_point + DEH_SIZE * new_entry_count, records,
+		   paste_size - DEH_SIZE * new_entry_count);
+  
+  /* prepare space for new entry heads */
+  deh += before;
+  memmove ((char *)(deh + new_entry_count), deh, insert_point - (char *)deh);
+
+  /* copy new entry heads */
+  deh = (struct reiserfs_de_head *)((char *)deh);
+  memcpy (deh, new_dehs, DEH_SIZE * new_entry_count);
+
+  /* set locations of new records */
+  for (i = 0; i < new_entry_count; i ++)
+    deh[i].deh_location += 
+      (- new_dehs[new_entry_count - 1].deh_location + insert_point + DEH_SIZE * new_entry_count - item);
+
+
+  /* change item key if neccessary (when we paste before 0-th entry */
+  if (!before)
+    {
+#ifdef REISERFS_CHECK
+/*
+      if ( old_entry_num && COMP_SHORT_KEYS ((unsigned long *)&ih->ih_key.k_offset,
+					     &(new_dehs->deh_offset)) <= 0)
+	reiserfs_panic (0, "leaf_paste_entries: 10235: new key must be less, that old key");
+*/
+#endif
+      ih->ih_key.k_offset = new_dehs->deh_offset;
+/*      memcpy (&ih->ih_key.k_offset, 
+		       &new_dehs->deh_offset, SHORT_KEY_SIZE);*/
+    }
+
+#ifdef REISERFS_CHECK
+  {
+    int prev, next;
+    /* check record locations */
+    deh = B_I_DEH (bh, ih);
+    for (i = 0; i < I_ENTRY_COUNT(ih); i ++) {
+      next = (i < I_ENTRY_COUNT(ih) - 1) ? deh[i + 1].deh_location : 0;
+      prev = (i != 0) ? deh[i - 1].deh_location : 0;
+      
+      if (prev && prev <= deh[i].deh_location)
+	reiserfs_warning ("vs-10240: leaf_paste_entries: directory item corrupted (%d %d)\n", prev, deh[i].deh_location);
+      if (next && next >= deh[i].deh_location)
+	reiserfs_warning ("vs-10250: leaf_paste_entries: directory item corrupted (%d %d)\n", prev, deh[i].deh_location);
+    }
+  }
+#endif
+
+}
+
+
+
Index: empeg/kernel/fs/reiserfs/lock.c
diff -u /dev/null empeg/kernel/fs/reiserfs/lock.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/lock.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,86 @@
+/*
+ * Copyright 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
+ */
+#ifdef __KERNEL__
+
+#include <linux/reiserfs_fs.h>
+#include <linux/fs.h>
+#include <linux/malloc.h>
+#include <linux/sched.h>
+
+#else
+
+#include "nokernel.h"
+
+#endif
+
+/* This is a modification of the lock_buffer code that takes an
+   arbitrary lock ulong, bitnumber and wait queue pointer rather than
+   being buffer_head specific.  (Undoubtedly one of the SMP guys is
+   writting something that will replace this but it was not in the
+   code that I have seen.)  Note that lock_buffer has buffer specific
+   stuff that this does not do and so this cannot replace that code.
+   If someone writes bitops for shorts I'll write this for shorts.
+   -Hans */
+
+int __wait_on_ulong_lock(unsigned long *, unsigned short, struct  wait_queue **);
+extern inline int wait_on_ulong_lock( unsigned long *, unsigned short, struct  wait_queue **);
+inline int ulong_lock_locked(unsigned long *, unsigned short);
+void unlock_ulong_lock(unsigned long *, unsigned short, struct  wait_queue **);
+
+inline int lock_ulong_lock(unsigned long * lock, unsigned short bitnumber, struct  wait_queue ** l_wait)
+{
+  int repeat = 0;
+
+  if (test_and_set_bit(bitnumber, lock))
+    repeat = __wait_on_ulong_lock(lock, bitnumber, l_wait);
+  return repeat;
+}
+
+extern inline int wait_on_ulong_lock( unsigned long * lock, unsigned short bitnumber, struct  wait_queue ** l_wait)
+{
+  if (ulong_lock_locked(lock, bitnumber))
+    {
+      __wait_on_ulong_lock(lock, bitnumber, l_wait);
+      return 1;
+    }
+  return 0;
+}
+
+/* return whether it was able to give you the lock.  Note that it does
+   not wait on the lock, and it is used where schedule is a no-no and not
+   getting the lock is okay. */
+inline int try_ulong_lock(unsigned long * lock, unsigned short bitnumber)
+{
+  return (!test_and_set_bit(bitnumber, lock));
+}
+
+int __wait_on_ulong_lock(unsigned long * lock, unsigned short bitnumber, struct  wait_queue ** l_wait) 
+{
+  struct wait_queue wait = { current, NULL };
+  int repeat = 0;
+
+  add_wait_queue(l_wait, &wait);
+loop:
+  current->state = TASK_UNINTERRUPTIBLE;
+  if (!try_ulong_lock(lock, bitnumber)) {
+    current->policy |= SCHED_YIELD;
+    schedule();
+    repeat = 1;
+    goto loop;
+  }
+  remove_wait_queue(l_wait, &wait);
+  current->state = TASK_RUNNING;
+  return repeat;
+}
+
+inline int ulong_lock_locked(unsigned long * lock, unsigned short bitnumber)
+{
+  return test_bit(bitnumber, lock);
+}
+
+void unlock_ulong_lock(unsigned long * lock, unsigned short bitnumber, struct  wait_queue ** l_wait)
+{
+  if (test_and_clear_bit(bitnumber, lock))      
+    wake_up(l_wait);
+}
Index: empeg/kernel/fs/reiserfs/namei.c
diff -u /dev/null empeg/kernel/fs/reiserfs/namei.c:1.2
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/namei.c	Fri Oct 20 16:48:40 2000
@@ -0,0 +1,1215 @@
+/*
+ * Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
+ */
+#ifdef __KERNEL__
+
+#include <linux/sched.h>
+#include <linux/reiserfs_fs.h>
+
+#else
+
+#include "nokernel.h"
+
+#endif
+
+
+
+#define MAX_GEN_NUMBER  127
+
+
+#define SET_GENERATION_NUMBER(offset,gen_number) (GET_HASH_VALUE(offset)|(gen_number))
+
+
+int bin_search_in_dir_item (struct item_head * ih, struct reiserfs_de_head * deh, struct key * key, int * pos_in_item)
+{
+  int rbound, lbound, j;
+
+  lbound = 0;
+  rbound = I_ENTRY_COUNT (ih) - 1;
+
+  for (j = (rbound + lbound) / 2; lbound <= rbound; j = (rbound + lbound) / 2) {
+    if (key->k_offset < deh[j].deh_offset) {
+      rbound = j - 1;
+      continue;
+    }
+    if (key->k_offset > deh[j].deh_offset) {
+      lbound = j + 1;
+      continue;
+    }
+    /* key found */
+    *pos_in_item = j;
+    return POSITION_FOUND;
+  }
+
+  *pos_in_item = lbound;
+  return POSITION_NOT_FOUND;
+}
+
+
+/* first calls search_by_key, then, if item is not found looks for the entry inside directory item indicated by
+   search_by_key. (We assign a key to each directory item, and place multiple entries in a single directory item.)
+   Fills the path to the entry, and to the entry position in the item */
+int search_by_entry_key (struct super_block * sb, struct key * key, struct path * path, int * pos_in_item, int * repeat)
+{
+  /* search for a directory item using key of entry */
+  if (search_by_key (sb, key, path, repeat, DISK_LEAF_NODE_LEVEL, READ_BLOCKS) == ITEM_FOUND) {
+    *pos_in_item = 0;
+    return POSITION_FOUND;
+  }
+#ifdef REISERFS_CHECK
+  if (!PATH_LAST_POSITION (path))
+    reiserfs_panic (sb, "vs-7000: search_by_entry_key: search_by_key returned item position == 0");
+#endif /* REISERFS_CHECK */
+  PATH_LAST_POSITION (path) --;
+
+#ifdef REISERFS_CHECK
+  {
+    struct item_head * ih = B_N_PITEM_HEAD (PATH_PLAST_BUFFER (path), PATH_LAST_POSITION (path));
+
+    if (!I_IS_DIRECTORY_ITEM (ih) || COMP_SHORT_KEYS (&(ih->ih_key), key)) {
+      print_block (PATH_PLAST_BUFFER (path), 0, -1, -1);
+      reiserfs_panic (sb, "vs-7005: search_by_entry_key: found item %h is not directory item or "
+		      "does not belong to the same directory as key %k", ih, key);
+    }
+  }
+#endif /* REISERFS_CHECK */
+
+  /* binary search in directory item by third component of the key */
+  return bin_search_in_dir_item (PATH_PITEM_HEAD (path), B_I_DEH (PATH_PLAST_BUFFER (path), PATH_PITEM_HEAD (path)), key, pos_in_item);
+}
+
+
+
+/* Keyed 32-bit hash function using TEA in a Davis-Meyer function */
+static unsigned long get_third_component (const char * name, int len)
+{
+  unsigned long res;
+
+  if (!len || (len == 1 && name[0] == '.'))
+    return DOT_OFFSET;
+  if (len == 2 && name[0] == '.' && name[1] == '.')
+    return DOT_DOT_OFFSET;
+
+  res = keyed_hash (name, len);
+  res = GET_HASH_VALUE(res);
+  if (res == 0)
+    res = 128;
+  return res + MAX_GEN_NUMBER;
+}
+
+
+/* fills the structure with various parameters of directory entry,
+   including key of the pointed object */
+static void get_entry_attributes (struct reiserfs_dir_entry * de, int entry_num)
+{
+#ifdef REISERFS_CHECK
+  if (I_ENTRY_COUNT (de->de_ih) < entry_num)
+    reiserfs_panic (0, "yr-7006: get_entry_attributes: no such entry (%d-th) in the item (%d)",
+		    entry_num, I_ENTRY_COUNT (de->de_ih));
+  if (de->de_deh != B_I_DEH (de->de_bh, de->de_ih) + entry_num)
+    reiserfs_panic (0, "yr-7008: get_entry_attributes: dir entry header not found");
+    
+#endif /* REISERFS_CHECK */
+
+  /* few fields are set already (de_bh, de_item_num, de_deh) */
+  de->de_entrylen = I_DEH_N_ENTRY_LENGTH (de->de_ih, de->de_deh, entry_num);
+  de->de_namelen = de->de_entrylen - (de_with_sd (de->de_deh) ? SD_SIZE : 0);
+
+  de->de_name = B_I_PITEM (de->de_bh, de->de_ih) + de->de_deh->deh_location;
+
+#ifdef REISERFS_ALIGNED
+  if ( de->de_name[ de->de_namelen-1 ] == '\0' )
+      de->de_namelen = strlen(de->de_name);
+#endif
+
+  /* key of object pointed by entry */
+  de->de_dir_id = de->de_deh->deh_dir_id;
+  de->de_objectid = de->de_deh->deh_objectid;
+
+  /* key of the entry */
+  memcpy (&(de->de_entry_key.k_dir_id), &(de->de_ih->ih_key), SHORT_KEY_SIZE);
+  de->de_entry_key.k_offset = de->de_deh->deh_offset;
+  de->de_entry_key.k_uniqueness = DIRENTRY_UNIQUENESS;
+
+}
+
+
+static int try_name (struct reiserfs_dir_entry * de, 
+		     const char * name,
+		     int          namelen)
+{
+  int retval = POSITION_NOT_FOUND;
+
+  if ((namelen == de->de_namelen) &&
+      !memcmp(de->de_name, name, de->de_namelen))
+    retval = de_visible (de->de_deh) ? POSITION_FOUND : POSITION_FOUND_INVISIBLE;
+
+  return retval;
+}
+
+
+/* after this function de_entry_num is set correctly only if name
+   found or there was no entries with given hash value */
+static int linear_search_in_dir_item (struct key * key, struct reiserfs_dir_entry * de, const char * name, int namelen)
+{
+  int retval;
+  int i;
+
+  i = de->de_entry_num;
+
+  if (i == I_ENTRY_COUNT (de->de_ih) ||
+      GET_HASH_VALUE (de->de_deh[i].deh_offset) != GET_HASH_VALUE (key->k_offset)) {
+    i --;
+  }
+
+#ifdef REISERFS_CHECK
+  if (de->de_deh != B_I_DEH (de->de_bh, de->de_ih))
+    reiserfs_panic (0, "vs-7010: linear_search_in_dir_item: array of entry headers not found");
+#endif /* REISERFS_CHECK */
+
+  de->de_deh += i;
+
+  for (; i >= 0; i --, de->de_deh --) {
+    if (GET_HASH_VALUE (de->de_deh->deh_offset) != GET_HASH_VALUE (key->k_offset)) {
+      return POSITION_NOT_FOUND;
+    }
+   
+    /* mark, that this generation number is used */
+    if (de->de_gen_number_bit_string)
+      set_bit (GET_GENERATION_NUMBER (de->de_deh->deh_offset), de->de_gen_number_bit_string);
+    
+    /* de_bh, de_item_num, de_ih, de_deh are already set. Set others fields */
+    get_entry_attributes (de, i);
+    if ((retval = try_name (de, name, namelen)) != POSITION_NOT_FOUND) {
+      de->de_entry_num = i;
+      return retval;
+    }
+  }
+
+  if (GET_GENERATION_NUMBER (de->de_ih->ih_key.k_offset) == 0)
+    return POSITION_NOT_FOUND;
+
+#ifdef REISERFS_CHECK
+  if (de->de_ih->ih_key.k_offset <= DOT_DOT_OFFSET || de->de_item_num != 0)
+    reiserfs_panic (0, "vs-7015: linear_search_in_dir_item: item must be 0-th item in block (%d)", de->de_item_num);
+#endif /* REISERFS_CHECK */
+
+  return GOTO_PREVIOUS_ITEM;
+}
+
+
+static int reiserfs_find_entry (struct inode * dir, const char * name, int namelen, struct path * path_to_entry, struct reiserfs_dir_entry * de)
+{
+  struct key key_to_search;
+  int repeat;
+  int retval;
+
+  if (!dir || !dir->i_sb)
+    return POSITION_NOT_FOUND;
+
+  if ((unsigned int)namelen > REISERFS_MAX_NAME_LEN (dir->i_sb->s_blocksize))
+    return POSITION_NOT_FOUND;
+
+  /* there are no entries having the same third component of key, so
+     fourth key component is not used */
+  copy_key (&key_to_search, INODE_PKEY (dir));
+  key_to_search.k_offset = get_third_component (name, namelen);
+  key_to_search.k_uniqueness = DIRENTRY_UNIQUENESS;
+
+  while (1) {
+    /* search for a directory item using the formed key */
+    if (search_by_key (dir->i_sb, &key_to_search, path_to_entry, &repeat, DISK_LEAF_NODE_LEVEL, READ_BLOCKS) == ITEM_NOT_FOUND) {
+      /* take previous item */
+#ifdef REISERFS_CHECK
+      if (!PATH_LAST_POSITION (path_to_entry))
+	reiserfs_panic (dir->i_sb, "vs-7010: reiserfs_find_entry: search_by_key returned bad position == 0");
+#endif /* REISERFS_CHECK */
+      PATH_LAST_POSITION (path_to_entry) --;
+    }
+    
+    de->de_bh = PATH_PLAST_BUFFER (path_to_entry);
+    de->de_item_num = PATH_LAST_POSITION (path_to_entry);
+    de->de_ih = B_N_PITEM_HEAD (de->de_bh, de->de_item_num);
+    de->de_deh = B_I_DEH (de->de_bh, de->de_ih);
+
+#ifdef REISERFS_CHECK
+    if (!I_IS_DIRECTORY_ITEM (de->de_ih) || COMP_SHORT_KEYS (&(de->de_ih->ih_key), INODE_PKEY (dir)))
+      reiserfs_panic (dir->i_sb, "vs-7020: reiserfs_find_entry: item must be an item of the same directory item as inode");
+#endif /* REISERFS_CHECK */
+
+    /* we do not check whether bin_search_in_dir_item found the given key, even if so, we still have
+       to compare names */
+    bin_search_in_dir_item (de->de_ih, de->de_deh, &key_to_search, &(de->de_entry_num));
+
+    /* compare names for all entries having given hash value */
+    retval = linear_search_in_dir_item (&key_to_search, de, name, namelen);
+    if (retval != GOTO_PREVIOUS_ITEM)
+      /* there is no need to scan directory anymore. Given entry found or does not exist */
+      return retval;
+
+    /* there is left neighboring item of this directory and given entry can be there */
+    key_to_search.k_offset = de->de_ih->ih_key.k_offset - 1;
+    pathrelse (path_to_entry);
+
+  } /* while (1) */
+}
+
+
+/* add entry to the directory (entry can be hidden). Does not mark dir
+   inode dirty, do it after successesfull call to it */
+static int reiserfs_add_entry (struct reiserfs_transaction_handle *th, struct inode * dir, 
+                               const char * name, int namelen, struct key * object_key, struct reiserfs_dir_entry * de,
+			       int visible
+			       )
+{
+  struct key entry_key;
+  char * buffer;
+  int buflen;
+  struct reiserfs_de_head * deh;
+  struct path path;
+  char bit_string [MAX_GEN_NUMBER / 8 + 1];
+  int gen_number;
+  int repeat;
+#ifdef REISERFS_ALIGNED
+  int aligned_namelen = (namelen+3) & ~3;
+#endif
+
+  init_path (&path);
+
+  if (!dir || !dir->i_sb)
+    return -ENOENT;
+
+  if ((unsigned int)namelen > REISERFS_MAX_NAME_LEN (dir->i_sb->s_blocksize))
+    return -ENAMETOOLONG;
+
+  /* each entry has unique key. compose it */
+  copy_key (&entry_key, INODE_PKEY(dir));
+  entry_key.k_offset = get_third_component (name, namelen);
+  entry_key.k_uniqueness = DIRENTRY_UNIQUENESS;
+
+  /* get memory for composing the entry */
+#ifdef REISERFS_ALIGNED
+  buflen = DEH_SIZE + aligned_namelen;
+#else
+  buflen = DEH_SIZE + namelen;
+#endif
+  buffer = reiserfs_kmalloc (buflen, GFP_KERNEL, dir->i_sb);
+  if (buffer == 0)
+    return -ENOMEM;
+
+  /* fill buffer : directory entry head, name[, dir objectid | , stat data | ,stat data, dir objectid ] */
+  deh = (struct reiserfs_de_head *)buffer;
+  deh->deh_location = 0;
+  deh->deh_offset = entry_key.k_offset;
+  deh->deh_state = 0;
+  /* put key (ino analog) to de */
+  deh->deh_dir_id = object_key->k_dir_id;
+  deh->deh_objectid = object_key->k_objectid;
+
+  /* copy name */
+#ifdef REISERFS_ALIGNED
+  memset( (char*)(deh+1), '\0', aligned_namelen );
+#endif
+  memcpy ((char *)(deh + 1), name, namelen);
+
+  /* entry is ready to be pasted into tree, set 'visibility' and 'stat data in entry' attributes */
+  mark_de_without_sd (deh);
+  visible ? mark_de_visible (deh) : mark_de_hidden (deh);
+
+  /* find the proper place for the new entry */
+  memset (bit_string, 0, sizeof (bit_string));
+  de->de_gen_number_bit_string = bit_string;
+  if (reiserfs_find_entry (dir, name, namelen, &path, de) == POSITION_FOUND) {
+    reiserfs_panic (dir->i_sb, "vs-7030: reiserfs_add_entry: entry with this key %k already exists",
+		    &entry_key);
+  }
+
+  if (find_first_nonzero_bit (bit_string, MAX_GEN_NUMBER + 1) < MAX_GEN_NUMBER + 1) {
+    /* there are few names with given hash value */
+    gen_number = find_first_zero_bit (bit_string, MAX_GEN_NUMBER + 1);
+    if (gen_number > MAX_GEN_NUMBER) {
+      /* there is no free generation number */
+      reiserfs_kfree (buffer, buflen, dir->i_sb);
+      pathrelse (&path);
+      return -EHASHCOLLISION;
+    }
+    /* adjust offset of directory enrty */
+    deh->deh_offset = SET_GENERATION_NUMBER (deh->deh_offset, gen_number);
+    entry_key.k_offset = deh->deh_offset;
+
+    /* find place for new entry */
+    if (search_by_entry_key (dir->i_sb, &entry_key, &path, &(de->de_entry_num), &repeat)) {
+      reiserfs_panic (dir->i_sb, "reiserfs_add_entry: 7032: entry with this key (%k) already exists", &entry_key);
+    }
+  } else {
+    deh->deh_offset = SET_GENERATION_NUMBER (deh->deh_offset, 0);
+    entry_key.k_offset = deh->deh_offset;    
+  }
+  
+  /* perform the insertion of the entry that we have prepared */
+  if (reiserfs_paste_into_item (th, dir->i_sb, &path, &(de->de_entry_num), &entry_key, buffer, 
+                                buflen, REISERFS_KERNEL_MEM, 0) == -1) {
+    reiserfs_kfree (buffer, buflen, dir->i_sb);
+    return -ENOSPC;
+  }
+
+  reiserfs_kfree (buffer, buflen, dir->i_sb);
+  dir->i_size += buflen;
+  dir->i_mtime = dir->i_ctime = CURRENT_TIME;
+
+  return 0;
+}
+
+
+struct dentry * reiserfs_lookup (struct inode * dir, struct dentry * dentry)
+{
+  struct inode * inode = 0;
+  struct reiserfs_dir_entry de;
+  struct path path_to_entry;
+  int error;
+
+  init_path (&path_to_entry);
+
+  de.de_gen_number_bit_string = 0;
+  error = reiserfs_find_entry (dir, dentry->d_name.name, dentry->d_name.len, &path_to_entry, &de);
+  pathrelse (&path_to_entry);
+  if (error == POSITION_FOUND) {
+    inode = reiserfs_iget (dir->i_sb, (struct key *)&(de.de_dir_id));
+    if (!inode)
+      return ERR_PTR(-EACCES);
+  }
+
+  d_add(dentry, inode);
+  return NULL;
+}
+
+
+int reiserfs_create (struct inode * dir, struct dentry *dentry, int mode)
+{
+  int error;
+  struct inode * inode;
+  struct reiserfs_dir_entry de;
+  int windex ;
+  int jbegin_count = JOURNAL_PER_BALANCE_CNT * 2 ;
+  struct reiserfs_transaction_handle th ;
+  int err;
+	
+  if (!dir)
+    return -ENOENT;
+	
+  inode = get_empty_inode() ;
+  if (!inode) {
+    return -ENOSPC ;
+  }
+  journal_begin(&th, dir->i_sb, jbegin_count) ;
+  th.t_caller = "create" ;
+  windex = push_journal_writer("reiserfs_create") ;
+  inode = reiserfs_new_inode (&th, dir, mode, 0, dentry, inode, &err);
+  if (!inode) {
+    pop_journal_writer(windex) ;
+    journal_end(&th, dir->i_sb, jbegin_count) ;
+    return err;
+  }
+  reiserfs_update_inode_transaction(inode) ;
+  reiserfs_update_inode_transaction(dir) ;
+	
+  inode->i_op = &reiserfs_file_inode_operations;
+  inode->i_mode = mode;
+
+  error = reiserfs_add_entry (&th, dir, dentry->d_name.name, dentry->d_name.len, INODE_PKEY (inode), &de, 1);
+  if (error) {
+    inode->i_nlink--;
+    if_in_ram_update_sd (&th, inode);
+    pop_journal_writer(windex) ;
+    journal_end(&th, dir->i_sb, jbegin_count) ;
+    iput (inode);
+    return error;
+  }
+  if_in_ram_update_sd (&th, dir); 
+  d_instantiate(dentry, inode);
+  pop_journal_writer(windex) ;
+  journal_end(&th, dir->i_sb, jbegin_count) ;
+  return 0;
+}
+
+
+int reiserfs_mknod (struct inode * dir, struct dentry *dentry, int mode, int rdev)
+{
+  int error;
+  struct inode * inode;
+  struct path path_to_entry;
+  struct reiserfs_dir_entry de;
+  int windex ;
+  struct reiserfs_transaction_handle th ;
+  int jbegin_count = JOURNAL_PER_BALANCE_CNT * 3; 
+  int err;
+
+  if (!dir)
+    return -ENOENT;
+
+  init_path (&path_to_entry);
+
+  inode = get_empty_inode() ;
+  if (!inode) {
+    return -ENOSPC ;
+  }
+  journal_begin(&th, dir->i_sb, jbegin_count) ;
+  windex = push_journal_writer("reiserfs_mknod") ;
+  de.de_gen_number_bit_string = 0;
+  if (reiserfs_find_entry (dir, dentry->d_name.name, dentry->d_name.len, &path_to_entry, &de) == POSITION_FOUND) {
+    pathrelse ( &path_to_entry);
+    pop_journal_writer(windex) ;
+    journal_end(&th, dir->i_sb, jbegin_count) ;
+    iput(inode) ;
+    return -EEXIST;
+  }
+
+  pathrelse ( &path_to_entry);
+
+  inode = reiserfs_new_inode (&th, dir, mode, 0, dentry, inode, &err);
+  if (!inode) {
+    pop_journal_writer(windex) ;
+    journal_end(&th, dir->i_sb, jbegin_count) ;
+    return err;
+  }
+  reiserfs_update_inode_transaction(inode) ;
+  reiserfs_update_inode_transaction(dir) ;
+
+  inode->i_uid = current->fsuid;
+  inode->i_mode = mode;
+  inode->i_op = NULL;
+
+  if (S_ISREG(inode->i_mode))
+    inode->i_op = &reiserfs_file_inode_operations;
+  else if (S_ISDIR(inode->i_mode)) {
+    inode->i_op = &reiserfs_dir_inode_operations;
+    if (dir->i_mode & S_ISGID)
+      inode->i_mode |= S_ISGID;
+  }
+  else if (S_ISLNK(inode->i_mode))
+    inode->i_op = &reiserfs_symlink_inode_operations;
+  else if (S_ISCHR(inode->i_mode))
+    inode->i_op = &chrdev_inode_operations;
+  else if (S_ISBLK(inode->i_mode))
+    inode->i_op = &blkdev_inode_operations;
+  else if (S_ISFIFO(inode->i_mode))
+    init_fifo(inode);
+  if (S_ISBLK(mode) || S_ISCHR(mode))
+    inode->i_rdev = to_kdev_t(rdev);
+
+  if_in_ram_update_sd (&th, inode);
+
+  error = reiserfs_add_entry (&th, dir, dentry->d_name.name, dentry->d_name.len, INODE_PKEY (inode), &de, 1);
+  if (error) {
+    inode->i_nlink--;
+    if_in_ram_update_sd (&th, inode);
+    pop_journal_writer(windex) ;
+    journal_end(&th, dir->i_sb, jbegin_count) ;
+    iput (inode);
+    return error;
+  }
+  if_in_ram_update_sd (&th, dir);
+  d_instantiate(dentry, inode);
+  pop_journal_writer(windex) ;
+  journal_end(&th, dir->i_sb, jbegin_count) ;
+  return 0;
+}
+
+
+int reiserfs_mkdir (struct inode * dir, struct dentry *dentry, int mode)
+{
+  int error;
+  struct inode * inode;
+  struct path path_to_entry;
+  struct reiserfs_dir_entry de;
+  int windex ;
+  struct reiserfs_transaction_handle th ;
+  int jbegin_count = JOURNAL_PER_BALANCE_CNT * 3; 
+  int err;
+
+
+  init_path (&path_to_entry);
+  if (!dir || !dir->i_sb) {
+    return -EINVAL;
+  }
+  inode = get_empty_inode() ;
+  if (!inode) {
+    return -ENOSPC ;
+  }
+
+  journal_begin(&th, dir->i_sb, jbegin_count) ;
+  windex = push_journal_writer("reiserfs_mkdir") ;
+  de.de_gen_number_bit_string = 0;
+  if (reiserfs_find_entry (dir, dentry->d_name.name, dentry->d_name.len, &path_to_entry, &de) == POSITION_FOUND) {
+    pathrelse (&path_to_entry);
+    pop_journal_writer(windex) ;
+    journal_end(&th, dir->i_sb, jbegin_count) ;
+    iput(inode) ;
+    return -EEXIST;
+  }
+  pathrelse (&path_to_entry);
+  
+  if (dir->i_nlink >= REISERFS_LINK_MAX) {
+    pop_journal_writer(windex) ;
+    journal_end(&th, dir->i_sb, jbegin_count) ;
+    iput(inode) ;
+    return -EMLINK;
+  }
+  
+  mode = S_IFDIR | (mode & 0777 & ~current->fs->umask);
+  if (dir->i_mode & S_ISGID)
+    mode |= S_ISGID;
+  inode = reiserfs_new_inode (&th, dir, mode, 0, dentry, inode, &err);
+  if (!inode) {
+    pop_journal_writer(windex) ;
+    journal_end(&th, dir->i_sb, jbegin_count) ;
+    return err;
+  }
+  reiserfs_update_inode_transaction(inode) ;
+  reiserfs_update_inode_transaction(dir) ;
+
+  inode->i_op = &reiserfs_dir_inode_operations;
+
+  /* new inode and stat data are uptodate. Inode is clean. */
+  error = reiserfs_add_entry (&th, dir, dentry->d_name.name, dentry->d_name.len, INODE_PKEY (inode), &de, 1);
+  if (error) {
+    inode->i_nlink = 0;
+    if_in_ram_update_sd (&th, inode);
+    pop_journal_writer(windex) ;
+    journal_end(&th, dir->i_sb, jbegin_count) ;
+    iput (inode);
+    return error;
+  }
+
+  /* update dir inode, reiserfs_add_entry does not do that */
+  dir->i_nlink ++;
+  if_in_ram_update_sd (&th, dir);
+  d_instantiate(dentry, inode);
+  pop_journal_writer(windex) ;
+  journal_end(&th, dir->i_sb, jbegin_count) ;
+  return 0;
+}
+
+
+static int reiserfs_empty_dir(struct inode * inode)
+{
+  return inode->i_size == EMPTY_DIR_SIZE;
+}
+
+
+int rmdir_not_allowed (struct inode * dir, struct reiserfs_dir_entry * de, struct inode * inode)
+{
+  if ((dir->i_mode & S_ISVTX) && !fsuser() &&
+      current->fsuid != inode->i_uid &&
+      current->fsuid != dir->i_uid)
+    return -EPERM;
+
+  if (inode->i_dev != dir->i_dev)
+    return -EPERM;
+
+  if (inode == dir)	/* we may not delete ".", but "../dir" is ok */
+    return -EPERM;
+
+  if (!S_ISDIR(inode->i_mode))
+    return -ENOTDIR;
+
+  if (!reiserfs_empty_dir(inode))
+    return -ENOTEMPTY;
+
+  if (de->de_objectid != inode->i_ino)
+    return -ENOENT;
+
+  return 0;
+}
+
+
+int reiserfs_rmdir (struct inode * dir, struct dentry *dentry)
+{
+  struct inode * inode;
+  int retval;
+  struct reiserfs_dir_entry de;
+  struct path path;
+  struct super_block *s ;
+  int windex ;
+  struct reiserfs_transaction_handle th ;
+  int jbegin_count = JOURNAL_PER_BALANCE_CNT * 3; 
+
+  init_path (&path);
+
+  retval = -ENOENT;
+  de.de_gen_number_bit_string = 0;
+  journal_begin(&th, dir->i_sb, jbegin_count) ;
+  windex = push_journal_writer("reiesrfs_rmdir") ;
+  if (reiserfs_find_entry (dir, dentry->d_name.name, dentry->d_name.len, &path, &de) == POSITION_NOT_FOUND)
+    goto end_rmdir;
+
+  inode = dentry->d_inode;
+
+  /* we don't need call this so early here, I'm just being cautious */
+  reiserfs_update_inode_transaction(inode) ;
+  reiserfs_update_inode_transaction(dir) ;
+
+  retval = rmdir_not_allowed (dir, &de, inode);
+  if (retval)
+    goto end_rmdir;
+
+  /* free preserve list if we should */
+/*  maybe_free_preserve_list (dir->i_sb);*/
+
+  if (!reiserfs_empty_dir (inode))
+    retval = -ENOTEMPTY;
+  else {
+    /* cut entry from dir directory */
+    if (reiserfs_cut_from_item (&th, dir, dir->i_sb, &path, &(de.de_entry_num), &(de.de_entry_key), 0, NOTHING_SPECIAL) == 0) {
+      retval = -ENOENT;
+    }
+  }
+  if (retval)
+    goto end_rmdir;
+
+  if (inode->i_nlink != 2)
+    printk ("reiserfs_rmdir: empty directory has nlink != 2 (%d)\n", inode->i_nlink);
+  inode->i_nlink = 0;
+  inode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;
+  if_in_ram_update_sd (&th, inode);
+  dir->i_nlink --;
+  dir->i_size -= (DEH_SIZE + de.de_entrylen);
+  if_in_ram_update_sd (&th, dir);
+
+  s = dir->i_sb ;
+  pop_journal_writer(windex) ;
+  journal_end(&th, s, jbegin_count) ;
+  d_delete(dentry); /* note, we've moved this after the journal end */
+  return 0;
+	
+end_rmdir:
+  /* we must release path, because we did not call reiserfs_cut_from_item, or reiserfs_cut_from_item
+     does not release path if operation was not complete */
+  pathrelse (&path);
+  pop_journal_writer(windex) ;
+  journal_end(&th, dir->i_sb, jbegin_count) ;
+  return retval;	
+}
+
+
+int reiserfs_unlink (struct inode * dir, struct dentry *dentry)
+{
+  int retval;
+  struct inode * inode;
+  struct reiserfs_dir_entry de;
+  struct path path;
+  int windex ;
+  int call_journal_end = 1 ;
+  struct reiserfs_transaction_handle th ;
+  int jbegin_count = JOURNAL_PER_BALANCE_CNT * 3; 
+
+  init_path (&path);
+
+  retval = -ENOENT;
+	
+  journal_begin(&th, dir->i_sb, jbegin_count) ;
+  windex = push_journal_writer("reiserfs_unlink") ;
+  /* free preserve list if we should */
+/*  maybe_free_preserve_list (dir->i_sb);*/
+	
+  de.de_gen_number_bit_string = 0;
+  if (reiserfs_find_entry (dir, dentry->d_name.name, dentry->d_name.len, &path, &de) == POSITION_NOT_FOUND) {
+    goto end_unlink;
+  }
+
+  inode = dentry->d_inode;
+
+  reiserfs_update_inode_transaction(inode) ;
+  reiserfs_update_inode_transaction(dir) ;
+
+  retval = -EPERM;
+  if (S_ISDIR (inode->i_mode)) {
+    goto end_unlink;
+  }
+  if ((dir->i_mode & S_ISVTX) && !fsuser() &&
+      current->fsuid != inode->i_uid &&
+      current->fsuid != dir->i_uid) {
+    goto end_unlink;
+  }
+
+  retval = -ENOENT;
+  if (comp_short_keys ((struct key *)&(de.de_dir_id), INODE_PKEY (inode))) {
+    goto end_unlink;
+  }
+  
+  if (!inode->i_nlink) {
+    printk("reiserfs_unlink: deleting nonexistent file (%s:%lu), %d\n",
+	   kdevname(inode->i_dev), inode->i_ino, inode->i_nlink);
+    inode->i_nlink = 1;
+  }
+  if (reiserfs_cut_from_item (&th, dir, dir->i_sb, &path, &(de.de_entry_num), &(de.de_entry_key), 0, NOTHING_SPECIAL) == 0) {
+    retval = -ENOENT;
+    goto end_unlink;
+  }
+
+  inode->i_nlink--;
+  inode->i_ctime = CURRENT_TIME;
+  if_in_ram_update_sd (&th, inode);
+
+  dir->i_size -= (de.de_entrylen + DEH_SIZE);
+  dir->i_ctime = dir->i_mtime = CURRENT_TIME;
+  if_in_ram_update_sd (&th, dir) ;
+  pop_journal_writer(windex) ;
+  journal_end(&th, dir->i_sb, jbegin_count) ;
+  call_journal_end = 0 ;
+  d_delete(dentry); 
+  retval = 0;
+
+end_unlink:
+  pathrelse (&path);
+  pop_journal_writer(windex) ;
+  if (call_journal_end) 
+    journal_end(&th, dir->i_sb, jbegin_count) ;
+  return retval;
+}
+
+
+int reiserfs_symlink (struct inode * dir, struct dentry * dentry, const char * symname)
+{
+  struct inode * inode;
+  struct path path_to_entry;
+  struct reiserfs_dir_entry de;
+  int error;
+  int windex ;
+  struct reiserfs_transaction_handle th ;
+  int jbegin_count = JOURNAL_PER_BALANCE_CNT * 3; 
+  int err;
+
+  init_path (&path_to_entry);
+  if (strlen (symname) + 1 + SD_SIZE > MAX_ITEM_LEN (dir->i_sb->s_blocksize)) {
+    return -ENAMETOOLONG;
+  }
+  inode = get_empty_inode() ;
+  if (!inode) {
+    return -ENOSPC ;
+  }
+ 
+  journal_begin(&th, dir->i_sb, jbegin_count) ;
+  windex = push_journal_writer("reiserfs_symlink") ;
+  inode = reiserfs_new_inode (&th, dir, S_IFLNK, symname, dentry, inode, &err);
+  if (inode == 0) {
+    pop_journal_writer(windex) ;
+    journal_end(&th, dir->i_sb, jbegin_count) ;
+    return err;
+  }
+  reiserfs_update_inode_transaction(inode) ;
+  reiserfs_update_inode_transaction(dir) ;
+
+  inode->i_op = &reiserfs_symlink_inode_operations;
+  inode->i_size = strlen (symname);
+  inode->i_mode = S_IFLNK | 0777;
+  if_in_ram_update_sd (&th, inode);
+
+  de.de_gen_number_bit_string = 0;
+  if (reiserfs_find_entry (dir, dentry->d_name.name, dentry->d_name.len, &path_to_entry, &de) == POSITION_FOUND) {
+    pathrelse (&path_to_entry);
+    inode->i_nlink--;
+    if_in_ram_update_sd (&th, inode);
+    pop_journal_writer(windex) ;
+    journal_end(&th, dir->i_sb, jbegin_count) ;
+    iput (inode);
+    return -EEXIST;
+  }
+  pathrelse (&path_to_entry);
+
+  error = reiserfs_add_entry (&th, dir, dentry->d_name.name, dentry->d_name.len, INODE_PKEY (inode), &de, 1);
+  if (error) {
+    inode->i_nlink--;
+    if_in_ram_update_sd (&th, inode);
+    pop_journal_writer(windex) ;
+    journal_end(&th, dir->i_sb, jbegin_count) ;
+    iput (inode);
+    return error;
+  }
+  if_in_ram_update_sd (&th, dir);
+  d_instantiate(dentry, inode);
+  pop_journal_writer(windex) ;
+  journal_end(&th, dir->i_sb, jbegin_count) ;
+  return 0;
+}
+
+
+int reiserfs_link (struct dentry * old_dentry, struct inode * dir, struct dentry * dentry)
+{
+  struct inode *inode = old_dentry->d_inode;
+  struct path path_to_entry;
+  struct reiserfs_dir_entry de;
+  int error;
+  int windex ;
+  struct reiserfs_transaction_handle th ;
+  int jbegin_count = JOURNAL_PER_BALANCE_CNT * 3; 
+  
+  init_path (&path_to_entry);
+
+  /* object must not be directory */
+  if (S_ISDIR(inode->i_mode)) {
+    return -EPERM;
+  }
+  
+  /* file has too many links */
+  if (inode->i_nlink >= REISERFS_LINK_MAX) {
+    return -EMLINK;
+  }
+
+  journal_begin(&th, dir->i_sb, jbegin_count) ;
+  windex = push_journal_writer("reiserfs_link") ;
+
+  reiserfs_update_inode_transaction(inode) ;
+  reiserfs_update_inode_transaction(dir) ;
+
+  de.de_gen_number_bit_string = 0;
+  if (reiserfs_find_entry (dir, dentry->d_name.name, dentry->d_name.len, &path_to_entry, &de) == POSITION_FOUND) {
+    pathrelse (&path_to_entry);
+    pop_journal_writer(windex) ;
+    journal_end(&th, dir->i_sb, jbegin_count) ;
+    return -EEXIST;
+  }
+  
+  pathrelse (&path_to_entry);
+
+  /* free preserve list if we should */
+/*  maybe_free_preserve_list (dir->i_sb);*/
+
+  /* create new entry */
+  error = reiserfs_add_entry (&th, dir, dentry->d_name.name, dentry->d_name.len, INODE_PKEY (inode), &de, 1);
+  if (error) {
+    pop_journal_writer(windex) ;
+    journal_end(&th, dir->i_sb, jbegin_count) ;
+    return error;
+  }
+  inode->i_nlink++;
+  inode->i_ctime = CURRENT_TIME;
+  if_in_ram_update_sd (&th, inode);
+  if_in_ram_update_sd (&th, dir);
+  inode->i_count++;
+  d_instantiate(dentry, inode);
+  pop_journal_writer(windex) ;
+  journal_end(&th, dir->i_sb, jbegin_count) ;
+  return 0;
+}
+
+
+static int de_still_valid (const char * name, int len, struct reiserfs_dir_entry * de)
+{
+  struct item_head * ih;
+  struct reiserfs_de_head * deh;
+
+  if (!de || !de->de_bh)
+    return 0;
+
+  deh = B_I_DEH (de->de_bh, ih = B_N_PITEM_HEAD (de->de_bh, de->de_item_num));
+  /* compare dir entry headers, record loacation and names */
+  if (memcmp (&(deh[de->de_entry_num]), de->de_deh, DEH_SIZE) ||
+      B_I_E_NAME (de->de_entry_num, de->de_bh, ih) != de->de_name ||
+      memcmp (name, de->de_name, len))
+    return 0;
+  return 1;
+}
+
+
+static int entry_points_to_object (const char * name, int len, struct reiserfs_dir_entry * de, struct inode * inode)
+{
+  if (!de_still_valid (name, len, de))
+    return 0;
+
+  if (inode) {
+    if (!de_visible (de->de_deh))
+      reiserfs_panic (0, "vs-7042: entry_points_to_object: entry must be visible");
+    return (de->de_objectid == inode->i_ino) ? 1 : 0;
+  }
+
+  /* this must be added hidden entry */
+  if (de_visible (de->de_deh))
+    reiserfs_panic (0, "vs-7043: entry_points_to_object: entry must be visible");
+
+  return 1;
+}
+
+
+/* sets key of parent directory in ".." entry */
+static void set_ino_in_dir_entry (struct reiserfs_dir_entry * de, struct key * key)
+{
+  de->de_deh->deh_dir_id = key->k_dir_id;;
+  de->de_deh->deh_objectid = key->k_objectid;
+  /*
+  *((unsigned long *)(de->de_name + 2)) = key->k_dir_id;
+  mark_de_with_directory_id (de->de_deh);*/
+}
+
+/* 
+ * process, that is going to call fix_nodes/do_balance must hold only
+ * one path. If it holds 2 or more, it can get into endless waiting in
+ * get_empty_nodes or its clones 
+ */
+static int do_reiserfs_rename (struct reiserfs_transaction_handle *th, struct inode * old_dir, struct dentry *old_dentry,
+			       struct inode * new_dir, struct dentry *new_dentry)
+{
+  int retval;
+  struct path old_entry_path, new_entry_path, dot_dot_entry_path;
+  struct reiserfs_dir_entry old_de, new_de, dot_dot_de;
+  struct inode * old_inode, * new_inode;
+  int new_entry_added = 0;
+
+  init_path (&old_entry_path);
+  init_path (&new_entry_path);
+  init_path (&dot_dot_entry_path);
+  goto start_up;
+
+try_again:
+  current->policy |= SCHED_YIELD;
+  schedule();
+	
+start_up:
+  old_inode = new_inode = NULL;
+  dot_dot_de.de_bh = 0;
+  new_de.de_bh = 0;
+
+  /* 
+   * look for the old name in old directory 
+   */
+  retval = -ENOENT;
+  old_de.de_gen_number_bit_string = 0;
+  if (reiserfs_find_entry (old_dir, old_dentry->d_name.name, old_dentry->d_name.len, &old_entry_path, &old_de) == POSITION_NOT_FOUND)
+    goto end_rename;
+
+  pathrelse (&old_entry_path);
+
+  old_inode = old_dentry->d_inode;
+  retval = -EPERM;
+
+  if ((old_dir->i_mode & S_ISVTX) && 
+      current->fsuid != old_inode->i_uid &&
+      current->fsuid != old_dir->i_uid && !fsuser())
+    goto end_rename;
+
+  new_inode = new_dentry->d_inode;
+
+  /* look for the new entry in target directory */
+  new_de.de_gen_number_bit_string = 0;
+  if (reiserfs_find_entry (new_dir, new_dentry->d_name.name, new_dentry->d_name.len, &new_entry_path, &new_de) == POSITION_FOUND) {
+    if (!new_inode) {
+      printk ("do_reiserfs_rename: new entry found, inode == 0 though\n");
+    }
+    /* this entry already exists, we can just set key of object */
+    new_entry_added = 1;
+  } else {
+#ifdef REISERFS_CHECK
+    if (new_entry_added) {
+      if (new_de.de_namelen != new_dentry->d_name.len || memcmp (new_de.de_name, new_dentry->d_name.name, new_de.de_namelen) ||
+	  de_visible (new_de.de_deh))
+	reiserfs_panic (old_dir->i_sb, "vs-7045: reiserfs_rename: suspicious entry found");
+    }
+#endif /* REISERFS_CHECK */
+  }
+  pathrelse (&new_entry_path);
+
+
+  if (new_inode == old_inode) {
+    retval = 0;
+    goto end_rename;
+  }
+
+  if (new_inode && S_ISDIR(new_inode->i_mode)) {
+    /* new name exists and points to directory */
+    retval = -EISDIR;
+    if (!S_ISDIR(old_inode->i_mode))
+      goto end_rename;
+    retval = -EINVAL;
+    if (is_subdir (new_dentry, old_dentry))
+      goto end_rename;
+    retval = -ENOTEMPTY;
+    if (!reiserfs_empty_dir (new_inode))
+      goto end_rename;
+    retval = -EBUSY;
+    if (new_inode->i_count > 1)
+      goto end_rename;
+  }
+
+  retval = -EPERM;
+  if (new_inode && (new_dir->i_mode & S_ISVTX) && 
+      current->fsuid != new_inode->i_uid &&
+      current->fsuid != new_dir->i_uid && !fsuser())
+    goto end_rename;
+
+  if (S_ISDIR(old_inode->i_mode)) {
+    /* old name points to directory */
+    retval = -ENOTDIR;
+    if (new_inode && !S_ISDIR(new_inode->i_mode))
+      goto end_rename;
+
+    retval = -EINVAL;
+    if (is_subdir(new_dentry, old_dentry))
+      goto end_rename;
+
+    retval = -EIO;
+    /* directory is renamed, its parent directory will be changed, so find ".." entry */
+    dot_dot_de.de_gen_number_bit_string = 0;
+    if (reiserfs_find_entry (old_inode, "..", 2, &dot_dot_entry_path, &dot_dot_de) == POSITION_NOT_FOUND)
+      goto end_rename;
+    if (dot_dot_de.de_objectid != old_dir->i_ino)
+      goto end_rename;
+    pathrelse (&dot_dot_entry_path);
+
+    retval = -EMLINK;
+    if (!new_inode && new_dir->i_nlink >= REISERFS_LINK_MAX)
+      goto end_rename;
+  }
+  
+  if (new_entry_added == 0) {
+    /* add new entry if we did not do it, but do not mark it as visible */
+    retval = reiserfs_add_entry (th, new_dir, new_dentry->d_name.name, new_dentry->d_name.len, INODE_PKEY (old_inode), &new_de, 0);
+    if (retval)
+      goto end_rename;
+    if_in_ram_update_sd (th, new_dir);
+    new_entry_added = 1;
+    goto try_again;
+  }
+
+
+  /* 
+   * look for old name, new name and ".." when renaming directories again
+   */
+  if (reiserfs_find_entry (old_dir, old_dentry->d_name.name, old_dentry->d_name.len, &old_entry_path, &old_de) == POSITION_NOT_FOUND)
+    reiserfs_panic (old_dir->i_sb, "vs-7050: reiserfs_rename: old name not found");
+  if (reiserfs_find_entry (new_dir, new_dentry->d_name.name, new_dentry->d_name.len, &new_entry_path, &new_de) == POSITION_NOT_FOUND)
+    reiserfs_panic (old_dir->i_sb, "vs-7055: reiserfs_rename: new name not found");
+  if (S_ISDIR(old_inode->i_mode) && reiserfs_find_entry (old_inode, "..", 2, &dot_dot_entry_path, &dot_dot_de) == POSITION_NOT_FOUND)
+    reiserfs_panic (old_dir->i_sb, "vs-7060: reiserfs_rename: \"..\" name not found");
+ 
+
+  /* sanity checking before doing the rename - avoid races */
+  if (!entry_points_to_object (new_dentry->d_name.name, new_dentry->d_name.len, &new_de, new_inode))
+    goto try_again;
+  if (!entry_points_to_object (old_dentry->d_name.name, old_dentry->d_name.len, &old_de, old_inode))
+    /* go to re-looking for old entry */
+    goto try_again;
+
+  if (S_ISDIR(old_inode->i_mode) && !entry_points_to_object ("..", 2, &dot_dot_de, old_dir))
+    /* go to re-looking for ".." entry of renamed directory */
+    goto try_again;
+  
+  /* ok, all the changes can be done in one fell swoop when we have
+     claimed all the buffers needed.*/
+
+  /* make old name hidden */
+  mark_de_hidden (old_de.de_deh);
+  journal_mark_dirty(th, old_dir->i_sb, old_de.de_bh) ;
+
+  /* make new name visible and set key of old object (if entry
+     existed, it is already visible, if not, key is correct already) */
+  mark_de_visible (new_de.de_deh);
+  new_de.de_deh->deh_dir_id = INODE_PKEY (old_inode)->k_dir_id;
+  new_de.de_deh->deh_objectid = INODE_PKEY (old_inode)->k_objectid;
+  journal_mark_dirty(th, old_dir->i_sb, new_de.de_bh) ;
+
+  old_dir->i_ctime = old_dir->i_mtime = CURRENT_TIME;
+  if_in_ram_update_sd (th, old_dir);
+
+  new_dir->i_ctime = new_dir->i_mtime = CURRENT_TIME;
+  if_in_ram_update_sd (th, new_dir);
+
+  if (new_inode) {
+    new_inode->i_nlink--;
+    new_inode->i_ctime = CURRENT_TIME;
+    if_in_ram_update_sd (th, new_inode);
+  }
+  if (dot_dot_de.de_bh) {
+    set_ino_in_dir_entry (&dot_dot_de, INODE_PKEY (new_dir));
+    journal_mark_dirty(th, old_dir->i_sb, dot_dot_de.de_bh) ;
+    old_dir->i_nlink--;
+    if_in_ram_update_sd (th, old_dir);
+    if (new_inode) {
+      new_inode->i_nlink--;
+      if_in_ram_update_sd (th, new_inode);
+    } else {
+      new_dir->i_nlink++;
+      if_in_ram_update_sd (th, new_dir);
+    }
+  }
+
+  /* ok, renaming done */
+  decrement_counters_in_path (&new_entry_path);
+  decrement_counters_in_path (&dot_dot_entry_path);
+
+  /* remove old name (it is hidden now) */
+  if (reiserfs_cut_from_item (th, old_dir, old_dir->i_sb, &old_entry_path, &(old_de.de_entry_num),
+			      &(old_de.de_entry_key), 0, PRESERVE_RENAMING) == 0)
+    printk ("reiserfs_rename: could not remove old name\n");
+  else {
+    old_dir->i_size -= DEH_SIZE + old_de.de_entrylen;
+    old_dir->i_blocks = old_dir->i_size / 512 + ((old_dir->i_size % 512) ? 1 : 0);
+    if_in_ram_update_sd (th, old_dir);
+  }
+
+  /* Update the dcache */
+  d_move(old_dentry, new_dentry);
+  retval = 0;
+
+end_rename:
+  pathrelse (&old_entry_path);
+  return retval;
+}
+
+
+int	reiserfs_rename (
+			 struct inode * old_dir, struct dentry *old_dentry,
+			 struct inode * new_dir, struct dentry *new_dentry
+			 )
+{
+  static struct wait_queue * wait = NULL;
+  static int lock = 0;
+  int result;
+  int windex ;
+  struct reiserfs_transaction_handle th ;
+  int jbegin_count = JOURNAL_PER_BALANCE_CNT * 3; 
+  
+  while (lock)
+    sleep_on(&wait);
+  lock = 1;
+  journal_begin(&th, old_dir->i_sb, jbegin_count) ;
+  windex = push_journal_writer("reiesrfs_rename") ;
+  /* we are trusting if_in_ram_update_sd to update the transaction 
+  ** info in each inode as they get chagned
+  */
+  result = do_reiserfs_rename (&th, old_dir, old_dentry, new_dir, new_dentry);
+  pop_journal_writer(windex) ;
+  journal_end(&th, old_dir->i_sb, jbegin_count) ;
+  lock = 0;
+  wake_up(&wait);
+  return result;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
Index: empeg/kernel/fs/reiserfs/objectid.c
diff -u /dev/null empeg/kernel/fs/reiserfs/objectid.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/objectid.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,151 @@
+/*
+ * Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
+ */
+#ifdef __KERNEL__
+
+#include <linux/string.h>
+#include <linux/locks.h>
+#include <linux/sched.h>
+#include <linux/reiserfs_fs.h>
+
+#else
+
+#include "nokernel.h"
+
+#endif
+
+
+/* When we allocate objectids we allocate the first unused objectid.
+   Each sequence of objectids in use (the odd sequences) is followed
+   by a sequence of objectids not in use (the even sequences).  We
+   only need to record the last objectid in each of these sequences
+   (both the odd and even sequences) in order to fully define the
+   boundaries of the sequences.  A consequence of allocating the first
+   objectid not in use is that under most conditions this scheme is
+   extremely compact.  The exception is immediately after a sequence
+   of operations which deletes a large number of objects of
+   non-sequential objectids, and even then it will become compact
+   again as soon as more objects are created.  Note that many
+   interesting optimizations of layout could result from complicating
+   objectid assignment, but we have deferred making them for now. */
+
+
+/* get unique object identifier */
+unsigned long	reiserfs_get_unused_objectid (struct reiserfs_transaction_handle *th, struct super_block * s)
+{
+  unsigned long unused_objectid;
+  struct reiserfs_super_block * disk_sb;
+  unsigned long * objectid_map;
+
+
+  disk_sb = SB_DISK_SUPER_BLOCK (s);
+  objectid_map = (unsigned long *)(disk_sb + 1); /* The objectid map follows the superblock. */
+  
+                                /* comment needed -Hans */
+  unused_objectid = objectid_map[1];
+  if (unused_objectid == TYPE_INDIRECT) {
+    printk ("REISERFS: get_objectid: no more object ids\n");
+    return 0;
+  }
+
+  /* This incrementation allocates the first unused objectid. That is to say, the first entry on the
+   objectid map is the first unused objectid, and by incrementing it we use it.  See below where we
+   check to see if we eliminated a sequence of unused objectids.... */
+  objectid_map[1] ++;
+
+  /* Now we check to see if we eliminated the last remaining member of
+     the first even sequence (and can eliminate the sequence by
+     eliminating its last objectid from oids), and can collapse the
+     first two odd sequences into one sequence.  If so, then the net
+     result is to eliminate a pair of objectids from oids.  We do this
+     by shifting the entire map to the left. */
+  if (disk_sb->s_oid_cursize > 2 && objectid_map[1] == objectid_map[2]) {
+    memmove (objectid_map + 1, objectid_map + 3, (disk_sb->s_oid_cursize - 3) * sizeof(unsigned long));
+    disk_sb->s_oid_cursize -= 2;
+  }
+
+  /* super block has been changed. Non-atomic mark_buffer_dirty is allowed here */
+  /* mark_buffer_dirty (SB_BUFFER_WITH_SB (s), 1); journal victim *//* no need to place buffer on preserve list */
+  journal_mark_dirty(th, s, SB_BUFFER_WITH_SB (s));/* no need to place buffer on preserve list */
+  s->s_dirt = 1;
+  return unused_objectid;
+}
+
+
+/* makes object identifier unused */
+void	reiserfs_release_objectid (struct reiserfs_transaction_handle *th, 
+				   unsigned long objectid_to_release, struct super_block * s)
+{
+  struct reiserfs_super_block * disk_sb;
+  unsigned long * objectid_map;
+  int i = 0;
+
+
+  /* return; */
+
+  /* mark_buffer_dirty (SB_BUFFER_WITH_SB (s), 1);  journal victim */
+  journal_mark_dirty(th, s, SB_BUFFER_WITH_SB (s)); 
+  s->s_dirt = 1;
+
+  /* let disk_sb serve as a convenient shorthand pointing to the Reiserfs
+     Specific portion of the super_block */
+  disk_sb = SB_DISK_SUPER_BLOCK (s);
+
+  /* This means/assumes that the objectid map immediately follows
+     the superblock in memory. */
+  objectid_map = (unsigned long *)(disk_sb + 1);
+
+  /* start at the beginning of the objectid map (i = 0) and go to the
+     end of it (i = disk_sb->s_oid_cursize).  Linear search is what we use,
+     though it is possible that binary search would be more efficient
+     after performing lots of deletions (which is when oids is large.)
+     We only check even i's. */
+  while (i < disk_sb->s_oid_cursize) {
+    if (objectid_to_release == objectid_map[i]) {
+      if (i == 0)
+	reiserfs_panic (s, "vs-15000: reiserfs_release_objectid: trying to free root object id (%lu)",
+			    objectid_to_release);
+      /* This incrementation unallocates the objectid. */
+      objectid_map[i]++;
+      /* Did we unallocate the last member of an odd sequence, and can shrink oids? */
+      if (objectid_map[i] == objectid_map[i+1]) {
+	/* shrink objectid map */
+	memmove (objectid_map + i, objectid_map + i + 2, 
+		 (disk_sb->s_oid_cursize - i - 2)*sizeof(unsigned long));
+	disk_sb->s_oid_cursize -= 2;
+#ifdef REISERFS_CHECK
+	if (disk_sb->s_oid_cursize < 2 || disk_sb->s_oid_cursize > disk_sb->s_oid_maxsize)
+	  reiserfs_panic (s, "vs-15005: reiserfs_release_objectid: "
+			  "objectid map corrupted cur_size == %d (max == %d)",
+			  disk_sb->s_oid_cursize, disk_sb->s_oid_maxsize);
+#endif
+      }
+      return;
+    }
+
+    if (objectid_to_release > objectid_map[i] && objectid_to_release < objectid_map[i+1]) {
+      /* size of objectid map is not changed */
+      if (objectid_to_release + 1 == objectid_map[i+1]) {
+	objectid_map[i+1]--;
+	return;
+      }
+
+      if (disk_sb->s_oid_cursize == disk_sb->s_oid_maxsize)
+	/* objectid map must be expanded, but there is no space */
+	return;
+
+      /* expand the objectid map*/
+      memmove (objectid_map+i+3, objectid_map+i+1, (disk_sb->s_oid_cursize-i-1) * sizeof(unsigned long));
+      objectid_map[i+1] = objectid_to_release;
+      objectid_map[i+2] = objectid_to_release + 1;
+      disk_sb->s_oid_cursize += 2;
+      return;
+    }
+    i += 2;
+  }
+
+  reiserfs_panic (0, "vs-15010: reiserfs_release_objectid: trying to free free object id (%lu)", objectid_to_release);
+}
+
+
+
Index: empeg/kernel/fs/reiserfs/preserve.c
diff -u /dev/null empeg/kernel/fs/reiserfs/preserve.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/preserve.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,1059 @@
+/*
+ * Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
+ */
+
+/* There are two schemes we can choose from in ensuring that shifted
+objects are not obliterated on disk before they are written to their
+new location.  
+
+One is to track the shifting, and this was the approach taken by the
+flush cells approach that was first tried.  It was complex, unfinished
+for handling formatted/unformatted item conversions, and we decided to
+do something simpler.  It may have been a valid approach, it was
+probably more efficient for files under 10k, but it is abandoned for
+now.  The preserve list has interesting possibilities for it to be
+enhanced in the future in ways that are of interest.
+
+The other approach is to write all formatted leaf nodes next to rather
+than on top of themselves, and to restrict the freeing of these formatted
+nodes so that it is only performed at times when there are no dirtied leaf
+buffers.  It is not necessary to restrict the freeing of unformatted
+nodes since objects are never shifted from one unformatted node to
+another.  This approach pays a price in efficiency, in that when a
+file system is heavily loaded it may never have a moment of having no
+dirty buffers, and it is necesssary to force the existence of such a
+moment by flushing all dirty buffers.  It reduces the precision of
+layout optimization performed in reiserfs_new_block by causing blocks to
+wander.  This is somewhat alleviated by the possibility that a block may
+be placed closer to its optimal position if it was not optimally placed
+to begin with.  It also wastes space, and requires writing error code
+to handle lack of disk space caused by nodes being consumed by this.
+It offers three benefits: 1) it potentially allows recovery from
+partial node write which the flush cells approach inherently could
+not, 2) it potentially enables a fast recovery mechanism that might
+prevent people from suggesting that I add a log to this system, 3) it
+is simpler.
+
+The preserve list code involved modifications to:
+preserve.c
+reiserfs_fs.h (read the comments for the preserve list data structures.)
+fs.h (especially notice mark_buffer_dirty() )
+buffer.c
+bitmap.c
+fix_node.c
+locks.h
+
+plus you should tags-search for all places in linux that call the functions that are in preserve.c.
+
+All operations that involve super blocks, internal nodes, bitmap
+blocks, oids, or operations that alter but do not balance leaves, do
+not need to use preserve_*() calls.  At some point in the future I
+want to try preserving more and more, and measuring the performance
+effect, for now a minimal approach is taken.  
+
+We must restrict the freeing of those nodes which have had objects
+shifted from them.  Nothing else needs to be duplicated to be
+adequately recoverable, just shifting.  Note that tail conversion and
+rename involve shifting.  
+
+The set of preserved nodes is the set of nodes which have shifted
+items out and which are not new nodes that have never been written to disk.
+
+So what we do is keep a count of all blocks which are dirty suspected
+recipients.  The set of BH_Suspected_Recipient flagged nodes is the
+set of nodes which might have received those shifted items.  That is
+to say, any dirty node whose node type is one which can receive
+shifted items (for all such nodes, B_IS_COUNTED(bh) is true).
+Actually, to simplify the recovery algorithm, we also flag bitmap
+blocks as BH_Suspected_Recipient when they are dirtied.  When we set
+this flag we increase the suspected_recipient_count in the superblock
+
+We create a BH_PRESERVED buffer state flag to avoid preserving
+multiple blocks for one buffer when doing multiple shifts from the
+same buffer prior to it being written to disk.  BH_Preserved and
+BH_Suspected_Recipient are cleared on buffer write completion or the
+buffer being invalidated (Nodes are invalidated as a result of:
+deleting their contents, when all of the nodes contents are shifted by
+balancing to other nodes, and when an unformatted node is converted to
+a direct item as a result of truncation.)  using the function
+unpreserve().  However, we still don't try to track the shifting, and
+we only free preserved nodes when no BH_Suspected_Recipient flagged
+buffers exist.  A feasible improvement might be to track who has
+received and only free when no recipients exist, but that requires
+more code to support another list.
+
+An unformatted node is a suspected recipient iff a direct item is
+converted to the indirect item that points to this unformatted node.
+
+A mod_time_count is a 32 bit timestamp that counts in seconds, plus a
+32 bit count of item modifications and preserve list freeings since
+the beginning of the second.  In the unlikely event that the count
+reaches UL_MAX_INT, we spin until the second ends.
+
+If we wanted to prevent indirect items from pointing to unformatted
+nodes which never reached disk before a crash, we would preserve
+indirect items and their unformatted nodes.  We would use a
+mod_time_count on the indirect items and on the freeing of the
+preserve list, and we would store this mod_time_count for the preserve
+list in the super block.  We would then throw away all indirect items
+subsequent to the last moment of consistency (well, actually, we would
+put them in the lost+found directory).  We won't do this prior to
+implementing a cleaner.
+
+Unfortunately, getting a free blocknr risks schedule, and many of our
+operations are not able to handle schedule.  This creates much pain,
+in that we must get all the blocknrs at the beginning of the operation
+(do_balance, rename, etc.), and it motivates the existence of a
+free_and_near list in the tb structure for all of the sub-procedures
+of do_balance.  We also create a free_and_near list in other
+procedures as well.  To solve this problem, ready_preserve_list
+reserves enough blocknrs for an operation, and ensures that there is
+space on the preserve list.
+
+To support transactions in a much later release we will need to use
+both write_next_to and restrict the freeing of all written_next_to
+nodes affected by a transaction at least until all of its modified
+nodes have reached the disk and the transaction is complete in its
+non-disk dependencies (and the transaction does not return completion
+until then as well.)  We will need to pass an optional transaction id
+with every fs system call, and create a complete_transaction() system
+call as well.  Note that the design intent will be to optimize
+parallel transaction throughput not serialized latency.
+
+In unlock_buffer() we cannot wait on a lock, but we can choose to skip
+freeing the preserve list.  unlock_buffer() can interrupt
+add_to_preserve() but add_to_preserve() cannot interrupt either
+unlock_buffer or itself.  I hope that unlock_buffer cannot interrupt
+itself, I must check it.  In add_to_preserve() we cannot wait on a
+lock but we must add to the preserve list.  In reiserfs_new_blocknrs
+we must wait on freeing the preserve list while syncing, which means
+it can be interrupted by add_to_preserve which must not wait.
+reserve_space_preserve can experience schedule.
+
+These conditions determine our preserve list locking strategy. 
+add_to_preserve, reserve_space_preserve, and reiserfs_new_blocknrs 
+shall lock the preserve list.  reserve_space_preserve, and 
+reiserfs_new_blocknrs shall release the preserve list before nonatomic 
+kmalloc or syncing.  After unlocking the preserve list they will check 
+the free_it flag, and if set they will free the list on behalf of 
+unlock_buffers.  reserve_space_preserve will keep one free page always 
+present on the free list, and assume that there are not enough 
+parallel writes in progress to need more than that. 
+
+add_to_preserve() shall add to either the preserve list or the jam
+list and shall lock without waiting the one it uses.
+
+If reiserfs_new_blocknrs() and add_to_preserve() lock both lists then 
+unlock_buffers skips freeing the list.  reiserfs_new_blocknrs must 
+unlock before syncing or otherwise risking schedule.  If either list 
+is locked reserve_space_preserve will first get the space it needs and 
+only then perform its action.  Since unlock_buffers is not interrupted 
+by schedule it cannot cause reiserfs_new_blocknrs() or 
+add_to_preserve() to fail to find at least one list to use. 
+unlock_buffers will free any unlocked list.  unlock_buffers && 
+reiserfs_new_blocknrs will lock and then free any unlocked list. 
+ 
+While implementing this code we faced the following problem: 
+ 
+Our recovery algorithm works by going through every block marked as 
+used in the bitmap, finding every leaf node in an allocated block, and 
+adding those nodes to a tree that it constructs from scratch.  It does 
+this because we don't sync internal nodes to disk.  We don't sync 
+internal nodes to disk because it would require writing more code for 
+us to do it efficiently, and this current code needs to ship. 
+
+The problem arises when the bitmap block reaches disk before the 
+crash, but the change to the allocated block does not reach disk 
+before the crash.  This can cause us to examine a garbage node for 
+possible insertion into the tree.  Since the preserve list creates 
+lots of garbage former internal nodes, we need to worry about how we 
+will avoid adding a former internal node into the tree and clobbering 
+the current version of that node. 
+ 
+I had come up with this overly complex method involving timestamps, 
+and a bitmap of released but not yet overwritten former members of the 
+preserve list. 
+ 
+Vladimir came up with a much simpler approach: we have two copies of 
+the bitmap.  One of them represents the state of the bitmap at the 
+last freeing of the preserve list: the preserved_bitmap.  The other is 
+the current_bitmap, and the version of it which is on disk might not 
+be accurate.  We can think of no combination of operations which will 
+cause a stale internal node to be present in the preserved_bitmap 
+using this algorithm.  The file system that will be recovered may 
+reflect some deletions more recent than the freeing of the bitmap. 
+This is okay.  All newly allocated nodes must be flagged 
+Suspected_Recipients, or, using a new name for this flag, 
+Write_Before_Freeing_Preserve.  This means that the preserve list will 
+be freed much less often, which is bad but tolerable.  It means we 
+ought to someday write code to ensure that it frees at least every 6 
+minutes, which is annoying but tolerable. 
+  
+    -Hans */ 
+
+
+
+/* Preserve List Code Overview (these comments should be merged into the ones above):
+
+   We store preserved blocknrs on the preserve list (reiser_fs_sb.h ).
+
+   preserve_shifted(), and preserve_invalidate
+   place them on the list by calling add_to_preserve().
+
+   We need to preserve buffers without incurring schedule during
+   do_balance.  To allow preserve_shifted() to do that, before
+   do_balance we insert a call to ready_preserve_list().
+   ready_preserve_list() calls reserve_space_preserve() to grow the
+   preserve list if it will be needed, and gets all of the new blocknrs that
+   might be used by preserve_shifted during do_balance().
+
+   free_all_preserve_members() frees the members of the preserve list
+   when conditions indicate that it can be freed.
+
+   maybe_free_preserve_list() checks if it can be freed, and calls
+   free_all_preserve_members() if it can be.
+
+   unpreserve() plus mark_buffer_dirty() accomplish the counting
+   necessary to determine if the preserve list can be freed.
+
+   */
+
+#ifdef __KERNEL__
+
+#include <linux/sched.h>
+#include <linux/reiserfs_fs.h>
+#include <linux/locks.h>
+
+#else
+
+#include "nokernel.h"
+
+static void reiserfs_refile_buffer(struct buffer_head * bh) {}
+
+#endif
+
+
+#ifdef REISERFS_CHECK
+
+
+#define SR_BITMAP(s) ((s)->u.reiserfs_sb.s_suspected_recipient_bitmap)
+#define PB_BITMAP(s) ((s)->u.reiserfs_sb.s_preserved_block_bitmap)
+
+
+void preserve_trace_init_bitmap (struct super_block * s)
+{
+  int i;
+
+  SR_BITMAP(s) = reiserfs_kmalloc (sizeof (char *) * SB_BMAP_NR (s), GFP_KERNEL, s);
+  PB_BITMAP(s) = reiserfs_kmalloc (sizeof (char *) * SB_BMAP_NR (s), GFP_KERNEL,s );
+
+  if (SR_BITMAP(s) == 0 || PB_BITMAP(s) == 0)
+    goto free_allocated;
+
+  for (i = 0; i < SB_BMAP_NR (s); i ++) {
+    SR_BITMAP(s)[i] = reiserfs_kmalloc (s->s_blocksize, GFP_KERNEL, s);
+    PB_BITMAP(s)[i] = reiserfs_kmalloc (s->s_blocksize, GFP_KERNEL, s);
+
+    if (SR_BITMAP(s)[i] == 0 || PB_BITMAP(s)[i] == 0)
+      goto free_allocated;
+
+    memset (SR_BITMAP(s)[i], 0, s->s_blocksize);
+    memset (PB_BITMAP(s)[i], 0, s->s_blocksize);
+  }
+  return;
+
+ free_allocated:
+  if (SR_BITMAP(s)) {
+    for (i = 0; i < SB_BMAP_NR (s); i ++)
+      if (SR_BITMAP(s)[i])
+	reiserfs_kfree (SR_BITMAP(s)[i], s->s_blocksize, s);
+      else
+	break;
+  }
+  if (PB_BITMAP(s)) {
+    for (i = 0; i < SB_BMAP_NR (s); i ++)
+      if (PB_BITMAP(s)[i])
+	reiserfs_kfree (PB_BITMAP(s)[i], s->s_blocksize, s);
+      else
+	break;
+  }
+}
+
+
+static void preserve_trace_print_bitmap (struct super_block * s, char ** bitmap, char * mes)
+{
+  int i, j;
+
+  printk ("%s:", mes);
+  for (i = 0; i < SB_BMAP_NR (s); i ++) {
+    for (j = 0; j < s->s_blocksize * 8; j ++)
+      if (test_bit (j, bitmap[i]))
+	printk (" %lu", j + i * s->s_blocksize * 8);
+  }
+  printk ("\n");
+
+}
+
+
+void preserve_trace_release_bitmap (struct super_block * s)
+{
+  int i;
+
+  if (s->u.reiserfs_sb.s_set_pb_bits || s->u.reiserfs_sb.s_set_sr_bits)
+    reiserfs_warning ("vs-: preserve_trace_release_bitmap: preserved_blocks %d, suspected_recipients %d\n",
+		      s->u.reiserfs_sb.s_set_pb_bits, s->u.reiserfs_sb.s_set_sr_bits);
+
+  if (s->u.reiserfs_sb.s_set_sr_bits)
+    preserve_trace_print_bitmap (s, SR_BITMAP (s), "suspected_recipients");
+
+  if (s->u.reiserfs_sb.s_set_pb_bits)
+    preserve_trace_print_bitmap (s, PB_BITMAP (s), "preserved_blocks");
+
+  for (i = 0; i < SB_BMAP_NR (s); i ++) {
+    reiserfs_kfree (SR_BITMAP (s)[i], s->s_blocksize, s);
+    reiserfs_kfree (PB_BITMAP (s)[i], s->s_blocksize, s);
+  }
+  reiserfs_kfree (SR_BITMAP (s), sizeof (char **) * SB_BMAP_NR (s), s);
+  reiserfs_kfree (PB_BITMAP (s), sizeof (char **) * SB_BMAP_NR (s), s);
+}
+
+
+static void preserve_trace_add_to_preserve (struct super_block * s, unsigned long block)
+{
+  int i, j;
+
+  if (block >= SB_BLOCK_COUNT (s))
+    reiserfs_panic (s, "vs-3004: preserve_trace_add_to_preserve: block %lu", block);
+
+  i = block / (s->s_blocksize * 8);
+  j = block % (s->s_blocksize * 8);
+  if (test_bit (j, PB_BITMAP (s)[i]))
+    reiserfs_panic (s, "vs-3005: preserve_trace_add_to_preserve: block %lu is preserved already", block);
+  set_bit (j, PB_BITMAP (s)[i]);
+  s->u.reiserfs_sb.s_set_pb_bits ++;
+}
+
+
+static void preserve_trace_mark_suspected_recipient (struct super_block * s, struct buffer_head * bh)
+{
+  int i, j;
+
+  if (s->u.reiserfs_sb.s_suspected_recipient_count != s->u.reiserfs_sb.s_set_sr_bits)
+    reiserfs_panic (s, "vs-3007: preserve_trace_mark_suspected_recipient: suspected recipients are %d or %d",
+		    s->u.reiserfs_sb.s_suspected_recipient_count, s->u.reiserfs_sb.s_set_sr_bits);
+  if (bh->b_blocknr >= SB_BLOCK_COUNT (s))
+    reiserfs_panic (s, "vs-3008: preserve_trace_mark_suspected_recipient: block %lu", bh->b_blocknr);
+  i = bh->b_blocknr / (s->s_blocksize * 8);
+  j = bh->b_blocknr % (s->s_blocksize * 8);
+
+  if (test_bit (j, SR_BITMAP (s)[i]))
+    reiserfs_panic (s, "vs-3010: preserve_trace_mark_suspected_recipient: block %lu is suspected recipient", bh->b_blocknr);
+
+  set_bit (j, SR_BITMAP (s)[i]);
+  s->u.reiserfs_sb.s_set_sr_bits ++;
+}
+
+
+static void preserve_trace_unmark_suspected_recipient (struct super_block * s, struct buffer_head * bh)
+{
+  int i, j;
+
+  if (s->u.reiserfs_sb.s_suspected_recipient_count != s->u.reiserfs_sb.s_set_sr_bits)
+    reiserfs_panic (s, "vs-3012: preserve_trace_unmark_suspected_recipient: suspected recipients are %d or %d",
+		    s->u.reiserfs_sb.s_suspected_recipient_count, s->u.reiserfs_sb.s_set_sr_bits);
+  i = bh->b_blocknr / (s->s_blocksize * 8);
+  j = bh->b_blocknr % (s->s_blocksize * 8);
+  if (!test_bit (j, SR_BITMAP (s)[i]))
+    reiserfs_panic (s, "vs-3015: preserve_trace_unmark_suspected_recipient: block %lu is not suspected recipient", bh->b_blocknr);
+  clear_bit (j, SR_BITMAP (s)[i]);
+  s->u.reiserfs_sb.s_set_sr_bits --;
+  if (s->u.reiserfs_sb.s_set_sr_bits < 0)
+    reiserfs_panic (s, "vs-3017: preserve_trace_unmark_suspected_recipient: suspected recipients counter < 0");
+}
+
+
+static void preserve_trace_free_preserved_block (struct super_block * s, unsigned long block)
+{
+  int i, j;
+
+  i = block / (s->s_blocksize * 8);
+  j = block % (s->s_blocksize * 8);
+  if (!test_bit (j, PB_BITMAP (s)[i]))
+    reiserfs_panic (s, "vs-3020: preserve_trace_free_preserved_block: block %lu is not preserved", block);
+  clear_bit (j, PB_BITMAP (s)[i]);
+  s->u.reiserfs_sb.s_set_pb_bits --;
+  if (s->u.reiserfs_sb.s_set_pb_bits < 0)
+    reiserfs_panic (s, "vs-3025: preserve_trace_free_preserved_block: preserved_blocks counter < 0");
+}
+
+
+static void preserve_trace_free_preserve_list (struct super_block * s)
+{
+  if (s->u.reiserfs_sb.s_set_sr_bits != 0) {
+    preserve_trace_print_bitmap (s, SR_BITMAP (s), "suspected recipients");
+    reiserfs_panic (0, "vs-3030: preserve_trace_free_preserve_list: preserved_blocks %d, suspected recipients %d, super block suspected recipient count %d",
+		    s->u.reiserfs_sb.s_set_pb_bits, s->u.reiserfs_sb.s_set_sr_bits,
+		    s->u.reiserfs_sb.s_suspected_recipient_count);
+  }
+}
+
+
+void preserve_trace_reset_suspected_recipients (struct super_block * s)
+{
+  int i, j;
+
+  for (i = 0; i < SB_BMAP_NR (s); i ++) {
+    for (j = 0; j < s->s_blocksize * 8; j ++)
+      if (test_bit (j, SR_BITMAP (s)[i])) {
+	clear_bit (j, SR_BITMAP (s)[i]);
+	s->u.reiserfs_sb.s_set_sr_bits --;
+      }
+  }
+  if (s->u.reiserfs_sb.s_set_sr_bits)
+    printk ("vs-3032: reset_suspected_recipients: %d buffers are marked for write\n",
+	    s->u.reiserfs_sb.s_set_sr_bits);
+}
+
+
+void preserve_trace_print_srs (struct super_block * s)
+{
+  preserve_trace_print_bitmap (s, SR_BITMAP (s), "suspected_recipients");  
+}
+
+
+#endif /* REISERFS_CHECK */
+
+
+static char * preserve_list_getmem (int size, int * repeat, struct super_block * s)
+{
+  char * buf;
+
+  *repeat = SCHEDULE_OCCURRED;
+
+  buf = reiserfs_kmalloc (size, GFP_KERNEL, s);
+  if (buf == NULL)
+    /* preserve list code is not ready to get 0 from kmalloc */
+    reiserfs_panic (0, "vs-3035: preserve_list_getmem: kmalloc returned 0");
+  return buf;
+}
+
+
+#define PL_PAGE_SIZE 4096
+#define PL_NEXT_PAGE(p) ((void **)(p + PL_PAGE_SIZE - sizeof (void *)))
+
+static int is_there_preserve_list (struct super_block * sb)
+{
+  return (SB_PL_FIRST_PAGE (sb) != 0);
+}
+
+
+/* no preserve list or no preserved blocks */
+static int is_preserve_list_empty (struct super_block * sb)
+{
+  return (SB_PL_FIRST_PAGE (sb) == 0 || (unsigned long *)SB_PL_FIRST_PAGE (sb) == SB_PL_END (sb));
+}
+
+
+/* Ensure that the preserve list will have enough slots for a
+   subsequent balancing operation.  It is possible for expanding the
+   preserve list to cause schedule, and so this ensurance must be done
+   before do_balance. Because I don't want to get a buffer for every
+   do_balance and put it in tb on the small chance it might be used, I
+   simply ensure that a full free buffer of unused slots exists.  The
+   conditions under which this would not be enough are unlikely to
+   exist for today's linux machines, and the more one ponders what it
+   would take to consume a whole buffer before any process adds
+   another buffer to the list the more distant the possibility of a
+   problem seems.  Used in ready_preserve_list(). */
+static int reserve_space_preserve (struct super_block * sb)
+{
+  int repeat = CARRY_ON, repeat2 = CARRY_ON;
+  void * vp;
+
+  /* Here we handle when the preserve list is empty, which only occurs once after mounting. */
+  if (!is_there_preserve_list (sb)) {
+#ifdef REISERFS_CHECK
+    if (SB_PL_CURRENT_PAGE (sb))
+      reiserfs_panic (sb, "reiser-3040: reserve_space_preserve: end but not start was nulled");
+#endif /* REISERFS_CHECK */
+
+    vp = preserve_list_getmem (PL_PAGE_SIZE, &repeat, sb);
+    if (is_preserve_list_empty (sb)) {
+      SB_PL_FIRST_PAGE (sb) = SB_PL_CURRENT_PAGE (sb) = vp;
+      memset (SB_PL_FIRST_PAGE (sb), '\0', PL_PAGE_SIZE);
+      /* set first entry */
+      SB_PL_END (sb) = (unsigned long *)SB_PL_FIRST_PAGE (sb);
+    } else
+      /* somebody else has created preserve list already */
+      reiserfs_kfree (vp, PL_PAGE_SIZE, sb);
+  }
+
+  /* if the current preserve list page is the last one in the preserve list, allocate a new one */
+  if (*PL_NEXT_PAGE (SB_PL_CURRENT_PAGE (sb)) == 0) {
+    /* preserve list always has empty memory block.*/
+    vp = preserve_list_getmem (PL_PAGE_SIZE, &repeat2, sb);
+    if (*PL_NEXT_PAGE (SB_PL_CURRENT_PAGE (sb)) == 0) {
+      *PL_NEXT_PAGE (SB_PL_CURRENT_PAGE (sb)) = vp;
+      memset (vp, '\0', PL_PAGE_SIZE);
+    } else
+      /* somebody else has expanded preserve list already */
+      reiserfs_kfree (vp, PL_PAGE_SIZE, sb);
+  }
+
+  return (repeat | repeat2);
+}
+
+
+static int get_nodes_for_preserving (struct reiserfs_transaction_handle *th, struct tree_balance * tb, struct buffer_head * bh)
+{
+  struct buffer_head * new_bh;
+  unsigned long	blocknrs[MAX_PRESERVE_NODES] = {0,};
+  int i;
+  int repeat1, repeat;
+
+  if (tb->tb_nodes_for_preserving[0] != 0)
+    return CARRY_ON;
+
+  if ((repeat = reiserfs_new_blocknrs (th, tb->tb_sb, blocknrs, bh->b_blocknr, MAX_PRESERVE_NODES, 1/*for preserve list*/)) == NO_DISK_SPACE)
+    return repeat; /* there is no free blocks */
+
+  /* for each blocknumber we just got, get a buffer and stick it on tb array of nodes to be used in
+     preserving */
+  for (i = 0; i < MAX_PRESERVE_NODES; i ++) {
+
+#ifdef REISERFS_CHECK
+    if ( ! blocknrs[i] )
+      reiserfs_panic (tb->tb_sb, "vs-3055: get_nodes_for_preserving: "
+		      "reiserfs_new_blocknrs failed when got new blocks");
+#endif
+
+    repeat1 = CARRY_ON;
+    new_bh = reiserfs_getblk (bh->b_dev, blocknrs[i], bh->b_size, &repeat1);
+    repeat |= repeat1;
+    if (new_bh->b_count > 1) {
+      repeat |= SCHEDULE_OCCURRED;
+      free_buffers_in_tb (tb);
+      wait_buffer_until_released (new_bh);
+    }
+#ifdef REISERFS_CHECK
+    if ( new_bh->b_count != 1 || buffer_dirty (new_bh)) {
+      reiserfs_panic(tb->tb_sb,"vs-3060: get_nodes_for_preserving: not free or dirty buffer %b for the new block",
+		     new_bh);
+  }
+#endif
+
+    mark_buffer_journal_new(new_bh) ;
+    /* Put empty buffers into the array. */
+    tb->tb_nodes_for_preserving[i] = new_bh;
+    
+    /* we have atomically dirtied bitmap block, containing bit, that
+       corresponds to p_s_new_bh->b_blocknr. Tree balance contains 1
+       bit per each bitmap block. Set there bit corresponding to
+       dirtied bitmap */
+    set_bit (new_bh->b_blocknr / (new_bh->b_size * 8), DIRTY_BITMAP_MAP (tb));
+  }
+
+  return repeat;
+}
+
+
+/* expand preserve list if neccessary and get empty nodes to use in preserving */
+int ready_preserve_list (struct tree_balance * tb, struct buffer_head * bh)
+{
+  int repeat, repeat1;
+
+  if (dont_preserve (tb->tb_sb))
+    return CARRY_ON;
+
+  /* There is an operation (do_balance or reiserfs_rename) that needs to preserve block without
+     risking schedule. Ensure that there is space on the preserve list for blocknrs of blocks that
+     might be dirtied before the operation that must be protected from schedule ends. */
+  repeat = reserve_space_preserve (tb->tb_sb);
+  repeat1 = get_nodes_for_preserving (NULL, tb, bh);
+  if (repeat1 == NO_DISK_SPACE)
+    return NO_DISK_SPACE;
+  return repeat | repeat1;
+}
+
+
+/* adds blocknr to preserve list so that shifted items are not overwritten before they are written.  assumes that
+   pointer 'preserve_list_end' already points to the next available slot, and that there is another slot after that to
+   increment to. */
+void add_to_preserve (unsigned long blocknr, struct super_block * sb)
+{
+  if (dont_preserve (sb))
+    return;
+  
+#ifdef REISERFS_CHECK
+  if (SB_PL_CURRENT_PAGE (sb) == 0)
+    reiserfs_panic (sb, "reiser-3065: add_to_preserve: current page is NULL");
+
+  if ((char *)SB_PL_END (sb) > SB_PL_CURRENT_PAGE (sb) + PL_PAGE_SIZE - sizeof (void *) - sizeof (unsigned long))
+    reiserfs_panic (sb, "reiser-3070: add_to_preserve: ran past the end of the current page somehow\n"); 
+
+  if (*SB_PL_END (sb))
+    reiserfs_panic (sb, "reiser-3075: add_to_preserve: "
+		    "slot points to non-empty (does not contain 0) location, pointer run amuck\n");
+  
+  preserve_trace_add_to_preserve (sb, blocknr);
+
+#endif /* REISERFS_CHECK */
+
+  *SB_PL_END (sb) = blocknr;
+  sb->u.reiserfs_sb.s_preserved ++;
+
+  /* increment preserve_offset pointers appropriately */
+  /* if not at end of page then increment to next slot else point offset to next page on jam.start */
+  SB_PL_END (sb) ++;
+  if (SB_PL_END (sb) + 1 > (unsigned long *)PL_NEXT_PAGE (SB_PL_CURRENT_PAGE (sb))) {
+    SB_PL_CURRENT_PAGE (sb) = *PL_NEXT_PAGE (SB_PL_CURRENT_PAGE (sb));
+    SB_PL_END (sb) = (unsigned long *)SB_PL_CURRENT_PAGE (sb);
+  }
+}
+
+
+int is_buffer_unwritten (struct buffer_head * bh)
+{
+  return test_bit (BH_Unwritten, &bh->b_state);
+}
+
+
+int is_buffer_preserved (struct buffer_head * bh)
+{
+  return test_bit (BH_Preserved, &bh->b_state);
+}
+
+
+int is_buffer_suspected_recipient (struct super_block * s, struct buffer_head * bh)
+{
+  if (s) {
+#ifdef REISERFS_CHECK
+    int i, j;
+    
+    i = bh->b_blocknr / (s->s_blocksize * 8);
+    j = bh->b_blocknr  % (s->s_blocksize * 8);
+    if ((test_bit (BH_Suspected_Recipient, &bh->b_state) && !test_bit (j, SR_BITMAP (s)[i])) ||
+	(!test_bit (BH_Suspected_Recipient, &bh->b_state) && test_bit (j, SR_BITMAP (s)[i]))) {
+      reiserfs_warning ("vs-3077: is_suspected_recipient: block %d, state %d, sr_bitmap %d\n",
+			bh->b_blocknr, test_bit (BH_Suspected_Recipient, &bh->b_state),
+			test_bit (j, SR_BITMAP (s)[i]));
+    }
+    ;
+#endif
+  }
+  return test_bit (BH_Suspected_Recipient, &bh->b_state);
+}
+
+
+
+
+
+extern int g_balances_number;
+extern struct tree_balance init_tb;
+extern int init_item_pos;
+extern int init_pos_in_item;
+extern int init_mode;
+extern struct tree_balance * cur_tb;
+
+
+
+inline void mark_buffer_unwritten (struct buffer_head * bh)
+{
+  set_bit (BH_Unwritten, &bh->b_state);
+}
+
+
+static inline void mark_buffer_preserved (struct buffer_head * bh)
+{
+  set_bit (BH_Preserved, &bh->b_state);
+}
+
+
+
+/* This function should be called on every buffer into which anything
+   is shifted.  It also is called on some buffers which are involved
+   in direct_to_indirect conversions, indirect_to_direct, and marking
+   of bitmap block, and rename. It should also be done for the
+   objectid map perhaps, we are still discussing it.  Functionally, it
+   is every buffer which must be written to disk before the preserve
+   list can be freed.  */
+inline void mark_suspected_recipient (struct super_block * s, struct buffer_head * bh)
+{
+  if (dont_preserve (s))
+    return;
+
+  if (bh && !is_buffer_suspected_recipient (s, bh)) {
+
+#ifdef REISERFS_CHECK
+
+    if (s->u.reiserfs_sb.s_suspected_recipient_count == MAX_UL_INT)
+      reiserfs_panic (s, "reiser-3080: mark_suspected_recipient: suspected_recipient_count reached max, must be leaking");
+
+    if (!buffer_dirty (bh))
+      reiserfs_warning ("vs-3082: mark_suspected_recipient: buffer is clean (%lu, state %o)\n",
+			bh->b_blocknr, bh->b_state);
+
+    preserve_trace_mark_suspected_recipient (s, bh);
+
+#endif /* REISERFS_CHECK */
+
+    s->u.reiserfs_sb.s_suspected_recipient_count ++;
+
+    set_bit (BH_Suspected_Recipient, &bh->b_state);
+  }
+
+}
+
+
+inline void unmark_suspected_recipient (struct super_block * s, struct buffer_head * bh)
+{
+  if (dont_preserve (s))
+    return;
+  
+  if (bh && is_buffer_suspected_recipient (s, bh)) {
+
+#ifdef REISERFS_CHECK
+
+    if (s->u.reiserfs_sb.s_suspected_recipient_count == 0)
+      reiserfs_panic (s, "reiser-3085: unmark_suspected_recipient: suspected_recipient_count is 0");
+
+    preserve_trace_unmark_suspected_recipient (s, bh);
+
+#endif /* REISERFS_CHECK */
+    
+    s->u.reiserfs_sb.s_suspected_recipient_count --;
+    clear_bit (BH_Suspected_Recipient, &bh->b_state);
+  }
+}
+
+
+
+/* For greater consistency in the event of a power loss we avoid writting nodes that contain
+   meta-data in-place.  (We also preserve tails via reiserfs_invalidate_unfm.)  This could be
+   changed to avoiding writing any nodes in place if transactions are implemented at some future
+   time.  in do_balance() the parameter count = MAX_DIRTIABLE
+
+   bh is the buffer whose blocknr should not be overwritten until there are no dirty blocks.
+
+   free_and_near is a list of count blocknrs that are free for use and are near the neighbors of the
+   old block.
+
+   count is the length of the list free_and_near.
+
+   this function is used by do_balance`s subprocedures and reiserfs_rename().
+
+   Schedule may not be allowed (and is not allowed) in this function (because of both do_balance and
+   the locking mechanism of the preserve list).  */
+static struct buffer_head * get_node_for_preserving (struct tree_balance * tb, struct buffer_head * being_preserved)
+{
+  int i;
+  struct buffer_head * bh;
+
+  for (i = 0; i < MAX_PRESERVE_NODES; i ++)
+    if (tb->tb_nodes_for_preserving[i]) {
+      bh = tb->tb_nodes_for_preserving[i];
+      tb->tb_nodes_for_preserving[i] = 0;
+
+      tb->preserved[i] = being_preserved;
+      if (bh->b_count != 1)
+	reiserfs_panic (tb->tb_sb, "vs-3090: get_node_for_preserving: not free buffer on the list of empty nodes");
+      return bh;
+    }
+  reiserfs_panic (tb->tb_sb, "vs-3095: get_node_for_preserving: no nodes for preserving");
+  return 0;
+}
+
+
+
+void preserve_shifted (struct tree_balance * tb, struct buffer_head ** to_be_preserved, struct buffer_head * parent, int position,
+		       struct buffer_head * dest)
+{
+  struct buffer_head * bh = *to_be_preserved;
+
+  if (dont_preserve (tb->tb_sb))
+    return;
+
+  if (is_buffer_unwritten (bh) || is_buffer_preserved (bh)) {
+    /* nothing to preserve: new node which has never been written on disk or buffer is preserved
+       already */
+    if (is_buffer_suspected_recipient (tb->tb_sb, bh) || is_buffer_preserved (bh)) {
+      mark_suspected_recipient (tb->tb_sb, dest);
+    }
+
+    return;
+  }
+
+  *to_be_preserved = get_node_for_preserving (tb, bh);
+
+  memcpy ((*to_be_preserved)->b_data, bh->b_data, bh->b_size);
+  (*to_be_preserved)->b_state = bh->b_state;
+
+  /* if bh was suspected recipient, then new buffer is suspected recipient also. Few line below
+     reiserfs_invalidate_buffer will unmark_suspected_recipient (bh). To keep counter of suspected
+     recipients in correct state we increase it */
+  if (is_buffer_suspected_recipient (tb->tb_sb, bh)) {
+
+#ifdef REISERFS_CHECK
+    preserve_trace_mark_suspected_recipient (tb->tb_sb, (*to_be_preserved));
+#endif
+    tb->tb_sb->u.reiserfs_sb.s_suspected_recipient_count ++;
+  }
+
+  /* buffer (bh) is being shifted from for the first time since the last write */
+  mark_buffer_preserved (*to_be_preserved);
+  mark_suspected_recipient (tb->tb_sb, dest);
+
+#ifdef REISERFS_CHECK
+  /* make sure, that parent is correct */
+  if (parent && B_N_CHILD_NUM (parent, position) != bh->b_blocknr) {
+    print_block (parent, 0, position, position + 2);
+    reiserfs_panic (tb->tb_sb, "reiser-3100: preserve_shifted: parent buffer (%b) "
+		    "contains incorrect child pointer %y to %b in position %d",
+		    parent, B_N_CHILD (parent, position), position, bh);
+  }
+#endif /* REISERFS_CHECK */
+
+  add_to_preserve (bh->b_blocknr, tb->tb_sb);
+  reiserfs_invalidate_buffer (NULL, tb, bh, 0/* do not free block */);
+/*  brelse (bh);*/
+  
+  if (parent == 0) {
+    if (bh->b_blocknr != SB_ROOT_BLOCK (tb->tb_sb))
+      reiserfs_panic (tb->tb_sb, "reiser-3105: preserve_shifted: block must be root");
+    SB_ROOT_BLOCK (tb->tb_sb) = (*to_be_preserved)->b_blocknr;
+    
+  } else
+    B_N_CHILD_NUM (parent, position) = (*to_be_preserved)->b_blocknr;
+
+}
+
+
+/* When deleting files with a full disk I needed to preserve the
+   buffer without asking for a free block.  This does that, unlike
+   what preserve_shifted would do, and then it invalidates the buffer, thus
+   avoiding the necessity of getting a new blocknr for the buffer. */
+void preserve_invalidate (struct reiserfs_transaction_handle *th, 
+                          struct tree_balance * tb, struct buffer_head * bh, struct buffer_head * dest)
+{
+  int do_free_block = 1;
+
+  if (! dont_preserve (tb->tb_sb)) {
+    if (is_buffer_preserved (bh)) {
+      mark_suspected_recipient (tb->tb_sb, dest);
+    } else if (is_buffer_unwritten (bh)) {
+      if (is_buffer_suspected_recipient (tb->tb_sb, bh)) {
+	mark_suspected_recipient (tb->tb_sb, dest);
+      }
+    } else {
+      /* buffer is not preserved and not unwritten. put block number to the preserve list and,
+         therefore, do not free block */
+      mark_buffer_preserved (bh);
+      add_to_preserve (bh->b_blocknr, tb->tb_sb);
+      mark_suspected_recipient (tb->tb_sb, dest);
+      do_free_block = 0;
+    }
+  }
+
+  reiserfs_invalidate_buffer (th, tb,bh, do_free_block);
+}
+
+
+static void save_and_reset_preserve_list (struct super_block * sb, char ** first_page)
+{
+  *first_page = SB_PL_FIRST_PAGE (sb);
+  SB_PL_FIRST_PAGE (sb) = 0;
+  SB_PL_CURRENT_PAGE (sb) = 0;
+  SB_PL_END (sb) = 0;
+  /* now any processes that come along will see an empty preserve list that they will start
+     appending to using add_to_preserve() without affecting us. -Hans */
+
+}
+
+
+static void free_preserve_list (struct reiserfs_transaction_handle *th, struct super_block * sb, char * freeing_page)
+{
+  char * tmp;
+  unsigned long * freed_so_far;
+  int freed = 0;
+
+  sb->u.reiserfs_sb.s_preserve_list_freeings ++;
+
+  /* inner loop moves from slot to slot freeing blocks, outer loop moves from page to page */
+  /* this is one place where we could benefit from a reiserfs_free_block() that took a list as its
+     arg... */
+  for (;;) {
+    freed_so_far = (unsigned long *)freeing_page;
+    do {
+      if (*freed_so_far) {
+	reiserfs_free_block(th, sb, *freed_so_far);
+	reiserfs_refile_buffer (SB_AP_BITMAP (sb)[*freed_so_far/(sb->s_blocksize * 8)]);
+	/* reiserfs_refile_buffer (SB_AP_CAUTIOUS_BITMAP (sb)[*freed_so_far/(sb->s_blocksize * 8)]); journal victim */
+#ifdef REISERFS_CHECK
+	preserve_trace_free_preserved_block (sb, *freed_so_far);
+#endif
+	if (sb->u.reiserfs_sb.s_preserved == 0) {
+	  printk ("vs-3107: free_preserve_list: preserved block counter is 0\n");
+	  sb->u.reiserfs_sb.s_preserved = 1;
+	}
+	sb->u.reiserfs_sb.s_preserved --;
+	freed ++;
+      } else {
+	/* Null slot, the first null slot should be the end of the preserve list. */
+	if (*PL_NEXT_PAGE (freeing_page)) {
+	  /* free next memory block if we have it */
+	  reiserfs_kfree (*PL_NEXT_PAGE (freeing_page), PL_PAGE_SIZE, sb);
+	}
+	reiserfs_kfree (freeing_page, PL_PAGE_SIZE, sb);
+	return;
+      }
+      freed_so_far ++;
+      /* While not at end of page, and while testing condition
+	 we increment the slot pointer. */
+    } while ((freed_so_far + 1) <= (unsigned long *)PL_NEXT_PAGE (freeing_page));
+	
+    /* We reached the end of the page, so now we go to the next page, and free the current one. */
+    tmp = freeing_page;
+    freeing_page = *PL_NEXT_PAGE (freeing_page);
+
+#ifdef REISERFS_CHECK
+    if (!freeing_page)
+      reiserfs_panic(sb, "reiser-3110: free_preserve_list: "
+		     "preserve list contained unexpected null page prior to end of preserve list");
+#endif
+    reiserfs_kfree (tmp, PL_PAGE_SIZE, sb);
+  }
+
+  /* this is next operator after for (;;) */
+  reiserfs_panic (sb, "reiser-3115: free_preserve_list: no next page on preserve list");
+  return;
+}
+
+
+/* check to see if we can free the members of the preserve list.
+
+   All sys calls which can dirty a block, before the block is dirtied, should check this:
+
+   These calls are:
+   reiserfs_object_write 
+   create 
+   link 
+   unlink 
+   symlink 
+   mkdir 
+   rmdir 
+   mknod 
+   rename
+
+   It is also called when reiserfs_new_blocknr() runs out of disk space.
+
+   */
+/* if there are no dirty buffers that might contain shiftable objects && there is anything on the
+   free list, and the list is not locked then free it.  Note that there is a presumption that if the
+   list is locked it doesn't much matter, there will be plenty of other opportunities to free the
+   list, go onwards without waiting for it to unlock.. */
+int maybe_free_preserve_list (struct super_block * s)
+{
+  char * first_page;
+
+  if (dont_preserve (s))
+    return 1;
+
+  if (s->u.reiserfs_sb.s_suspected_recipient_count != 0) {
+    /* preserve list can not be freed */
+    return 0;
+  }
+
+#ifdef REISERFS_CHECK
+  preserve_trace_free_preserve_list (s);
+#endif
+
+  if (is_there_preserve_list (s)) {
+    /* preserve list can contain 0 preserved blocks */
+    save_and_reset_preserve_list (s, &first_page);
+    free_preserve_list (NULL, s, first_page);
+    return 1;
+  }
+
+  /* preserve list is empty */
+  return 1;
+}
+
+
+/* We are out of disk space, so if there are blocks on the preserve list then free them by using
+   sync, and return that schedule() occurred (1) so that fix_nodes can repeat, otherwise return that
+   we are truly out of disk space (NO_DISK_SPACE) */
+int get_space_from_preserve_list (struct super_block * s)
+{
+  static struct wait_queue * wait = NULL;
+  static int lock = 0;
+  char * first_page;
+
+  if (dont_preserve (s))
+    return NO_DISK_SPACE;
+
+  if (lock) {
+    sleep_on (&wait);
+    return SCHEDULE_OCCURRED;
+  }
+
+  if (is_preserve_list_empty (s))
+    return NO_DISK_SPACE;
+
+  lock = 1;
+
+  /* we are going to free all blocks saved on preserve list, disconnect preserve list from super
+     block */
+  save_and_reset_preserve_list (s, &first_page);
+
+  if (s->u.reiserfs_sb.s_suspected_recipient_count != 0) {
+    fsync_dev (s->s_dev);
+    /* do not worry about suspected recipient count anymore, fsync_dev may not return until all
+       buffer writes have completed. */
+  }
+
+  free_preserve_list (NULL, s, first_page);
+  lock = 0;
+  wake_up(&wait);
+  
+  return SCHEDULE_OCCURRED;
+}
+
+
+/* this is called on io completion */
+void unpreserve (struct super_block * s, struct buffer_head * bh)
+{
+  int nr, offset;
+
+
+  unmark_suspected_recipient (s, bh);
+
+  /* This does no harm to non-reiserfs buffers. */
+  clear_bit(BH_Preserved,&bh->b_state);	/* this is set when the buffer is preserved */
+  clear_bit(BH_Unwritten,&bh->b_state);	/* this is set when the buffer is get into tree
+					   via get_FEB */
+
+  /* set bit in the cautious bitmap if it was not set */
+  nr = bh->b_blocknr / (s->s_blocksize << 3);
+  offset = bh->b_blocknr % (s->s_blocksize << 3);
+#if 0 /* journal victim */
+  if (!test_bit (offset, SB_AP_CAUTIOUS_BITMAP (s)[nr]->b_data)) {
+    set_bit (offset, SB_AP_CAUTIOUS_BITMAP (s)[nr]->b_data);
+    reiserfs_mark_buffer_dirty (SB_AP_CAUTIOUS_BITMAP (s)[nr], 1); /* journal victim */
+    reiserfs_refile_buffer (SB_AP_CAUTIOUS_BITMAP (s)[nr]);
+
+    mark_suspected_recipient (s, SB_AP_CAUTIOUS_BITMAP (s)[nr]);
+  }
+#endif
+
+  if (!s->u.reiserfs_sb.lock_preserve)
+    /* no tree updates are in progress */
+    maybe_free_preserve_list (s);
+}
+
+
+
+
+
+
+
+
Index: empeg/kernel/fs/reiserfs/prints.c
diff -u /dev/null empeg/kernel/fs/reiserfs/prints.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/prints.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,1122 @@
+/*
+ * Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
+ */
+#ifdef __KERNEL__
+
+#include <stdarg.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/reiserfs_fs.h>
+#include <linux/string.h>
+
+#else
+
+#include "nokernel.h"
+#include <stdarg.h>
+#include <limits.h>
+
+#endif
+
+
+static char error_buf[1024];
+static char fmt_buf[1024];
+static char off_buf[80];
+
+static char * offset (struct key * key)
+{
+  if (KEY_IS_DIRECTORY_KEY (key))
+    sprintf (off_buf, "%d(%d)", GET_HASH_VALUE (key->k_offset), GET_GENERATION_NUMBER (key->k_offset));
+  else
+    sprintf (off_buf, "%d", key->k_offset);
+  return off_buf;
+}
+
+
+static void sprintf_key (char * buf, struct key * key)
+{
+  if (key)
+    sprintf (buf, "[%d %d %s %d]", key->k_dir_id, key->k_objectid, offset (key), key->k_uniqueness);
+  else
+    sprintf (buf, "[NULL]");
+}
+
+
+static void sprintf_item_head (char * buf, struct item_head * ih)
+{
+  if (ih) {
+    sprintf_key (buf, &(ih->ih_key));
+    sprintf (buf + strlen (buf), ", item_len %d, item_location %d", ih->ih_item_len, ih->ih_item_location);
+  } else
+    sprintf (buf, "[NULL]");
+}
+
+
+static void sprintf_direntry (char * buf, struct reiserfs_dir_entry * de)
+{
+  char name[20];
+
+  memcpy (name, de->de_name, de->de_namelen > 19 ? 19 : de->de_namelen);
+  name [de->de_namelen > 19 ? 19 : de->de_namelen] = 0;
+  sprintf (buf, "\"%s\"==>[%d %d]", name, de->de_dir_id, de->de_objectid);
+}
+
+
+static void sprintf_block_head (char * buf, struct buffer_head * bh)
+{
+  sprintf (buf, "level=%d, nr_items=%d, free_space=%d rdkey ",
+	   B_LEVEL (bh), B_NR_ITEMS (bh), B_BLK_HEAD (bh)->blk_free_space);
+  if (B_LEVEL (bh) == DISK_LEAF_NODE_LEVEL)
+    sprintf_key (buf + strlen (buf), B_PRIGHT_DELIM_KEY (bh));
+}
+
+
+static void sprintf_buffer_head (char * buf, struct buffer_head * bh) 
+{
+  sprintf (buf, "dev x%x, size %ld, blocknr %ld, count %d, state(%s, %s, %s)",
+	   bh->b_dev, bh->b_size, bh->b_blocknr, bh->b_count,
+	   buffer_uptodate (bh) ? "UPTODATE" : "!UPTODATE",
+	   buffer_dirty (bh) ? "DIRTY" : "CLEAN",
+	   buffer_locked (bh) ? "LOCKED" : "UNLOCKED");
+}
+
+
+static void sprintf_disk_child (char * buf, struct disk_child * dc)
+{
+  sprintf (buf, "[dc_number=%lu, dc_size=%u]", dc->dc_block_number, dc->dc_size);
+}
+
+
+static char * is_there_reiserfs_struct (char * fmt, int * what, int * skip)
+{
+  char * k = fmt;
+
+  *skip = 0;
+  
+  while (1) {
+    k = strstr (k, "%");
+    if (!k)
+      break;
+    if (k && (k[1] == 'k' || k[1] == 'h' || k[1] == 't' ||
+	      k[1] == 'z' || k[1] == 'b' || k[1] == 'y')) {
+      *what = k[1];
+      break;
+    }
+    (*skip) ++;
+    k ++;
+  }
+  return k;
+}
+
+
+/* debugging reiserfs we used to print out a lot of different
+   variables, like keys, item headers, buffer heads etc. Values of
+   most fields matter. So it took a long time just to write
+   appropriative printk. With this reiserfs_warning you can use format
+   specification for complex structures like you used to do with
+   printfs for integers, doubles and pointers. For instance, to print
+   out key structure you have to write just: 
+   reiserfs_warning ("bad key %k", key); 
+   instead of 
+   printk ("bad key %lu %lu %lu %lu", key->k_dir_id, key->k_objectid, 
+           key->k_offset, key->k_uniqueness); 
+*/
+
+#define do_reiserfs_warning \
+{\
+  char * fmt1 = fmt_buf;\
+  va_list args;\
+  int i, j;\
+  char * k;\
+  char * p = error_buf;\
+  int what, skip;\
+\
+  strcpy (fmt1, fmt);\
+  va_start(args, fmt);\
+\
+  while (1) {\
+    k = is_there_reiserfs_struct (fmt1, &what, &skip);\
+    if (k != 0) {\
+      *k = 0;\
+      p += vsprintf (p, fmt1, args);\
+\
+      for (i = 0; i < skip; i ++)\
+	j = va_arg (args, int);\
+\
+      switch (what) {\
+      case 'k':\
+	sprintf_key (p, va_arg(args, struct key *));\
+	break;\
+      case 'h':\
+	sprintf_item_head (p, va_arg(args, struct item_head *));\
+	break;\
+      case 't':\
+	sprintf_direntry (p, va_arg(args, struct reiserfs_dir_entry *));\
+	break;\
+      case 'y':\
+	sprintf_disk_child (p, va_arg(args, struct disk_child *));\
+	break;\
+      case 'z':\
+	sprintf_block_head (p, va_arg(args, struct buffer_head *));\
+	break;\
+      case 'b':\
+	sprintf_buffer_head (p, va_arg(args, struct buffer_head *));\
+	break;\
+      }\
+      p += strlen (p);\
+      fmt1 = k + 2;\
+    } else {\
+      i = vsprintf (p, fmt1, args);\
+      break;\
+    }\
+  }\
+\
+  va_end(args);\
+}
+
+
+/* in addition to usual conversion specifiers this accepts reiserfs
+   specific conversion specifiers: 
+   %k to print key, 
+   %h to print item_head,
+   %t to print directory entry 
+   %z to print block head (arg must be struct buffer_head *
+   %b to print buffer_head
+*/
+void reiserfs_warning (const char * fmt, ...)
+{
+  do_reiserfs_warning;
+  printk ("%s", error_buf);
+}
+
+
+
+/* The format:
+
+           maintainer-errorid: [function-name:] message
+
+    where errorid is unique to the maintainer and function-name is
+    optional, is recommended, so that anyone can easily find the bug
+    with a simple grep for the short to type string
+    maintainer-errorid.  Don't bother with reusing errorids, there are
+    lots of numbers out there.
+
+    Example: 
+    
+    reiserfs_panic(
+	p_sb, "reiser-29: reiserfs_new_blocknrs: "
+	"one of search_start or rn(%d) is equal to MAX_B_NUM,"
+	"which means that we are optimizing location based on the bogus location of a temp buffer (%p).", 
+	rn, bh
+    );
+
+    Regular panic()s sometimes clear the screen before the message can
+    be read, thus the need for the while loop.  
+
+    Numbering scheme for panic used by Vladimir and Anatoly( Hans completely ignores this scheme, and considers it
+    pointless complexity):
+
+    panics in reiserfs_fs.h have numbers from 1000 to 1999
+    super.c				        2000 to 2999
+    preserve.c				    3000 to 3999
+    bitmap.c				    4000 to 4999
+    stree.c				        5000 to 5999
+    prints.c				    6000 to 6999
+    namei.c                     7000 to 7999
+    fix_nodes.c                 8000 to 8999
+    dir.c                       9000 to 9999
+	lbalance.c					10000 to 10999
+	ibalance.c		11000 to 11999 not ready
+	do_balan.c		12000 to 12999
+	inode.c			13000 to 13999
+	file.c			14000 to 14999
+    objectid.c                       15000 - 15999
+    buffer.c                         16000 - 16999
+    symlink.c                        17000 - 17999
+
+   .  */
+
+void flush_log_buf (void);
+extern int g_balances_number;
+
+#ifdef REISERFS_CHECK
+extern struct tree_balance * cur_tb;
+extern unsigned long log_size;
+#endif
+
+void reiserfs_panic (struct super_block * sb, const char * fmt, ...)
+{
+  do_reiserfs_warning;
+  printk ("%s", error_buf);
+
+#ifdef __KERNEL__
+
+  /* comment before release */
+  for (;;);
+
+  if (sb && !(sb->s_flags & MS_RDONLY)) {
+    sb->u.reiserfs_sb.s_mount_state |= REISERFS_ERROR_FS;
+    sb->u.reiserfs_sb.s_rs->s_state = REISERFS_ERROR_FS;
+    
+    /* should we journal this??? BUG */
+    mark_buffer_dirty(sb->u.reiserfs_sb.s_sbh, 1);
+    sb->s_dirt = 1;
+  }
+
+  /* this is to prevent panic from syncing this filesystem */
+  if (sb && sb->s_lock)
+    sb->s_lock=0;
+  if (sb)
+    sb->s_flags |= MS_RDONLY;
+
+  panic ("REISERFS: panic (device %s): %s\n",
+	 sb ? kdevname(sb->s_dev) : "sb == 0", error_buf);
+#else
+  exit (0);
+#endif
+}
+
+static char * vi_type (struct virtual_item * vi)
+{
+  static char *types[]={"directory", "direct", "indirect", "stat data"};
+
+  if (vi->vi_type & VI_TYPE_STAT_DATA)
+    return types[3];
+  if (vi->vi_type & VI_TYPE_INDIRECT)
+    return types[2];
+  if (vi->vi_type & VI_TYPE_DIRECT)
+    return types[1];
+  if (vi->vi_type & VI_TYPE_DIRECTORY)
+    return types[0];
+
+  reiserfs_panic (0, "vi_type: 6000: unknown type (0x%x)", vi->vi_type);
+  return NULL;
+}
+
+void print_virtual_node (struct virtual_node * vn)
+{
+  int i, j;
+  
+
+  printk ("VIRTUAL NODE CONTAINS %d items, has size %d,%s,%s, ITEM_POS=%d POS_IN_ITEM=%d MODE=\'%c\'\n",
+	  vn->vn_nr_item, vn->vn_size,
+	  (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE )? "left mergeable" : "", 
+	  (vn->vn_vi[vn->vn_nr_item - 1].vi_type & VI_TYPE_RIGHT_MERGEABLE) ? "right mergeable" : "",
+	  vn->vn_affected_item_num, vn->vn_pos_in_item, vn->vn_mode);
+
+
+  for (i = 0; i < vn->vn_nr_item; i ++)
+    {
+      printk ("%s %d %d", vi_type (&vn->vn_vi[i]), i, vn->vn_vi[i].vi_item_len);
+      if (vn->vn_vi[i].vi_entry_sizes)
+	{
+	  printk ("It is directory with %d entries: ", vn->vn_vi[i].vi_entry_count);
+	  for (j = 0; j < vn->vn_vi[i].vi_entry_count; j ++)
+	    printk ("%d ", vn->vn_vi[i].vi_entry_sizes[j]);
+	}
+      printk ("\n");
+    }
+}
+
+
+void print_path (struct tree_balance * tb, struct path * path)
+{
+  int h = 0;
+  
+  if (tb) {
+    while (tb->insert_size[h]) {
+      printk ("block %lu (level=%d), position %d\n", PATH_H_PBUFFER (path, h) ? PATH_H_PBUFFER (path, h)->b_blocknr : 0,
+	      PATH_H_PBUFFER (path, h) ? B_BLK_HEAD (PATH_H_PBUFFER (path, h))->blk_level : 0,
+	      PATH_H_POSITION (path, h));
+      h ++;
+    }
+  } else {
+    int offset = path->path_length;
+    struct buffer_head * bh;
+    printk ("Offset    Bh     (b_blocknr, b_count) Position Nr_item\n");
+    while ( offset > ILLEGAL_PATH_ELEMENT_OFFSET ) {
+      bh = PATH_OFFSET_PBUFFER (path, offset);
+      printk ("%6d %10p (%9lu, %7d) %8d %7d\n", offset, 
+	      bh, bh ? bh->b_blocknr : 0, bh ? bh->b_count : 0,
+	      PATH_OFFSET_POSITION (path, offset), bh ? B_NR_ITEMS (bh) : -1);
+
+      offset --;
+    }
+  }
+
+#if 0
+  printk ("#####################\n");
+  printk ("Offset    Bh     (b_blocknr, b_count) Position Nr_item\n");
+  while ( offset > ILLEGAL_PATH_ELEMENT_OFFSET ) {
+    bh = PATH_OFFSET_PBUFFER (path, offset);
+    printk ("%6d %10p (%9lu, %7d) %8d %7d\n", offset, 
+	    bh, bh ? bh->b_blocknr : 0, bh ? bh->b_count : 0,
+	    PATH_OFFSET_POSITION (path, offset), bh ? B_NR_ITEMS (bh) : -1);
+
+    print_buffer_head(bh,"print_path");
+    offset --;
+  }
+  printk ("#####################\n");
+#endif
+}
+
+char * int2nameprefix (char * nameprefix, unsigned int num);
+char * k_offset_to_string (unsigned long offset, unsigned long uniqueness)
+{
+  static char buf[15];
+
+  if (offset == SD_OFFSET)		/* offset == 0 */
+    strcpy (buf, "SD");
+  else if (offset == DOT_OFFSET) {	/* offset == 1 */
+    /* directory and regular files can have k_offset == 1 */
+    if (uniqueness < TYPE_INDIRECT)
+      strcpy (buf, ".");
+    else
+      strcpy (buf, "1");
+  } else if (offset == DOT_DOT_OFFSET) {/* offset == 2 */
+    /* directory and regular files can have k_offset == 2 */
+    if (uniqueness < TYPE_INDIRECT)
+      strcpy (buf, "..");
+    else
+      strcpy (buf, "2");
+  } else {				/* offset > 2 */
+    if (uniqueness < TYPE_INDIRECT)
+       int2nameprefix (buf, offset);
+    else
+      sprintf (buf, "%lu", offset);
+  }
+  return buf;
+}
+
+char * k_uniqueness_to_string (unsigned long uniqueness)
+{
+  static char * item_type[] = {"SD", "IND", "TAIL", "DIR"};
+
+  if (uniqueness == TYPE_STAT_DATA)
+    return item_type[0];
+  if (uniqueness == TYPE_INDIRECT)
+    return item_type[1];
+  if (uniqueness == TYPE_DIRECT)
+    return item_type[2];
+  return item_type[3];
+}
+
+
+
+void print_de (struct reiserfs_dir_entry * de)
+{
+  printk ("entry key: [%d, %d, \"%s\" %s], object_key: [%u %u], b_blocknr=%lu, item_num=%d, pos_in_item=%d\n",
+	  de->de_entry_key.k_dir_id, de->de_entry_key.k_objectid, 
+	  k_offset_to_string (de->de_entry_key.k_offset, de->de_entry_key.k_uniqueness),
+	  k_uniqueness_to_string (de->de_entry_key.k_uniqueness),
+	  de->de_dir_id, de->de_objectid,
+	  de->de_bh->b_blocknr, de->de_item_num, de->de_entry_num);
+}
+
+void print_bi (struct buffer_info * bi, char * mes)
+{
+  printk ("%s: bh->b_blocknr=%lu, bh->b_item_order=%d, bh->b_parent->b_blocknr=%lu\n", 
+	  mes ? mes : "print_bi", bi->bi_bh->b_blocknr, bi->bi_position, bi->bi_parent ? bi->bi_parent->b_blocknr : 0);
+}
+
+
+static char * item_type (struct item_head * ih)
+{
+    static char * types[] = {
+        "stat data", "directory", "direct", "indirect", "unknown"
+    };
+
+    if (I_IS_STAT_DATA_ITEM(ih))
+        return types[0];
+    if (I_IS_DIRECTORY_ITEM(ih))
+        return types[1];
+    if (I_IS_DIRECT_ITEM(ih))
+        return types[2];
+    if (I_IS_INDIRECT_ITEM(ih))
+        return types[3];
+    return types[4];
+}
+
+char * int2nameprefix (char * nameprefix, unsigned int num)
+{
+  int j, k;
+  char * third;
+
+  if (!num)
+    {
+      nameprefix[0] = '0';
+      nameprefix[1] = 0;
+      return nameprefix;
+    }
+             
+  third = (char *)&num;
+  for (j = 3, k = 0; j >= 0 && third[j]; j --, k ++)
+    nameprefix[k] = third[j];
+  nameprefix[k] = 0;
+
+  return nameprefix;
+}
+
+static void check_directory_item (struct buffer_head * bh, struct item_head * ih)
+{
+  int i;
+  int namelen;
+  struct reiserfs_de_head * deh;
+
+  if (!I_IS_DIRECTORY_ITEM (ih))
+    return;
+
+  deh = B_I_DEH (bh, ih);
+  for (i = 0; i < I_ENTRY_COUNT (ih); i ++, deh ++) {
+    namelen = I_DEH_N_ENTRY_FILE_NAME_LENGTH (ih, deh, i);
+  }
+}
+
+void print_directory_item (struct buffer_head * bh, struct item_head * ih)
+{
+  int i;
+  int namelen;
+  struct reiserfs_de_head * deh;
+  char * name;
+  static char namebuf [80];
+
+  if (!I_IS_DIRECTORY_ITEM (ih))
+    return;
+
+  printk ("\n # %-15s%-30s%-15s%-15s%-15s\n", "Name", "Key of pointed object", "Hash", "Gen number", "Status");
+  deh = B_I_DEH (bh, ih);
+  for (i = 0; i < I_ENTRY_COUNT (ih); i ++, deh ++) {
+    namelen = I_DEH_N_ENTRY_FILE_NAME_LENGTH (ih, deh, i);
+    name = B_I_DEH_ENTRY_FILE_NAME (bh, ih, deh);
+    namebuf[0] = '"';
+    if (namelen > sizeof (namebuf) - 3) {
+      strncpy (namebuf + 1, name, sizeof (namebuf) - 3);
+      namebuf[sizeof (namebuf) - 2] = '"';
+      namebuf[sizeof (namebuf) - 1] = 0;
+    } else {
+      memcpy (namebuf + 1, name, namelen);
+      namebuf[namelen + 1] = '"';
+      namebuf[namelen + 2] = 0;
+    }
+
+
+    printk ("%d:  %-15s%-15d%-15d%-15d%-15d(%s)\n", 
+            i, namebuf,
+	    deh->deh_dir_id, deh->deh_objectid,
+/*
+            de_with_number(deh) ? (*(unsigned long *)(B_I_PITEM(bh,ih) + deh->deh_location + strlen (namebuf))) : 
+	    ((namelen == 1 && name[0] == '.') ? ih->ih_key.k_dir_id : ih->ih_key.k_objectid),
+            deh->deh_objectid,
+*/
+	    GET_HASH_VALUE (deh->deh_offset), GET_GENERATION_NUMBER (deh->deh_offset),
+	    (de_hidden (deh)) ? "HIDDEN" : "VISIBLE");
+  }
+}
+
+
+//
+// printing of indirect item
+//
+static void start_new_sequence (__u32 * start, int * len, __u32 new)
+{
+    *start = new;
+    *len = 1;
+}
+
+static int sequence_finished (__u32 start, int * len, __u32 new)
+{
+    if (start == INT_MAX)
+	return 1;
+
+    if (start == 0 && new == 0) {
+	(*len) ++;
+	return 0;
+    }
+    if (start != 0 && (start + *len) == new) {
+	(*len) ++;
+	return 0;
+    }
+    return 1;
+}
+
+static void print_sequence (__u32 start, int len)
+{
+    if (start == INT_MAX)
+	return;
+
+    if (len == 1)
+	printk (" %d", start);
+    else
+	printk (" %d(%d)", start, len);
+}
+
+void print_indirect_item (struct buffer_head * bh, int item_num)
+{
+    struct item_head * ih;
+    int j;
+    __u32 * unp, prev = INT_MAX;
+    int num;
+
+    ih = B_N_PITEM_HEAD (bh, item_num);
+    unp = (__u32 *)B_I_PITEM (bh, ih);
+
+    if (ih->ih_item_len % UNFM_P_SIZE)
+	printk ("print_indirect_item: invalid item len");  
+
+    printk ("%d pointers\n[ ", I_UNFM_NUM (ih));
+    for (j = 0; j < I_UNFM_NUM (ih); j ++) {
+	if (sequence_finished (prev, &num, unp[j])) {
+	    print_sequence (prev, num);
+	    start_new_sequence (&prev, &num, unp[j]);
+	}
+    }
+    print_sequence (prev, num);
+    printk ("]\n");
+}
+
+
+
+char timebuf[256];
+
+char * timestamp (time_t t)
+{
+#ifndef __KERNEL__
+  strftime (timebuf, 256, "%m/%d/%Y %T", localtime (&t));
+#else
+  sprintf (timebuf, "%d", (int) t);
+#endif
+  return timebuf;
+}
+
+
+/* this prints internal nodes (4 keys/items in line) (dc_number,
+   dc_size)[k_dirid, k_objectid, k_offset, k_uniqueness](dc_number,
+   dc_size)...*/
+static int print_internal (struct buffer_head * bh, int first, int last)
+{
+    struct key * key;
+    struct disk_child * dc;
+    int i;
+    int from, to;
+
+    if (!B_IS_KEYS_LEVEL (bh))
+	return 1;
+
+    if (first == -1) {
+	from = 0;
+	to = B_NR_ITEMS (bh);
+    } else {
+	from = first;
+	to = last < B_NR_ITEMS (bh) ? last : B_NR_ITEMS (bh);
+    }
+
+    reiserfs_warning ("INTERNAL NODE (%ld) contains %z\n",  bh->b_blocknr, bh);
+
+    dc = B_N_CHILD (bh, from);
+    reiserfs_warning ("PTR %d: %y ", from, dc);
+
+    for (i = from, key = B_N_PDELIM_KEY (bh, from), dc ++; i < to; i ++, key ++, dc ++) {
+	reiserfs_warning ("KEY %d: %k PTR %d: %y ", i, key, i + 1, dc);
+	if (i && i % 4 == 0)
+	    printk ("\n");
+    }
+    printk ("\n");
+    return 0;
+}
+
+
+static int is_symlink = 0;
+static int print_leaf (struct buffer_head * bh, int print_mode, int first, int last)
+{
+    struct block_head * blkh;
+    struct item_head * ih;
+    int i;
+    int from, to;
+
+    if (!B_IS_ITEMS_LEVEL (bh))
+	return 1;
+
+    blkh = B_BLK_HEAD (bh);
+    ih = B_N_PITEM_HEAD (bh,0);
+
+    printk ("\n===================================================================\n");
+    reiserfs_warning ("LEAF NODE (%ld) contains %z\n", bh->b_blocknr, bh);
+
+    if (!(print_mode & PRINT_LEAF_ITEMS)) {
+	reiserfs_warning ("FIRST ITEM_KEY: %k, LAST ITEM KEY: %k\n",
+			  &(ih->ih_key), &((ih + blkh->blk_nr_item - 1)->ih_key));
+	return 0;
+    }
+
+    if (first < 0 || first > blkh->blk_nr_item - 1) 
+	from = 0;
+    else 
+	from = first;
+
+    if (last < 0 || last > blkh->blk_nr_item)
+	to = blkh->blk_nr_item;
+    else
+	to = last;
+
+
+    printk ("------------------------------------------------------------------------------------------------------------------\n");
+    printk ("|##|   type    |           key           | ilen | free_space | reserved | loc  |   mode  |  size  | nl | direct byte | mtime | ctime | atime |\n");
+    for (i = from; i < to; i++) {
+	printk ("------------------------------------------------------------------------------------------------------------\n");
+	printk ("|%2d| %9s | %5d %5d %5d %5d | %4d | %10d | %8d | %4d |",
+		i, item_type(ih+i), ih[i].ih_key.k_dir_id, ih[i].ih_key.k_objectid, ih[i].ih_key.k_offset, ih[i].ih_key.k_uniqueness,
+		ih[i].ih_item_len, ih[i].u.ih_free_space, ih[i].ih_reserved, ih[i].ih_item_location);
+
+	if (I_IS_STAT_DATA_ITEM(ih+i)) {
+	    struct stat_data * sd = B_I_STAT_DATA (bh,ih+i);
+
+	    printk (" 0%-6o | %6u | %2u | %d | %s | %s | %s |\n", sd->sd_mode, sd->sd_size, sd->sd_nlink, sd->sd_first_direct_byte, 
+		    timestamp (sd->sd_mtime), timestamp (sd->sd_ctime), timestamp (sd->sd_atime));
+	    is_symlink = (S_ISLNK(sd->sd_mode)) ? 1 : 0;
+	    continue;
+	}
+	printk ("\n");
+	if (I_IS_DIRECTORY_ITEM(ih+i) && print_mode & PRINT_DIRECTORY_ITEMS) {
+	    print_directory_item (bh, ih+i);
+	    continue;
+	}
+
+	if (I_IS_INDIRECT_ITEM(ih+i)) {
+	    print_indirect_item (bh, i);
+	    continue;
+	}
+
+	if (I_IS_DIRECT_ITEM(ih+i)) {
+	    int j = 0;
+	    if (is_symlink || print_mode & PRINT_DIRECT_ITEMS) {
+		printk ("\"");
+		while (j < ih[i].ih_item_len)
+		    printk ("%c", B_I_PITEM(bh,ih+i)[j++]);
+		printk ("\"\n");
+	    }
+	    continue;
+	}
+    }
+    printk ("===================================================================\n");
+    return 0;
+}
+
+/*
+char buf[20];
+
+#include <linux/kdev_t.h>
+static char * devname (int dev)
+{
+  struct stat st;
+
+  if (fstat (dev, &st) != 0)
+    die ("stat failed");
+  sprintf (buf, "0x%x:0x%x", MAJOR((int)st.st_rdev), MINOR((int)st.st_rdev));
+  return buf;
+}
+*/
+
+static char * reiserfs_version (char * buf)
+{
+    __u16 * pversion;
+
+    pversion = (__u16 *)(buf + 30);
+    if (*pversion == 0)
+	return "0";
+    if (*pversion == 2)
+	return "2";
+    return "Unknown";
+}
+
+/* return 1 if this is not super block */
+static int print_super_block (struct buffer_head * bh)
+{
+    struct reiserfs_super_block * rs = (struct reiserfs_super_block *)(bh->b_data);
+    int skipped, data_blocks;
+    
+
+    if (strncmp (rs->s_magic,  REISERFS_SUPER_MAGIC_STRING, strlen ( REISERFS_SUPER_MAGIC_STRING)))
+	return 1;
+
+    printk ("%s\'s super block in block %ld\n======================\n", kdevname (bh->b_dev), bh->b_blocknr);
+    printk ("Reiserfs version %s\n", reiserfs_version (bh->b_data));
+
+#if 0
+    printk ("-------------------------------------------------------------------------------------------------------------------\n");
+    printk ("| block count | free block | used block | blocksize | tree height |  state  |   magic   | root block | bmap count |\n");
+    printk ("|             |   count    |  count     |           |             |         |           |            |            |\n");
+    printk ("|-----------------------------------------------------------------------------------------------------------------|\n");
+    printk ("| %11d | %10d | %10d | %9d | %11d | %7s | %9s | %10d | %10d |\n", 
+	    rs->s_block_count, rs->s_free_blocks, rs->s_block_count - rs->s_free_blocks, rs->s_blocksize, rs->s_tree_height, 
+	    (rs->s_state == REISERFS_VALID_FS) ? "VALID" : "ERROR", rs->s_magic, rs->s_root_block, rs->s_bmap_nr);
+    printk ("|-----------------------------------------------------------------------------------------------------------------|\n\n");
+#endif
+
+    printk ("Block count %u\n", rs->s_block_count);
+    printk ("Blocksize %d\n", rs->s_blocksize);
+    printk ("Free blocks %u\n", rs->s_free_blocks);
+    skipped = bh->b_blocknr; // FIXME: this would be confusing if
+    // someone stores reiserfs super block in reiserfs ;)
+    data_blocks = rs->s_block_count - skipped - 1 -
+	rs->s_bmap_nr - (rs->s_orig_journal_size + 1) - rs->s_free_blocks;
+    printk ("Busy blocks (skipped %d, bitmaps - %d, journal blocks - %d\n"
+	    "1 super blocks, %d data blocks\n", 
+	    skipped, rs->s_bmap_nr, 
+	    (rs->s_orig_journal_size + 1), data_blocks);
+    printk ("Root block %u\n", rs->s_root_block);
+    printk ("Journal block (first?) %d\n", rs->s_journal_block);
+    printk ("Journal dev %d\n", rs->s_journal_dev);    
+    printk ("Journal orig size %d\n", rs->s_orig_journal_size);
+    printk ("Filesystem state %s\n", (rs->s_state == REISERFS_VALID_FS) ? "VALID" : "ERROR");
+
+#if 0
+    __u32 s_journal_trans_max ;           /* max number of blocks in a transaction.  */
+    __u32 s_journal_block_count ;         /* total size of the journal. can change over time  */
+    __u32 s_journal_max_batch ;           /* max number of blocks to batch into a trans */
+    __u32 s_journal_max_commit_age ;      /* in seconds, how old can an async commit be */
+    __u32 s_journal_max_trans_age ;       /* in seconds, how old can a transaction be */
+#endif
+    printk ("Tree height %d\n", rs->s_tree_height);
+    return 0;
+}
+
+
+static int print_desc_block (struct buffer_head * bh)
+{
+    struct reiserfs_journal_desc * desc;
+
+    desc = (struct reiserfs_journal_desc *)(bh->b_data);
+    if (memcmp(desc->j_magic, JOURNAL_DESC_MAGIC, 8))
+	return 1;
+
+    printk ("Desc block %lu (j_trans_id %ld, j_mount_id %ld, j_len %ld)",
+	    bh->b_blocknr, desc->j_trans_id, desc->j_mount_id, desc->j_len);
+
+    return 0;
+}
+
+
+void print_block (struct buffer_head * bh, ...)//int print_mode, int first, int last)
+{
+    va_list args;
+    int mode, first, last;
+
+    va_start (args, bh);
+
+    if ( ! bh ) {
+	printk("print_block: buffer is NULL\n");
+	return;
+    }
+
+    mode = va_arg (args, int);
+    first = va_arg (args, int);
+    last = va_arg (args, int);
+    if (print_leaf (bh, mode, first, last))
+	if (print_internal (bh, first, last))
+	    if (print_super_block (bh))
+		if (print_desc_block (bh))
+		    printk ("Block %ld contains unformatted data\n", bh->b_blocknr);
+}
+
+
+
+void print_tb (int mode, int item_pos, int pos_in_item, struct tree_balance * tb, char * mes)
+{
+  int h = 0;
+  int i;
+  struct buffer_head * tbSh, * tbFh;
+
+
+  if (!tb)
+    return;
+
+  printk ("\n********************** PRINT_TB for %s *******************\n", mes);
+  printk ("MODE=%c, ITEM_POS=%d POS_IN_ITEM=%d\n", mode, item_pos, pos_in_item);
+  printk ("*********************************************************************\n");
+
+  printk ("* h *    S    *    L    *    R    *   F   *   FL  *   FR  *  CFL  *  CFR  *\n");
+/*
+01234567890123456789012345678901234567890123456789012345678901234567890123456789
+       1        2         3         4         5         6         7         8
+  printk ("*********************************************************************\n");
+*/
+  
+  
+  for (h = 0; h < sizeof(tb->insert_size) / sizeof (tb->insert_size[0]); h ++) {
+    if (PATH_H_PATH_OFFSET (tb->tb_path, h) <= tb->tb_path->path_length && 
+	PATH_H_PATH_OFFSET (tb->tb_path, h) > ILLEGAL_PATH_ELEMENT_OFFSET) {
+      tbSh = PATH_H_PBUFFER (tb->tb_path, h);
+      tbFh = PATH_H_PPARENT (tb->tb_path, h);
+    } else {
+      /*      printk ("print_tb: h=%d, PATH_H_PATH_OFFSET=%d, path_length=%d\n", 
+	      h, PATH_H_PATH_OFFSET (tb->tb_path, h), tb->tb_path->path_length);*/
+      tbSh = 0;
+      tbFh = 0;
+    }
+    printk ("* %d * %3ld(%2d) * %3ld(%2d) * %3ld(%2d) * %5ld * %5ld * %5ld * %5ld * %5ld *\n",
+	    h, 
+	    (tbSh) ? (tbSh->b_blocknr):(-1),
+	    (tbSh) ? tbSh->b_count : -1,
+	    (tb->L[h]) ? (tb->L[h]->b_blocknr):(-1),
+	    (tb->L[h]) ? tb->L[h]->b_count : -1,
+	    (tb->R[h]) ? (tb->R[h]->b_blocknr):(-1),
+	    (tb->R[h]) ? tb->R[h]->b_count : -1,
+	    (tbFh) ? (tbFh->b_blocknr):(-1),
+	    (tb->FL[h]) ? (tb->FL[h]->b_blocknr):(-1),
+	    (tb->FR[h]) ? (tb->FR[h]->b_blocknr):(-1),
+	    (tb->CFL[h]) ? (tb->CFL[h]->b_blocknr):(-1),
+	    (tb->CFR[h]) ? (tb->CFR[h]->b_blocknr):(-1));
+  }
+
+  printk ("*********************************************************************\n");
+
+
+  /* print balance parameters for leaf level */
+  h = 0;
+  printk ("* h * size * ln * lb * rn * rb * blkn * s0 * s1 * s1b * s2 * s2b * curb * lk * rk *\n");
+  printk ("* %d * %4d * %2d * %2d * %2d * %2d * %4d * %2d * %2d * %3d * %2d * %3d * %4d * %2d * %2d *\n",
+	  h, tb->insert_size[h], tb->lnum[h], tb->lbytes, tb->rnum[h],tb->rbytes, tb->blknum[h], 
+	  tb->s0num, tb->s1num,tb->s1bytes,  tb->s2num, tb->s2bytes, tb->cur_blknum, tb->lkey[h], tb->rkey[h]);
+
+
+/* this prints balance parameters for non-leaf levels */
+  do {
+    h++;
+    printk ("* %d * %4d * %2d *    * %2d *    * %2d *\n",
+    h, tb->insert_size[h], tb->lnum[h], tb->rnum[h], tb->blknum[h]);
+  } while (tb->insert_size[h]);
+
+  printk ("*********************************************************************\n");
+
+
+  /* print FEB list (list of buffers in form (bh (b_blocknr, b_count), that will be used for new nodes) */
+  h = 0;
+  for (i = 0; i < sizeof (tb->FEB) / sizeof (tb->FEB[0]); i ++)
+    printk ("%s%p (%lu %d)", i == 0 ? "FEB list: " : ", ", tb->FEB[i], tb->FEB[i] ? tb->FEB[i]->b_blocknr : 0,
+	    tb->FEB[i] ? tb->FEB[i]->b_count : 0);
+  printk ("\n");
+
+  printk ("********************** END OF PRINT_TB *******************\n\n");
+
+}
+
+
+void print_bmap_block (int i, struct buffer_head * bmap, int blocks, int silent)
+{
+    int j, k;
+    int bits = bmap->b_size * 8;
+    int zeros = 0, ones = 0;
+  
+    printk ("#%d: block %lu: ", i, bmap->b_blocknr);
+
+    if (test_bit (0, bmap->b_data)) {
+	/* first block addressed by this bitmap block is used */
+	ones ++;
+	if (!silent)
+	    printk ("Busy (%d-", i * bits);
+	for (j = 1; j < blocks; j ++) {
+	    while (test_bit (j, bmap->b_data)) {
+		ones ++;
+		if (j == blocks - 1) {
+		    if (!silent)
+			printk ("%d)\n", j + i * bits);
+		    goto end;
+		}
+		j++;
+	    }
+	    if (!silent)
+		printk ("%d) Free(%d-", j - 1 + i * bits, j + i * bits);
+
+	    while (!test_bit (j, bmap->b_data)) {
+		zeros ++;
+		if (j == blocks - 1) {
+		    if (!silent)
+			printk ("%d)\n", j + i * bits);
+		    goto end;
+		}
+		j++;
+	    }
+	    if (!silent)
+		printk ("%d) Busy(%d-", j - 1 + i * bits, j + i * bits);
+
+	    j --;
+	end:
+	}
+    } else {
+	/* first block addressed by this bitmap is free */
+	zeros ++;
+	if (!silent)
+	    printk ("Free (%d-", i * bits);
+	for (j = 1; j < blocks; j ++) {
+	    k = 0;
+	    while (!test_bit (j, bmap->b_data)) {
+		k ++;
+		if (j == blocks - 1) {
+		    if (!silent)
+			printk ("%d)\n", j + i * bits);
+		    zeros += k;
+		    goto end2;
+		}
+		j++;
+	    }
+	    zeros += k;
+	    if (!silent)
+		printk ("%d) Busy(%d-", j - 1 + i * bits, j + i * bits);
+	    
+	    k = 0;
+	    while (test_bit (j, bmap->b_data)) {
+		ones ++;
+		if (j == blocks - 1) {
+		    if (!silent)
+			printk ("%d)\n", j + i * bits);
+		    ones += k;
+		    goto end2;
+		}
+		j++;
+	    }
+	    ones += k;
+	    if (!silent)
+		printk ("%d) Free(%d-", j - 1 + i * bits, j + i * bits);
+	
+	    j --;
+	end2:
+	}
+    }
+
+    printk ("used %d, free %d\n", ones, zeros);
+}
+
+
+/* if silent == 1, do not print details */
+void print_bmap (struct super_block * s, int silent)
+{
+    int bmapnr = SB_BMAP_NR (s);
+    int i;
+    int blocks = s->s_blocksize * 8; /* adressed by bitmap */
+
+    printk ("Bitmap blocks are:\n");
+    for (i = 0; i < bmapnr; i ++) {
+
+	if (i == bmapnr - 1)
+	    if (SB_BLOCK_COUNT (s) % (s->s_blocksize * 8))
+		blocks = SB_BLOCK_COUNT (s) % (s->s_blocksize * 8);
+	print_bmap_block (i, SB_AP_BITMAP(s)[i], blocks, silent);
+    }
+
+    /* check unused part of last bitmap */
+    {
+	int bad_unused_bitmap = 0;
+	int ones;
+
+	ones = s->s_blocksize * 8 - SB_BLOCK_COUNT (s) % (s->s_blocksize * 8);
+	if (ones == s->s_blocksize * 8)
+	    ones = 0;
+      
+	for (i = s->s_blocksize * 8; --i >= blocks; )
+	    if (!test_bit (i, SB_AP_BITMAP (s)[bmapnr - 1]->b_data))
+		bad_unused_bitmap ++;
+
+	if (bad_unused_bitmap) {
+	    printk ("Unused part of bitmap is wrong: should be %d ones, found %d zeros\n",
+		    ones, bad_unused_bitmap);
+	}
+    }
+    
+}
+
+
+
+void print_objectid_map (struct super_block * s)
+{
+  int i;
+  struct reiserfs_super_block * rs;
+  unsigned long * omap;
+
+  rs = SB_DISK_SUPER_BLOCK (s);
+  omap = (unsigned long *)(rs + 1);
+  printk ("Map of objectids\n");
+      
+  for (i = 0; i < rs->s_oid_cursize; i ++) {
+    if (i % 2 == 0)
+      printk ("busy(%lu-%lu) ", omap[i], omap[i+1] - 1); 
+    else
+      printk ("free(%lu-%lu) ", 
+	      omap[i], ((i+1) == rs->s_oid_cursize) ? -1 : omap[i+1] - 1);
+    }
+  printk ("\n");
+  
+  printk ("Object id array has size %d (max %d):", rs->s_oid_cursize, 
+	  rs->s_oid_maxsize);
+  
+  for (i = 0; i < rs->s_oid_cursize; i ++)
+    printk ("%lu ", omap[i]); 
+  printk ("\n");
+
+}
+
+
+static void check_leaf_block_head (struct buffer_head * bh)
+{
+  struct block_head * blkh;
+
+  blkh = B_BLK_HEAD (bh);
+  if (le16_to_cpu (blkh->blk_nr_item) > (bh->b_size - BLKH_SIZE) / IH_SIZE)
+    reiserfs_panic (0, "vs-6010: check_leaf_block_head: invalid item number %z", bh);
+  if (le16_to_cpu (blkh->blk_free_space) > 
+      bh->b_size - BLKH_SIZE - IH_SIZE * le16_to_cpu (blkh->blk_nr_item))
+    reiserfs_panic (0, "vs-6020: check_leaf_block_head: invalid free space %z", bh);
+    
+}
+
+static void check_internal_block_head (struct buffer_head * bh)
+{
+  struct block_head * blkh;
+
+  return  ;
+  blkh = B_BLK_HEAD (bh);
+  if (!(le16_to_cpu (blkh->blk_level) > DISK_LEAF_NODE_LEVEL && le16_to_cpu (blkh->blk_level) <= MAX_HEIGHT))
+    reiserfs_panic (0, "vs-6025: check_internal_block_head: invalid level %z", bh);
+
+  if (le16_to_cpu (blkh->blk_nr_item) > (bh->b_size - BLKH_SIZE) / IH_SIZE)
+    reiserfs_panic (0, "vs-6030: check_internal_block_head: invalid item number %z", bh);
+
+  if (le16_to_cpu (blkh->blk_free_space) != 
+      bh->b_size - BLKH_SIZE - KEY_SIZE * le16_to_cpu (blkh->blk_nr_item) - DC_SIZE * (blkh->blk_nr_item + 1))
+    reiserfs_panic (0, "vs-6040: check_internal_block_head: invalid free space %z", bh);
+
+}
+
+
+void check_leaf (struct buffer_head * bh)
+{
+  int i;
+  struct item_head * ih;
+
+  if (!bh)
+    return;
+  check_leaf_block_head (bh);
+  for (i = 0, ih = B_N_PITEM_HEAD (bh, 0); i < B_NR_ITEMS (bh); i ++, ih ++) {
+    if (I_IS_DIRECTORY_ITEM (ih))
+      check_directory_item (bh, ih);
+  }
+}
+
+
+void check_internal (struct buffer_head * bh)
+{
+  if (!bh)
+    return;
+  check_internal_block_head (bh);
+}
+
+
+void print_statistics (struct super_block * s)
+{
+  /*
+  printk ("reiserfs_put_super: session statistics: balances %d, fix_nodes %d, preserve list freeings %d, \
+bmap with search %d, without %d, dir2ind %d, ind2dir %d\n",
+	  s->u.reiserfs_sb.s_do_balance, s->u.reiserfs_sb.s_fix_nodes, s->u.reiserfs_sb.s_preserve_list_freeings,
+	  s->u.reiserfs_sb.s_bmaps, s->u.reiserfs_sb.s_bmaps_without_search,
+	  s->u.reiserfs_sb.s_direct2indirect, s->u.reiserfs_sb.s_indirect2direct);
+  */
+
+}
Index: empeg/kernel/fs/reiserfs/resize.c
diff -u /dev/null empeg/kernel/fs/reiserfs/resize.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/resize.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,160 @@
+/* Copyright 1999 Hans Reiser, see README file for licensing details.
+ *
+ * Written by Alexander Zarochentcev.
+ *
+ * The kernel part of the (on-line) reiserfs resizer.
+ */
+
+#ifdef __KERNEL__
+
+#include <linux/kernel.h>
+#include <linux/vmalloc.h>
+#include <linux/locks.h>
+#include <linux/string.h>
+#include <linux/reiserfs_fs.h>
+#include <linux/reiserfs_fs_sb.h>
+
+#else
+
+#include "nokernel.h"
+
+#endif
+
+int reiserfs_resize (struct super_block * s, unsigned long block_count_new)
+{
+	struct reiserfs_super_block * sb;
+	struct buffer_head ** bitmap, * bh;
+	struct reiserfs_transaction_handle th;
+	unsigned int bmap_nr_new, bmap_nr;
+	unsigned int block_r_new, block_r;
+	
+	struct reiserfs_list_bitmap * jb;
+	char * jbitmap[JOURNAL_NUM_BITMAPS];
+	
+	unsigned long int block_count, free_blocks;
+	int i,j; 
+
+	sb = SB_DISK_SUPER_BLOCK(s);
+
+	if (SB_BLOCK_COUNT(s) >= block_count_new) {
+		printk("can\'t shrink filesystem on-line\n");
+		return 1;
+	}
+
+	/* check the device size */
+	bh = bread(s->s_dev, block_count_new - 1, s->s_blocksize);
+	if (!bh) {
+		printk("reiserfs_resize: can\'t read last block\n");
+		return 1;
+	}	
+	brelse(bh);
+
+	/* old disk layout detection; those partitions can be mounted, but
+	 * cannot be resized */
+	if (SB_BUFFER_WITH_SB(s)->b_blocknr *	SB_BUFFER_WITH_SB(s)->b_size 
+		!= REISERFS_DISK_OFFSET_IN_BYTES ) {
+		printk("reiserfs_resize: unable to resize a reiserfs without distributed bitmap (fs version < 3.5.12)\n");
+		return 1;
+	}
+
+	
+	/* count used bits in last bitmap block */
+	block_r = le32_to_cpu(SB_BLOCK_COUNT(s)) -
+	        (le16_to_cpu(SB_BMAP_NR(s)) - 1) * s->s_blocksize * 8;
+	
+	/* count bitmap blocks in new fs */
+	bmap_nr_new = block_count_new / ( s->s_blocksize * 8 );
+	block_r_new = block_count_new - bmap_nr_new * s->s_blocksize * 8;
+	if (block_r_new) 
+		bmap_nr_new++;
+	else
+		block_r_new = s->s_blocksize * 8;
+
+	/* save old values */
+	block_count = le32_to_cpu(SB_BLOCK_COUNT(s));
+	bmap_nr     = le16_to_cpu(SB_BMAP_NR(s));
+	free_blocks = le32_to_cpu(SB_FREE_BLOCKS(s));
+
+	/* begin transaction */
+	lock_super(s);
+	journal_begin(&th, s, 10);
+
+	/* reallocate journal bitmaps */
+	for (i = 0 ; i < JOURNAL_NUM_BITMAPS ; i++) {
+		jb = SB_JOURNAL(s)->j_list_bitmap + i;
+		jbitmap[i] = vmalloc(block_count_new / 8);
+		if (!jbitmap[i]) {
+			printk("reiserfs_resize: unable to allocate memory for journal bitmaps\n");
+			while (--i >= 0) 
+				vfree(jbitmap[i]);
+			return 1;
+		}
+		memset(jbitmap[i], 0, block_count_new / 8);
+		memcpy(jbitmap[i], jb->bitmap, block_count / 8);
+		for(j = bmap_nr; j < bmap_nr_new ; j++)
+			set_bit(j * s->s_blocksize * 8, jbitmap[i]);
+	}
+	for (i = 0 ; i < JOURNAL_NUM_BITMAPS ; i++) {
+		jb = SB_JOURNAL(s)->j_list_bitmap + i;
+		vfree(jb->bitmap);
+		jb->bitmap = jbitmap[i];
+	}	
+	
+	/* allocate additional bitmap blocks, reallocate array of bitmap
+	 * block pointers */
+	if (bmap_nr_new > bmap_nr) {
+		bitmap = reiserfs_kmalloc(sizeof(struct buffer_head *) * bmap_nr_new,
+								   GFP_KERNEL, s);
+		if (!bitmap) {
+			printk("reiserfs_resize: unable to allocate memory.\n");
+			journal_end(&th, s, 10);
+			unlock_super(s);
+			return 1;
+		}
+		for (i = 0; i < bmap_nr; i++)
+			bitmap[i] = SB_AP_BITMAP(s)[i];
+		for (i = bmap_nr; i < bmap_nr_new; i++) {
+			bitmap[i] = getblk(s->s_dev, i * s->s_blocksize * 8, s->s_blocksize);
+			if(!bitmap[i]) {
+				printk("reiserfs_resize: getblk() failed");
+				while (--i >= bmap_nr) 
+					brelse(bitmap[i]);
+				reiserfs_kfree(bitmap, 
+					sizeof(struct buffer_head *) * bmap_nr_new, s);
+				journal_end(&th, s, 10);
+				unlock_super(s);
+				return 1;
+			}
+			memset(bitmap[i]->b_data, 0, sb->s_blocksize);
+			set_bit(0, bitmap[i]->b_data);
+		}	
+		/* free old bitmap blocks array */
+		reiserfs_kfree(SB_AP_BITMAP(s), 
+			sizeof(struct buffer_head *) * bmap_nr, s);
+		SB_AP_BITMAP(s) = bitmap;
+	}
+
+	/* correct last bitmap blocks in old and new disk layout */
+	for (i = block_r; i < s->s_blocksize * 8; i++)
+		clear_bit(i, SB_AP_BITMAP(s)[bmap_nr - 1]->b_data);
+	for (i = block_r_new; i < s->s_blocksize * 8; i++)
+		set_bit(i, SB_AP_BITMAP(s)[bmap_nr_new - 1]->b_data);
+	
+	for (i = bmap_nr - 1; i < bmap_nr_new; i++)  
+		journal_mark_dirty_nolog(&th, s, SB_AP_BITMAP(s)[i]);
+/*	journal_mark_dirty(&th, s, SB_AP_BITMAP(s)[bmap_nr - 1]);
+ */
+	sb->s_free_blocks = cpu_to_le32(free_blocks + (block_count_new 
+		- block_count - (bmap_nr_new - bmap_nr)));
+	sb->s_block_count = cpu_to_le32(block_count_new);
+	sb->s_bmap_nr = cpu_to_le16(bmap_nr_new);
+	s->s_dirt = 1;
+
+	journal_mark_dirty(&th, s, SB_BUFFER_WITH_SB(s));
+	
+	journal_end(&th, s, 10);
+	unlock_super(s);
+
+	return 0;
+}
+
Index: empeg/kernel/fs/reiserfs/stree.c
diff -u /dev/null empeg/kernel/fs/reiserfs/stree.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/stree.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,2609 @@
+/*
+ *  Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
+ */
+
+/*
+ *  Written by Anatoly P. Pinchuk pap@namesys.botik.ru
+ *  Programm System Institute
+ *  Pereslavl-Zalessky Russia
+ */
+
+/*
+ *  This file contains functions dealing with S+tree
+ *
+ * comp_keys
+ * comp_short_keys
+ * bin_search
+ * get_lkey
+ * get_rkey
+ * key_in_buffer
+ * decrement_bcount
+ * decrement_counters_in_path
+ * pathrelse
+ * search_by_key
+ * search_for_position_by_key
+ * comp_items
+ * prepare_for_delete_or_cut
+ * calc_deleted_bytes_number
+ * init_tb_struct
+ * reiserfs_delete_item
+ * reiserfs_delete_object
+ * indirect_to_direct
+ * maybe_indirect_to_direct
+ * reiserfs_cut_from_item
+ * reiserfs_truncate_file
+ * reiserfs_paste_into_item
+ * reiserfs_insert_item
+ * get_buffer_by_range
+ * get_buffers_from_range
+ */
+#ifdef __KERNEL__
+
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/reiserfs_fs.h>
+
+#else
+
+#include "nokernel.h"
+
+#endif
+
+/* Does the buffer contain a disk block which is in the tree. */
+inline int B_IS_IN_TREE (struct buffer_head * p_s_bh)
+{
+
+#ifdef REISERFS_CHECK
+  if ( B_BLK_HEAD(p_s_bh)->blk_level > MAX_HEIGHT ) {
+    reiserfs_panic(0, "PAP-1010: B_IS_IN_TREE: block (%b) has too big level (%z)",
+		   p_s_bh, p_s_bh);
+  }
+#endif
+
+  return ( B_BLK_HEAD(p_s_bh)->blk_level != FREE_LEVEL );
+}
+
+
+inline void copy_key (void * to, void * from)
+{
+  memcpy (to, from, KEY_SIZE);
+}
+
+inline void copy_short_key (void * to, void * from)
+{
+  memcpy (to, from, SHORT_KEY_SIZE);
+}
+
+inline void copy_item_head(void * p_v_to, void * p_v_from)
+{
+  memcpy (p_v_to, p_v_from, IH_SIZE);
+}
+
+
+/*
+ Compare keys using all 4 key fields.
+ Returns:  -1 if key1 < key2
+            0 if key1 = key2
+            1 if key1 > key2
+*/
+inline int  comp_keys (void * k1, void * k2)
+{
+  __u32 * p_s_key1, * p_s_key2;
+  int n_key_length = REISERFS_FULL_KEY_LEN;
+
+  p_s_key1 = (__u32 *)k1;
+  p_s_key2 = (__u32 *)k2;
+  for( ; n_key_length--; ++p_s_key1, ++p_s_key2 ) {
+    if ( *p_s_key1 < *p_s_key2 )
+      return -1;
+    if ( *p_s_key1 > *p_s_key2 )
+      return 1;
+  }
+
+  return 0;
+}
+
+
+/*
+ Compare keys using REISERFS_SHORT_KEY_LEN fields.
+ Returns:  -1 if key1 < key2
+            0 if key1 = key2
+            1 if key1 > key2
+*/
+inline int  comp_short_keys (void * k1, void * k2)
+{
+  __u32 * p_s_key1, * p_s_key2;
+  int n_key_length = REISERFS_SHORT_KEY_LEN;
+
+  p_s_key1 = (__u32 *)k1;
+  p_s_key2 = (__u32 *)k2;
+
+  for( ; n_key_length--; ++p_s_key1, ++p_s_key2 ) {
+    if ( *p_s_key1 < *p_s_key2 )
+      return -1;
+    if ( *p_s_key1 > *p_s_key2 )
+      return 1;
+  }
+
+  return 0;
+}
+
+
+
+
+
+
+
+
+/**************************************************************************
+ *  Binary search toolkit function                                        *
+ *  Search for an item in the array by the item key                       *
+ *  Returns:    1 if found,  0 if not found;                              *
+ *        *p_n_pos = number of the searched element if found, else the    *
+ *        number of the first element that is larger than p_v_key.        *
+ **************************************************************************/
+/* For those not familiar with binary search: n_lbound is the leftmost item that it
+ could be, n_rbound the rightmost item that it could be.  We examine the item
+ halfway between n_lbound and n_rbound, and that tells us either that we can increase
+ n_lbound, or decrease n_rbound, or that we have found it, or if n_lbound <= n_rbound that
+ there are no possible items, and we have not found it. With each examination we
+ cut the number of possible items it could be by one more than half rounded down,
+ or we find it. */
+inline	int bin_search (
+              void    * p_v_key,    /* Key to search for.                   */
+	      void    * p_v_base,   /* First item in the array.             */
+	      int       p_n_num,    /* Number of items in the array.        */
+	      int       p_n_width,  /* Item size in the array.
+				       searched. Lest the reader be
+				       confused, note that this is crafted
+				       as a general function, and when it
+				       is applied specifically to the array
+				       of item headers in a node, p_n_width
+				       is actually the item header size not
+				       the item size.                      */
+	      int     * p_n_pos     /* Number of the searched for element. */
+            ) {
+  int   n_rbound, n_lbound, n_j;
+
+  for ( n_j = ((n_rbound = p_n_num - 1) + (n_lbound = 0))/2; n_lbound <= n_rbound; n_j = (n_rbound + n_lbound)/2 )
+    switch( COMP_KEYS(((char * )p_v_base + n_j * p_n_width), p_v_key) )  {
+    case -1: n_lbound = n_j + 1; continue;
+    case  1: n_rbound = n_j - 1; continue;
+    case  0: *p_n_pos = n_j;     return ITEM_FOUND; /* Key found in the array.  */
+    }
+
+  /* bin_search did not find given key, it returns position of key,
+     that is minimal and greater than the given one. */
+  *p_n_pos = n_lbound;
+  return ITEM_NOT_FOUND;
+}
+
+#ifdef REISERFS_CHECK
+extern struct tree_balance * cur_tb;
+extern struct tree_balance init_tb;
+extern int init_item_pos, init_pos_in_item, init_mode;
+#endif
+
+
+
+/* Minimal possible key. It is never in the tree. */
+struct key  MIN_KEY = {0, 0, 0, 0};
+
+/* Maximal possible key. It is never in the tree. */
+struct key  MAX_KEY = {0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff};
+
+
+/* Get delimiting key of the buffer by looking for it in the buffers in the path, starting from the bottom
+   of the path, and going upwards.  We must check the path's validity at each step.  If the key is not in
+   the path, there is no delimiting key in the tree (buffer is first or last buffer in tree), and in this
+   case we return a special key, either MIN_KEY or MAX_KEY. */
+inline	struct  key * get_lkey  (
+	                struct path         * p_s_chk_path,
+                        struct super_block  * p_s_sb
+                      ) {
+  int                   n_position, n_path_offset = p_s_chk_path->path_length;
+  struct buffer_head  * p_s_parent;
+  
+#ifdef REISERFS_CHECK
+  if ( n_path_offset < FIRST_PATH_ELEMENT_OFFSET )
+    reiserfs_panic(p_s_sb,"PAP-5010: get_lkey: illegal offset in the path");
+#endif
+
+  /* While not higher in path than first element. */
+  while ( n_path_offset-- > FIRST_PATH_ELEMENT_OFFSET ) {
+
+#ifdef REISERFS_CHECK
+    if ( ! buffer_uptodate(PATH_OFFSET_PBUFFER(p_s_chk_path, n_path_offset)) )
+      reiserfs_panic(p_s_sb, "PAP-5020: get_lkey: parent is not uptodate");
+#endif
+
+    /* Parent at the path is not in the tree now. */
+    if ( ! B_IS_IN_TREE(p_s_parent = PATH_OFFSET_PBUFFER(p_s_chk_path, n_path_offset)) )
+      return &MAX_KEY;
+    /* Check whether position in the parent is correct. */
+    if ( (n_position = PATH_OFFSET_POSITION(p_s_chk_path, n_path_offset)) > B_NR_ITEMS(p_s_parent) )
+       return &MAX_KEY;
+    /* Check whether parent at the path really points to the child. */
+    if ( B_N_CHILD_NUM(p_s_parent, n_position) !=
+	 PATH_OFFSET_PBUFFER(p_s_chk_path, n_path_offset + 1)->b_blocknr )
+      return &MAX_KEY;
+    /* Return delimiting key if position in the parent is not equal to zero. */
+    if ( n_position )
+      return B_N_PDELIM_KEY(p_s_parent, n_position - 1);
+  }
+  /* Return MIN_KEY if we are in the root of the buffer tree. */
+  if ( PATH_OFFSET_PBUFFER(p_s_chk_path, FIRST_PATH_ELEMENT_OFFSET)->b_blocknr ==
+                                      p_s_sb->u.reiserfs_sb.s_rs->s_root_block )
+    return &MIN_KEY;
+  return  &MAX_KEY;
+}
+
+
+/* Get delimiting key of the buffer at the path and its right neighbor. */
+inline	struct  key * get_rkey  (
+	                struct path         * p_s_chk_path,
+                        struct super_block  * p_s_sb
+                      ) {
+  int                   n_position,
+    			n_path_offset = p_s_chk_path->path_length;
+  struct buffer_head  * p_s_parent;
+
+#ifdef REISERFS_CHECK
+  if ( n_path_offset < FIRST_PATH_ELEMENT_OFFSET )
+    reiserfs_panic(p_s_sb,"PAP-5030: get_rkey: illegal offset in the path");
+#endif
+
+  while ( n_path_offset-- > FIRST_PATH_ELEMENT_OFFSET ) {
+
+#ifdef REISERFS_CHECK
+    if ( ! buffer_uptodate(PATH_OFFSET_PBUFFER(p_s_chk_path, n_path_offset)) )
+      reiserfs_panic(p_s_sb, "PAP-5040: get_rkey: parent is not uptodate");
+#endif
+
+    /* Parent at the path is not in the tree now. */
+    if ( ! B_IS_IN_TREE(p_s_parent = PATH_OFFSET_PBUFFER(p_s_chk_path, n_path_offset)) )
+      return &MIN_KEY;
+    /* Check whether position in the parrent is correct. */
+    if ( (n_position = PATH_OFFSET_POSITION(p_s_chk_path, n_path_offset)) > B_NR_ITEMS(p_s_parent) )
+      return &MIN_KEY;
+    /* Check whether parent at the path really points to the child. */
+    if ( B_N_CHILD_NUM(p_s_parent, n_position) !=
+                                        PATH_OFFSET_PBUFFER(p_s_chk_path, n_path_offset + 1)->b_blocknr )
+      return &MIN_KEY;
+    /* Return delimiting key if position in the parent is not the last one. */
+    if ( n_position != B_NR_ITEMS(p_s_parent) )
+      return B_N_PDELIM_KEY(p_s_parent, n_position);
+  }
+  /* Return MAX_KEY if we are in the root of the buffer tree. */
+  if ( PATH_OFFSET_PBUFFER(p_s_chk_path, FIRST_PATH_ELEMENT_OFFSET)->b_blocknr ==
+       p_s_sb->u.reiserfs_sb.s_rs->s_root_block )
+    return &MAX_KEY;
+  return  &MIN_KEY;
+}
+
+
+/* Check whether a key is contained in the tree rooted from a buffer at a path. */
+/* This works by looking at the left and right delimiting keys for the buffer in the last path_element in
+   the path.  These delimiting keys are stored at least one level above that buffer in the tree. If the
+   buffer is the first or last node in the tree order then one of the delimiting keys may be absent, and in
+   this case get_lkey and get_rkey return a special key which is MIN_KEY or MAX_KEY. */
+static  inline  int key_in_buffer (
+                      struct path         * p_s_chk_path, /* Path which should be checked.  */
+                      struct key          * p_s_key,      /* Key which should be checked.   */
+                      struct super_block  * p_s_sb        /* Super block pointer.           */
+		      ) {
+
+#ifdef REISERFS_CHECK
+  if ( ! p_s_key || p_s_chk_path->path_length < FIRST_PATH_ELEMENT_OFFSET ||
+       p_s_chk_path->path_length > MAX_HEIGHT )
+    reiserfs_panic(p_s_sb, "PAP-5050: key_in_buffer:  pointer to the key(%p) is NULL or illegal path length(%d)",
+		   p_s_key, p_s_chk_path->path_length);
+  
+  if ( PATH_PLAST_BUFFER(p_s_chk_path)->b_dev == NODEV )
+    reiserfs_panic(p_s_sb, "PAP-5060: key_in_buffer: device must not be NODEV");
+#endif
+
+  if ( COMP_KEYS(get_lkey(p_s_chk_path, p_s_sb), p_s_key) == 1 )
+    return 0;
+  if ( COMP_KEYS(p_s_key, get_rkey(p_s_chk_path, p_s_sb)) != -1 )
+    return 0;
+  return 1;
+}
+
+
+inline void decrement_bcount(
+              struct buffer_head  * p_s_bh
+            ) { 
+  if ( p_s_bh ) {
+    if ( p_s_bh->b_count ) {
+      p_s_bh->b_count--;
+      return;
+    }
+    reiserfs_panic(NULL, "PAP-5070: decrement_bcount: trying to free free buffer %b", p_s_bh);
+  }
+}
+
+
+/* Decrement b_count field of the all buffers in the path. */
+void decrement_counters_in_path (
+              struct path * p_s_search_path
+            ) {
+  int n_path_offset = p_s_search_path->path_length;
+
+#ifdef REISERFS_CHECK
+  if ( n_path_offset < ILLEGAL_PATH_ELEMENT_OFFSET ||
+       n_path_offset > EXTENDED_MAX_HEIGHT - 1 )
+    reiserfs_panic(NULL, "PAP-5080: decrement_counters_in_path: illegal path offset of %d", n_path_offset);
+#endif
+
+  while ( n_path_offset > ILLEGAL_PATH_ELEMENT_OFFSET )
+    decrement_bcount(PATH_OFFSET_PBUFFER(p_s_search_path, n_path_offset--));
+  p_s_search_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;
+}
+
+
+/* Release all buffers in the path. */
+void  pathrelse (
+        struct path * p_s_search_path
+      ) {
+  int n_path_offset = p_s_search_path->path_length;
+
+#ifdef REISERFS_CHECK
+  if ( n_path_offset < ILLEGAL_PATH_ELEMENT_OFFSET )
+    reiserfs_panic(NULL, "PAP-5090: pathrelse: illegal path offset");
+#endif
+  
+  while ( n_path_offset > ILLEGAL_PATH_ELEMENT_OFFSET ) 
+    brelse(PATH_OFFSET_PBUFFER(p_s_search_path, n_path_offset--));
+
+  p_s_search_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;
+}
+
+
+#ifdef SEARCH_BY_KEY_READA
+
+static int search_by_key_reada (struct super_block * s, int blocknr)
+{
+  struct buffer_head * bh;
+  int repeat;
+  
+  repeat = CARRY_ON;
+  if (blocknr == 0)
+    return CARRY_ON;
+
+  bh = reiserfs_getblk (s->s_dev, blocknr, s->s_blocksize, &repeat);
+  
+  if (!buffer_uptodate (bh)) {
+    ll_rw_block (READA, 1, &bh);
+    repeat = SCHEDULE_OCCURRED;
+  }
+  bh->b_count --;
+  return repeat;
+}
+
+#endif
+
+/**************************************************************************
+ * Algorithm   SearchByKey                                                *
+ *             look for item in the Disk S+Tree by its key                *
+ * Input:  p_s_sb   -  super block                                        *
+ *         p_s_key  - pointer to the key to search                        *
+ * Output: true value -  1 - found,  0 - not found                        *
+ *         p_s_search_path - path from the root to the needed leaf        *
+ **************************************************************************/
+
+/* This function fills up the path from the root to the leaf as it
+   descends the tree looking for the key.  It uses reiserfs_bread to
+   try to find buffers in the cache given their block number.  If it
+   does not find them in the cache it reads them from disk.  For each
+   node search_by_key finds using reiserfs_bread it then uses
+   bin_search to look through that node.  bin_search will find the
+   position of the block_number of the next node if it is looking
+   through an internal node.  If it is looking through a leaf node
+   bin_search will find the position of the item which has key either
+   equal to given key, or which is the maximal key less than the given
+   key.  search_by_key returns a path that must be checked for the
+   correctness of the top of the path but need not be checked for the
+   correctness of the bottom of the path */
+int search_by_key(
+                  struct super_block  * p_s_sb,         /* Super block.                           */
+                  struct key          * p_s_key,        /* Key to search.                         */
+                  struct path         * p_s_search_path,/* This structure was allocated and initialized by
+                                                           the calling function. It is filled up by this
+                                                           function.  */
+                  int                 * p_n_repeat,     /* Whether schedule occured. */
+                  int                   n_stop_level,   /* How far down the tree to search.*/
+                  int                   n_bread_par     /* Whether to search even if it requires disk I/O, this is
+                                                           either READ_BLOCKS or DONT_READ_BLOCKS or 0. Hans doesn't
+                                                           know what 0 means, it seems to evaluate to DONT_READ_BLOCKS,
+                                                           but it is bad style to not use the macro.... there is a
+                                                           #define of search by key with no explanation that can allow
+                                                           it to happen.... */
+                  ) {
+    kdev_t                      n_dev           = p_s_sb->s_dev;
+    int                         n_repeat,
+                                n_block_number  = p_s_sb->u.reiserfs_sb.s_rs->s_root_block,
+                                n_block_size    = p_s_sb->s_blocksize;
+    struct buffer_head  *       p_s_bh;
+    struct path_element *       p_s_last_element;
+    int				n_node_level, n_retval;
+    int 			right_neighbor_of_leaf_node;
+
+#ifdef REISERFS_CHECK
+    int n_repeat_counter = 0;
+#endif
+
+    /* As we add each node to a path we increase its count.  This means that we must be careful to
+       release all nodes in a path before we either discard the path struct or re-use the path
+       struct, as we do here. */
+
+    decrement_counters_in_path(p_s_search_path);
+
+    *p_n_repeat = CARRY_ON;
+    right_neighbor_of_leaf_node = 0;
+
+    /* With each iteration of this loop we search through the items in the current node, and
+       calculate the next current node(next path element) for the next iteration of this loop.. */
+    while ( 1 ) {
+
+#ifdef REISERFS_CHECK
+      if ( !(++n_repeat_counter % 50000) )
+	printk ("PAP-5100: search_by_key(pid %u): there were %d searches from the tree_root lokking for key %p\n",
+			  current->pid, n_repeat_counter, p_s_key);
+#endif
+
+      /* prep path to have another element added to it. */
+      p_s_last_element = PATH_OFFSET_PELEMENT(p_s_search_path, ++p_s_search_path->path_length);
+      n_repeat = CARRY_ON;
+
+      if ( n_bread_par == READ_BLOCKS ) { 
+	/* schedule read of right neighbor */
+#ifdef SEARCH_BY_KEY_READA
+	n_repeat |= search_by_key_reada (p_s_sb, right_neighbor_of_leaf_node);
+#endif
+
+	/* Read the next tree node, and set the last element in the path to have a pointer to it. */
+	if ( ! (p_s_bh = p_s_last_element->pe_buffer =
+		reiserfs_bread(n_dev, n_block_number, n_block_size, &n_repeat)) ) {
+	  p_s_search_path->path_length --;
+	  pathrelse(p_s_search_path);
+	  *p_n_repeat |= n_repeat;
+	  return ITEM_NOT_FOUND;	/* IO error */
+	}
+      }
+      else { /* We are looking for the next tree node in cache. */
+	p_s_bh = p_s_last_element->pe_buffer = reiserfs_getblk(n_dev, n_block_number, n_block_size, &n_repeat);
+      }
+
+      *p_n_repeat |= n_repeat;
+
+      /* It is possible that schedule occured. We must check whether the key to search is still in
+	 the tree rooted from the current buffer. If not then repeat search from the root. */
+      if ( n_repeat != CARRY_ON && ((buffer_uptodate (p_s_bh) && !B_IS_IN_TREE (p_s_bh)) ||
+				    (! key_in_buffer(p_s_search_path, p_s_key, p_s_sb))) ) { /* in fact this checks whether path is correct */
+	decrement_counters_in_path(p_s_search_path);
+	
+	/* Get the root block number so that we can repeat the search starting from the root. */
+	n_block_number  = p_s_sb->u.reiserfs_sb.s_rs->s_root_block;
+
+	right_neighbor_of_leaf_node = 0;
+
+	/* repeat search from the root */
+	continue;
+      }
+      
+#ifdef REISERFS_CHECK
+
+      if ( ! key_in_buffer(p_s_search_path, p_s_key, p_s_sb) )
+	reiserfs_panic(p_s_sb, "PAP-5130: search_by_key: key is not in the buffer");
+      if ( cur_tb ) {
+/*	print_tb (init_mode, init_item_pos, init_pos_in_item, &init_tb, "5140");*/
+	reiserfs_panic(p_s_sb, "PAP-5140: search_by_key: schedule occurred in do_balance!");
+      }
+
+#endif
+
+      if ( ! buffer_uptodate(p_s_bh) ) {
+
+#ifdef REISERFS_CHECK
+	if ( n_bread_par != DONT_READ_BLOCKS )
+	  reiserfs_panic(p_s_sb, "PAP-5150: search_by_key: buffer is not uptodate in case of READ_BLOCKS");
+#endif
+
+	return ITEM_NOT_FOUND; /* We can not continue search in the cache. */
+      }
+
+      /* ok, we have acquired next formatted node in the tree */
+      n_node_level = B_BLK_HEAD(p_s_bh)->blk_level;
+
+#ifdef REISERFS_CHECK
+
+      if (n_node_level < n_stop_level)
+	reiserfs_panic (p_s_sb, "vs-5152: search_by_key: tree level is less than stop level (%d)",
+			n_node_level, n_stop_level);
+
+#endif
+
+      n_retval = bin_search (p_s_key, B_N_PITEM_HEAD(p_s_bh, 0), B_NR_ITEMS(p_s_bh),
+		       ( n_node_level == DISK_LEAF_NODE_LEVEL ) ? IH_SIZE : KEY_SIZE, &(p_s_last_element->pe_position));
+      if (n_node_level == n_stop_level)
+	return n_retval;
+
+      /* we are not in the stop level */
+      if (n_retval == ITEM_FOUND)
+	/* item has been found, so we choose the pointer which is to the right of the found one */
+	p_s_last_element->pe_position++;
+      /* if item was not found we choose the position which is to the left of the found item. This
+	 requires no code, bin_search did it already.*/
+
+
+      /* So we have chosen a position in the current node which is an
+	 internal node.  Now we calculate child block number by position in the node. */
+      n_block_number = B_N_CHILD_NUM(p_s_bh, p_s_last_element->pe_position);
+
+#ifdef SEARCH_BY_KEY_READA
+      /* if we are going to read leaf node, then calculate its right neighbor if possible */
+      if (n_node_level == DISK_LEAF_NODE_LEVEL + 1 && p_s_last_element->pe_position < B_NR_ITEMS (p_s_bh))
+	right_neighbor_of_leaf_node = B_N_CHILD_NUM(p_s_bh, p_s_last_element->pe_position + 1);
+#endif
+    }
+}
+
+
+/* Form the path to an item and position in this item which contains file byte defined by p_s_key. If there
+    is no such item corresponding to the key, we point the path to the item with maximal key less than
+    p_s_key, and *p_n_pos_in_item is set to one past the last entry/byte in the item.  If searching for
+    entry in a directory item, and it is not found, *p_n_pos_in_item is set to one entry more than the entry with
+    maximal key which is less than the sought key.  
+
+    Note that if there is no entry in this same node which is one more, then we point to an imaginary entry.
+
+    for direct items, the position is in units of bytes, for
+    indirect items the position is in units of blocknr entries, for directory items the position is in units
+    of directory entries.  */
+int search_for_position_by_key (
+      struct super_block  * p_s_sb,         /* Pointer to the super block.          */
+      struct key          * p_s_key,        /* Key to search.                       */
+      struct path         * p_s_search_path,/* Filled up by this function.          */
+      int		  * p_n_pos_in_item,/* returned value, which is the found position in the item */
+      int                 * p_n_repeat	    /* Whether schedule occured. */
+    ) {
+  struct item_head    * p_s_ih;
+  int                   n_blk_size;
+
+  /* If searching for directory entry. */
+  if ( KEY_IS_DIRECTORY_KEY(p_s_key) )
+    return  search_by_entry_key(p_s_sb, p_s_key, p_s_search_path, p_n_pos_in_item, p_n_repeat);
+
+  /* If not searching for directory entry. */
+
+  /* If item is found. */
+  if ( search_by_key(p_s_sb, p_s_key, p_s_search_path, p_n_repeat, DISK_LEAF_NODE_LEVEL, READ_BLOCKS) == ITEM_FOUND )  {
+
+#ifdef REISERFS_CHECK
+    if ( ! B_N_PITEM_HEAD(PATH_PLAST_BUFFER(p_s_search_path),
+			  PATH_LAST_POSITION(p_s_search_path))->ih_item_len )
+      reiserfs_panic(p_s_sb, "PAP-5165: search_for_position_by_key: item length equals zero");
+#endif
+
+    *p_n_pos_in_item = 0;
+    return POSITION_FOUND;
+  }
+
+#ifdef REISERFS_CHECK
+  if ( ! PATH_LAST_POSITION(p_s_search_path) )
+    reiserfs_panic(p_s_sb, "PAP-5170: search_for_position_by_key: position equals zero");
+#endif
+
+  /* Item is not found. Set path to the previous item. */
+  p_s_ih = B_N_PITEM_HEAD(PATH_PLAST_BUFFER(p_s_search_path), --PATH_LAST_POSITION(p_s_search_path));
+  n_blk_size = p_s_sb->s_blocksize;
+
+/*#ifdef REISERFS_CHECK */
+  if ( COMP_SHORT_KEYS(&(p_s_ih->ih_key), p_s_key) ) {
+    reiserfs_panic(p_s_sb, "PAP-5180: search_for_position_by_key: found item %h belongs to an other object %k",
+		   p_s_ih, p_s_key);
+  }
+
+  if ( ! I_IS_STAT_DATA_ITEM(p_s_ih) && ((KEY_IS_INDIRECT_KEY(p_s_key) && ! I_IS_INDIRECT_ITEM(p_s_ih)) ||
+					 (KEY_IS_DIRECT_KEY(p_s_key) && ! I_IS_DIRECT_ITEM(p_s_ih))) ) {
+    print_block (PATH_PLAST_BUFFER(p_s_search_path), PRINT_LEAF_ITEMS, 
+		 PATH_LAST_POSITION (p_s_search_path) - 2,
+		 PATH_LAST_POSITION (p_s_search_path) + 2);
+    reiserfs_panic(p_s_sb, "PAP-5190: search_for_position_by_key: found item %h type does not match to the expected one %k",
+		   p_s_key, p_s_ih);
+  }
+/*#endif*/
+
+  /* Needed byte is contained in the item pointed to by the path.*/
+  if ( I_K_KEY_IN_ITEM(p_s_ih, p_s_key, n_blk_size) )  {
+    *p_n_pos_in_item = p_s_key->k_offset - p_s_ih->ih_key.k_offset;
+    if ( I_IS_INDIRECT_ITEM(p_s_ih) )
+      *p_n_pos_in_item /= n_blk_size;
+    return POSITION_FOUND;
+  }
+
+  /* Needed byte is not contained in the item pointed to by the path. Set *p_n_pos_in_item out of the
+     item. */
+  if ( I_IS_INDIRECT_ITEM(p_s_ih) )
+    *p_n_pos_in_item = I_UNFM_NUM(p_s_ih);
+  else
+    *p_n_pos_in_item = p_s_ih->ih_item_len;
+  return POSITION_NOT_FOUND;
+}
+
+
+/* Compare given item and item pointed to by the path. */
+int comp_items(
+      struct item_head  * p_s_ih,
+      struct path       * p_s_path
+    ) {
+  struct buffer_head  * p_s_bh;
+  struct item_head    * p_s_path_item;
+
+  /* Last buffer at the path is not in the tree. */
+  if ( ! B_IS_IN_TREE(p_s_bh = PATH_PLAST_BUFFER(p_s_path)) )
+    return 1;
+
+#ifdef REISERFS_CHECK
+    if ( p_s_bh->b_dev == NODEV )
+      reiserfs_panic(0, "PAP-5200: comp_items: device is invalid");
+#endif
+
+  /* Last path position is invalid. */
+  if ( PATH_LAST_POSITION(p_s_path) >= B_NR_ITEMS(p_s_bh) )
+    return 1;
+  /* Get item at the path. */
+  p_s_path_item = PATH_PITEM_HEAD(p_s_path);
+  /* Compare keys. */
+  if ( COMP_KEYS(p_s_path_item, p_s_ih) )
+    return 1;
+  /* Compare other items fields. */
+  if ( p_s_path_item->u.ih_free_space != p_s_ih->u.ih_free_space ||
+       p_s_path_item->ih_item_len != p_s_ih->ih_item_len ||
+       p_s_path_item->ih_item_location != p_s_ih->ih_item_location )
+    return 1;
+  /* Items are equal. */
+  return 0;
+}
+
+
+/*  If the path points to a directory or direct item, calculate mode and the size cut, for balance.
+    If the path points to an indirect item, remove some number of its unformatted nodes.
+    In case of file truncate calculate whether this item must be deleted/truncated or last
+    unformatted node of this item will be converted to a direct item.
+    This function returns a determination of what balance mode the calling function should employ. */
+static char  prepare_for_delete_or_cut(
+    struct reiserfs_transaction_handle *th,
+    struct inode * inode,
+    struct path         * p_s_path,
+    struct key          * p_s_item_key,
+    int                 * p_n_pos_in_item,
+    int                 * p_n_removed,      /* Number of unformatted nodes which were removed
+					       from end of the file. */
+    int                 * p_n_cut_size,
+    unsigned long         n_new_file_length, /* MAX_KEY_OFFSET in case of delete. */
+    int		      preserve_mode,
+    int * was_unfm_suspected_recipient
+    ) {
+    struct super_block  * p_s_sb = inode->i_sb;
+    struct item_head    * p_s_ih = PATH_PITEM_HEAD(p_s_path);
+    struct buffer_head  * p_s_bh = PATH_PLAST_BUFFER(p_s_path);
+
+#ifdef REISERFS_CHECK
+    int n_repeat_counter = 0;
+#endif
+
+    /* Stat_data item. */
+    if ( I_IS_STAT_DATA_ITEM(p_s_ih) ) {
+
+#ifdef REISERFS_CHECK
+	if ( n_new_file_length != MAX_KEY_OFFSET )
+	    reiserfs_panic(p_s_sb, "PAP-5210: prepare_for_delete_or_cut: mode must be M_DELETE");
+#endif
+
+	*p_n_cut_size = -(IH_SIZE + p_s_ih->ih_item_len);
+	return M_DELETE;
+    }
+
+    /* Directory item. */
+    if ( I_IS_DIRECTORY_ITEM(p_s_ih) ) {
+	if (p_s_ih->ih_key.k_offset == DOT_OFFSET && n_new_file_length == MAX_KEY_OFFSET) {
+#ifdef REISERFS_CHECK
+	    if (p_s_ih->ih_key.k_uniqueness != DIRENTRY_UNIQUENESS/*DOT_UNIQUENESS*/ || I_ENTRY_COUNT (p_s_ih) != 2)
+		reiserfs_panic(p_s_sb,"PAP-5220: prepare_for_delete_or_cut: "
+			       "empty directory item has uniqueness==%lu and entry count==%d", 
+			       p_s_ih->ih_key.k_uniqueness, I_ENTRY_COUNT (p_s_ih));
+#endif
+	    *p_n_cut_size = -(IH_SIZE + p_s_ih->ih_item_len);
+	    return M_DELETE; /* Delete the directory item containing "." and ".." entry. */
+	}
+
+	if ( I_ENTRY_COUNT(p_s_ih) == 1 )  {
+	    *p_n_cut_size = -(IH_SIZE + p_s_ih->ih_item_len);
+	    return M_DELETE; /* Delete the directory item such as there is one record only in this item. */
+	}
+	*p_n_cut_size = -(DEH_SIZE +
+			  I_DEH_N_ENTRY_LENGTH(p_s_ih, B_I_DEH(p_s_bh,p_s_ih) +
+					       *p_n_pos_in_item, *p_n_pos_in_item));
+	return M_CUT; /* Cut one record from the directory item. */
+    }
+
+#ifdef REISERFS_CHECK
+    if ( ! p_s_ih->ih_key.k_offset )
+	reiserfs_panic(p_s_sb, "PAP-5230: prepare_for_delete_or_cut: k_offset is NULL");
+#endif
+
+    /* Direct item. */
+    if ( I_IS_DIRECT_ITEM(p_s_ih) ) {
+	if ( n_new_file_length == MAX_KEY_OFFSET ) { /* Case of delete. */
+	    *p_n_cut_size = -(IH_SIZE + p_s_ih->ih_item_len);
+	    return M_DELETE; /* Delete this item. */
+	}
+	/* Case of truncate. */
+	if ( n_new_file_length < p_s_ih->ih_key.k_offset )  {
+	    *p_n_cut_size = -(IH_SIZE + p_s_ih->ih_item_len);
+	    return M_DELETE; /* Delete this item. */
+	}
+	/* Calculate first position and size for cutting from item. */
+	*p_n_cut_size = -(p_s_ih->ih_item_len -
+			  (*p_n_pos_in_item = n_new_file_length + 1 - p_s_ih->ih_key.k_offset));
+	return M_CUT; /* Cut from this item. */
+    }
+
+    /* Case of an indirect item. */
+    {
+	int                   n_unfm_number,    /* Number of the item unformatted nodes. */
+	    n_counter,
+	    n_repeat,
+	    n_retry,        /* Set to one if there is unformatted node buffer in use. */
+	    n_blk_size;
+	unsigned long       * p_n_unfm_pointer; /* Pointer to the unformatted node number. */
+	struct item_head      s_ih;           /* Item header. */
+	char                  c_mode;           /* Returned mode of the balance. */
+	struct buffer_head  * p_s_un_bh;
+
+
+	n_blk_size = p_s_sb->s_blocksize;
+
+	/* Search for the needed object indirect item until there are no unformatted nodes to be removed. */
+	do  {
+	    /* Copy indirect item header to a temp variable. */
+	    copy_item_head(&s_ih, PATH_PITEM_HEAD(p_s_path));
+	    /* Calculate number of unformatted nodes in this item. */
+	    n_unfm_number = I_UNFM_NUM(&s_ih);
+
+#ifdef REISERFS_CHECK
+	    if ( ! I_IS_INDIRECT_ITEM(&s_ih) || ! n_unfm_number ||
+		 *p_n_pos_in_item + 1 !=  n_unfm_number ) {
+		printk("n_unfm_number = %d *p_n_pos_in_item = %d\n",n_unfm_number, *p_n_pos_in_item);
+		reiserfs_panic(p_s_sb, "PAP-5240: prepare_for_delete_or_cut: illegal item %h", &s_ih);
+	    }
+#endif
+
+	    /* Calculate balance mode and position in the item to remove unformatted nodes. */
+	    if ( n_new_file_length == MAX_KEY_OFFSET ) {/* Case of delete. */
+		*p_n_pos_in_item = 0;
+		*p_n_cut_size = -(IH_SIZE + s_ih.ih_item_len);
+		c_mode = M_DELETE;
+	    }
+	    else  { /* Case of truncate. */
+		if ( n_new_file_length < s_ih.ih_key.k_offset )  {
+		    *p_n_pos_in_item = 0;
+		    *p_n_cut_size = -(IH_SIZE + s_ih.ih_item_len);
+		    c_mode = M_DELETE; /* Delete this item. */
+		}
+		else  {
+		    /* indirect item must be truncated starting from *p_n_pos_in_item-th position */
+		    *p_n_pos_in_item = (n_new_file_length + n_blk_size - s_ih.ih_key.k_offset ) / n_blk_size;
+
+#ifdef REISERFS_CHECK
+		    if ( *p_n_pos_in_item > n_unfm_number ) 
+			reiserfs_panic(p_s_sb, "PAP-5250: prepare_for_delete_or_cut: illegal position in the item");
+#endif
+
+		    /* Either convert last unformatted node of indirect item to direct item or increase
+		       its free space.  */
+		    if ( *p_n_pos_in_item == n_unfm_number )  {
+			*p_n_cut_size = 0; /* Nothing to cut. */
+			return M_CONVERT; /* Maybe convert last unformatted node to the direct item. */
+		    }
+		    /* Calculate size to cut. */
+		    *p_n_cut_size = -(s_ih.ih_item_len - *p_n_pos_in_item * UNFM_P_SIZE);
+
+		    c_mode = M_CUT;     /* Cut from this indirect item. */
+		}
+	    }
+
+#ifdef REISERFS_CHECK
+	    if ( n_unfm_number <= *p_n_pos_in_item ) 
+		reiserfs_panic(p_s_sb, "PAP-5260: prepare_for_delete_or_cut: illegal position in the indirect item");
+#endif
+
+	    /* pointers to be cut */
+	    n_unfm_number -= *p_n_pos_in_item;
+	    /* Set pointer to the last unformatted node pointer that is to be cut. */
+	    p_n_unfm_pointer = (unsigned long *)B_I_PITEM(PATH_PLAST_BUFFER(p_s_path),&s_ih) + I_UNFM_NUM(&s_ih) - 1 - *p_n_removed;
+
+	    /* We go through the unformatted nodes pointers of the indirect item and look for
+	       the unformatted nodes in the cache. If we found some of them we free it and zero
+	       corresponding indirect item entry. If some unformatted node has b_count > 1 we must
+	       not free this unformatted node since it is in use. */
+	    for ( n_retry = 0, n_counter = *p_n_removed;
+		  n_counter < n_unfm_number; n_counter++, p_n_unfm_pointer-- )  {
+		if (comp_items(&s_ih, p_s_path))
+		    break;
+#ifdef REISERFS_CHECK
+		if (p_n_unfm_pointer < (unsigned long *)B_I_PITEM(PATH_PLAST_BUFFER(p_s_path),&s_ih) ||
+		    p_n_unfm_pointer > (unsigned long *)B_I_PITEM(PATH_PLAST_BUFFER(p_s_path),&s_ih) + I_UNFM_NUM(&s_ih) - 1)
+		    reiserfs_panic (p_s_sb, "vs-5265: prepare_for_delete_or_cut: pointer out of range");
+#endif
+		if ( ! *p_n_unfm_pointer )  { /* Hole, nothing to remove. */
+		    if ( ! n_retry )
+			(*p_n_removed)++;
+		    continue;
+		}
+		/* Search for the buffer in cache. */
+		n_repeat = CARRY_ON;
+		p_s_un_bh = reiserfs_get_hash_table(p_s_sb->s_dev, *p_n_unfm_pointer,
+						    n_blk_size, &n_repeat);
+		/* Current item was shifted from buffer pointed to by the path. */
+		if ( n_repeat != CARRY_ON && comp_items(&s_ih, p_s_path) )  {
+		    brelse(p_s_un_bh);
+		    break;
+		}
+
+		/* Block is in use. */
+		/* BUG, find a better test -- CLM */
+		if ( p_s_un_bh && p_s_un_bh->b_count != 1)  {
+		    if ((buffer_journaled(p_s_un_bh) || buffer_journal_dirty(p_s_un_bh)) && p_s_un_bh->b_count == 2) {
+			;
+		    } else {
+
+#ifdef REISERFS_CHECK_ONE_PROCESS
+			reiserfs_panic(p_s_sb, "PAP-5270: prepare_for_delete_or_cut: b_count != 1");
+#endif
+
+			n_retry = 1;
+			brelse(p_s_un_bh);
+			continue;
+		    }
+		}
+      
+		if ( ! n_retry )
+		    (*p_n_removed)++;
+      
+#ifdef REISERFS_CHECK
+		if ( p_s_un_bh && (*p_n_unfm_pointer != p_s_un_bh->b_blocknr || buffer_locked (p_s_un_bh)))
+		    reiserfs_panic(p_s_sb, "PAP-5280: prepare_for_delete_or_cut: blocks numbers are different");	
+#endif
+
+		{
+		    __u32 block_addr = *p_n_unfm_pointer;
+		    *p_n_unfm_pointer = 0;
+		    journal_mark_dirty(th, p_s_sb, PATH_PLAST_BUFFER(p_s_path));
+		    if (p_s_un_bh) {
+			mark_buffer_clean (p_s_un_bh);
+			brelse (p_s_un_bh);
+		    }
+		    reiserfs_free_block(th, p_s_sb, block_addr);
+		    /* non-atomic refile_buffer is allowed */
+		    COMPLETE_BITMAP_DIRTING_AFTER_FREEING (p_s_sb, block_addr / (p_s_sb->s_blocksize * 8));		    
+		}
+#if 0
+		/* journal BUG, we should be dealing with this! */
+		if (preserve_mode == PRESERVE_INDIRECT_TO_DIRECT) {
+		    /* preserve block in case of indirect_to_direct conversion */
+		    if (!p_s_un_bh || !is_buffer_suspected_recipient (p_s_sb, p_s_un_bh)) {
+			add_to_preserve (*p_n_unfm_pointer, p_s_sb);
+		    } else {
+			if (was_unfm_suspected_recipient == 0)
+			    reiserfs_panic (p_s_sb, "vs-5282: prepare_for_delete_or_cut: can not set \'was unfm suspect recipient\' flag");
+			*was_unfm_suspected_recipient = 1;
+		    }
+		    /* leaves contents of this node falled to are marked as suspected recipient already */
+		    unmark_suspected_recipient (p_s_sb, p_s_un_bh);
+		    if (n_unfm_number != 1)
+			reiserfs_panic (p_s_sb, "PAP-5285: prepare_for_delete_or_cut: "
+					"indirect_to_direct must cut only one pointer (not %d)", n_unfm_number);
+		} else {
+		    __u32 block_addr = *p_n_unfm_pointer;
+ 
+		    *p_n_unfm_pointer = 0;
+		    journal_mark_dirty(th, p_s_sb, PATH_PLAST_BUFFER(p_s_path));
+ 
+		    /* Free block and buffer in case of removal or cutting. */
+		    unmark_suspected_recipient (p_s_sb, p_s_un_bh);
+		    if (p_s_un_bh) {
+			mark_buffer_clean (p_s_un_bh);
+			brelse (p_s_un_bh);
+		    }
+ 
+		    reiserfs_free_block(th, p_s_sb, block_addr);
+		    /* non-atomic refile_buffer is allowed */
+		    COMPLETE_BITMAP_DIRTING_AFTER_FREEING (p_s_sb, block_addr / (p_s_sb->s_blocksize * 8));
+
+		}
+#endif /*0*/
+		inode->i_blocks -= p_s_sb->s_blocksize / 512;
+	    } /* for */
+
+	    /* There is block in use. */
+	    if ( n_retry )  {
+
+#ifdef REISERFS_CHECK
+		if ( *p_n_removed >= n_unfm_number )
+		    reiserfs_panic(p_s_sb, "PAP-5290: prepare_for_delete_or_cut: illegal case");
+		if ( !(++n_repeat_counter % 50000) ) {
+		    printk ("5300: new file length = %ld\n", n_new_file_length);
+		    reiserfs_warning("PAP-5300: prepare_for_delete_or_cut: (pid %u): "
+				     "could not delete item %k in (%d) iterations. Still trying",
+				     current->pid, p_s_item_key, n_repeat_counter);
+		}
+#endif
+
+#ifdef __KERNEL__
+		current->policy |= SCHED_YIELD;
+		schedule();
+#endif
+	    }
+	    /* This loop can be optimized. */
+	} while ( *p_n_removed < n_unfm_number &&
+		  search_for_position_by_key(p_s_sb, p_s_item_key, p_s_path, p_n_pos_in_item, &n_repeat) == POSITION_FOUND );
+
+#ifdef REISERFS_CHECK
+	if ( *p_n_removed < n_unfm_number )
+	    reiserfs_panic(p_s_sb, "PAP-5310: prepare_for_delete_or_cut: indirect item is not found");
+
+	if ( comp_items(&s_ih, p_s_path) ) {
+	    printk("*p_n_removed = %d n_unfm_number = %d\n",*p_n_removed, n_unfm_number);
+	    reiserfs_panic(p_s_sb, "PAP-5312: prepare_for_delete_or_cut: path to item %h has been unexpectedly changed",
+			   &s_ih);
+	}
+#endif
+
+	if (c_mode == M_CUT)
+	    *p_n_pos_in_item *= UNFM_P_SIZE;
+	return c_mode;
+    }
+}
+
+
+/* Calculate bytes number which will be deleted or cutted in the balance. */
+int calc_deleted_bytes_number(
+      struct  tree_balance  * p_s_tb,
+      char                    c_mode
+    ) {
+  int                     n_del_size;
+  struct  item_head     * p_s_ih = PATH_PITEM_HEAD(p_s_tb->tb_path);
+
+  if ( I_IS_STAT_DATA_ITEM(p_s_ih) )
+    return 0;
+
+  if ( I_IS_DIRECTORY_ITEM(p_s_ih) )
+    return EMPTY_DIR_SIZE; /* We delete emty directoris only. */
+
+  n_del_size = ( c_mode == M_DELETE ) ? p_s_ih->ih_item_len : -p_s_tb->insert_size[0];
+
+  if ( I_IS_INDIRECT_ITEM(p_s_ih) )
+    n_del_size = (n_del_size/UNFM_P_SIZE)*
+      (PATH_PLAST_BUFFER(p_s_tb->tb_path)->b_size) - p_s_ih->u.ih_free_space;
+  return n_del_size;
+}
+
+static void init_tb_struct(
+              struct tree_balance * p_s_tb,
+	      struct super_block  * p_s_sb,
+	      struct path         * p_s_path,
+              int                   n_size
+            ) {
+ memset (p_s_tb,'\0',sizeof(struct tree_balance));
+ p_s_tb->tb_sb = p_s_sb;
+ p_s_tb->tb_path = p_s_path;
+ PATH_OFFSET_PBUFFER(p_s_path, ILLEGAL_PATH_ELEMENT_OFFSET) = NULL;
+ PATH_OFFSET_POSITION(p_s_path, ILLEGAL_PATH_ELEMENT_OFFSET) = 0;
+ p_s_tb->insert_size[0] = n_size;
+}
+
+
+#if 0
+/* bh contains direct item to be preserved, unfm is unformatted node direct item is copied to, unfm
+   becomes suspected recipient */
+static void preserve_direct_item (struct tree_balance * tb, struct buffer_head * unfm)
+{
+/*  struct buffer_info bi;
+
+  bi.bi_bh = PATH_PLAST_BUFFER (tb->tb_path);
+  bi.bi_parent = PATH_H_PPARENT (tb->tb_path, 0);
+  bi.bi_position = PATH_H_B_ITEM_ORDER (tb->tb_path, 0);*/
+
+  /* unfm is to become suspected recipient */
+  preserve_shifted (tb, &PATH_PLAST_BUFFER (tb->tb_path), PATH_H_PPARENT (tb->tb_path, 0), PATH_H_B_ITEM_ORDER (tb->tb_path, 0), unfm);
+}
+
+
+/* it is called in reiserfs_cut_from_item before call to do_balance, which is going to cut last
+   unformatted pointer of indirect item. Direct item is in tree already, and buffers containing it
+   are marked as suspected recipients. Last unformatted pointer is preserved by (added to preserve list)
+   prepare_for_cut_or_delete and corresponding node is forgotten */
+void preserve_indirect_item (struct tree_balance * tb)
+{
+/*  struct buffer_info bi;
+  
+  bi.bi_bh = PATH_PLAST_BUFFER (tb->tb_path);
+  bi.bi_parent = PATH_H_PPARENT (tb->tb_path, 0);
+  bi.bi_position = PATH_H_B_ITEM_ORDER (tb->tb_path, 0);*/
+  preserve_shifted (tb, &PATH_PLAST_BUFFER (tb->tb_path), PATH_H_PPARENT (tb->tb_path, 0), PATH_H_B_ITEM_ORDER (tb->tb_path, 0), 0);
+}
+
+
+/* it is called in reiserfs_cut_from_item before call to do_balance if
+   it is cutting old entry in reiserfs_rename. Node containing new
+   entry is marked as suspected recipient */
+void preserve_entry (struct tree_balance * tb)
+{
+  preserve_indirect_item (tb);
+}
+
+#endif /*0*/
+
+/* Delete object item. */
+int reiserfs_delete_item(
+      struct reiserfs_transaction_handle *th,
+      struct inode * p_s_inode,
+      struct path         * p_s_path,     /* Path to the deleted item.            */
+      int		  * p_n_pos_in_item,
+      struct key          * p_s_item_key, /* Key to search for the deleted item.  */
+      struct buffer_head  * p_s_un_bh,    /* NULL or unformatted node pointer.    */
+      int                 preserve_mode   /* can be PRESERVE_DIRECT_TO_INDIRECT or NOTHING_SPECIAL */
+    ) {
+  struct super_block * p_s_sb = p_s_inode->i_sb;
+  struct buffer_head *bh ;
+  struct tree_balance   s_del_balance;
+  struct item_head      s_ih;
+  int                   n_repeat,
+                        n_ret_value,
+                        n_del_size,
+                        n_removed;
+
+#ifdef REISERFS_CHECK
+  char                  c_mode;
+  int			n_iter = 0;
+#endif
+
+  init_tb_struct(&s_del_balance, p_s_sb, p_s_path, 0);
+  s_del_balance.preserve_mode = preserve_mode;
+
+  while ( 1 ) {
+    n_removed = 0;
+
+#ifdef REISERFS_CHECK
+    n_iter++;
+    c_mode =
+#endif
+
+    prepare_for_delete_or_cut(th, p_s_inode, p_s_path, p_s_item_key, p_n_pos_in_item, &n_removed, &n_del_size, MAX_KEY_OFFSET, NOTHING_SPECIAL, 0);
+
+#ifdef REISERFS_CHECK
+    if ( c_mode != M_DELETE )
+      reiserfs_panic(p_s_sb, "PAP-5320: reiserfs_delete_item: mode must be M_DELETE");
+#endif
+
+    copy_item_head(&s_ih, PATH_PITEM_HEAD(p_s_path));
+    s_del_balance.insert_size[0] = n_del_size;
+
+#ifdef REISERFS_CHECK
+    if ( ( ! KEY_IS_STAT_DATA_KEY(p_s_item_key) && ! KEY_IS_DIRECTORY_KEY(p_s_item_key) &&
+	   ! I_K_KEY_IN_ITEM(PATH_PITEM_HEAD(s_del_balance.tb_path), p_s_item_key, p_s_sb->s_blocksize))  ||
+	 p_s_item_key->k_uniqueness != PATH_PITEM_HEAD(s_del_balance.tb_path)->ih_key.k_uniqueness ) {
+      reiserfs_panic(p_s_sb, "PAP-5325: reiserfs_delete_item: (iteration %d): "
+		     "key %k does not correspond to the found item %h", n_iter, p_s_item_key,
+		     PATH_PITEM_HEAD(s_del_balance.tb_path));
+    }
+
+    if ( KEY_IS_DIRECTORY_KEY(p_s_item_key) && (p_s_item_key->k_uniqueness != DIRENTRY_UNIQUENESS/*DOT_DOT_UNIQUENESS*/ &&
+						I_ENTRY_COUNT(PATH_PITEM_HEAD(s_del_balance.tb_path)) != 2) )
+      reiserfs_panic(p_s_sb, "PAP-5327: reiserfs_delete_item(%d): key does not correspond to the item(directory case)", n_iter);
+
+    if ( PATH_LAST_POSITION(s_del_balance.tb_path) >= B_NR_ITEMS(PATH_PLAST_BUFFER(s_del_balance.tb_path)) ) {
+      reiserfs_panic(p_s_sb, "PAP-5330: reiserfs_delete_item: invalid item number (%d) iter = %d, must be < %d. item to delete key %k", 
+		     PATH_LAST_POSITION(s_del_balance.tb_path), n_iter,
+		     B_NR_ITEMS(PATH_PLAST_BUFFER(s_del_balance.tb_path)), p_s_item_key);
+    }
+#endif
+
+    n_ret_value = fix_nodes(th, M_DELETE, &s_del_balance, 0, NULL);
+
+#ifdef REISERFS_CHECK_ONE_PROCESS
+    if ( n_ret_value == PATH_INCORRECT )
+      reiserfs_panic(p_s_sb,"PAP-5340: reiserfs_delete_item: illegal returned value");
+#endif
+
+    if ( n_ret_value != SCHEDULE_OCCURRED && n_ret_value != PATH_INCORRECT )
+      break;
+    /* schedule() occured while make_balance() worked */
+    if ( search_for_position_by_key(p_s_sb, p_s_item_key, p_s_path, p_n_pos_in_item, &n_repeat) == POSITION_NOT_FOUND )
+      reiserfs_panic(p_s_sb, "PAP-5350: reiserfs_delete_item: item to delete does not exist");
+  }
+  if ( n_ret_value == NO_DISK_SPACE || n_ret_value == IO_ERROR ) {
+    unfix_nodes(th, &s_del_balance);
+    return 0;
+  }
+  journal_lock_dobalance(p_s_sb) ;
+ 
+  /* Here n_ret_value equals CARRY_ON. */
+  n_ret_value = calc_deleted_bytes_number(&s_del_balance, M_DELETE);
+
+  if ( p_s_un_bh )  {
+    /* We are deleting direct items in a tail, that we are converting
+       into an unformatted node. */
+
+#ifdef REISERFS_CHECK
+    if ( ! I_IS_DIRECT_ITEM(&s_ih) || ! buffer_uptodate(p_s_un_bh) || 
+       ((p_s_un_bh->b_count != 1) && !buffer_journaled(p_s_un_bh)) ) {
+      reiserfs_panic(p_s_sb,"PAP-5370: reiserfs_delete_item: illegal unformatted node buffer %b or item type %h)",
+		     p_s_un_bh, &s_ih);
+    }
+#endif
+
+    memcpy(p_s_un_bh->b_data + (s_ih.ih_key.k_offset - 1) % (p_s_sb->s_blocksize),
+	   B_I_PITEM(PATH_PLAST_BUFFER(p_s_path), &s_ih), n_ret_value);
+#ifdef REISERFS_CHECK
+    if ( preserve_mode != PRESERVE_DIRECT_TO_INDIRECT )
+      reiserfs_panic(p_s_sb, "PAP-5380: reiserfs_delete_item: "
+		     "you need to change the code to check converting_tail before preserving");
+#endif /* REISERFS_CHECK */
+
+    /* brelse (p_s_un_bh) will complete mark_buffer_dirty */
+    /* reiserfs_mark_buffer_dirty(p_s_un_bh, 0); journal victim */
+    /* BUG? should I be journaling more here, should I journal the p_s_un_bh at all */
+    bh = PATH_PLAST_BUFFER(p_s_path) ;
+    journal_mark_dirty(th, p_s_sb, p_s_un_bh) ;
+
+
+    /* preserve node containing direct item that is being deleted and
+       mark unformatted node (p_s_un_bh) getting contents of direct
+       item as suspected recipient */
+/*    preserve_direct_item (&s_del_balance, p_s_un_bh);*/
+
+  }
+
+  /* Perform balancing after all resources will be collected at once. */ 
+  do_balance(th, &s_del_balance, 0, NULL, NULL, M_DELETE, REISERFS_KERNEL_MEM, 0/* zeros number */);
+  journal_unlock_dobalance(p_s_sb) ;
+
+  /* Return deleted body length */ 
+  return n_ret_value;
+}
+
+
+/* Summary Of Mechanisms For Handling Collisions Between Processes:
+
+ deletion of the body of the object is performed by iput(), with the
+ result that if multiple processes are operating on a file, the
+ deletion of the body of the file is deferred until the last process
+ that has an open inode performs its iput().
+
+ writes and truncates are protected from collisions by use of
+ semaphores.
+
+ creates, linking, and mknod are protected from collisions with other
+ processes by making the reiserfs_add_entry() the last step in the
+ creation, and then rolling back all changes if there was a collision.
+ - Hans
+*/
+
+/* Delete all items of an object. */
+/* This would work faster if it did not use search by key to access data one node at a time, but instead
+   resembled read more by doing read ahead. */
+void  reiserfs_delete_object(
+	struct reiserfs_transaction_handle *th, 
+        struct inode  * p_s_inode       /* Pointer to the object inode. */
+      ) {
+  struct path           s_search_path;  /* Path to the last object item. */
+  struct key            s_item_key;     /* Key to search for a file item. */  
+  unsigned long         n_obj_size;     /* Object size. */
+  int                   n_repeat,
+                        n_deleted,      /* Number of deleted bytes. */
+                        n_pos_in_item,  /* Found position in the item. */
+    			n_is_last_item = 1;
+
+  struct super_block *  p_s_sb = p_s_inode->i_sb;
+
+  
+  init_path (&s_search_path);
+  /* Copy key of the object stat_data. */
+  copy_key(&s_item_key, INODE_PKEY(p_s_inode));
+
+  /* Get object size. */
+  n_obj_size = p_s_inode->i_size;
+  /* Case of a directory. */
+  if ( S_ISDIR(p_s_inode->i_mode) ) {
+
+#ifdef REISERFS_CHECK
+  /* reiserfs_delete_object is called to delete a directory only for empty directories. */
+    if ( n_obj_size != EMPTY_DIR_SIZE && n_obj_size != 0 )
+      reiserfs_panic (p_s_sb, "PAP-5390: reiserfs_delete_object: bad empty directory sdize (%lu)", n_obj_size);
+#endif
+
+    /* Set key to search for the ".." directory entry. */
+    s_item_key.k_offset = DOT_DOT_OFFSET;
+    s_item_key.k_uniqueness = DIRENTRY_UNIQUENESS/*DOT_DOT_UNIQUENESS*/;
+  }
+  else  {
+    /* Set key to search for the last file byte. */
+    if ( (s_item_key.k_offset = n_obj_size) >= p_s_inode->u.reiserfs_i.i_first_direct_byte )
+      s_item_key.k_uniqueness = TYPE_DIRECT;
+    else
+      s_item_key.k_uniqueness = TYPE_INDIRECT;
+  }
+  /* Delete object body. */
+  while ( n_obj_size )  {
+    /* Search for the last object item. */
+    if ( search_for_position_by_key(p_s_sb, &s_item_key, &s_search_path, &n_pos_in_item, &n_repeat) == POSITION_NOT_FOUND ) {
+      if (  n_is_last_item ) {
+	struct item_head * p_s_ih;
+
+	n_is_last_item = 0;
+	p_s_ih = PATH_PITEM_HEAD(&s_search_path);
+
+	if ( COMP_SHORT_KEYS(&s_item_key, &(p_s_ih->ih_key)) )
+	  reiserfs_panic (p_s_sb, "PAP-5400: reiserfs_delete_object: item to delete doesn't exist");
+
+	if ( I_IS_STAT_DATA_ITEM(p_s_ih) ) {
+	  n_obj_size = 0;
+
+#ifdef REISERFS_INFO
+	  printk("reiserfs_delete_object: file size calculated by last file item(%lu) less than file size in inode(%lu)\n",
+		 n_obj_size, p_s_inode->i_size);
+#endif
+
+	  break;
+	}
+	s_item_key.k_offset = n_obj_size = p_s_ih->ih_key.k_offset + I_BYTES_NUMBER(p_s_ih, p_s_sb->s_blocksize) - 1;
+	n_pos_in_item--;
+
+#ifdef REISERFS_INFO
+	printk("reiserfs_delete_object: file size calculated by last file item(%lu) less than file size in inode(%lu)\n",
+	       n_obj_size, p_s_inode->i_size);
+#endif
+
+      }
+      else {
+	reiserfs_panic (p_s_sb, "PAP-5410: reiserfs_delete_object: item %k to delete doesn't exist", &s_item_key);
+      }
+
+    }
+
+    /* Delete last object item. */
+    n_deleted = reiserfs_delete_item(th, p_s_inode, &s_search_path, &n_pos_in_item, &s_item_key, NULL, NOTHING_SPECIAL);
+
+#ifdef REISERFS_CHECK
+    if ( n_deleted <= 0 )
+	    reiserfs_panic(p_s_sb, "reiser-5420: reiserfs_delete_object: this code needs to be fixed to handle ENOSPC");
+    if ( n_deleted > n_obj_size )
+	    reiserfs_panic (p_s_sb, "PAP-5430: reiserfs_delete_object: " 
+                    "reiserfs_delete_item returns too big number");
+#endif
+
+    n_obj_size -= n_deleted;
+
+#ifdef REISERFS_CHECK
+    if ( n_obj_size && s_item_key.k_offset < n_deleted )
+	    reiserfs_panic (p_s_sb, "PAP-5440: reiserfs_delete_object: illegal search key offset");
+#endif
+    /* Update key to search for the new last object item. */
+    if ( (s_item_key.k_offset -= n_deleted) < p_s_inode->u.reiserfs_i.i_first_direct_byte )
+      s_item_key.k_uniqueness = TYPE_INDIRECT;
+
+    if (journal_transaction_should_end(th, th->t_blocks_allocated)) {
+      int orig_len_alloc = th->t_blocks_allocated ;
+      struct super_block *orig_super = th->t_super ;
+      p_s_inode->i_size = n_obj_size ;
+      p_s_inode->i_ctime = CURRENT_TIME ;
+      p_s_inode->i_mtime = CURRENT_TIME ;
+      decrement_counters_in_path(&s_search_path);
+      if_in_ram_update_sd(th, p_s_inode) ;
+      journal_end(th, orig_super, orig_len_alloc) ;
+      journal_begin(th, orig_super, orig_len_alloc) ;
+      reiserfs_update_inode_transaction(p_s_inode) ;
+    }
+  }
+
+  /* Set key to search for the object stat_data. */  
+  s_item_key.k_offset = SD_OFFSET;
+  s_item_key.k_uniqueness = SD_UNIQUENESS;
+  /* Search for the object stat_data. */
+  if ( search_by_key(p_s_sb, &s_item_key, &s_search_path, &n_repeat, DISK_LEAF_NODE_LEVEL, READ_BLOCKS) == ITEM_NOT_FOUND ) {
+    print_block (PATH_PLAST_BUFFER (&s_search_path), 0, -1, -1);
+    reiserfs_panic (p_s_sb, "PAP-5450: reiserfs_delete_object: stat_data %k is not found", &s_item_key);
+  }
+
+  /* Delete object stat_data. */
+  if ( reiserfs_delete_item(th, p_s_inode, &s_search_path, &n_pos_in_item, &s_item_key, NULL, NOTHING_SPECIAL) < 0 )
+    reiserfs_panic (p_s_sb, "PAP: 5455: reiserfs_delete_object: reiserfs_delete_item: this code needs to be fixed");
+
+#ifdef REISERFS_CHECK
+  s_item_key.k_offset = MAX_KEY_OFFSET;
+  s_item_key.k_uniqueness = MAX_KEY_UNIQUENESS;
+  /* Try to find item of the deleted object. */
+  if ( search_by_key (p_s_sb, &s_item_key, &s_search_path, &n_repeat, DISK_LEAF_NODE_LEVEL, READ_BLOCKS) == ITEM_FOUND )
+    reiserfs_panic(p_s_sb,"PAP: 5460: reiserfs_delete_object: there is the item of deleted object");
+
+  PATH_LAST_POSITION(&s_search_path)--;
+  if (!COMP_SHORT_KEYS (&(PATH_PITEM_HEAD(&s_search_path)->ih_key), &s_item_key)) {
+    print_block (PATH_PLAST_BUFFER (&s_search_path), PRINT_LEAF_ITEMS,
+		 PATH_LAST_POSITION(&s_search_path) - 2, PATH_LAST_POSITION(&s_search_path) + 2);
+    reiserfs_panic(p_s_sb,"PAP-5470: reiserfs_delete_object: there is the item %h of deleted object %k. Inode key %k",
+		   PATH_PITEM_HEAD(&s_search_path), &s_item_key, INODE_PKEY (p_s_inode));
+  }
+  decrement_counters_in_path(&s_search_path);
+#endif
+
+  p_s_inode->i_size = 0;
+}
+
+
+/*********************** Inode part **************************************/
+int increment_i_read_sync_counter(
+      struct inode  * p_s_inode
+    ) {
+  int n_repeat = CARRY_ON;
+
+#ifdef REISERFS_CHECK
+  int n_repeat_counter = 0;
+#endif
+
+  /* Call schedule while this file is being converted. */
+  while ( p_s_inode->u.reiserfs_i.i_is_being_converted )  {
+#ifdef REISERFS_CHECK
+    if (p_s_inode->u.reiserfs_i.i_read_sync_counter)
+      reiserfs_panic (p_s_inode->i_sb, "PAP-5480: increment_i_read_sync_counter: file is read (synced) already");
+    if ( !(++n_repeat_counter % 15000) )
+      printk ("increment_i_read_sync_counter: (inode=%lu, pid=%d, counter=%d)\n", p_s_inode->i_ino, current->pid, n_repeat_counter);
+#endif
+    n_repeat |= SCHEDULE_OCCURRED;
+    current->policy |= SCHED_YIELD;
+    schedule();
+  }
+
+  p_s_inode->u.reiserfs_i.i_read_sync_counter++;
+  return n_repeat;
+}
+
+
+void  decrement_i_read_sync_counter(
+        struct inode  * p_s_inode
+      ) {
+
+#ifdef REISERFS_CHECK
+  if ( ! p_s_inode->u.reiserfs_i.i_read_sync_counter )
+    reiserfs_panic (p_s_inode->i_sb, "PAP-5490: increment_i_read_sync_counter: read_sync_counter is zero");
+#endif
+
+  p_s_inode->u.reiserfs_i.i_read_sync_counter--;
+}
+
+
+int lock_inode_to_convert(
+      struct inode  * p_s_inode
+    ) {
+  int n_repeat = CARRY_ON;
+
+#ifdef REISERFS_CHECK
+  int n_repeat_counter = 0;
+#endif
+
+  /* Call schedule() while there is read from this file. */
+  while ( p_s_inode->u.reiserfs_i.i_read_sync_counter ) {
+#ifdef REISERFS_CHECK
+    if (p_s_inode->u.reiserfs_i.i_is_being_converted)
+      reiserfs_panic (p_s_inode->i_sb, "PAP-5495: lock_inode_to_convert: file is being truncated (or appended) already");
+    if ( !(++n_repeat_counter % 15000) )
+      printk ("lock_inode_to_convert: (inode=%lu, pid=%d, counter=%d)\n", p_s_inode->i_ino, current->pid, n_repeat_counter);
+#endif
+    n_repeat |= SCHEDULE_OCCURRED;
+    current->policy |= SCHED_YIELD;
+    schedule();
+  }
+
+#ifdef REISERFS_CHECK
+  if ( p_s_inode->u.reiserfs_i.i_is_being_converted || p_s_inode->u.reiserfs_i.i_read_sync_counter )
+    reiserfs_panic (p_s_inode->i_sb, "PAP-5500: lock_inode_to_convert: illegal case");
+#endif
+
+  /* Mark file as ready to convert. */
+  p_s_inode->u.reiserfs_i.i_is_being_converted = 1;
+  return n_repeat;
+}
+
+
+void  unlock_inode_after_convert(
+        struct inode * p_s_inode
+      ) {
+
+#ifdef REISERFS_CHECK
+  if ( p_s_inode->u.reiserfs_i.i_is_being_converted != 1 ||
+                                        p_s_inode->u.reiserfs_i.i_read_sync_counter )
+    reiserfs_panic (p_s_inode->i_sb, "PAP-5510: unlock_inode_after_convert: illegal case");
+#endif
+
+  /* Read is possible. */
+  p_s_inode->u.reiserfs_i.i_is_being_converted = 0;
+}
+
+/************ End of the inode part ***************************/
+
+
+
+
+
+
+/* Convert an unformatted node to a direct item. 
+   Returns number of deleted bytes or -1 if io error encountered. */
+static int indirect_to_direct(
+      struct reiserfs_transaction_handle *th,
+      struct inode        * p_s_inode,          /* Pointer to the file inode.                 */
+      struct super_block  * p_s_sb,             /* Pointer to the super block.                */
+      struct path         * p_s_path,           /* Pointer to the path to the indirect item.  */
+      struct key          * p_s_item_key,       /* Key to search for the last file byte.      */
+      unsigned long         n_new_file_size,    /* New file size.                             */
+      char                * p_c_mode
+    ) {
+  struct buffer_head  * p_s_unfm_bh;              /* Pointer to the converted unformatted node
+                                                    buffer.                                   */
+  struct item_head      s_ih;
+  unsigned long         n_unfm_number = 0; 	/* Unformatted node block number              */
+  int                   n_pos_in_item,
+                        n_repeat_or_retval, /* this variable is overloaded to be used for two purposes:
+					       tracking whether schedule occured, and for use as
+					       a temporary variable */
+                        n_block_size = p_s_sb->s_blocksize;
+
+  p_s_sb->u.reiserfs_sb.s_indirect2direct ++;
+  /* Copy item at the path. */
+  copy_item_head(&s_ih, PATH_PITEM_HEAD(p_s_path) );
+  /* Don't read while we are converting the unformatted node. */
+  if ( (n_repeat_or_retval = lock_inode_to_convert(p_s_inode)) )
+    /* Check whether saved item is at the path. */
+    n_repeat_or_retval = comp_items(&s_ih,p_s_path);
+  if ( n_repeat_or_retval == CARRY_ON )
+    /* Calculate last unformatted node number. */
+    n_unfm_number = B_I_POS_UNFM_POINTER(PATH_PLAST_BUFFER(p_s_path), &s_ih, I_UNFM_NUM(&s_ih) - 1);
+
+  /* We get the pointer to the unformatted to be converted into a direct item. */
+  while ( 1 ) {
+    if ( n_repeat_or_retval != CARRY_ON ) {
+      /* Search for the indirect item. */
+      if ( search_for_position_by_key(p_s_sb, p_s_item_key, p_s_path, &n_pos_in_item, &n_repeat_or_retval) == POSITION_NOT_FOUND )
+	reiserfs_panic(p_s_sb, "PAP-5520: indirect_to_direct: item to convert does not exist");
+      copy_item_head(&s_ih, PATH_PITEM_HEAD(p_s_path) );
+      n_unfm_number = B_I_POS_UNFM_POINTER(PATH_PLAST_BUFFER(p_s_path), &s_ih, I_UNFM_NUM(&s_ih) - 1);
+    }
+    p_s_unfm_bh = NULL;
+    if ( n_unfm_number )  {
+      /* Read unformatted node to convert. */
+      n_repeat_or_retval = CARRY_ON;
+      p_s_unfm_bh = reiserfs_bread(p_s_sb->s_dev, n_unfm_number, p_s_sb->s_blocksize, &n_repeat_or_retval);
+      if (!p_s_unfm_bh) {
+	*p_c_mode = M_SKIP_BALANCING;
+	pathrelse (p_s_path);
+	return -1;
+      }
+      /* Current item was shifted from buffer at the path. */
+      if ( n_repeat_or_retval != CARRY_ON && comp_items(&s_ih, p_s_path) )  {
+        brelse(p_s_unfm_bh);
+        continue;
+      }
+
+#if defined(REISERFS_CHECK) && !defined(PACKING_LOCALITY_READ_AHEAD)
+
+      if ( p_s_unfm_bh->b_count != 1 && !buffer_journaled(p_s_unfm_bh)) {
+        reiserfs_panic (p_s_sb, "PAP-5530: indirect_to_direct: (read counter %d, converted %d)"
+			" converted block (%d) must not be in use (b_count==%d)",
+			p_s_inode->u.reiserfs_i.i_read_sync_counter, 
+			p_s_inode->u.reiserfs_i.i_is_being_converted, n_unfm_number, p_s_unfm_bh->b_count);
+      }
+
+#endif
+
+    }
+    break;
+  }
+
+  /* Set direct item header to insert. */
+  s_ih.ih_key.k_offset += (I_UNFM_NUM (&s_ih) - 1) * n_block_size;
+  n_pos_in_item = s_ih.ih_key.k_offset;	/*(s_ih.ih_key.k_offset -= (s_ih.ih_key.k_offset - 1) % n_block_size);*/
+  s_ih.ih_key.k_uniqueness    = TYPE_DIRECT;
+  s_ih.u.ih_free_space          = MAX_US_INT;
+  n_repeat_or_retval = s_ih.ih_item_len = n_new_file_size % n_block_size;
+  PATH_LAST_POSITION(p_s_path)++;
+
+  /* Insert new direct item in the tree. This insert must mark nodes getting a new item as suspected recipient */
+  /* Vladimir, LOOK journal **** was preserve indirect to direct */
+  if ( reiserfs_insert_item(th, p_s_sb, p_s_path, &s_ih,
+                      ( p_s_unfm_bh ) ? p_s_unfm_bh->b_data : NULL, REISERFS_KERNEL_MEM, 0/*zero bytes*/, NOTHING_SPECIAL) < 0 ) {
+    /* No disk memory. So we can not convert last unformatted node to the direct item.
+       In this case we mark that node has just 'n_new_file_size % n_block_size'
+       bytes of the file.*/
+    struct item_head * p_s_ih;
+
+    if ( search_for_position_by_key(p_s_sb, p_s_item_key, p_s_path, &n_pos_in_item, &n_repeat_or_retval) == POSITION_NOT_FOUND )
+      reiserfs_panic(p_s_sb, "PAP-5540: indirect_to_direct: item to convert does not exist");
+    n_repeat_or_retval = (p_s_ih = PATH_PITEM_HEAD(p_s_path))->u.ih_free_space;
+    p_s_ih->u.ih_free_space = n_block_size - n_new_file_size % n_block_size;
+
+#ifdef REISERFS_CHECK
+    if ( n_repeat_or_retval > p_s_ih->u.ih_free_space )
+      reiserfs_panic (p_s_sb, "PAP-5550: indirect_to_direct: illegal new ih_free_space");
+#endif
+
+    n_repeat_or_retval = p_s_ih->u.ih_free_space - n_repeat_or_retval;
+    *p_c_mode = M_SKIP_BALANCING;
+
+    /* non-atomic mark_buffer_dirty is allowed here */
+    /* mark_buffer_dirty(PATH_PLAST_BUFFER(p_s_path), 0); journal victim */
+    journal_mark_dirty(th, p_s_sb, PATH_PLAST_BUFFER(p_s_path));
+    unlock_inode_after_convert(p_s_inode);
+    pathrelse(p_s_path);
+  }
+  else {
+    /* We have inserted new direct item and must remove last unformatted node. */
+    *p_c_mode = M_CUT;
+    /* Set position of its first byte to inode (for read needs) */
+    p_s_inode->u.reiserfs_i.i_first_direct_byte = n_pos_in_item;
+    p_s_inode->i_blocks += p_s_sb->s_blocksize / 512;
+  }
+
+  brelse(p_s_unfm_bh);
+  /* We have inserted new direct item and must remove last unformatted node. */
+/*  *p_c_mode = M_CUT;*/
+  return n_repeat_or_retval;
+}
+
+
+
+int maybe_indirect_to_direct(
+      struct reiserfs_transaction_handle *th,
+      struct inode        * p_s_inode,
+      struct super_block  * p_s_sb,
+      struct path         * p_s_path,
+      struct key          * p_s_item_key,
+      unsigned long         n_new_file_size,
+      char                * p_c_mode
+    ) {
+  int n_block_size = p_s_sb->s_blocksize;
+  int cut_bytes;
+
+  /* We can store tail of the file in an unformatted node. */ 
+  if ( dont_have_tails (p_s_sb) ||
+       STORE_TAIL_IN_UNFM(n_new_file_size, n_new_file_size % n_block_size, n_block_size) ) { /* tail too long */
+    /* Change ih->u.ih_free_space in the indirect item defined by path. */
+    struct item_head  * p_s_ih = PATH_PITEM_HEAD(p_s_path);
+    int                 n_old_free_space = p_s_ih->u.ih_free_space;
+
+    *p_c_mode = M_SKIP_BALANCING;
+    p_s_ih->u.ih_free_space = n_block_size - n_new_file_size % n_block_size;
+    
+#ifdef REISERFS_CHECK
+    if ( n_old_free_space >= p_s_ih->u.ih_free_space )
+      reiserfs_panic (p_s_sb, "PAP-5560: maybe_indirect_to_direct: tail is too small");
+#endif
+
+    cut_bytes = p_s_ih->u.ih_free_space - n_old_free_space;
+
+    /* non-atomic mark_buffer_dirty is allowed here */
+    /* mark_buffer_dirty(PATH_PLAST_BUFFER(p_s_path), 0); */
+    journal_mark_dirty(th, p_s_sb, PATH_PLAST_BUFFER(p_s_path)) ;
+    pathrelse(p_s_path);
+    return cut_bytes;
+  }
+  /* Permorm the conversion to a direct_item. */
+  return indirect_to_direct(th, p_s_inode, p_s_sb, p_s_path, p_s_item_key, n_new_file_size, p_c_mode);
+}
+
+
+/* we did indirect_to_direct conversion. And we have inserted direct
+   item successesfully, but there were no disk space to cut unfm
+   pointer being converted. Therefore we have to delete inserted
+   direct item(s) */
+static void indirect_to_direct_roll_back (struct reiserfs_transaction_handle *th, struct inode * inode, struct path * path)
+{
+  struct key tail_key;
+  int tail_len;
+  int pos_in_item;
+  int repeat_or_removed;
+
+
+  copy_key (&tail_key, INODE_PKEY (inode));
+  tail_key.k_offset = inode->i_size + 1;
+  tail_key.k_uniqueness = TYPE_DIRECT;
+  tail_len = tail_key.k_offset % inode->i_sb->s_blocksize - 1;
+  while (tail_len) {
+    /* look for the last byte of the tail */
+    if (search_for_position_by_key (inode->i_sb, &tail_key, path, &pos_in_item, &repeat_or_removed) == POSITION_NOT_FOUND)
+      reiserfs_panic (inode->i_sb, "vs-5615: indirect_to_direct_roll_back: found invalid item");
+#ifdef REISERFS_CHECK
+    if (pos_in_item != PATH_PITEM_HEAD (path)->ih_item_len - 1)
+      reiserfs_panic (inode->i_sb, "vs-5616: indirect_to_direct_roll_back: appended bytes found");
+#endif
+    PATH_LAST_POSITION (path) --;
+	
+    repeat_or_removed = reiserfs_delete_item (th, inode, path, &pos_in_item, &tail_key, 0, NOTHING_SPECIAL);
+#ifdef REISERFS_CHECK
+    if (repeat_or_removed <= 0 || repeat_or_removed > tail_len)
+      reiserfs_panic (inode->i_sb, "vs-5617: indirect_to_direct_roll_back: "
+		      "there was tail %d bytes, removed item length %d bytes",
+		      tail_len, repeat_or_removed);
+#endif
+    tail_len -= repeat_or_removed;
+    tail_key.k_offset -= repeat_or_removed;
+  }
+  printk ("indirect_to_direct_roll_back: indirect_to_direct conversion has been rolled back due to lack of disk space\n");
+  inode->u.reiserfs_i.i_first_direct_byte = NO_BYTES_IN_DIRECT_ITEM;
+  mark_inode_dirty (inode);
+}
+
+
+/* (Truncate or cut entry) or delete object item. */
+int reiserfs_cut_from_item(
+      struct reiserfs_transaction_handle *th,
+      struct inode        * p_s_inode,
+      struct super_block  * p_s_sb,
+      struct path         * p_s_path,
+      int                 * p_n_pos_in_item,
+      struct key          * p_s_item_key,
+      unsigned long         n_new_file_size,
+      int		    preserve_mode	/* can be PRESERVE_RENAMING or NOTHING SPECIAL */
+    ) {
+  /* Every function which is going to call do_balance must first
+     create a tree_balance structure.  Then it must fill up this
+     structure by using the init_tb_struct and fix_nodes functions.
+     After that we can make tree balancing. */
+  struct tree_balance s_cut_balance;
+  int                 n_repeat,
+                      n_cut_size,        /* Amount to be cut. */
+                      /* n_ret_value = CARRY_ON, */
+		      n_fix_ret_value = CARRY_ON, /* return value from fix_nodes and do_balance */
+		      n_count_ret_value = 0,      /* return value from indirect->direct */
+                      n_removed = 0,     /* Number of the removed unformatted nodes. */
+  		      n_is_inode_locked = 0;
+  char                c_mode;            /* Mode of the balance. */
+  int was_unfm_suspected_recipient = 0;
+
+  init_tb_struct(&s_cut_balance, p_s_sb, p_s_path, n_cut_size);
+  s_cut_balance.preserve_mode = preserve_mode;
+
+  /* Repeat this loop until we either cut the item without needing to balance, or we fix_nodes without
+     schedule occuring */
+  while ( 1 ) {
+      /* Determine the balance mode, position of the first byte to be cut, and size to be cut.
+	 In case of the indirect item free unformatted nodes which are pointed to by
+	 the cut pointers. */
+
+    /* Vladimir, LOOK, journal **** first nothing special was preserving indirect to direct */
+    c_mode = prepare_for_delete_or_cut(th, p_s_inode, p_s_path, p_s_item_key, p_n_pos_in_item, &n_removed, &n_cut_size, 
+    				       n_new_file_size,
+				       n_is_inode_locked ? NOTHING_SPECIAL : NOTHING_SPECIAL, &was_unfm_suspected_recipient);
+    if ( c_mode == M_CONVERT )  {
+	/* convert last unformatted node to direct item or adjust its ih_free_space */
+#ifdef REISERFS_CHECK
+      if ( n_fix_ret_value != CARRY_ON )
+        reiserfs_panic (p_s_sb, "PAP-5570: reiserfs_cut_from_item: can not convert twice");
+#endif
+
+      n_count_ret_value = maybe_indirect_to_direct (th, p_s_inode, p_s_sb, p_s_path, p_s_item_key,
+					      n_new_file_size, &c_mode);
+      if (n_count_ret_value == -1)
+	return 0;
+      /* We have cut all item bytes and must stop. */
+      if ( c_mode == M_SKIP_BALANCING )
+        break;
+      n_is_inode_locked = 1;
+      /* So, we have performed the first part of the conversion:
+	 inserting the new direct item.  Now we are removing the last
+	 unformatted node pointer. Set key to search for it. */
+      p_s_item_key->k_uniqueness = TYPE_INDIRECT;
+      n_new_file_size -= n_new_file_size % p_s_sb->s_blocksize;
+      p_s_item_key->k_offset = n_new_file_size + 1;
+      if ( search_for_position_by_key(p_s_sb, p_s_item_key, p_s_path, p_n_pos_in_item, &n_repeat) == POSITION_NOT_FOUND ){
+	print_block (PATH_PLAST_BUFFER (p_s_path), 3, PATH_LAST_POSITION (p_s_path) - 1, PATH_LAST_POSITION (p_s_path) + 1);
+	reiserfs_panic(p_s_sb, "PAP-5580: reiserfs_cut_from_item: item to convert does not exist (%k)", p_s_item_key);
+      }
+      continue;
+    }
+
+    s_cut_balance.insert_size[0] = n_cut_size;
+
+    n_fix_ret_value = fix_nodes(th, c_mode, &s_cut_balance, *p_n_pos_in_item, NULL);
+ 
+#ifdef REISERFS_CHECK_ONE_PROCESS
+    if ( n_fix_ret_value == PATH_INCORRECT )
+      reiserfs_panic(p_s_sb, "PAP-5600: reiserfs_cut_from_item: "
+		     "illegal returned value");
+#endif
+
+    if ( n_fix_ret_value != SCHEDULE_OCCURRED && n_fix_ret_value != PATH_INCORRECT )
+      break;
+
+    /* else schedule() occured while fix_nodes() worked */
+    if ( search_for_position_by_key(p_s_sb, p_s_item_key, p_s_path, p_n_pos_in_item, &n_repeat) == POSITION_NOT_FOUND )
+      reiserfs_panic(p_s_sb, "PAP-5610: reiserfs_cut_from_item: item to delete does not exist");
+  } /* while */
+
+  if ( n_fix_ret_value == NO_DISK_SPACE || n_fix_ret_value == IO_ERROR || n_count_ret_value == NO_DISK_SPACE) {
+    if ( n_is_inode_locked ) {
+      indirect_to_direct_roll_back(th, p_s_inode, p_s_path);
+    }
+    unfix_nodes (th, &s_cut_balance);
+    return 0;
+  }
+
+  if ( c_mode != M_SKIP_BALANCING ) {
+    journal_lock_dobalance(p_s_sb) ;
+
+#ifdef REISERFS_CHECK
+/*    if ( n_ret_value >= calc_deleted_bytes_number(&s_cut_balance, c_mode) )
+      reiserfs_panic (p_s_sb, "PAP-5630: reiserfs_cut_from_item: returned value is too big");*/
+    if (n_fix_ret_value != CARRY_ON)
+      reiserfs_panic (p_s_sb, "PAP-5630: ret_value is other than CARRY_ON");
+    if ( c_mode == M_PASTE || c_mode == M_INSERT )
+      reiserfs_panic (p_s_sb, "PAP-5640: reiserfs_cut_from_item: illegal mode");
+#endif
+      /* Calculate number of bytes that need to be cut from the item.  how could this have been right? */
+      /* it was n_ret_value = calc - n_ret_value.  We know from above that n_ret_value was CARRY_ON
+      ** or we would be reiserfs_panic'ing.  So in the error case (with reiserfs_check off), we were subtracting some number
+      ** of bytes, for no apparent reason.
+      */
+    n_count_ret_value = calc_deleted_bytes_number(&s_cut_balance, c_mode) ;
+
+    if ( c_mode == M_DELETE ) {
+      struct item_head * p_s_ih = B_N_PITEM_HEAD(PATH_PLAST_BUFFER(s_cut_balance.tb_path), PATH_LAST_POSITION(s_cut_balance.tb_path));
+
+      if ( I_IS_DIRECT_ITEM(p_s_ih) && p_s_ih->ih_key.k_offset % p_s_sb->s_blocksize == 1 ) {
+
+#ifdef REISERFS_CHECK
+	if ( p_s_inode->u.reiserfs_i.i_first_direct_byte != p_s_ih->ih_key.k_offset )
+	  reiserfs_panic (p_s_sb, "PAP-5650: reiserfs_cut_from_item: illegal first direct byte position");
+#endif
+
+	p_s_inode->u.reiserfs_i.i_first_direct_byte = NO_BYTES_IN_DIRECT_ITEM;
+	p_s_inode->i_blocks -= p_s_sb->s_blocksize / 512;
+      }
+    }
+
+    if (n_is_inode_locked) {
+      /* we are going to cut last unfm ptr, preserve it first. unfm node block number is on preserve list already */
+#ifdef REISERFS_CHECK
+      if (!I_IS_INDIRECT_ITEM (PATH_PITEM_HEAD (s_cut_balance.tb_path)))
+	reiserfs_panic (p_s_sb, "vs-5652: reiserfs_cut_from_item: item must be indirect %h", PATH_PITEM_HEAD (s_cut_balance.tb_path));
+      if (c_mode == M_DELETE && -(PATH_PITEM_HEAD (s_cut_balance.tb_path)->ih_item_len + IH_SIZE) != s_cut_balance.insert_size[0]) {
+	reiserfs_panic (p_s_sb, "vs-5653: reiserfs_cut_from_item: "
+			"can not complete indirect_to_direct conversion of %h (DELETE, insert_size==%d)",
+			PATH_PITEM_HEAD (s_cut_balance.tb_path), s_cut_balance.insert_size[0]);
+      }
+      if (c_mode == M_CUT && s_cut_balance.insert_size[0] != -UNFM_P_SIZE) {
+	reiserfs_panic (p_s_sb, "vs-5654: reiserfs_cut_from_item: can not complete indirect_to_direct conversion of %h (CUT, insert_size==%d)",
+			PATH_PITEM_HEAD (s_cut_balance.tb_path), s_cut_balance.insert_size[0]);
+      }
+#endif
+      /* we should not preserve indirect item if unformatted node was marked as suspected recipient */
+/*
+      if (!was_unfm_suspected_recipient)
+	preserve_indirect_item (&s_cut_balance);
+*/
+    }
+/*
+    if (preserve_mode == PRESERVE_RENAMING)
+      preserve_entry (&s_cut_balance);
+*/
+    do_balance(th, &s_cut_balance, *p_n_pos_in_item, NULL, NULL, c_mode, REISERFS_KERNEL_MEM, 0/* zero number */);
+    journal_unlock_dobalance(p_s_sb) ;
+    if ( n_is_inode_locked )
+      unlock_inode_after_convert(p_s_inode);
+  } /* ! SKIP_BALANCING */
+
+  return n_count_ret_value;
+}
+
+int reiserfs_file_release(struct inode *p_s_inode, struct file *p_s_filp) {
+  struct path           s_search_path;  /* Path to the current object item. */
+  struct item_head    * p_s_ih;         /* Pointer to an item header. */
+  struct key            s_item_key;     /* Key to search for a previous file item. */
+  unsigned long         n_file_size,    /* Old file size. */
+                        n_new_file_size;/* New file size. */
+  int                   n_deleted,      /* Number of deleted or truncated bytes. */
+                        n_pos_in_item,  /* Found position in an item. */
+  			n_repeat;   
+  int windex ;
+  struct reiserfs_transaction_handle th ;
+  int jbegin_count = JOURNAL_PER_BALANCE_CNT * 3; 
+
+  if ( ! (S_ISREG(p_s_inode->i_mode) || S_ISDIR(p_s_inode->i_mode) || S_ISLNK(p_s_inode->i_mode)) )
+    return 0;
+
+  /* only pack when reiserfs_file_write tells us to by setting i_pack_on_close */
+  if (!p_s_inode->u.reiserfs_i.i_pack_on_close || dont_have_tails (p_s_inode->i_sb)) {
+    return 0 ;
+  }
+  p_s_inode->u.reiserfs_i.i_pack_on_close = 0 ;
+  journal_begin(&th, p_s_inode->i_sb, jbegin_count) ;
+  windex = push_journal_writer("reiserfs_release_inode") ;
+  reiserfs_update_inode_transaction(p_s_inode) ;
+  init_path (&s_search_path);
+
+  /* Copy key of the first object item. */
+  copy_key(&s_item_key, INODE_PKEY(p_s_inode));
+
+  /* New file size is the same as the original.  We are calling cut_from_item so it will do all the
+  ** indirect->direct work for us
+  */
+  n_new_file_size = p_s_inode->i_size;
+
+  /* Form key to search for the last file item. */
+  s_item_key.k_offset = MAX_KEY_OFFSET; /* pasted from truncate, I should be able to put the file size here right? */
+  if ( p_s_inode->u.reiserfs_i.i_first_direct_byte != NO_BYTES_IN_DIRECT_ITEM ) {
+    /* already packed, we're done */
+    pop_journal_writer(windex) ;
+    journal_end(&th, p_s_inode->i_sb, jbegin_count) ;
+    return 0 ;
+  } else {
+    s_item_key.k_uniqueness = TYPE_INDIRECT;
+  }
+  if ( search_for_position_by_key(p_s_inode->i_sb, &s_item_key, &s_search_path, &n_pos_in_item, &n_repeat) == POSITION_FOUND )
+    reiserfs_panic (p_s_inode->i_sb, "PAP-5660: reiserfs_file_release: "
+		      "object item has too big offset");
+
+  /* pasted from truncate.  Why am I doing this? */
+  n_pos_in_item--;
+
+  /* Calculate old size of the file. Pasted from truncate.  I'm keeping this incase the inode is wrong some how,
+  ** but I really don't need it
+  */
+  p_s_ih = PATH_PITEM_HEAD(&s_search_path);
+  if ( I_IS_STAT_DATA_ITEM(p_s_ih) )
+    n_file_size = 0;
+  else
+    n_file_size = p_s_ih->ih_key.k_offset + I_BYTES_NUMBER(p_s_ih,p_s_inode->i_sb->s_blocksize) - 1;
+
+  if ( n_file_size == 0 || n_file_size != n_new_file_size ||
+       (STORE_TAIL_IN_UNFM( I_BYTES_NUMBER(p_s_ih,p_s_inode->i_sb->s_blocksize), n_file_size, p_s_inode->i_sb->s_blocksize))
+  ) {
+    pathrelse(&s_search_path);
+    pop_journal_writer(windex) ;
+    journal_end(&th, p_s_inode->i_sb, jbegin_count) ;
+    return 0;
+  }
+
+  /* Update key to search for the last file item. */
+  s_item_key.k_offset = n_file_size;
+
+  /* Cut or delete file item. */
+  n_deleted = reiserfs_cut_from_item(&th, p_s_inode, p_s_inode->i_sb, &s_search_path, &n_pos_in_item, &s_item_key, n_new_file_size, 
+                                     NOTHING_SPECIAL);
+
+#ifdef REISERFS_CHECK
+  if ( n_deleted > n_file_size ){
+    reiserfs_panic (p_s_inode->i_sb, "PAP-5670: reiserfs_file_release: "
+		    "reiserfs_file_release returns too big number: deleted %d, file_size %lu, item_key %k",
+		    n_deleted, n_file_size, &s_item_key);
+  }
+#endif
+
+#ifdef REISERFS_CHECK
+  if ( n_file_size > n_new_file_size )
+    reiserfs_panic (p_s_inode->i_sb, "PAP-5680: reiserfs_file_release: object item did not find");
+#endif
+
+  /* note, FS corruption after crash if I don't update the stat data.  Why? */
+  p_s_inode->i_mtime = p_s_inode->i_ctime = CURRENT_TIME;
+  if_in_ram_update_sd (&th, p_s_inode);
+  pop_journal_writer(windex) ;
+  journal_end(&th, p_s_inode->i_sb, jbegin_count) ;
+  return 0 ;
+}
+
+/* Truncate file to the new size. */
+void  reiserfs_truncate_file(
+        struct  inode * p_s_inode       /* Pointer to the file inode. New size
+                                            already marked in the inode. */
+      ) {
+  struct path           s_search_path;  /* Path to the current object item. */
+  struct item_head    * p_s_ih;         /* Pointer to an item header. */
+  struct key            s_item_key;     /* Key to search for a previous file item. */
+  unsigned long         n_file_size,    /* Old file size. */
+                        n_new_file_size;/* New file size. */
+  int                   n_deleted,      /* Number of deleted or truncated bytes. */
+                        n_pos_in_item,  /* Found position in an item. */
+  			n_repeat;   
+  int windex ;
+  int jbegin_count = JOURNAL_PER_BALANCE_CNT * 3 ;
+  struct reiserfs_transaction_handle th ;
+
+  if ( ! (S_ISREG(p_s_inode->i_mode) || S_ISDIR(p_s_inode->i_mode) || S_ISLNK(p_s_inode->i_mode)) )
+    return;
+
+  journal_begin(&th, p_s_inode->i_sb, jbegin_count) ;
+  windex = push_journal_writer("reiserfs_truncate_file") ;
+  init_path (&s_search_path);
+  reiserfs_update_inode_transaction(p_s_inode) ;
+
+  /* Copy key of the first object item. */
+  copy_key(&s_item_key, INODE_PKEY(p_s_inode));
+
+  /* Get new file size. */
+  n_new_file_size = p_s_inode->i_size;
+
+  /* Form key to search for the last file item. */
+  s_item_key.k_offset = MAX_KEY_OFFSET; /* We don't know old size of the file. */
+  if ( p_s_inode->u.reiserfs_i.i_first_direct_byte != NO_BYTES_IN_DIRECT_ITEM )
+    s_item_key.k_uniqueness = TYPE_DIRECT;
+  else
+    s_item_key.k_uniqueness = TYPE_INDIRECT;
+
+  if ( search_for_position_by_key(p_s_inode->i_sb, &s_item_key, &s_search_path, &n_pos_in_item, &n_repeat) == POSITION_FOUND )
+    reiserfs_panic (p_s_inode->i_sb, "PAP-5660: reiserfs_truncate_file: "
+		      "object item has too big offset");
+  n_pos_in_item--;
+
+  /* Calculate old size of the file. */
+  p_s_ih = PATH_PITEM_HEAD(&s_search_path);
+  if ( I_IS_STAT_DATA_ITEM(p_s_ih) )
+    n_file_size = 0;
+  else
+    n_file_size = p_s_ih->ih_key.k_offset + I_BYTES_NUMBER(p_s_ih,p_s_inode->i_sb->s_blocksize) - 1;
+
+  if ( n_file_size == 0 || n_file_size <= n_new_file_size ) {
+#ifdef REISERFS_INFO
+    printk ("reiserfs_truncate_file: old file size = %lu < new file size = %lu\n", n_file_size, n_new_file_size);
+#endif
+    pathrelse(&s_search_path);
+    pop_journal_writer(windex) ;
+    journal_end(&th, p_s_inode->i_sb, jbegin_count) ;
+    return;
+  }
+  
+
+
+  /* Update key to search for the last file item. */
+  s_item_key.k_offset = n_file_size;
+
+  do  {
+    /* Cut or delete file item. */
+    n_deleted = reiserfs_cut_from_item(&th, p_s_inode, p_s_inode->i_sb, &s_search_path, &n_pos_in_item, 
+                                       &s_item_key, n_new_file_size, NOTHING_SPECIAL);
+
+#ifdef REISERFS_CHECK
+    if ( n_deleted > n_file_size ){
+      reiserfs_panic (p_s_inode->i_sb, "PAP-5670: reiserfs_truncate_file: "
+		      "reiserfs_truncate_file returns too big number: deleted %d, file_size %lu, item_key %k",
+		      n_deleted, n_file_size, &s_item_key);
+    }
+#endif
+
+    /* Change key to search the last file item. */
+    if ( (s_item_key.k_offset = (n_file_size -= n_deleted)) < p_s_inode->u.reiserfs_i.i_first_direct_byte )
+      s_item_key.k_uniqueness = TYPE_INDIRECT;
+
+    if (journal_transaction_should_end(&th, th.t_blocks_allocated)) {
+      int orig_len_alloc = th.t_blocks_allocated ;
+      p_s_inode->i_ctime = CURRENT_TIME ;
+      p_s_inode->i_mtime = CURRENT_TIME ;
+      decrement_counters_in_path(&s_search_path);
+      if_in_ram_update_sd(&th, p_s_inode) ;
+      journal_end(&th, p_s_inode->i_sb, orig_len_alloc) ;
+      journal_begin(&th, p_s_inode->i_sb, orig_len_alloc) ;
+      reiserfs_update_inode_transaction(p_s_inode) ;
+    }
+
+    /* While there are bytes to truncate and previous file item is presented in the tree. */
+  } while ( n_file_size > n_new_file_size &&
+	    search_for_position_by_key(p_s_inode->i_sb, &s_item_key, &s_search_path, &n_pos_in_item, &n_repeat) == POSITION_FOUND )  ;
+
+#ifdef REISERFS_CHECK
+  if ( n_file_size > n_new_file_size )
+    reiserfs_panic (p_s_inode->i_sb, "PAP-5680: reiserfs_truncate_file: object item did not find");
+#endif
+
+  p_s_inode->i_mtime = p_s_inode->i_ctime = CURRENT_TIME;
+  if_in_ram_update_sd (&th, p_s_inode);
+  pop_journal_writer(windex) ;
+  journal_end(&th, p_s_inode->i_sb, jbegin_count) ;
+}
+
+
+/* Paste bytes to the existing item. Returns bytes number pasted into the item. */
+int reiserfs_paste_into_item(
+	struct reiserfs_transaction_handle *th,
+	struct super_block  * p_s_sb,	   	/* Pointer to the supoer block.	*/
+	struct path         * p_s_search_path,	/* Path to the pasted item.          */
+	int                 * p_n_pos_in_item,	/* Paste position in the item above. */
+	struct key          * p_s_key,        	/* Key to search for the needed item.*/
+	const char          * p_c_body,       	/* Pointer to the bytes to paste.    */
+	int                   n_pasted_size,  	/* Size of pasted bytes.             */
+	int                   n_mem_mode,     	/* Copy from KERNEL or USER buffer.  */
+	int		      n_zeros_num	/* Number of zeros to be pasted.     */
+	) {
+    struct tree_balance s_paste_balance;
+    int                 n_fix_nodes_res,
+      			n_repeat;
+
+    if ( n_pasted_size < 0 )
+      reiserfs_panic(p_s_sb, "PAP-5690: reiserfs_paste_into_item: illegal pasted size");
+
+    init_tb_struct(&s_paste_balance, p_s_sb, p_s_search_path, n_pasted_size);
+    s_paste_balance.preserve_mode = NOTHING_SPECIAL;
+    while ( (n_fix_nodes_res = fix_nodes(th, M_PASTE, &s_paste_balance, *p_n_pos_in_item, NULL)) == SCHEDULE_OCCURRED ||
+	    n_fix_nodes_res == PATH_INCORRECT )  {
+
+#ifdef REISERFS_CHECK_ONE_PROCESS
+      if ( n_fix_nodes_res == PATH_INCORRECT )
+	reiserfs_panic(p_s_sb, "PAP-5700: reiserfs_paste_into_item: illegal returned value");
+#endif
+
+      /* schedule() occurred while fix_balance() worked */
+      if ( search_for_position_by_key (p_s_sb, p_s_key, p_s_search_path, p_n_pos_in_item, &n_repeat) == POSITION_FOUND ) {
+	reiserfs_panic (p_s_sb, "PAP-5710: reiserfs_paste_into_item: entry or pasted byte (%k) exists", p_s_key);
+      }
+#ifdef REISERFS_CHECK
+      {
+	struct item_head * found_ih = B_N_PITEM_HEAD (PATH_PLAST_BUFFER (p_s_search_path),
+						      PATH_LAST_POSITION (p_s_search_path));
+
+	if (I_IS_DIRECT_ITEM (found_ih)) {
+	  if (found_ih->ih_key.k_offset + I_BYTES_NUMBER (found_ih, p_s_sb->s_blocksize) !=
+	      p_s_key->k_offset ||
+	      I_BYTES_NUMBER (found_ih, p_s_sb->s_blocksize) != *p_n_pos_in_item)
+	    reiserfs_panic (p_s_sb, "PAP-5720: reiserfs_paste_into_item: found direct item (offset=%lu, length=%d) or position (%d) does not match to key (offset=%lu)",
+			    found_ih->ih_key.k_offset, found_ih->ih_item_len, *p_n_pos_in_item, p_s_key->k_offset);
+	}
+	if (I_IS_INDIRECT_ITEM (found_ih)) {
+	  if (found_ih->ih_key.k_offset + I_BYTES_NUMBER (found_ih, p_s_sb->s_blocksize) != p_s_key->k_offset || 
+	      I_UNFM_NUM (found_ih) != *p_n_pos_in_item ||
+	      found_ih->u.ih_free_space != 0)
+	    reiserfs_panic (p_s_sb, "PAP-5730: reiserfs_paste_into_item: "
+			  "found indirect item (offset=%lu, unfm pointers=%d, free_space=%d) or position (%d) does not match to key (%lu)",
+			    found_ih->ih_key.k_offset, I_UNFM_NUM (found_ih), found_ih->u.ih_free_space,
+			    *p_n_pos_in_item, p_s_key->k_offset);
+	}
+      }
+#endif
+    }
+
+    /* Perform balancing after all resources are collected by fix_nodes, and accessing
+      them will not risk triggering schedule. */
+    if ( n_fix_nodes_res == CARRY_ON ) {
+      journal_lock_dobalance(p_s_sb) ;
+
+      if ( s_paste_balance.insert_size[0] < 0 )
+	reiserfs_panic (p_s_sb, "PAP-5740: reiserfs_paste_into_item: insert_size = %d\n",s_paste_balance.insert_size[0]);
+
+      do_balance(th, &s_paste_balance, *p_n_pos_in_item, NULL, p_c_body, M_PASTE, n_mem_mode, n_zeros_num);
+      journal_unlock_dobalance(p_s_sb) ;
+      return (n_pasted_size);
+    }
+    unfix_nodes(th, &s_paste_balance);
+    return NO_DISK_SPACE; /* No disk space or io error. */
+}
+
+
+/* Insert new item into the buffer at the path. */
+int reiserfs_insert_item(
+			 struct reiserfs_transaction_handle *th,
+			 struct super_block  * 	p_s_sb,           /* Pointer to the super block.          */
+			 struct path         * 	p_s_path,         /* Path to the inserteded item.         */
+			 struct item_head    * 	p_s_ih,           /* Pointer to the item header to insert.*/
+			 const char          * 	p_c_body,         /* Pointer to the bytes to insert.      */
+			 int                   	n_mem_mode,       /* Copy from KERNEL or USER buffer.     */
+			 int			n_zeros_num,
+			 int			preserve_mode	  /* can be
+								     PRESERVE_INDIRECT_TO_DIRECT or
+								     NOTHING_SPECIAL. if
+								     PRESERVE_INDIRECT_TO_DIRECT,
+								     mark buffers new item gets into
+								     as suspected recipients */
+			 ) {
+    struct tree_balance s_ins_balance;
+    int                 n_fix_nodes_res,
+      			n_repeat;
+
+
+    init_tb_struct(&s_ins_balance, p_s_sb, p_s_path, IH_SIZE + p_s_ih->ih_item_len);
+    s_ins_balance.preserve_mode = preserve_mode;
+
+    p_s_ih->ih_reserved = 0;
+    if (p_c_body == 0)
+      n_zeros_num = p_s_ih->ih_item_len;
+
+
+    while ( (n_fix_nodes_res = fix_nodes(th, M_INSERT, &s_ins_balance, 0, p_s_ih)) == SCHEDULE_OCCURRED ||
+	    n_fix_nodes_res == PATH_INCORRECT ) {
+
+
+#ifdef REISERFS_CHECK_ONE_PROCESS
+      if ( n_fix_nodes_res == PATH_INCORRECT )
+	reiserfs_panic(p_s_sb, "PAP-5750: reiserfs_insert_item: illegal returned value");
+#endif
+
+      /* schedule occurred while fix_nodes() worked */
+      if ( search_by_key(p_s_sb, &(p_s_ih->ih_key), p_s_path, &n_repeat, DISK_LEAF_NODE_LEVEL, READ_BLOCKS) == ITEM_FOUND )
+	reiserfs_panic (p_s_sb, "PAP-5760: reiserfs_insert_item: inserted item exists (%k)", &(p_s_ih->ih_key));
+    }
+    /* make balancing after all resources will be collected at a time */ 
+    if ( n_fix_nodes_res == CARRY_ON ) {
+      journal_lock_dobalance(p_s_sb) ;
+      do_balance (th, &s_ins_balance, 0, p_s_ih, p_c_body, M_INSERT, n_mem_mode, n_zeros_num);
+      journal_unlock_dobalance(p_s_sb) ;
+      return p_s_ih->ih_item_len;
+    }
+
+    unfix_nodes(th, &s_ins_balance);
+    return NO_DISK_SPACE; /* No disk space or io error */
+}
+
+
+
+
+
+/*********************** range_read code ***************************************/
+
+/* It is interesting to consider why this code is so
+   complicated.... It seems like it ought to be simpler.*/
+
+
+/*  Get data buffer from cache which contains data (byte or directory record) of some object.
+    This data has minimal possible key >= than *p_range_begin and <= than *p_range_end.
+    In other words get first buffer contains data with key from range
+    [*p_key,*p_range_end].
+    If it is not possible (needed buffer is not in the cache) prepare (not uptodate) buffer
+    at path from root to the needed buffer. Don't read any blocks.
+    Returns:    1) via return value     0 if there is not an needed buffer, 1 otherwise;
+
+                2) via pp_s_buf:        NULL if the needed buffer is not in memory, 
+                                        or pointer to the needed buffer, or pointer to the prepared buffer;
+
+                3) via p_n_objectid:    Corresponding object id if pointer above points to an unformatted node, MAX_KEY_OBJECTID otherwise.
+
+                4) Recalculated head of the range in p_s_range_head */
+
+int get_buffer_by_range(
+      struct super_block      *	p_s_sb,			/* Super block.								*/
+      struct key              *	p_s_range_head,		/* Range begin.								*/
+      struct key              *	p_s_range_end,  	/* Range end.								*/
+      struct buffer_head     **	pp_s_buf,        	/* Returned value; result buffer.					*/
+      unsigned long	      *	p_n_objectid		/* Returned value; corresponding object id if *pp_s_buf points to an
+							   unformatted node, MAX_KEY_OBJECTID in other cases.			*/
+) {			
+
+  int                   n_res,
+    			n_pos_in_buffer,
+    			n_repeat,
+   			n_item_num,
+  			n_pos_in_item;
+  struct path		s_path;
+  struct buffer_head  * p_s_bh;             	/* current buffer                       */
+  struct key	        s_min_key,
+  		      *	p_s_rkey;
+  struct item_head    * p_s_ih,
+			s_ih;
+  unsigned long		n_unfm_pointer;
+
+#ifdef REISERFS_CHECK
+  int			n_repeat_counter = 0;
+#endif
+
+  init_path (&s_path);
+
+repeat:
+
+#ifdef REISERFS_CHECK
+  if ( ! (++n_repeat_counter % 10000) ) {
+    reiserfs_panic(p_s_sb, "PAP-5765: get_buffer_by_range: counter(%d) too big. range_head %k", n_repeat_counter, p_s_range_head);
+  }
+#endif
+
+
+  /* Search for the needed buffer in the range. */
+  n_res = search_by_key(p_s_sb, p_s_range_head, &s_path, &n_repeat, DISK_LEAF_NODE_LEVEL, DONT_READ_BLOCKS);
+
+  n_pos_in_buffer = PATH_LAST_POSITION(&s_path);
+
+#ifdef REISERFS_CHECK
+  if ( ! key_in_buffer (&s_path, p_s_range_head, p_s_sb) )
+    reiserfs_panic(p_s_sb, " PAP: 5770: get_buffer_by_range: key is not in the buffer");
+#endif
+
+  if ( ! buffer_uptodate(p_s_bh = PATH_PLAST_BUFFER(&s_path)) ) {
+    /* We can not get data buffer from range. Prepare buffer from the cache and recalculate right delimiting key. */
+    p_s_rkey = get_rkey(&s_path, p_s_sb);
+
+    if ( ! COMP_KEYS(p_s_rkey, &MIN_KEY) ) {
+
+#ifdef REISERFS_CHECK_ONE_PROCESS
+      reiserfs_panic(p_s_sb, "PAP-5780: get_buffer_by_range: can not get right delimiting key in case of one process");
+#endif
+
+#ifdef REISERFS_CHECK
+      if ( n_repeat == CARRY_ON )
+	reiserfs_panic(p_s_sb, "PAP-5790: get_buffer_by_range: get_rkey returns KEY_MIN");
+#endif
+
+      goto repeat;  /* We can not recalculate right delimiting key to continue search for the buffers in the range.
+		       Do that by old one. */
+    }
+    *pp_s_buf = p_s_bh;
+
+
+#ifdef REISERFS_CHECK
+    if ( ! key_in_buffer(&s_path, p_s_range_head, p_s_sb) )
+      reiserfs_panic(p_s_sb, "PAP-5791: get_buffer_by_range: key is not in the path");
+    if ( s_path.path_length < FIRST_PATH_ELEMENT_OFFSET )
+      reiserfs_panic(p_s_sb, "PAP-5792: get_buffer_by_range: path length is too small");
+#endif
+    
+    copy_key(p_s_range_head, p_s_rkey);
+    
+    s_path.path_length--;
+    decrement_counters_in_path(&s_path);
+    *p_n_objectid = MAX_KEY_OBJECTID;
+    return 1;
+  }
+
+  /* last buffer on the path is uptodate */
+
+#ifdef REISERFS_CHECK
+  if ( COMP_KEYS(B_N_PKEY(p_s_bh, 0), p_s_range_head) == 1 || COMP_KEYS(B_PRIGHT_DELIM_KEY(p_s_bh), p_s_range_head ) < 1 ) {
+    reiserfs_panic(p_s_sb, "PAP-5795: range head key %k we looked for is not in the buffer", p_s_range_head);
+  }
+  if ( ! B_IS_ITEMS_LEVEL(p_s_bh) || (n_res == ITEM_NOT_FOUND && ! n_pos_in_buffer) )
+    reiserfs_panic(p_s_sb, "PAP-5800: get_buffer_by_range: last buffer on the path is not leaf or returned position is 0");
+#endif
+
+  p_s_ih = B_N_PITEM_HEAD(p_s_bh, n_pos_in_buffer);
+  n_item_num = B_NR_ITEMS(p_s_bh);
+  /* Now we are defining the data which are placed in buffer p_s_bh and has minimal key
+     more than or equal to *p_range_begin. */
+  if ( n_res == ITEM_FOUND ) { /* Item was found in the tree. */
+    n_pos_in_item = 0;
+    copy_key(&s_min_key,&(p_s_ih->ih_key));
+  }
+
+  else {  /* Item was not found in the tree. */
+    /* Calculate min_key which is the minimal key of the byte or directory entry
+       more or equal than p_range_begin. */
+    n_pos_in_item = MAX_INT;
+    /*  Previous item is item of the same object we are looking for. */
+    if ( ! COMP_SHORT_KEYS(p_s_range_head, &((p_s_ih - 1)->ih_key)) ) {
+      if ( I_IS_DIRECTORY_ITEM(p_s_ih - 1) ) {
+	/* Search in the directory item for the entry that has minimal key more or equal than *p_s_range_head. */
+	bin_search_in_dir_item (p_s_ih - 1, B_I_DEH(p_s_bh, p_s_ih - 1), p_s_range_head, &n_pos_in_item);
+	if ( n_pos_in_item < I_ENTRY_COUNT(p_s_ih - 1) ) {
+	/* Previous item contains needed directory entry. */
+	  p_s_ih--;
+	  PATH_LAST_POSITION(&s_path)--;
+	  n_pos_in_buffer--;
+	  copy_key(&s_min_key, &p_s_ih->ih_key);
+	  s_min_key.k_offset = B_I_DEH(p_s_bh, p_s_ih)[n_pos_in_item].deh_offset;
+	  s_min_key.k_uniqueness = DIRENTRY_UNIQUENESS;
+	}
+	else
+	  /* key *p_s_range_head is greater than last entry in directory item */
+	  n_pos_in_item = MAX_INT;
+      }
+      else {
+	/* key *p_s_range_head is key of regular file */
+	if ( I_K_KEY_IN_ITEM(p_s_ih - 1, p_s_range_head, p_s_bh->b_size) ) {
+	  /* Previous item contains needed byte. */
+	  p_s_ih--;
+	  PATH_LAST_POSITION(&s_path)--;
+	  n_pos_in_buffer--;
+	  copy_key(&s_min_key, p_s_range_head);
+	  n_pos_in_item = p_s_range_head->k_offset - p_s_ih->ih_key.k_offset;
+	  if ( I_IS_INDIRECT_ITEM(p_s_ih) )
+	    n_pos_in_item /= p_s_bh->b_size;
+	}
+      }
+    }
+
+    if ( n_pos_in_item == MAX_INT ) {
+      /* key we looked for is not in the item */
+      if ( n_pos_in_buffer == n_item_num )
+	copy_key(&s_min_key, &MIN_KEY);
+      else {
+ 	n_pos_in_item = 0;
+	copy_key(&s_min_key, &(p_s_ih->ih_key));
+      }
+    }
+  }
+
+  if ( COMP_KEYS(&s_min_key, p_s_range_end) == 1 ) {
+ 
+/******************************************
+    if ( ! key_in_buffer(&s_path, p_s_range_head, p_s_sb) )
+      reiserfs_panic(p_s_sb, "PAP-2: get_buffer_by_range: path length is too small");
+*********************************************/
+
+    *pp_s_buf = NULL;
+    copy_key(p_s_range_head, &s_min_key);
+    decrement_counters_in_path(&s_path);
+    *p_n_objectid = MAX_KEY_OBJECTID;
+    return 0;    /* There is no buffer in the range in the tree. */
+  }
+
+  if ( ! COMP_KEYS(&s_min_key, &MIN_KEY) ) {
+    /* This leaf buffer is not in the range. */
+    p_s_rkey = get_rkey(&s_path, p_s_sb);
+    if ( ! COMP_KEYS(p_s_rkey, &MIN_KEY) ) {
+
+#ifdef REISERFS_CHECK_ONE_PROCESS
+      reiserfs_panic(p_s_sb, "PAP-5810: get_buffer_by_range: can not get right delimiting key in case of one process");
+#endif
+
+#ifdef REISERFS_CHECK
+      if ( n_repeat == CARRY_ON )
+	reiserfs_panic(p_s_sb, "PAP-5820: get_buffer_by_range: get_rkey returns MIN_KEY");
+#endif
+
+      goto repeat; /* We can not recalculate right delimiting key to continue search for the buffer in the range.
+		      Do that by old one. */
+    }
+
+    if ( ! COMP_KEYS(p_s_rkey, &MAX_KEY) ) {
+
+#ifdef REISERFS_CHECK
+      if ( ! key_in_buffer(&s_path, p_s_range_head, p_s_sb) )
+	reiserfs_panic(p_s_sb, "PAP-5830: get_buffer_by_range: key_in_buffer returned 0");
+#endif
+
+      *pp_s_buf = NULL;
+      copy_key(p_s_range_head, &MAX_KEY);
+      decrement_counters_in_path(&s_path);
+      *p_n_objectid = MAX_KEY_OBJECTID;
+      return 0;    /* There is no buffer in the range in the tree. */
+    }
+
+    *pp_s_buf = NULL;
+    copy_key(p_s_range_head, p_s_rkey); /* Reset range head and continue search for the buffer in the range. */
+    decrement_counters_in_path(&s_path);
+    *p_n_objectid = MAX_KEY_OBJECTID;
+    return 1;
+  }
+
+
+  if ( ! I_IS_INDIRECT_ITEM(p_s_ih) ) { /*  We have direct or directory item which contains byte or
+                                          directory record in the range in the buffer p_s_bh. */
+    /* Look for the next indirect item in the buffer */
+    for ( p_s_ih++, n_pos_in_buffer++; n_pos_in_buffer < n_item_num; n_pos_in_buffer++, p_s_ih++ )
+      if ( I_IS_INDIRECT_ITEM(p_s_ih) )
+        break;
+
+    if ( n_pos_in_buffer == n_item_num ) {
+      /* indirect item was not found. */
+      p_s_rkey = get_rkey(&s_path, p_s_sb);
+      if ( ! COMP_KEYS(p_s_rkey, &MIN_KEY) ) {
+
+#ifdef REISERFS_CHECK_ONE_PROCESS
+	reiserfs_panic(p_s_sb, "PAP-5830: get_buffer_by_range: can not get right delimiting key in case of one process");
+#endif
+
+#ifdef REISERFS_CHECK
+	if ( n_repeat == CARRY_ON )
+	  reiserfs_panic(p_s_sb, "PAP-5840: get_buffer_by_range: get_rkey returns MIN_KEY");
+#endif
+	
+	goto repeat; /* We can not recalculate right delimiting key to continue search for the buffers in the range.
+			Do that by old one. */
+      }
+      
+#ifdef REISERFS_CHECK
+      if ( ! key_in_buffer(&s_path, p_s_range_head, p_s_sb) )
+	reiserfs_panic(p_s_sb, "PAP-5850: get_buffer_by_range: key_in_buffer returned 0");
+
+      if ( COMP_KEYS(B_N_PKEY(p_s_bh, 0), p_s_range_head) == 1 || COMP_KEYS(B_PRIGHT_DELIM_KEY(p_s_bh), p_s_range_head ) < 1 ) {
+	reiserfs_panic(p_s_sb, "PAP-5860: get_buffer_by_range: range_head key %k is not in the last buffer on the path",
+		       p_s_range_head);
+      }
+#endif
+
+      copy_key(p_s_range_head, p_s_rkey); /* Reset range_head. */
+    }
+    else /* indirect item was found. */ {
+
+#ifdef REISERFS_CHECK
+      if ( COMP_KEYS(B_N_PKEY(p_s_bh, 0), p_s_range_head) == 1 || COMP_KEYS(B_PRIGHT_DELIM_KEY(p_s_bh), p_s_range_head ) < 1 ) {
+	reiserfs_panic(p_s_sb, "PAP-5870: get_buffer_by_range: range_head key %k is not in the last buffer on the path",
+		       p_s_range_head);
+      }
+#endif
+
+/******************************************
+      if ( ! key_in_buffer(&s_path, p_s_range_head, p_s_sb) )
+	reiserfs_panic(p_s_sb, "PAP-4: get_buffer_by_range: path length is too small");
+*********************************************/
+
+      copy_key(p_s_range_head, &(p_s_ih->ih_key)); /* Reset range head. */
+    }
+
+    *pp_s_buf = p_s_bh;
+
+#ifdef REISERFS_CHECK
+    if ( s_path.path_length < FIRST_PATH_ELEMENT_OFFSET )
+      reiserfs_panic(0, "PAP-5880: get_buffer_by_range: path length is too small (%d)", s_path.path_length);
+#endif
+
+    s_path.path_length--;
+    decrement_counters_in_path(&s_path);
+    *p_n_objectid = MAX_KEY_OBJECTID;
+    return 1;
+  }
+
+  /* Needed byte is located in an unformatted node. Check whether it is in cache.
+      And if not prepare buffer to read it. */
+  n_unfm_pointer = B_I_POS_UNFM_POINTER(p_s_bh, p_s_ih, n_pos_in_item);
+  if ( ! n_unfm_pointer ) { /* This is a hole (nothing to read). */
+    if ( n_pos_in_item + 1 == I_UNFM_NUM(p_s_ih) )
+      if ( n_pos_in_buffer + 1 == B_NR_ITEMS(p_s_bh) ) {
+	p_s_rkey = get_rkey(&s_path, p_s_sb);
+
+	if ( ! COMP_KEYS(p_s_rkey, &MIN_KEY) )
+	  goto repeat;
+
+	copy_key(p_s_range_head, p_s_rkey);
+      }
+      else
+	copy_key(p_s_range_head, &((p_s_ih + 1)->ih_key));
+    else {
+      copy_key(p_s_range_head, &(p_s_ih->ih_key));
+      p_s_range_head->k_offset += (n_pos_in_item + 1)*(p_s_sb->s_blocksize);
+    }
+
+    *pp_s_buf = NULL;
+    decrement_counters_in_path(&s_path);
+    *p_n_objectid = p_s_ih->ih_key.k_objectid;
+    return 1;
+  } /* unformatted node pointer contains 0 */
+
+
+  /* Copy found item header. */
+  copy_item_head(&s_ih, p_s_ih);
+  /* Get unformatted node buffer. */
+  n_repeat = CARRY_ON;
+  p_s_bh = reiserfs_getblk(p_s_sb->s_dev, n_unfm_pointer, p_s_sb->s_blocksize, &n_repeat);
+
+  if ( n_repeat != CARRY_ON  && comp_items(&s_ih, &s_path) ) {
+
+#ifdef REISERFS_CHECK_ONE_PROCESS
+    reiserfs_panic(p_s_sb, "PAP-5890: get_buffer_by_range: item in the path is changed in case of one process");
+#endif
+
+    brelse(p_s_bh);
+    goto repeat;
+  }
+
+#ifdef REISERFS_CHECK
+  if ( comp_items(&s_ih, &s_path) )
+    reiserfs_panic(p_s_sb, "PAP-5900: get_buffer_by_range: items must be equal");
+#endif
+
+  if ( n_pos_in_item + 1 == I_UNFM_NUM(p_s_ih) )
+    if ( n_pos_in_buffer + 1 == B_NR_ITEMS(PATH_PLAST_BUFFER(&s_path)) ) {
+      p_s_rkey = get_rkey(&s_path, p_s_sb);
+
+      if ( ! COMP_KEYS(p_s_rkey, &MIN_KEY) ) {
+	brelse(p_s_bh);
+	goto repeat;
+      }
+
+      copy_key(p_s_range_head, p_s_rkey);
+    }
+    else
+     copy_key(p_s_range_head, &((p_s_ih + 1)->ih_key));
+  else {
+    copy_key(p_s_range_head, &(p_s_ih->ih_key));
+    p_s_range_head->k_offset += (n_pos_in_item + 1)*(p_s_sb->s_blocksize);
+  }
+
+  *pp_s_buf = p_s_bh;
+  decrement_counters_in_path(&s_path);
+  *p_n_objectid = s_ih.ih_key.k_objectid;
+  return 1; 
+}
+
+
+int get_buffers_from_range(					/*  Returns length of the array of calculated
+								    buffers which is less or equal than
+								    max_nr_buffers_to_return.         			*/
+      struct  super_block     *	p_s_sb,				/*  Pointer to the super block.				*/
+      struct  key	      *	p_s_range_start,		/*  Minimal range key.                            	*/
+      struct  key	      * p_s_range_end,			/*  Maximal range key.                    		*/
+      struct  buffer_head    **	p_s_range_buffers,		/*  Returned array of pointers to buffer headers.
+								    Must be allocated in calling function.		*/
+      int     			n_max_nr_buffers_to_return	/*  Length of the allocated array.                	*/
+    ) {
+  struct key          * p_s_cur_key = p_s_range_start;
+  struct buffer_head  * p_s_res_buffer;
+  int			n_array_length = 0;
+  unsigned long		n_objectid;
+
+#ifdef REISERFS_CHECK
+  if ( COMP_KEYS(p_s_range_start, p_s_range_end) == 1 ||
+       ! COMP_KEYS(p_s_range_start, &MIN_KEY) || ! COMP_KEYS(p_s_range_start, &MAX_KEY) ||
+       ! COMP_KEYS(p_s_range_end, &MIN_KEY) || ! COMP_KEYS(p_s_range_end, &MAX_KEY) )
+    reiserfs_panic(p_s_sb, "PAP-5890: get_buffers_from_range: illegal range");
+#endif
+
+  /* While p_s_cur_key is in the range. */
+  while ( COMP_KEYS(p_s_cur_key, p_s_range_end) != 1 )  {
+    /* Calculate next buffer from range. */
+    if ( ! get_buffer_by_range(p_s_sb, p_s_cur_key, p_s_range_end, &p_s_res_buffer, &n_objectid) )
+      break; /* There are not more buffers in the range. */
+    p_s_range_buffers[n_array_length++] = p_s_res_buffer;
+    if ( n_array_length == n_max_nr_buffers_to_return )
+      break;
+  }
+  return n_array_length;
+}
+
+/* ok, this is not good at all.  Sometimes, we need to search for just an 
+** object id, without knowing the packing locality.  For the moment, this
+** searches through every possible packing locality until it founds the
+** object id in your key.  It starts by making a copy of the key, and setting
+** the k_dir_id to 0.  Every other arg works like search_by_key.
+**
+** After this returns, the last item in the p_s_search_path will have the
+** correct k_dir_id and k_objectid.
+**
+** This function is SLOW.  I mean really really SLOW.  Don't ever call it
+** unless you have no way at all to get the packing locality.
+**
+*/
+int search_by_objectid(
+                  struct super_block  * p_s_sb,         /* Super block.                           */
+                  struct key          * p_s_key,        /* Key to search. packing locality should be set to 0s */
+                  struct path         * p_s_search_path,/* This structure was allocated and initialized by
+                                                           the calling function. It is filled up by this
+                                                           function.  */
+                  int                 * p_n_repeat,     /* Whether schedule occured. */
+                  int                   n_stop_level,   /* How far down the tree to search.*/
+                  int                   n_bread_par     /* Whether to search even if it requires disk I/O, this is
+                                                           either READ_BLOCKS or DONT_READ_BLOCKS or 0. Hans doesn't
+                                                           know what 0 means, it seems to evaluate to DONT_READ_BLOCKS,
+                                                           but it is bad style to not use the macro.... there is a
+                                                           #define of search by key with no explanation that can allow
+                                                           it to happen.... */
+                  ) {
+  struct key cur_key ;
+  struct item_head *ih ;
+  int loop_count = 0 ;
+  int retval ;
+  unsigned long *objectid_map  ;
+  struct reiserfs_super_block *disk_sb ;
+  unsigned long max_objectid ;
+
+  /*  find the max possible objectid to search for */
+  disk_sb = SB_DISK_SUPER_BLOCK(p_s_sb) ;
+  objectid_map = (unsigned long *)(disk_sb + 1) ;
+  max_objectid = objectid_map[disk_sb->s_oid_cursize - 1] ;
+
+  copy_key(&cur_key, p_s_key) ;
+  cur_key.k_dir_id = 0 ;
+  while(1) {
+    retval = search_by_key(p_s_sb, &cur_key, p_s_search_path, p_n_repeat, n_stop_level, n_bread_par) ;    
+    ih = PATH_PITEM_HEAD(p_s_search_path) ;
+    if (retval == ITEM_FOUND) {
+      return retval ;
+    } else if (retval == ITEM_NOT_FOUND) {
+      cur_key.k_dir_id++ ;
+      if (cur_key.k_dir_id > max_objectid) {
+	reiserfs_warning("clm-1001: search_by_objectid: current key dir id %d is > than max object id %lu, giving up\n", cur_key.k_dir_id, max_objectid) ;
+        return retval ;
+      }
+    } else {
+      return retval ;
+    }
+    if ((++loop_count % 10000000) == 0) {
+      reiserfs_warning("clm-1000: search_by_objectid, item not found after %d iterations looking for %k, last attempt %k\n", loop_count, p_s_key, &(ih->ih_key)) ;
+    }
+  }
+  return retval ;
+}
Index: empeg/kernel/fs/reiserfs/super.c
diff -u /dev/null empeg/kernel/fs/reiserfs/super.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/super.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,711 @@
+/*
+ * Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
+ */
+#ifdef __KERNEL__
+
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <asm/uaccess.h>
+#include <linux/reiserfs_fs.h>
+#include <linux/locks.h>
+#include <linux/init.h>
+
+#else
+
+#include "nokernel.h"
+#include <stdlib.h> // for simple_strtoul
+
+#endif
+
+#define REISERFS_OLD_BLOCKSIZE 4096
+#define REISERFS_SUPER_MAGIC_STRING_OFFSET_NJ 20
+
+#if 0 /* journal victim */
+void mark_suspected_recipients_dirty (struct reiserfs_transaction_handle *th, kdev_t dev)
+{
+  struct buffer_head * bh;
+  int nlist;
+  int dirtied = 0;
+  struct super_block *s = reiserfs_get_super(dev) ;
+
+repeat:
+  for(nlist = 0; nlist < NR_LIST; nlist++) {
+    bh = lru_list[nlist];
+    if(!bh) continue;
+    
+    do {
+      if (bh->b_dev == dev && test_bit (12, &(bh->b_state))) {
+	if (!buffer_dirty (bh)) {
+	  journal_mark_dirty(th, s, bh) ;
+	  printk ("sr found: block %ld, state %lo\n", bh->b_blocknr, bh->b_state);
+	  dirtied ++;
+	  goto repeat;
+	}
+      }
+      bh = bh->b_next_free;
+    } while (bh != lru_list[nlist]);
+  }
+  if (dirtied)
+    printk ("mark_suspected_recipients_dirty: found %d suspected recipients, dirtied\n", dirtied);
+}
+#endif /* journal victim */
+
+/* like fs.h:/mark_buffer_dirty but refile_buffer */
+inline void reiserfs_mark_buffer_dirty (struct buffer_head * bh, int flag)
+{
+  if (!test_and_set_bit(BH_Dirty, &bh->b_state))
+    set_writetime(bh, flag);
+}
+
+
+/* like fs.h:/mark_buffer_clean but refile_buffer */
+inline void reiserfs_mark_buffer_clean (struct buffer_head * bh)
+{
+  test_and_clear_bit(BH_Dirty, &bh->b_state);
+}
+
+
+void reiserfs_write_super (struct super_block * s)
+{
+
+  int dirty = 0 ;
+  if (!(s->s_flags & MS_RDONLY)) {
+#if 0 /* journal victim */
+    rs = SB_DISK_SUPER_BLOCK (s);
+    /*
+     * if reiserfs was mounted with read-write permissions make file
+     * system state not valid so that if we crash without doing a
+     * clean umount we know that we must run file system
+     * checker. umount will mark it valid if it does a clean umount
+     */
+    if (le16_to_cpu (rs->s_state) == REISERFS_VALID_FS) {
+      rs->s_state = cpu_to_le16 (REISERFS_ERROR_FS);
+      /* mark_buffer_dirty (SB_BUFFER_WITH_SB (s), 1); */
+      journal_begin(&th, s, 1) ;
+      journal_mark_dirty(&th, s, SB_BUFFER_WITH_SB (s)) ;
+      journal_end(&th, s, 1) ;
+    }
+#endif
+    dirty = flush_old_commits(s, 1) ;
+  }
+  s->s_dirt = dirty;
+}
+
+
+void reiserfs_put_super (struct super_block * s)
+{
+  int i;
+  kdev_t dev = s->s_dev;
+  struct reiserfs_transaction_handle th ;
+
+  journal_begin(&th, s, 10) ;
+  if (s->u.reiserfs_sb.lock_preserve)
+    reiserfs_panic (s, "vs-2000: reiserfs_put_super: lock_preserve == %d", s->u.reiserfs_sb.lock_preserve);
+
+  /* change file system state to current state if it was mounted with read-write permissions */
+  if (!(s->s_flags & MS_RDONLY)) {
+    SB_REISERFS_STATE (s) = le16_to_cpu (s->u.reiserfs_sb.s_mount_state);
+    /* mark_buffer_dirty (SB_BUFFER_WITH_SB (s), 1); */
+    journal_mark_dirty(&th, s, SB_BUFFER_WITH_SB (s));
+  }
+
+#if 0
+  if (maybe_free_preserve_list (s) == 0) {
+    reiserfs_warning ("vs-2003: reiserfs_put_super: there are %ld buffers to write\n",
+		      s->u.reiserfs_sb.s_suspected_recipient_count);
+#ifdef REISERFS_CHECK
+    preserve_trace_print_srs (s);
+#endif
+
+    /* mark_suspected_recipients_dirty (&th, dev); journal victim */
+    fsync_dev (dev);
+    s->u.reiserfs_sb.s_suspected_recipient_count = 0;
+#ifdef REISERFS_CHECK
+    preserve_trace_reset_suspected_recipients (s);
+#endif
+    maybe_free_preserve_list (s);
+  }
+#endif
+
+  
+#if 0 /* journal victim */
+  for (i = 0; i < SB_BMAP_NR (s); i ++) {
+    /* update cautious bitmap */
+    if (memcmp (SB_AP_BITMAP (s)[i]->b_data, SB_AP_CAUTIOUS_BITMAP (s)[i], SB_AP_BITMAP (s)[i]->b_size)) {
+      memcpy (SB_AP_CAUTIOUS_BITMAP (s)[i]->b_data, SB_AP_BITMAP (s)[i]->b_data, SB_AP_BITMAP (s)[i]->b_size);
+      mark_buffer_dirty (SB_AP_CAUTIOUS_BITMAP (s)[i], 1);
+      ll_rw_block (WRITE, 1, &SB_AP_CAUTIOUS_BITMAP (s)[i]);
+    }
+  }
+#endif /* journal victim */
+  journal_release(&th, s) ;
+  /* reiserfs_sync_all_buffers(s->s_dev, 1) ; journal does not need this any more */
+
+
+  /* wait on write completion */
+  for (i = 0; i < SB_BMAP_NR (s); i ++) {
+    /* wait_on_buffer (SB_AP_CAUTIOUS_BITMAP (s)[i]); */
+    /* brelse (SB_AP_CAUTIOUS_BITMAP (s)[i]); */
+    brelse (SB_AP_BITMAP (s)[i]);
+  }
+
+  reiserfs_kfree (SB_AP_BITMAP (s), sizeof (struct buffer_head *) * SB_BMAP_NR (s), s);
+  /* reiserfs_kfree (SB_AP_CAUTIOUS_BITMAP (s), sizeof (struct buffer_head *) * SB_BMAP_NR (s), s); */
+
+
+  brelse (SB_BUFFER_WITH_SB (s));
+
+  print_statistics (s);
+
+  if (s->u.reiserfs_sb.s_kmallocs != 0) {
+    reiserfs_warning ("vs-2004: reiserfs_put_super: aloocated memory left %d\n", s->u.reiserfs_sb.s_kmallocs);
+  }
+
+  s->s_dev = 0;
+
+  fixup_reiserfs_buffers (dev);
+
+  MOD_DEC_USE_COUNT;
+  return;
+}
+
+
+/* super block operations are */
+static struct super_operations reiserfs_sops = 
+{
+  reiserfs_read_inode,
+  reiserfs_write_inode,
+  NULL,				/* put_inode*/
+  reiserfs_delete_inode,
+  reiserfs_notify_change,
+  reiserfs_put_super,
+  reiserfs_write_super,
+  reiserfs_statfs,
+  reiserfs_remount,
+  NULL, 				/* clear_inode */
+  NULL				/* umount_begin */
+};
+
+/* this was (ext2)parse_options */
+static int parse_options (char * options, unsigned long * mount_options, unsigned long * blocks)
+{
+    char * this_char;
+    char * value;
+  
+    *blocks = 0;
+    set_bit (GENERICREAD, mount_options);
+    if (!options)
+	/* use default configuration: complex read, create tails, preserve on */
+	return 1;
+    for (this_char = strtok (options, ","); this_char != NULL; this_char = strtok (NULL, ",")) {
+	if ((value = strchr (this_char, '=')) != NULL)
+	    *value++ = 0;
+	if (!strcmp (this_char, "notail")) {
+	    set_bit (NOTAIL, mount_options);
+	} else if (!strcmp (this_char, "replayonly")) {
+	    set_bit (REPLAYONLY, mount_options);
+	} else if (!strcmp (this_char, "resize")) {
+	    if (!value || !*value){
+	  	printk("reiserfs: resize option requires a value\n");
+	    }
+	    *blocks = simple_strtoul (value, &value, 0);
+	} else {
+	    printk ("reiserfs: Unrecognized mount option %s\n", this_char);
+	    return 0;
+	}
+    }
+    return 1;
+}
+
+
+
+int reiserfs_is_super(struct super_block *s) {
+   return (s->s_dev != 0 && s->s_op == &reiserfs_sops) ;
+}
+int reiserfs_remount (struct super_block * s, int * flags, char * data)
+{
+  struct reiserfs_super_block * rs;
+  struct reiserfs_transaction_handle th ;
+  unsigned long blocks;
+  unsigned long mount_options;
+
+  rs = SB_DISK_SUPER_BLOCK (s);
+
+  if (!parse_options(data, &mount_options, &blocks))
+  	return 0;
+
+  if(blocks) 
+  	reiserfs_resize(s, blocks);
+	
+  journal_begin(&th, s, 10) ;
+  if ((unsigned long)(*flags & MS_RDONLY) == (s->s_flags & MS_RDONLY)) {
+    /* there is nothing to do to remount read-only fs as read-only fs */
+    journal_end(&th, s, 10) ;
+    return 0;
+  }
+  if (*flags & MS_RDONLY) {
+    /* try to remount file system with read-only permissions */
+    if (le16_to_cpu (rs->s_state) == REISERFS_VALID_FS ||
+	s->u.reiserfs_sb.s_mount_state != REISERFS_VALID_FS) {
+      journal_end(&th, s, 10) ;
+      return 0;
+    }
+    /* Mounting a rw partition read-only. */
+    rs->s_state = cpu_to_le16 (s->u.reiserfs_sb.s_mount_state);
+    /* mark_buffer_dirty (SB_BUFFER_WITH_SB (s), 1); journal victim */
+    journal_mark_dirty(&th, s, SB_BUFFER_WITH_SB (s));
+    s->s_dirt = 0;
+  } else {
+    /* Mount a partition which is read-only, read-write */
+    s->u.reiserfs_sb.s_mount_state = le16_to_cpu (rs->s_state);
+    s->s_flags &= ~MS_RDONLY;
+    rs->s_state = cpu_to_le16 (REISERFS_ERROR_FS);
+    /* mark_buffer_dirty (SB_BUFFER_WITH_SB (s), 1); */
+    journal_mark_dirty(&th, s, SB_BUFFER_WITH_SB (s));
+    s->s_dirt = 0;
+    s->u.reiserfs_sb.s_mount_state = REISERFS_VALID_FS ;
+    if (test_bit(NOTAIL, &mount_options)) {
+      set_bit(NOTAIL, &(s->u.reiserfs_sb.s_mount_opt)) ;
+    }
+    
+    /* check state, which file system had when remounting read-write */
+#if 0 /* journal victim */    
+    if (s->u.reiserfs_sb.s_mount_state != REISERFS_VALID_FS)
+      printk ("REISERFS: remounting unchecked fs, "
+	      "running reiserfsck is recommended\n");
+#endif
+  }
+  /* this will force a full flush of all journal lists */
+  SB_JOURNAL(s)->j_must_wait = 1 ;
+  journal_end(&th, s, 10) ;
+  return 0;
+}
+
+
+struct key root_key = {REISERFS_ROOT_PARENT_OBJECTID, REISERFS_ROOT_OBJECTID, 0, 0};
+
+static int read_bitmaps (struct super_block * s)
+{
+  int i, repeat, bmp, dl ;
+  struct reiserfs_super_block * rs = SB_DISK_SUPER_BLOCK(s);
+
+  repeat = 0 ;
+  /* read true bitmap block */
+  SB_AP_BITMAP (s) = reiserfs_kmalloc (sizeof (struct buffer_head *) * le16_to_cpu (rs->s_bmap_nr), GFP_KERNEL, s);
+  if (SB_AP_BITMAP (s) == 0)
+    return 1;
+
+  memset (SB_AP_BITMAP (s), 0, sizeof (struct buffer_head *) * le16_to_cpu (rs->s_bmap_nr));
+
+  /* read bitmap blocks */
+				/* reiserfs leaves the first 64k unused
+                                   so that any partition labeling scheme
+                                   currently used will have enough
+                                   space. Then we need one block for the
+                                   super.  -Hans */
+  bmp = (REISERFS_DISK_OFFSET_IN_BYTES / s->s_blocksize) + 1;	/* first of bitmap blocks */
+  SB_AP_BITMAP (s)[0] = reiserfs_bread (s->s_dev, bmp, s->s_blocksize, &repeat);
+  if(!SB_AP_BITMAP(s)[0])
+	  return 1;
+  for (i = 1, bmp = dl = rs->s_blocksize * 8; i < le16_to_cpu (rs->s_bmap_nr); i ++) {
+    SB_AP_BITMAP (s)[i] = reiserfs_bread (s->s_dev, bmp, s->s_blocksize, &repeat);
+    if (!SB_AP_BITMAP (s)[i])
+      return 1;
+	bmp += dl;
+  }
+
+  return 0;
+}
+
+static int read_old_bitmaps (struct super_block * s)
+{
+  int i, repeat ;
+  struct reiserfs_super_block * rs = SB_DISK_SUPER_BLOCK(s);
+  int bmp1 = (REISERFS_OLD_DISK_OFFSET_IN_BYTES / s->s_blocksize) + 1;  /* first of bitmap blocks */
+
+  repeat = 0 ;
+  /* read true bitmap */
+  SB_AP_BITMAP (s) = reiserfs_kmalloc (sizeof (struct buffer_head *) * le16_to_cpu (rs->s_bmap_nr), GFP_KERNEL, s);
+  if (SB_AP_BITMAP (s) == 0)
+    return 1;
+
+  memset (SB_AP_BITMAP (s), 0, sizeof (struct buffer_head *) * le16_to_cpu (rs->s_bmap_nr));
+
+  for (i = 0; i < le16_to_cpu (rs->s_bmap_nr); i ++) {
+    SB_AP_BITMAP (s)[i] = reiserfs_bread (s->s_dev, bmp1 + i, s->s_blocksize, &repeat);
+    if (!SB_AP_BITMAP (s)[i])
+      return 1;
+  }
+	
+  return 0;
+}
+
+
+void check_bitmap (struct super_block * s)
+{
+  int i = 0;
+  int free = 0;
+  char * buf;
+
+  while (i < SB_BLOCK_COUNT (s)) {
+    buf = SB_AP_BITMAP (s)[i / (s->s_blocksize * 8)]->b_data;
+    if (!test_bit (i % (s->s_blocksize * 8), buf))
+      free ++;
+    i ++;
+  }
+
+  if (free != SB_FREE_BLOCKS (s))
+    reiserfs_warning ("vs-4000: check_bitmap: %d free blocks, must be %d\n",
+		      free, SB_FREE_BLOCKS (s));
+}
+
+
+/* support old disk layout */
+static int read_old_super_block (struct super_block * s, int size)
+{
+  struct buffer_head * bh;
+  struct reiserfs_super_block * rs;
+  int repeat ;
+
+  printk("reiserfs_read_super: try to find super block in old location\n");
+  repeat = 0 ;
+  /* there are only 4k-sized blocks in v3.5.10 */
+  if (size != REISERFS_OLD_BLOCKSIZE)
+	  set_blocksize(s->s_dev, REISERFS_OLD_BLOCKSIZE);
+  bh = bread (s->s_dev, 
+  			  REISERFS_OLD_DISK_OFFSET_IN_BYTES / REISERFS_OLD_BLOCKSIZE, 
+ 		      REISERFS_OLD_BLOCKSIZE);
+  if (!bh) {
+    printk("reiserfs_read_super: unable to read superblock on dev %s\n", kdevname(s->s_dev));
+    return 1;
+  }
+
+  rs = (struct reiserfs_super_block *)bh->b_data;
+  if (strncmp (rs->s_magic,  REISERFS_SUPER_MAGIC_STRING, strlen ( REISERFS_SUPER_MAGIC_STRING))) {
+	  /* pre-journaling version check */
+	  if(!strncmp((char*)rs + REISERFS_SUPER_MAGIC_STRING_OFFSET_NJ,
+				  REISERFS_SUPER_MAGIC_STRING, strlen(REISERFS_SUPER_MAGIC_STRING))) {
+		  printk("reiserfs_read_super: a pre-journaling reiserfs filesystem isn't suitable there.\n");
+		  brelse(bh);
+		  return 1;
+	  }
+	  
+    brelse (bh);
+    printk ("reiserfs_read_super: can't find a reiserfs filesystem on dev %s.\n", kdevname(s->s_dev));
+    return 1;
+  }
+
+  if(REISERFS_OLD_BLOCKSIZE != le16_to_cpu (rs->s_blocksize)) {
+  	printk("reiserfs_read_super: blocksize mismatch, super block corrupted\n");
+	brelse(bh);
+	return 1;
+  }	
+
+  s->s_blocksize = REISERFS_OLD_BLOCKSIZE;
+  s->s_blocksize_bits = 0;
+  while ((1 << s->s_blocksize_bits) != s->s_blocksize)
+    s->s_blocksize_bits ++;
+
+  SB_BUFFER_WITH_SB (s) = bh;
+  SB_DISK_SUPER_BLOCK (s) = rs;
+  s->s_op = &reiserfs_sops;
+  return 0;
+}
+
+
+static int read_super_block (struct super_block * s, int size)
+{
+  struct buffer_head * bh;
+  struct reiserfs_super_block * rs;
+  int repeat ;
+
+  repeat = 0 ;
+  bh = bread (s->s_dev, (REISERFS_DISK_OFFSET_IN_BYTES / size), size);
+  if (!bh) {
+    printk("reiserfs_read_super: unable to read superblock on dev %s\n", kdevname(s->s_dev));
+    return 1;
+  }
+
+  rs = (struct reiserfs_super_block *)bh->b_data;
+  if (strncmp (rs->s_magic,  REISERFS_SUPER_MAGIC_STRING, strlen ( REISERFS_SUPER_MAGIC_STRING))) {
+    brelse (bh);
+    printk ("reiserfs_read_super: can't find a reiserfs filesystem on dev %s.\n", kdevname(s->s_dev));
+    return 1;
+  }
+
+  s->s_blocksize = le16_to_cpu (rs->s_blocksize);
+  s->s_blocksize_bits = 0;
+  while ((1 << s->s_blocksize_bits) != s->s_blocksize)
+    s->s_blocksize_bits ++;
+
+  if (size != rs->s_blocksize) {
+    brelse (bh);
+    set_blocksize (s->s_dev, s->s_blocksize);
+    bh = reiserfs_bread (s->s_dev,  (REISERFS_DISK_OFFSET_IN_BYTES / s->s_blocksize), s->s_blocksize, &repeat);
+    if (!bh) {
+      printk("reiserfs_read_super: unable to read superblock on dev %s\n", kdevname(s->s_dev));
+      return 1;
+    }
+
+    rs = (struct reiserfs_super_block *)bh->b_data;
+    if (strncmp (rs->s_magic,  REISERFS_SUPER_MAGIC_STRING, strlen ( REISERFS_SUPER_MAGIC_STRING)) ||
+	le16_to_cpu (rs->s_blocksize) != s->s_blocksize) {
+      brelse (bh);
+      printk ("reiserfs_read_super: can't find a reiserfs filesystem on dev %s.\n", kdevname(s->s_dev));
+      return 1;
+    }
+  }
+  /* must check to be sure we haven't pulled an old format super out of the
+  ** old format's log.  This is a kludge of a check, but it will work.  
+  ** If block we've just read in is inside the journal for that
+  ** super, it can't be valid.
+  */
+  if (bh->b_blocknr >= rs->s_journal_block && 
+      bh->b_blocknr < (rs->s_journal_block + JOURNAL_BLOCK_COUNT)) {
+      brelse(bh) ;
+      printk("super-459: reiserfs_read_super: super found at block %lu is within its own log.  It must not be of this format type.\n", bh->b_blocknr) ;
+      return 1 ;
+  }
+
+  SB_BUFFER_WITH_SB (s) = bh;
+  SB_DISK_SUPER_BLOCK (s) = rs;
+  s->s_op = &reiserfs_sops;
+  return 0;
+}
+
+/* after journal replay, reread all bitmap and super blocks */
+static int reread_meta_blocks(struct super_block *s) {
+  int i ;
+  ll_rw_block(READ, 1, &(SB_BUFFER_WITH_SB(s))) ;
+  wait_on_buffer(SB_BUFFER_WITH_SB(s)) ;
+  if (!buffer_uptodate(SB_BUFFER_WITH_SB(s))) {
+    printk("reread_meta_blocks, error reading the super\n") ;
+    return 1 ;
+  }
+
+  for (i = 0; i < SB_BMAP_NR(s) ; i++) {
+    ll_rw_block(READ, 1, &(SB_AP_BITMAP(s)[i])) ;
+    wait_on_buffer(SB_AP_BITMAP(s)[i]) ;
+    if (!buffer_uptodate(SB_AP_BITMAP(s)[i])) {
+      printk("reread_meta_blocks, error reading bitmap block number %d at %ld\n", i, SB_AP_BITMAP(s)[i]->b_blocknr) ;
+      return 1 ;
+    }
+  }
+  return 0 ;
+
+}
+
+static void print_credits(void) {
+  /* avoid printing credits endlessly */
+  static int did_this = 0;
+  if (did_this) return;
+  did_this = 1;
+  printk("ReiserFS core development sponsored by SuSE Labs (suse.com)\n") ;
+  printk("Journaling sponsored by MP3.com\n") ;
+  printk("Item handlers sponsored by Ecila.com\n") ;
+}
+
+struct super_block * reiserfs_read_super (struct super_block * s, void * data, int silent)
+{
+  int size;
+  struct inode *root_inode;
+  kdev_t dev = s->s_dev;
+  int j;
+  extern int *blksize_size[];
+  struct reiserfs_transaction_handle th ;
+  int old_format = 0;
+  unsigned long blocks;
+  int jinit_done = 0 ;
+
+  memset (&s->u.reiserfs_sb, 0, sizeof (struct reiserfs_sb_info));
+
+  if (parse_options ((char *) data, &(s->u.reiserfs_sb.s_mount_opt), &blocks) == 0) {
+    s->s_dev = 0;
+    return NULL;
+  }
+
+  if (blocks) {
+  	printk("reserfs: resize option for remount only\n");
+	return NULL;
+  }	
+
+  MOD_INC_USE_COUNT;
+  lock_super (s);
+
+  if (blksize_size[MAJOR(dev)] && blksize_size[MAJOR(dev)][MINOR(dev)] != 0) {
+    /* as blocksize is set for partition we use it */
+    size = blksize_size[MAJOR(dev)][MINOR(dev)];
+  } else {
+    size = BLOCK_SIZE;
+    set_blocksize (s->s_dev, BLOCK_SIZE);
+  }
+
+  /* read block, containing reiserfs super block (it is stored at REISERFS_FIRST_BLOCK-th 1K block) */
+  if (read_super_block (s, size)) {
+	  if(read_old_super_block(s,size)) 
+		  goto error;
+	  else
+		  old_format = 1;
+  }
+
+  s->u.reiserfs_sb.s_mount_state = le16_to_cpu (SB_DISK_SUPER_BLOCK (s)->s_state); /* journal victim */
+  s->u.reiserfs_sb.s_mount_state = REISERFS_VALID_FS ;
+
+  /* reiserfs can not be mounted when it propably contains errors */
+#if 0 /* journal victim */
+  if (le16_to_cpu (SB_DISK_SUPER_BLOCK (s)->s_state) != REISERFS_VALID_FS) {
+    printk ("reiserfs_read_super:  mounting unchecked fs, run reiserfsck first\n");
+    goto error;
+  }
+#endif
+  if (old_format ? read_old_bitmaps(s) : read_bitmaps(s)) { 
+	  printk ("reiserfs_read_super: unable to read bitmap\n");
+	  goto error;
+  }
+
+  if (journal_init(s)) {
+    printk("reiserfs_read_super: unable to initialize journal space\n") ;
+    goto error ;
+  } else {
+    jinit_done = 1 ; /* once this is set, journal_release must be called
+                     ** if we error out of the mount 
+		     */
+  }
+  if (reread_meta_blocks(s)) {
+    printk("reiserfs_read_super: unable to reread meta blocks after journal init\n") ;
+    goto error ;
+  }
+
+  if (replay_only (s))
+    goto error;
+
+  /*s->s_op = &reiserfs_sops;*/
+   
+  /* get root directory inode */
+  store_key (s, &root_key);
+  root_inode = iget (s, root_key.k_objectid);
+  forget_key (s, &root_key);
+  if (!root_inode) {
+    printk ("reiserfs_read_super: get root inode failed\n");
+    goto error;
+  }
+
+  s->s_root = d_alloc_root(root_inode, NULL);  
+  if (!s->s_root) {
+    iput(root_inode);
+    goto error;
+  }
+
+  if (!(s->s_flags & MS_RDONLY)) {
+    SB_DISK_SUPER_BLOCK (s)->s_state = cpu_to_le16 (REISERFS_ERROR_FS);
+    /* mark_buffer_dirty (SB_BUFFER_WITH_SB (s), 1); */
+    journal_begin(&th, s, 1) ;
+    journal_mark_dirty(&th, s, SB_BUFFER_WITH_SB (s));
+    journal_end(&th, s, 1) ;
+    s->s_dirt = 0;
+  }
+
+  /*s->u.reiserfs_sb.unpreserve = dont_preserve (s) ? 0 : unpreserve;*/
+  /* we have to do this to make journal writes work correctly */
+  SB_BUFFER_WITH_SB(s)->b_end_io = reiserfs_end_buffer_io_sync ;
+
+  unlock_super (s);
+  print_credits() ;
+  printk("%s\n", reiserfs_get_version_string()) ;
+  return s;
+
+ error:
+  if (jinit_done) { /* kill the commit thread, free journal ram */
+    journal_release_error(NULL, s) ;
+  }
+  if (SB_DISK_SUPER_BLOCK (s)) {
+    for (j = 0; j < le16_to_cpu (SB_DISK_SUPER_BLOCK (s)->s_bmap_nr); j ++) {
+      if (SB_AP_BITMAP (s))
+	brelse (SB_AP_BITMAP (s)[j]);
+      /* if (SB_AP_CAUTIOUS_BITMAP (s))
+	brelse (SB_AP_CAUTIOUS_BITMAP (s)[j]); */
+    }
+    if (SB_AP_BITMAP (s))
+      reiserfs_kfree (SB_AP_BITMAP (s), sizeof (struct buffer_head *) * SB_BMAP_NR (s), s);
+    /* if (SB_AP_CAUTIOUS_BITMAP (s))
+      reiserfs_kfree (SB_AP_CAUTIOUS_BITMAP (s), sizeof (struct buffer_head *) * SB_BMAP_NR (s), s); */
+  }
+  if (SB_BUFFER_WITH_SB (s))
+    brelse(SB_BUFFER_WITH_SB (s));
+  s->s_dev = 0;
+  unlock_super(s);
+  MOD_DEC_USE_COUNT;
+
+  return NULL;
+}
+
+
+int reiserfs_statfs (struct super_block * s, struct statfs * buf, int bufsize)
+{
+  struct statfs tmp;
+  struct reiserfs_super_block * rs = SB_DISK_SUPER_BLOCK (s);
+  
+				/* changed to accomodate gcc folks.*/
+  tmp.f_type =  REISERFS_SUPER_MAGIC;
+  tmp.f_bsize = le32_to_cpu (s->s_blocksize);
+  tmp.f_blocks = le32_to_cpu (rs->s_block_count) - le16_to_cpu (rs->s_bmap_nr) - 1;
+  tmp.f_bfree = le32_to_cpu (rs->s_free_blocks);
+  tmp.f_bavail = tmp.f_bfree;
+  tmp.f_files = 0;
+  tmp.f_ffree = 0;
+  tmp.f_namelen = (REISERFS_MAX_NAME_LEN (s->s_blocksize));
+  return copy_to_user (buf, &tmp, bufsize) ? -EFAULT : 0;
+}
+
+#ifdef __KERNEL__
+
+static struct file_system_type reiserfs_fs_type = {
+  "reiserfs", FS_REQUIRES_DEV, reiserfs_read_super, NULL
+};
+
+
+__initfunc(int init_reiserfs_fs(void))
+{
+        return register_filesystem(&reiserfs_fs_type);
+}
+
+#endif
+
+#ifdef MODULE
+EXPORT_NO_SYMBOLS;
+
+int init_module(void)
+{
+	return init_reiserfs_fs();
+}
+
+void cleanup_module(void)
+{
+        unregister_filesystem(&reiserfs_fs_type);
+}
+
+#endif
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
Index: empeg/kernel/fs/reiserfs/symlink.c
diff -u /dev/null empeg/kernel/fs/reiserfs/symlink.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/symlink.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,128 @@
+/*
+ * Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
+ */
+#ifdef __KERNEL__
+
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/reiserfs_fs.h>
+#include <asm/uaccess.h>
+
+#else
+
+#include "nokernel.h"
+
+#endif
+
+
+static int reiserfs_readlink(struct dentry *, char *, int);
+static struct dentry * reiserfs_follow_link(struct dentry *, struct dentry *, unsigned int);
+
+
+struct inode_operations reiserfs_symlink_inode_operations = {
+	NULL,			/* file-operations */
+	NULL,			/* create */
+	NULL,			/* lookup */
+	NULL,			/* link */
+	NULL,			/* unlink */
+	NULL,			/* symlink */
+	NULL,			/* mkdir */
+	NULL,			/* rmdir */
+	NULL,			/* mknod */
+	NULL,			/* rename */
+	reiserfs_readlink,	/* readlink */
+	reiserfs_follow_link,	/* follow_link */
+	NULL,			/* readpage */
+	NULL,			/* writepage */
+	NULL,			/* bmap */
+	NULL,			/* truncate */
+	NULL,			/* permission */
+	NULL,			/* smap */
+	NULL,			/* updatepage */
+	NULL			/* revalidate */
+	
+};
+
+
+static int read_symlink (struct inode * inode, char * buf, int memmode)
+{
+  struct key key;
+  int repeat, pos_in_item, chars, len = inode->i_size;
+  struct path path;
+  struct item_head * ih;
+
+  init_path (&path);
+  copy_key (&key, INODE_PKEY(inode));
+  key.k_offset = 1;
+  key.k_uniqueness = TYPE_DIRECT;
+
+  while (len > 0) {
+    if (search_for_position_by_key (inode->i_sb, &key, &path, &pos_in_item, &repeat) == POSITION_NOT_FOUND) {
+      reiserfs_warning ("vs-17000: read_symlink: symlink item not found");
+      return -EIO ;
+    }
+    ih = PATH_PITEM_HEAD(&path);
+    chars = ih->ih_item_len - pos_in_item;
+    if (memmode == REISERFS_KERNEL_MEM)
+      memcpy (buf, B_I_PITEM(PATH_PLAST_BUFFER(&path),ih) + pos_in_item, chars);
+    else
+      copy_to_user (buf, B_I_PITEM(PATH_PLAST_BUFFER(&path),ih) + pos_in_item, chars);
+    buf += chars;
+    key.k_offset += chars;
+    len -= chars;
+
+#ifdef REISERFS_CHECK
+    if (len < 0)
+      reiserfs_panic (inode->i_sb, "vs-17005: read_symlink: too many bytes read from symlink (%d). Must be %d", inode->i_size - len,
+		      inode->i_size);
+#endif
+
+    
+  }
+  *buf = 0;
+  decrement_counters_in_path(&path);
+  return 0 ;
+}
+
+
+static struct dentry * reiserfs_follow_link (struct dentry * dentry, struct dentry * base, unsigned int follow)
+{
+  struct inode * inode = dentry->d_inode;
+  char * buf;
+  int ret ;
+
+  buf = reiserfs_kmalloc (inode->i_size + 1, GFP_KERNEL, inode->i_sb);
+  if (buf == 0) {
+    dput (base);
+    return ERR_PTR(-ENOMEM);
+  }
+
+  ret = read_symlink (inode, buf, REISERFS_KERNEL_MEM);
+  if (ret != 0) {
+    reiserfs_kfree (buf, inode->i_size + 1, inode->i_sb);
+    dput (base);
+    return ERR_PTR(-EIO) ;
+  }
+
+  UPDATE_ATIME(inode);
+  base = lookup_dentry (buf, base, follow);
+  reiserfs_kfree (buf, inode->i_size + 1, inode->i_sb);
+
+  return base;
+}
+
+
+static int reiserfs_readlink (struct dentry * dentry, char * buffer, int buflen)
+{
+  struct inode * inode = dentry->d_inode;
+
+  if (read_symlink (inode, buffer, REISERFS_USER_MEM) != 0) {
+    return -EIO ;
+  }
+  return inode->i_size;
+}
+
+
+
+
+
Index: empeg/kernel/fs/reiserfs/teahash3.c
diff -u /dev/null empeg/kernel/fs/reiserfs/teahash3.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/teahash3.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,208 @@
+/*
+ * Keyed 32-bit hash function using TEA in a Davis-Meyer function
+ *   H0 = Key
+ *   Hi = E Mi(Hi-1) + Hi-1
+ *
+ * (see Applied Cryptography, 2nd edition, p448).
+ *
+ * Jeremy Fitzhardinge <jeremy@zip.com.au> 1998
+ * 
+ * Jeremy has agreed to the contents of reiserfs/README. -Hans
+ */
+
+#ifdef __KERNEL__
+#define assert(x)
+#else
+#include <assert.h>
+#include "nokernel.h"
+#endif
+
+#if 1
+/* OK for Intel */
+typedef unsigned long u32;
+typedef const unsigned char u8;
+#else
+#include <inttypes.h>
+typedef uint32_t u32;
+typedef uint8_t u8;
+#endif
+
+#include <linux/config.h>
+
+#define DELTA 0x9E3779B9
+#define FULLROUNDS 10		/* 32 is overkill, 16 is strong crypto */
+#define PARTROUNDS 6		/* 6 gets complete mixing */
+
+/* a, b, c, d - data; h0, h1 - accumulated hash */
+#define TEACORE(rounds)							\
+	do {								\
+		u32 sum = 0;						\
+		int n = rounds;						\
+		u32 b0, b1;						\
+									\
+		b0 = h0;						\
+		b1 = h1;						\
+									\
+		do							\
+		{							\
+			sum += DELTA;					\
+			b0 += ((b1 << 4)+a) ^ (b1+sum) ^ ((b1 >> 5)+b);	\
+			b1 += ((b0 << 4)+c) ^ (b0+sum) ^ ((b0 >> 5)+d);	\
+		} while(--n);						\
+									\
+		h0 += b0;						\
+		h1 += b1;						\
+	} while(0)
+
+u32 keyed_hash(/*u32 k[2], *//*u8*/const char *msg, int len)
+{
+	u32 k[] = { 0x9464a485, 0x542e1a94, 0x3e846bff, 0xb75bcfc3}; 
+
+	u32 h0 = k[0], h1 = k[1];
+	u32 a, b, c, d;
+	u32 pad;
+	int i;
+ 
+#ifdef CONFIG_YRH_HASH
+	int j, pow;
+#endif
+
+	assert(len >= 0 && len < 256);
+
+#ifdef CONFIG_YRH_HASH
+
+	for (pow=1,i=1; i < len; i++) pow = pow * 10; 
+
+        if (len == 1) 
+	  a = msg[0]-48;
+        else
+	  a = (msg[0] - 48) * pow;
+
+	for (i=1; i < len; i++) {
+	    c = msg[i] - 48; 
+	    for (pow=1,j=i; j < len-1; j++) pow = pow * 10; 
+ 	    a = a + c * pow;
+	}
+
+	for (; i < 40; i++) {
+	    c = '0' - 48; 
+	    for (pow=1,j=i; j < len-1; j++) pow = pow * 10; 
+ 	    a = a + c * pow;
+	}
+
+	for (; i < 256; i++) {
+	    c = i; 
+	    for (pow=1,j=i; j < len-1; j++) pow = pow * 10; 
+ 	    a = a + c * pow;
+	}
+
+	a = a << 7;
+	return ((u32)a);
+	
+#endif
+
+	pad = (u32)len | ((u32)len << 8);
+	pad |= pad << 16;
+
+	while(len >= 16)
+	{
+		a = (u32)msg[ 0]      |
+		    (u32)msg[ 1] << 8 |
+		    (u32)msg[ 2] << 16|
+		    (u32)msg[ 3] << 24;
+		b = (u32)msg[ 4]      |
+		    (u32)msg[ 5] << 8 |
+		    (u32)msg[ 6] << 16|
+		    (u32)msg[ 7] << 24;
+		c = (u32)msg[ 8]      |
+		    (u32)msg[ 9] << 8 |
+		    (u32)msg[10] << 16|
+		    (u32)msg[11] << 24;
+		d = (u32)msg[12]      |
+		    (u32)msg[13] << 8 |
+		    (u32)msg[14] << 16|
+		    (u32)msg[15] << 24;
+		
+		TEACORE(PARTROUNDS);
+
+		len -= 16;
+		msg += 16;
+	}
+
+	if (len >= 12)
+	{
+		assert(len < 16);
+
+		a = (u32)msg[ 0]      |
+		    (u32)msg[ 1] << 8 |
+		    (u32)msg[ 2] << 16|
+		    (u32)msg[ 3] << 24;
+		b = (u32)msg[ 4]      |
+		    (u32)msg[ 5] << 8 |
+		    (u32)msg[ 6] << 16|
+		    (u32)msg[ 7] << 24;
+		c = (u32)msg[ 8]      |
+		    (u32)msg[ 9] << 8 |
+		    (u32)msg[10] << 16|
+		    (u32)msg[11] << 24;
+
+		d = pad;
+		for(i = 12; i < len; i++)
+		{
+			d <<= 8;
+			d |= msg[i];
+		}
+	}
+	else if (len >= 8)
+	{
+		assert(len < 12);
+
+		a = (u32)msg[ 0]      |
+		    (u32)msg[ 1] << 8 |
+		    (u32)msg[ 2] << 16|
+		    (u32)msg[ 3] << 24;
+		b = (u32)msg[ 4]      |
+		    (u32)msg[ 5] << 8 |
+		    (u32)msg[ 6] << 16|
+		    (u32)msg[ 7] << 24;
+
+		c = d = pad;
+		for(i = 8; i < len; i++)
+		{
+			c <<= 8;
+			c |= msg[i];
+		}
+	}
+	else if (len >= 4)
+	{
+		assert(len < 8);
+
+		a = (u32)msg[ 0]      |
+		    (u32)msg[ 1] << 8 |
+		    (u32)msg[ 2] << 16|
+		    (u32)msg[ 3] << 24;
+
+		b = c = d = pad;
+		for(i = 4; i < len; i++)
+		{
+			b <<= 8;
+			b |= msg[i];
+		}
+	}
+	else
+	{
+		assert(len < 4);
+
+		a = b = c = d = pad;
+		for(i = 0; i < len; i++)
+		{
+			a <<= 8;
+			a |= msg[i];
+		}
+	}
+
+	TEACORE(FULLROUNDS);
+
+/*	return 0;*/
+	return h0^h1;
+}
Index: empeg/kernel/fs/reiserfs/version.c
diff -u /dev/null empeg/kernel/fs/reiserfs/version.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/version.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,7 @@
+/*
+ * Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
+ */
+
+char *reiserfs_get_version_string(void) {
+  return "ReiserFS version 3.5.18" ;
+}
Index: empeg/kernel/fs/reiserfs/utils/Makefile
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/Makefile:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/Makefile	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,60 @@
+
+.EXPORT_ALL_VARIABLES:
+
+TOPDIR = $(shell pwd)
+TMPBINDIR = $(TOPDIR)/bin
+INCLUDEDIR = $(TOPDIR)/include
+INCLUDEDIR2 = $(TOPDIR)/../../../include/linux
+
+SBIN = /sbin
+MANDIR = /usr/man/man8
+
+IDIRS = -I$(INCLUDEDIR) -I$(INCLUDEDIR2) -I-
+
+CFLAGS = -Wall -c -g -O $(IDIRS)
+LFLAGS = -L$(TMPBINDIR)
+#CFLAGS = -Wall -c -g -pg -O $(IDIRS)
+#LFLAGS =  -pg -L$(TMPBINDIR)
+
+
+#ALL_SUB_DIRS = lib obj mkreiserfs print_disk_layout emu fsck
+#ALL_PROGS = mkreiserfs fsck
+ALL_SUB_DIRS = lib obj mkreiserfs resize_reiserfs fsck dumpreiserfs emu
+ALL_PROGS = mkreiserfs resize_reiserfs fsck dumpreiserfs emu
+
+all:
+	mkdir -p bin
+	set -e; for i in $(ALL_SUB_DIRS); do $(MAKE) -C $$i ; done
+
+dep:
+	set -e; for i in $(ALL_SUB_DIRS); do $(MAKE) -C $$i dep ; done
+
+clean:
+	set -e; for i in $(ALL_SUB_DIRS); do $(MAKE) -C $$i clean ; done
+
+install:
+	for i in $(ALL_PROGS); do $(MAKE) -C $$i install ; done
+
+uninstall:
+	set -e; for i in $(ALL_PROGS); do $(MAKE) -C $$i uninstall ; done
+
+tags:   
+	:> TAGS
+#	cd mkreiserfs; etags *.[ch] ../lib/*.c ../include/*.h ../../*.c ../../../../include/linux/reiserfs*h
+#	cd fsck; etags *.[ch] ../lib/*.c ../include/*.h ../../../../include/linux/reiserfs*h
+#	cd print_disk_layout; etags *.[ch] ../lib/*.c ../include/*.h ../../../../include/linux/reiserfs*h
+#	cd lib; etags *.[ch] ../lib/*.c ../include/*.h ../../../../include/linux/reiserfs*h
+#	cd include; etags *.[ch] ../lib/*.c ../include/*.h ../../../../include/linux/reiserfs*h
+#	cd emu; etags *.[ch] ../lib/*.c ../include/*.h ../../../../include/linux/reiserfs*h
+#	cd obj; etags ../../*.[ch] ../../../../include/linux/reiserfs*h
+	rm -f TAGS; etags ../*.[ch] ../../../include/linux/reiserfs*h include/*.h lib/*.c dumpreiserfs/*.c mkreiserfs/*.c emu/*.c fsck/*.c
+
+
+
+
+
+
+
+
+
+
Index: empeg/kernel/fs/reiserfs/utils/Makefile.empeg
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/Makefile.empeg:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/Makefile.empeg	Fri Oct 20 16:48:40 2000
@@ -0,0 +1,4 @@
+# Cross-compile utils for ARM Linux
+
+all:
+	$(MAKE) CC="arm-linux-gcc -fsigned-char" AR=arm-linux-ar
Index: empeg/kernel/fs/reiserfs/utils/README
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/README:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/README	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,29 @@
+This contains programs to create (mkreiserfs) and repair
+(reiserfsck) reiserfs file system on a block device. 
+
+Building is simple:
+mkdir bin
+make
+
+After that you have binaries in bin/.
+
+You can `make install` to copy programs to /sbin
+and man pages to /usr/man/man8.
+
+
+NOTE: 	do not store data you take care about on reiserfs partition. It
+	is quite unstable yet.  Please, report any weird behaviour ro
+	reiser@idiom.com.
+
+
+FSCK NOTE:
+	DON'T USE FSCK ON JOURNALING REISERFS!!!  
+	Reiserfs stores data on disk in quite complicate manner. This leads
+	that reiserfsck does not look as a simple program. It should
+	still contain bugs. The perfect way to use it is to backup
+	target partition first (I am sorry, if you have desire, time and disk
+	space). If reiserfs will fail, it would be useful to use backuped copy
+	of the partition in the debugging.
+
+Thanks a lot
+
Index: empeg/kernel/fs/reiserfs/utils/dumpreiserfs/README
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/dumpreiserfs/README:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/dumpreiserfs/README	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,14 @@
+This is to be a man page for dumpreiserfs
+
+This program exists only to help to solve problem with reiserfsck.
+
+DUMPREISERFS
+It can be used to dump reiserfs partition out.
+Called with -p it will calculate how many bytes have to be transfereed.
+If -P specified, dumpreiserfs will write the partition metadata out to stdout n
+which should be caugth with |gzip -c > whatever.gz
+
+UNPACKREISERFS deals with the file created in the above way.
+zcat whatever.gz | unpackreiserfs /dev/wherever you want to reiserfs transferred to.
+
+5/10/99
Index: empeg/kernel/fs/reiserfs/utils/dumpreiserfs/dumpreiserfs.c
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/dumpreiserfs/dumpreiserfs.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/dumpreiserfs/dumpreiserfs.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,616 @@
+/*
+ * Copyright 1996-1999 Hans Reiser
+ */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <asm/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/vfs.h>
+#include <netinet/in.h>
+
+#include "inode.h"
+#include "sb.h"
+#include "io.h"
+#include "misc.h"
+#include "reiserfs_fs.h"
+#include "reiserfs.h"
+
+
+int g_new_internals;
+
+
+#define print_usage_and_exit() die ("Usage: %s [-b block-to-print][-idc] device\n\
+-i Causes to print all items of a leaf\n\
+-d                 content of directory items\n\
+-c                 content of direct items\n\
+-m                 bitmap blocks\n", argv[0]);
+
+
+
+struct reiserfs_fsstat {
+  int nr_internals;
+  int nr_leaves;
+  int nr_files;
+  int nr_directories;
+  int nr_unformatted;
+} g_stat_info;
+int g_comp_number = 0;
+
+/*
+ *  options
+ */
+int opt_print_regular_file_content = 0;/* -c */
+int opt_print_directory_contents = 0;	/* -d */
+int opt_print_leaf_items = 0;		/* -i */
+int opt_print_objectid_map = 0;	/* -o */
+int opt_print_block_map = 0;		/* -m */
+/* when you want print one block specify -b # */
+int opt_block_to_print = -1;
+int opt_pack = 0;	/* -P will produce output that should be |gzip -c > whatever.gz */
+			/* -p will calculate number of bytes needed to transfer the partition */
+int opt_print_journal;
+int opt_pack_all = 0;
+
+struct super_block g_sb;
+
+
+
+int print_mode (void)
+{
+    int mode = 0;
+
+    if (opt_print_leaf_items == 1)
+	mode |= PRINT_LEAF_ITEMS;
+    if (opt_print_directory_contents == 1)
+	mode |= (PRINT_LEAF_ITEMS | PRINT_DIRECTORY_ITEMS);
+    if (opt_print_regular_file_content == 1)
+	mode |= (PRINT_LEAF_ITEMS | PRINT_DIRECT_ITEMS);
+    return mode;
+}
+
+
+void print_disk_tree (int block_nr)
+{
+    struct buffer_head * bh;
+
+    bh = bread (g_sb.s_dev, block_nr, g_sb.s_blocksize);
+    if (B_IS_KEYS_LEVEL (bh)) {
+	int i;
+	struct disk_child * dc;
+
+	g_stat_info.nr_internals ++;
+	print_block (bh, print_mode (), -1, -1);
+      
+	dc = B_N_CHILD (bh, 0);
+	for (i = 0; i <= B_NR_ITEMS (bh); i ++, dc ++)
+	    print_disk_tree (dc->dc_block_number);
+
+    } else if (B_IS_ITEMS_LEVEL (bh)) {
+	g_stat_info.nr_leaves ++;
+	print_block (bh, print_mode (), -1, -1);
+    } else {
+	print_block (bh, print_mode (), -1, -1);
+	die ("print_disk_tree: bad block type");
+    }
+    brelse (bh);
+}
+
+
+
+void print_one_block (int block)
+{
+    struct buffer_head * bh;
+    
+    if (test_bit (block % (g_sb.s_blocksize * 8), 
+		  SB_AP_BITMAP (&g_sb)[block / (g_sb.s_blocksize * 8)]->b_data))
+	printf ("%d is used in true bitmap\n", block);
+    else
+	printf ("%d is free in true bitmap\n", block);
+
+    bh = bread (g_sb.s_dev, block, g_sb.s_blocksize);
+    if (!not_formatted_node (bh->b_data, g_sb.s_blocksize))
+	print_block (bh, PRINT_LEAF_ITEMS | PRINT_DIRECTORY_ITEMS | (opt_print_regular_file_content == 1 ? PRINT_DIRECT_ITEMS : 0), -1, -1);
+    else
+	printf ("Looks like unformatted\n");
+    brelse (bh);
+    return;
+}
+
+
+static char * parse_options (int argc, char * argv [])
+{
+    int c;
+    char * tmp;
+  
+    while ((c = getopt (argc, argv, "b:icdmoMpPaAj")) != EOF) {
+	switch (c) {
+	case 'b':	/* print a single node */
+	    opt_block_to_print = strtol (optarg, &tmp, 0);
+	    if (*tmp)
+		die ("parse_options: bad block size");
+	    break;
+
+	case 'p':	/* calculate number of bytes, that need to be transfered */
+	    opt_pack = 'c'; break;
+	case 'P':	/* dump a partition */
+	    opt_pack = 'p'; break;
+	case 'a':
+	    opt_pack_all = 'c'; break;
+	case 'A':
+	    opt_pack_all = 'p'; break;
+
+	case 'i':	/* print items of a leaf */
+	    opt_print_leaf_items = 1; break;
+
+	case 'd':	/* print directories */
+	    opt_print_directory_contents = 1; break;
+
+	case 'c':	/* print contents of a regular file */
+	    opt_print_regular_file_content = 1; break;
+
+	case 'o':	/* print a objectid map */
+	    opt_print_objectid_map = 1; break;
+
+	case 'm':	/* print a block map */
+	    opt_print_block_map = 1;  break;
+	case 'M':	/* print a block map with details */
+	    opt_print_block_map = 2;  break;
+	case 'j':
+	    opt_print_journal = 1; break; /* print transactions */
+	}
+    }
+    if (optind != argc - 1)
+	/* only one non-option argument is permitted */
+	print_usage_and_exit();
+  
+    return argv[optind];
+}
+
+
+/* journal has permanent location (currently) (after first bitmap
+   block and constant size (JOURNAL_BLOCK_COUNT + 1) */
+int journal_block (struct super_block * s, __u32 block)
+{
+/*
+    if (block > SB_AP_BITMAP (s)[0]->b_blocknr &&
+	block < SB_AP_BITMAP (s)[0]->b_blocknr + JOURNAL_BLOCK_COUNT + 1)
+	return 1;
+*/
+    if (block >= SB_JOURNAL_BLOCK (s) &&
+	block <= SB_JOURNAL_BLOCK (s) + s->u.reiserfs_sb.s_rs->s_orig_journal_size + 1)
+	return 1;
+    return 0;
+}
+
+
+int data_block (struct super_block * s, __u32 block)
+{
+    int i;
+
+    if (block == REISERFS_DISK_OFFSET_IN_BYTES / s->s_blocksize)
+      /* super block, not data block */
+      return 0;
+
+    for (i = 0; i < SB_BMAP_NR (s); i ++)
+	if (block == SB_AP_BITMAP (s)[i]->b_blocknr)
+	    /* bitmap block, not data block */
+	    return 0;
+
+    if (journal_block (s, block))
+	return 0;
+
+    return 1;
+}
+
+
+/* this dumps file sustem to stdout as a such way: 
+   16 bit blocksize
+   32 bit blocknumber
+   16 bit - record length
+   the record of given length
+   ..
+
+   to pack :   print_disk_layout -p /dev/xxx | gzip -c > xxx.gz
+   to unpack : zcat xxx.gz | unpackreiserfs /dev/xxx
+*/
+
+
+static int get_total_block_number (void)
+{
+  int i, j;
+  int retval = 0;
+    
+  retval = 0;
+    
+  if (opt_pack_all)
+    retval = SB_BLOCK_COUNT (&g_sb);
+  else {
+    for (i = 0; i < SB_BMAP_NR (&g_sb); i ++) {
+      for (j = 0; j < g_sb.s_blocksize * 8; j ++)
+	if (i * g_sb.s_blocksize * 8 + j < SB_BLOCK_COUNT (&g_sb) &&
+	    test_bit (j, SB_AP_BITMAP (&g_sb)[i]->b_data))
+	  retval ++;
+    }
+  }
+  return retval;
+}
+
+
+int direct_items = 0, direct_item_total_length = 0;
+int items = 0;
+int unreachable_items = 0;
+
+/* fill direct items with 0s */
+static void zero_direct_items (char * buf)
+{
+    int i;
+    struct item_head * ih;
+
+    if (((struct block_head *)buf)->blk_level != DISK_LEAF_NODE_LEVEL)
+	return;
+
+    /* leaf node found */
+    ih = (struct item_head *)(buf + BLKH_SIZE);
+
+    for (i = 0; i < ((struct block_head *)buf)->blk_nr_item; i ++, ih ++) {
+	if (I_IS_DIRECT_ITEM (ih)) {
+	    /* FIXME: do not zero symlinks */
+	    direct_items ++;
+	    direct_item_total_length += ih->ih_item_len;
+	    memset (buf + ih->ih_item_location, 0, ih->ih_item_len);
+	}
+	items ++;
+	if (ih->u.ih_free_space == 0xffff)
+	    unreachable_items ++;
+    }
+}
+
+
+
+void pack_partition (struct super_block * s)
+{
+    int i, j, k;
+    uint32_t blocknumber32;
+    uint16_t reclen16, data16;
+    __u32 done = 0;
+    char * data;
+    long long bytes_to_transfer = 0;
+    struct buffer_head * bh;
+    int total_block_number;
+
+
+    total_block_number = get_total_block_number ();
+    
+
+    /* write filesystem's block size to stdout as 16 bit number */
+    reclen16 = htons (s->s_blocksize);
+    if (opt_pack == 'p' || opt_pack_all == 'p')
+	write (1, &reclen16, sizeof (uint16_t));
+    bytes_to_transfer = sizeof (uint16_t);
+
+    /* go through blocks which are marked used in cautious bitmap */
+    for (i = 0; i < SB_BMAP_NR (s); i ++) {
+	for (j = 0; j < s->s_blocksize; j ++) {
+	    /* make sure, that we are not out of the device */
+	    if (i * s->s_blocksize * 8 + j * 8 == SB_BLOCK_COUNT (s))
+		goto out_of_bitmap;
+
+	    if (i * s->s_blocksize * 8 + j * 8 + 8 > SB_BLOCK_COUNT (s))
+		die ("build_the_tree: Out of bitmap");
+
+	    if (opt_pack_all == 0)
+		if (SB_AP_BITMAP (s)[i]->b_data[j] == 0) {
+		    /* skip busy block if 'a' not specified */
+		    continue;
+		}
+
+	    /* read 8 blocks at once */
+	    bh = bread (s->s_dev, i * s->s_blocksize + j, s->s_blocksize * 8);
+	    for (k = 0; k < 8; k ++) {
+		__u32 block;
+		
+		block = i * s->s_blocksize * 8 + j * 8 + k;
+		
+		if (opt_pack_all == 0 && (SB_AP_BITMAP (s)[i]->b_data[j] & (1 << k)) == 0)
+		    continue;
+#if 0
+		if ((SB_AP_BITMAP (s)[i]->b_data[j] & (1 << k)) == 0  || /* k-th block is free */
+		    block < SB_BUFFER_WITH_SB (s)->b_blocknr) /* is in skipped for drive manager area */
+		    continue;
+#endif
+		
+		print_how_far (&done, total_block_number);
+		
+		data = bh->b_data + k * s->s_blocksize;
+
+		if (not_formatted_node (data, s->s_blocksize)) {
+		    /* ok, could not find formatted node here. But
+                       this can be commit block, or bitmap which has
+                       to be transferred */
+		    if (!not_data_block (s, block)) {
+			/* this is usual unformatted node. Transfer
+                           its number only to erase previously existed
+                           formatted nodes on the partition we will
+                           apply transferred metadata to */
+	    
+			/* size of following record in network byte order */
+			reclen16 = htons (2);
+
+			/* the record record */
+			data16 = htons (MAX_HEIGHT + 1);/*?*/
+			data = (char *)&data16;
+		    } else {
+			/* write super block and bitmap block must be transferred as are */
+			/* size of record  */
+			reclen16 = htons (s->s_blocksize);
+	    
+			/* the record itself */
+			data = data;
+		    }
+		} else {
+		    /* any kind of formatted nodes gets here (super
+                       block, desc block of journal): FIXME: it would
+                       be useful to be able to find commit blocks */
+		    zero_direct_items (data);
+		    /* FIXME: do other packing */
+		    /* write size of following record */
+		    reclen16 = htons (s->s_blocksize);
+		    
+		    /* the record itself */
+		    data = data;
+
+#if 0
+		    if (blkh->blk_level > DISK_LEAF_NODE_LEVEL) {
+			/* block must look like internal node on the target
+			   partition. But (currently) fsck do not consider internal
+			   nodes, therefore we do not have to transfer contents of
+			   internal nodes */
+	    
+			/* size of following record in network byte order */
+			reclen16 = htons (2);
+	    
+			/* the record itself */
+			data16 = htons (DISK_LEAF_NODE_LEVEL + 1);
+			data = (char *)&data16;	  
+		    } else {
+	    
+			/* leaf node found */
+			ih = (struct item_head *)(blkh + 1);
+	    
+			/* fill direct items with 0s */
+			for (l = 0; l < blkh->blk_nr_item; l ++, ih ++)
+			    if (I_IS_DIRECT_ITEM (ih)) {
+				direct_items ++;
+				direct_item_total_length += ih->ih_item_len;
+				memset ((char *)blkh + ih->ih_item_location, 0, ih->ih_item_len);
+			    }
+	    
+			/* write size of following record */
+			reclen16 = htons (s->s_blocksize);
+	    
+			/* the record itself */
+			data = (char *)blkh;
+		    }
+#endif
+		}
+	  
+		/*fprintf (stderr, "block %d, reclen %d\n", block, ntohs (reclen16));*/
+	
+		/* write block number */
+		blocknumber32 = htonl (block);
+		bytes_to_transfer += sizeof (uint32_t) + sizeof (uint16_t) + ntohs (reclen16);
+		if (opt_pack == 'p' || opt_pack_all == 'p') {
+		    write (1, &blocknumber32, sizeof (uint32_t));
+		    /* write record len */
+		    write (1, &reclen16, sizeof (uint16_t));
+		    /* write the record */
+		    write (1, data, ntohs (reclen16));
+		}
+	    }
+      
+	    bforget (bh);
+	}
+    }
+    
+ out_of_bitmap:
+    fprintf (stderr, "done\n");
+    if (opt_pack == 'c' || opt_pack_all == 'c')
+	fprintf (stderr, "Bytes to transfer %Ld, sequential 0s %d in %d sequeneces (%items (%d unreacable))\n",
+		 bytes_to_transfer, direct_item_total_length, direct_items, items, unreachable_items);
+    else
+	fprintf (stderr, "Bytes dumped %Ld, sequential 0s %d in %d sequeneces\n",
+		 bytes_to_transfer, direct_item_total_length, direct_items);
+    
+    
+}
+
+
+
+
+/* print all valid transactions and found dec blocks */
+static void print_journal (struct super_block * s)
+{
+    struct buffer_head * d_bh, * c_bh;
+    struct reiserfs_journal_desc * desc ;
+    struct reiserfs_journal_commit *commit ;
+    int end_journal;
+    int start_journal;
+    int i, j;
+    int first_desc_block = 0;
+    int wrapped = 0;
+    int valid_transactions = 0;
+
+    start_journal = SB_JOURNAL_BLOCK (s);
+    end_journal = start_journal + JOURNAL_BLOCK_COUNT;
+    printf ("Start scanning from %d\n", start_journal);
+
+    for (i = start_journal; i < end_journal; i ++) {
+	d_bh = bread (s->s_dev, i, s->s_blocksize);
+	if (is_desc_block (d_bh)) {
+	    int commit_block;
+
+	    if (first_desc_block == 0)
+		/* store where first desc block found */
+		first_desc_block = i;
+
+	    print_block (d_bh); /* reiserfs_journal_desc structure will be printed */
+	    desc = bh_desc (d_bh);
+
+	    commit_block = d_bh->b_blocknr + desc->j_len + 1;
+	    if (commit_block >= end_journal) {
+		printf ("-- wrapped?");
+		wrapped = 1;
+		break;
+	    }
+
+	    c_bh = bread (s->s_dev, commit_block, s->s_blocksize);
+	    commit = bh_commit (c_bh);
+	    if (does_desc_match_commit (desc, commit)) {
+		printf ("commit block %d (trans_id %ld, j_len %ld) does not match\n", commit_block,
+			commit->j_trans_id, commit->j_len);
+		brelse (c_bh) ;
+		brelse (d_bh);
+		continue;
+	    }
+
+	    valid_transactions ++;
+	    printf ("(commit block %d) - logged blocks (", commit_block);
+	    for (j = 0; j < desc->j_len; j ++) {
+		if (j < JOURNAL_TRANS_HALF) {
+		    printf (" %ld", desc->j_realblock[j]);
+		} else {
+		    printf (" %ld", commit->j_realblock[i - JOURNAL_TRANS_HALF]);
+		}
+	    }
+	    printf ("\n");
+	    i += desc->j_len + 1;
+	    brelse (c_bh);
+	}
+	brelse (d_bh);
+    }
+    
+    if (wrapped) {
+	c_bh = bread (s->s_dev, first_desc_block - 1, s->s_blocksize);
+	commit = bh_commit (c_bh);
+	if (does_desc_match_commit (desc, commit)) {
+	    printf ("No! commit block %d (trans_id %ld, j_len %ld) does not match\n", first_desc_block - 1,
+		    commit->j_trans_id, commit->j_len);
+	} else {
+	    printf ("Yes! (commit block %d) - logged blocks (\n", first_desc_block - 1);
+	    for (j = 0; j < desc->j_len; j ++) {
+		if (j < JOURNAL_TRANS_HALF) {
+		    printf (" %ld", desc->j_realblock[j]);
+		} else {
+		    printf (" %ld", commit->j_realblock[i - JOURNAL_TRANS_HALF]);
+		}
+	    }
+	    printf ("\n");
+	}
+	brelse (c_bh) ;
+	brelse (d_bh);
+    }
+
+    printf ("%d valid transactions found\n", valid_transactions);
+
+    {
+	struct buffer_head * bh;
+	struct reiserfs_journal_header * j_head;
+
+	bh = bread (s->s_dev, s->u.reiserfs_sb.s_rs->s_journal_block + s->u.reiserfs_sb.s_rs->s_orig_journal_size,
+		    s->s_blocksize);
+	j_head = (struct reiserfs_journal_header *)(bh->b_data);
+
+	printf ("#######################\nJournal header:\n"
+		"j_last_flush_trans_id %ld\n"
+		"j_first_unflushed_offset %ld\n"
+		"j_mount_id %ld\n", j_head->j_last_flush_trans_id, j_head->j_first_unflushed_offset,
+		j_head->j_mount_id);
+	brelse (bh);
+    }
+}
+
+int main (int argc, char * argv[])
+{
+    char * file_name;
+    int dev, i;
+
+#if 1
+    if (1) {
+	/* ???? */
+	schedule ();
+	iput (0);
+    }
+#endif
+
+    fprintf (stderr, "\n<-----------dumpreiserfs, version 0.99, 2000----------->\n"); 
+    file_name = parse_options (argc, argv);
+
+
+    dev = open (file_name, O_RDONLY);
+    if (dev == -1)
+	die ("dumpreiserfs: Can not open device %s: %s\n", file_name, strerror (errno));
+    g_sb.s_dev = dev;
+
+    if (uread_super_block (&g_sb))
+	die ("dumpreiserfs: no reiserfs found on %s", file_name);
+    if (uread_bitmaps (&g_sb))
+	die ("dumpreiserfs: read_bitmap failed");
+
+    if (opt_pack || opt_pack_all) {
+	pack_partition (&g_sb);
+    } else {
+	/* dump file system to stdout */
+	if (opt_block_to_print != -1) {
+	    print_one_block (opt_block_to_print);
+	    goto end;
+	}
+
+	print_block (SB_BUFFER_WITH_SB (&g_sb));
+
+	if (opt_print_journal)
+	    print_journal (&g_sb);
+    
+	if (opt_print_objectid_map == 1)
+	    print_objectid_map (&g_sb);
+    
+	if (opt_print_block_map) {
+	    print_bmap (&g_sb, opt_print_block_map == 1 ? 1 : 0);
+	}
+
+	if (opt_print_regular_file_content || opt_print_directory_contents ||
+	    opt_print_leaf_items) {
+	    print_disk_tree (SB_ROOT_BLOCK (&g_sb));
+
+	    /* print the statistic */
+	    printf ("File system uses %d internal + %d leaves + %d unformatted nodes = %d blocks\n", 
+		    g_stat_info.nr_internals, g_stat_info.nr_leaves, g_stat_info.nr_unformatted, 
+		    g_stat_info.nr_internals + g_stat_info.nr_leaves + g_stat_info.nr_unformatted);
+	}
+    }
+
+
+ end:
+    /* brelse bitmaps */
+    if (SB_AP_BITMAP (&g_sb)) {
+	for (i = 0; i < SB_BMAP_NR (&g_sb); i ++) {
+	    brelse (SB_AP_BITMAP (&g_sb)[i]);
+	}
+	freemem (SB_AP_BITMAP (&g_sb));
+    }
+
+    /* brelse buffer containing super block */
+    brelse (SB_BUFFER_WITH_SB (&g_sb));
+
+    check_and_free_buffer_mem ();
+
+    return 0;
+}
+/* end of main */
+
+
+
Index: empeg/kernel/fs/reiserfs/utils/dumpreiserfs/makefile
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/dumpreiserfs/makefile:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/dumpreiserfs/makefile	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,38 @@
+VPATH = ../bin
+
+OBJS1 = dumpreiserfs.o
+OBJS2 = unpack.o
+
+PRFS = $(TMPBINDIR)/dumpreiserfs
+UNPACK = $(TMPBINDIR)/unpackreiserfs
+
+
+all: $(PRFS) $(UNPACK)
+
+.c.o:
+	$(CC) $(CFLAGS) $<
+
+$(PRFS): $(OBJS1)  libreiserfs.a libmisc.a libbitmap.a
+	$(CC) $(LFLAGS) -o $(PRFS) $(OBJS1) -lmisc -lreiserfs -lbitmap
+
+$(UNPACK): $(OBJS2)  libmisc.a
+	$(CC) $(LFLAGS) -o $(UNPACK) $(OBJS2) -lmisc
+
+clean:
+	rm -f *.o $(PRFS) $(UNPACK) *~ TAGS .depend
+
+dep:
+	gcc -MM $(IDIRS) *.c > .depend
+
+install:
+	cp -f $(PRFS) $(SBIN)
+
+uninstall:
+	rm -f $(SBIN)/dumpreiserfs
+
+
+ifeq (.depend,$(wildcard .depend))
+include .depend
+endif
+
+
Index: empeg/kernel/fs/reiserfs/utils/dumpreiserfs/unpack.c
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/dumpreiserfs/unpack.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/dumpreiserfs/unpack.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,152 @@
+#include <stdio.h>
+#include <errno.h>
+#include <malloc.h>
+#include <string.h>
+#include <fcntl.h>
+#include <netinet/in.h>
+#include <unistd.h>
+#include <sys/stat.h>
+
+/*uint32_t htonl (uint32_t hostlong);
+uint32_t ntohl (uint32_t netlong);*/
+
+int opt_skip_unfms = 0;
+int opt_do_not_write = 0;
+
+int waiting_read (int fd, char * buf, int count)
+{
+    int rd, done = 0;
+
+    while (count) {
+	rd = read (fd, buf, count);
+	if (rd < 1)
+	    return rd;
+	buf += rd;
+	count -= rd;
+	done += rd;
+    }
+    return done;
+}
+
+int main (int argc, char ** argv)
+{
+    uint16_t blocksize, reclen16;
+    uint32_t blocknumber32;
+    int c;
+    char * buf;
+    int fd;
+    int res;
+    struct stat st;
+  
+    if (argc < 2) {
+	printf ("Usage: gunzip -c | unpack [-s][-n] /dev/dest\n");
+	return 0;
+    }
+
+    while ((c = getopt (argc, argv, "sn")) != EOF) {
+	switch (c) {
+	case 's': /* skip writing of unformatted nodes */
+	    opt_skip_unfms = 1;
+	    break;
+	case 'n':
+	    opt_do_not_write = 1;
+	    break;
+	default:
+	    printf ("Usage: gunzip -c | unpack [-s] /dev/dest\n");
+	    return 0;
+	}
+    }
+
+    /* get file system's block size */
+    read (0, &blocksize, sizeof (uint16_t));
+    blocksize = ntohs (blocksize);
+    fprintf (stderr, "blocksize = %d\n", blocksize);
+
+    buf = (char *)malloc (blocksize);
+    if (!buf) {
+	perror ("malloc failed");
+	return 1;
+    }
+
+    /* we need to skip the below:
+       reiserfs: read_bitmaps: 0 blocks differ in true and cautious bitmaps
+       reiserfs: read_bitmaps: 1 blocks differ in true and cautious bitmaps
+    */
+
+/*  
+    read (0, buf, strlen ("reiserfs: read_bitmaps: 0 blocks differ in true and cautious bitmaps\n"));
+    if (strncmp (buf, "reiserfs", strlen ("reiserfs"))) {
+    fprintf (stderr, "Bad signature 1\n");
+    return 1;
+    }
+*/
+    /*  
+	read (0, buf, strlen ("reiserfs: read_bitmaps: 1 blocks differ in true and cautious bitmaps\n"));
+	if (strncmp (buf, "reiserfs", strlen ("reiserfs"))) {
+	fprintf (stderr, "Bad signature 2\n");
+	return 1;
+	}*/
+
+    if (is_mounted (argv[optind])) {
+	/* check forced on clean filesystem, maybe we can rebuild it (if it is mounted read-only). Later. */
+	die ("unpack: '%s' contains a mounted file system\n", argv[optind]);
+    }
+
+    if (stat (argv[optind], &st) == -1)
+	die ("unpack: stat failed: %s", strerror (errno));
+    if (!S_ISBLK (st.st_mode))
+	die ("unpck: %s is not a block device", argv[optind]);
+
+    fd = open (argv[optind], O_CREAT | O_RDWR);
+    if (fd == -1) {
+	perror ("open failed");
+	return 1;
+    }
+
+    while ((res = waiting_read (0, (char *)&blocknumber32, sizeof (uint32_t))) == sizeof (uint32_t)) {
+	/* read block number from stdin */
+/*
+  if (blocknumber32 == 0) {
+  printf ("exit\n");
+  exit (0);
+  }
+*/
+	blocknumber32 = ntohl (blocknumber32);
+
+	/* read 16 bit record length */
+	if (waiting_read (0, (char *)&reclen16, sizeof (uint16_t)) != sizeof (uint16_t)) {
+	    perror ("read reclen failed");
+	    return 1;
+	}
+	reclen16 = ntohs (reclen16);
+
+	fprintf (stderr, "%d reclen %d\n", blocknumber32, reclen16);
+
+	/* read the record itself */
+	if ((res = waiting_read (0, buf, reclen16)) != reclen16) {
+	    fprintf (stderr, "read record failed (%d %d)\n", res, reclen16);
+	    return 1;
+	}
+
+
+	/* the only one requirement to this block: does not look like
+           leaf node. If you unpacked damaged partition already you
+           might consider using -s to save time */
+	if ((opt_skip_unfms && reclen16 == 2) || opt_do_not_write == 1)
+	    continue;
+
+
+	/* write to argv[1] */
+	if (reiserfs_llseek (fd, (loff_t)blocknumber32 * (loff_t)blocksize, SEEK_SET) == (loff_t)-1) {
+	    perror ("llseek failed");
+	    return 1;
+	}
+	if (write (fd, buf, reclen16) != reclen16) {
+	    perror ("write failed");
+	    return 1;
+	}
+    }
+
+    fprintf (stderr, "done\n");
+    return 0;
+}
Index: empeg/kernel/fs/reiserfs/utils/emu/emu.c
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/emu/emu.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/emu/emu.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,743 @@
+/*
+ * Copyright 1999-2000, 1998 Hans Reiser
+ */
+
+
+#include "nokernel.h"
+#include "reiserfs.h"
+#include <unistd.h>
+#include <dirent.h>
+#include <limits.h>
+
+int is_block_unformatted (__u32 b)
+{
+  return 0;
+}
+
+
+struct super_block g_sb;
+extern struct key root_key;
+
+
+/*------------------------------------------------------------------------*/
+
+/* de->d_iname contains name */
+static struct inode * get_inode_by_name (struct inode * dir, struct dentry * dentry)
+{
+  dentry->d_name.len = strlen (dentry->d_iname);
+  dentry->d_name.name = dentry->d_iname;
+
+  reiserfs_lookup (dir, dentry);
+
+  return dentry->d_inode;
+}
+
+
+struct inode * pwd;
+
+static void do_create (char * args)
+{
+  struct dentry de;
+
+  if (sscanf (args, "%255s", de.d_iname) != 1) {
+    reiserfs_warning ("create: usage: create filename\n");
+    return;
+  }
+
+  if (get_inode_by_name (pwd, &de) == 0) {
+    reiserfs_create (pwd, &de, 0100644);
+  } else
+    reiserfs_warning ("create: file %s exists\n", de.d_name.name);
+
+}
+
+static void do_mkdir (char * args)
+{
+  struct dentry de;
+
+  if (sscanf (args, "%255s", de.d_iname) != 1) {
+    reiserfs_warning ("mkdir: usage: mkdir dirname\n");
+    return;
+  }
+
+  if (get_inode_by_name (pwd, &de) == 0) {
+    reiserfs_mkdir (pwd, &de, 0100644);
+  } else
+    reiserfs_warning ("mkdir: dir %s exists\n", de.d_name.name);
+}
+
+static void do_rmdir (char * args)
+{
+  struct dentry de;
+
+  if (sscanf (args, "%255s", de.d_iname) != 1) {
+    reiserfs_warning ("rmdir: usage: rmdir dirname\n");
+    return;
+  }
+
+  if (get_inode_by_name (pwd, &de) != 0) {
+    reiserfs_rmdir (pwd, &de);
+  } else
+    reiserfs_warning ("rmdir: dir %s is not exists\n", de.d_name.name);
+}
+
+
+static void do_write (char * args)
+{
+  int i;
+  int count;
+  loff_t offset;
+  struct file file;
+  char * buf;
+  struct dentry de;
+
+  if (sscanf (args, "%255s %Ld %d", de.d_iname, &offset, &count) != 3) {
+    reiserfs_warning ("write: usage: write filename offset count\n");
+    return;
+  }
+
+  if (get_inode_by_name (pwd, &de)) {
+    file.f_dentry = &de;
+    file.f_flags = 0;
+    /* if regular file */
+    file.f_op = reiserfs_file_inode_operations.default_file_ops;
+    buf = (char *)malloc (count);
+    if (buf == 0)
+      reiserfs_panic (&g_sb, "do_write: no memory, or function not defined");
+    for (i = 0; i < count; i ++)
+      buf[i] = '0' + i % 10;
+
+    file.f_op->write (&file, buf, count, &offset);
+    free (buf);
+  }
+}
+
+static void do_read (char * args)
+{
+  int count;
+  loff_t offset;
+  struct file file;
+  char * buf;
+  struct dentry de;
+
+  if (sscanf (args, "%255s %Ld %d", de.d_iname, &offset, &count) != 3) {
+    reiserfs_warning ("do_read: usage: read filename offset count\n");
+    return;
+  }
+
+  if (get_inode_by_name (pwd, &de)) {
+    file.f_dentry = &de;
+    file.f_flags = 0;
+    file.f_pos = 0;
+    /* if regular file */
+    file.f_op = reiserfs_file_inode_operations.default_file_ops;
+    buf = (char *)malloc (count);
+    if (buf == 0)
+      reiserfs_panic (&g_sb, "do_read: no memory, or function not defined");
+    memset (buf, 0, count);
+
+    file.f_op->read (&file, buf, count, &offset);
+    free (buf);
+  }
+}
+
+
+
+static void do_fcopy (char * args)
+{
+    char * src;
+    char * dest;
+    int fd_source;
+    int rd, bufsize;
+    loff_t offset;
+    char * buf;
+    struct dentry de;
+    struct inode * inode;
+    struct file file;
+
+    current->rlim[RLIMIT_FSIZE].rlim_cur = INT_MAX;
+    src = args;
+    src [strlen (src) - 1] = 0;
+    dest = strrchr (args, '/') + 1;
+    if (dest == 0)
+	die ("/ must be in the name of source");
+
+    fd_source = open (src, O_RDONLY);
+    if (fd_source == -1) 
+	die ("fcopy: could not open \"%s\": %s", 
+	     src, strerror (errno));
+
+    bufsize = 1024;
+    buf = (char *)malloc (bufsize);
+    if (buf == 0)
+	reiserfs_panic (&g_sb, "fcopy: no memory, or function not defined");
+
+    strcpy (de.d_iname, dest);
+
+    if ((inode = get_inode_by_name (pwd, &de)) == 0) {
+	reiserfs_create (pwd, &de, 0100644);
+	inode = de.d_inode;
+    } else {
+	reiserfs_warning ("fcopy: file %s exists\n", de.d_name.name);
+	return;
+    }
+
+  file.f_dentry = &de;
+  file.f_flags = 0;
+  file.f_error = 0;
+  /* if regular file */
+  file.f_op = reiserfs_file_inode_operations.default_file_ops;
+    offset = 0;
+    while ((rd = read(fd_source, buf, bufsize)) > 0)
+      reiserfs_file_inode_operations.default_file_ops->write (&file, buf, rd, &offset);//	offset += _do_write (inode, rd, offset, buf);
+
+    iput (inode);
+    free (buf);
+  
+    close(fd_source);
+#if 0
+  char source[260];
+  char dest[260];
+  int fd_source;
+  int rd,bufsize;
+  loff_t offset;
+  struct file file;
+  char * buf;
+  struct dentry de;
+
+  if (sscanf (args, "%255s %255s", source, dest) != 2) {
+    reiserfs_warning ("fcopy: usage: fcopy source dest\n");
+    return;
+  }
+
+  fd_source=open(source, O_RDONLY);
+  if (fd_source == -1) 
+    reiserfs_panic (&g_sb, "fcopy: source file could not open");
+
+  bufsize = 1024;
+  buf = (char *)malloc (bufsize);
+  if (buf == 0)
+      reiserfs_panic (&g_sb, "fcopy: no memory, or function not defined");
+
+  strcpy(de.d_iname,dest);
+
+
+  if (get_inode_by_name (pwd, &de) == 0) {
+    reiserfs_create (pwd, &de, 0100644);
+  } else {
+    reiserfs_warning ("fcopy: file %s exists\n", de.d_name.name);
+    return;
+  }
+  
+
+  file.f_dentry = &de;
+  file.f_flags = 0;
+  /* if regular file */
+  file.f_op = reiserfs_file_inode_operations.default_file_ops;
+  
+  offset = 0;
+  while((rd = read(fd_source, buf, bufsize)) > 0)
+    {
+      file.f_op->write (&file, buf, rd, &offset);
+/*      offset += bufsize;*/
+    }
+  free (buf);
+  
+  close(fd_source);
+#endif
+}
+
+
+/****************************** readdir *****************************/
+
+struct linux_dirent {
+	unsigned long	d_ino;
+	unsigned long	d_off;
+	unsigned short	d_reclen;
+	char		d_name[1];
+};
+
+struct getdents_callback {
+	struct linux_dirent * current_dir;
+	struct linux_dirent * previous;
+	int count;
+	int error;
+};
+
+#define NAME_OFFSET(de) ((int) ((de)->d_name - (char *) (de)))
+#define ROUND_UP(x) (((x)+sizeof(long)-1) & ~(sizeof(long)-1))
+static int filldir(void * __buf, const char * name, int namlen, off_t offset, ino_t ino)
+{
+  struct linux_dirent * dirent;
+  struct getdents_callback * buf = (struct getdents_callback *) __buf;
+  int reclen = ROUND_UP(NAME_OFFSET(dirent) + namlen + 1);
+
+  buf->error = -EINVAL;	/* only used if we fail.. */
+  if (reclen > buf->count)
+    return -EINVAL;
+  dirent = buf->previous;
+  if (dirent)
+    put_user(offset, &dirent->d_off);
+  dirent = buf->current_dir;
+  buf->previous = dirent;
+  put_user(ino, &dirent->d_ino);
+  put_user(reclen, &dirent->d_reclen);
+  copy_to_user(dirent->d_name, name, namlen);
+  put_user(0, dirent->d_name + namlen);
+
+  ((char *) dirent) += reclen;
+  buf->current_dir = dirent;
+  buf->count -= reclen;
+  return 0;
+}
+
+
+int emu_getdents (struct file * file, void * dirent, int count)
+{
+  struct getdents_callback buf;
+  struct linux_dirent * lastdirent;
+  int error;
+
+  buf.current_dir = (struct linux_dirent *) dirent;
+  buf.previous = NULL;
+  buf.count = count;
+  buf.error = 0;
+  file->f_op->readdir (file, &buf, filldir);
+  error = buf.error;
+  lastdirent = buf.previous;
+  if (lastdirent) {
+    put_user(file->f_pos, &lastdirent->d_off);
+    error = count - buf.count;
+  }
+
+  return error;
+}
+
+
+void do_readdir (void)
+{
+  struct dentry de;
+  struct file file;
+  struct dirent * dirent;
+  struct linux_dirent * p;
+
+  de.d_inode = pwd;
+  file.f_dentry = &de;
+  file.f_pos = 0;
+  file.f_op = reiserfs_dir_inode_operations.default_file_ops;
+
+  dirent = (struct dirent *)malloc (sizeof (struct dirent));
+  while (emu_getdents (&file, dirent, sizeof (struct dirent)) != 0) {
+    p = (struct linux_dirent *)dirent;
+    while (p->d_reclen && (char *)p + p->d_reclen < (char *)(dirent + 1)) {
+      printf ("%s\n", p->d_name);
+      p = (struct linux_dirent *)((char *)p + p->d_reclen);
+    }
+  }
+  free (dirent);
+}
+
+
+int do_cd (char * args)
+{
+  struct inode * dir;
+  struct dentry de;
+
+  if (sscanf (args, "%255s", de.d_iname) != 1) {
+    reiserfs_warning ("do_cd: usage: cd dirname\n");
+    return 1;
+  }
+  dir = get_inode_by_name (pwd, &de);
+  if (dir != 0 && S_ISDIR (dir->i_mode)) {
+    pwd = dir;
+    return 0;
+  }
+  reiserfs_warning ("do_cd: no such file or not a directory \"%s\"\n", de.d_iname);
+  return 1;
+}
+
+char buf1[1024], buf2[1024];
+
+/* path is in buf1 */
+static int do_path_cd (char * path)
+{
+    char * p, * slash;
+
+    strcpy (buf2, path);
+    p = buf2;
+/*
+    while ((slash = strchr (p, '/'))) {
+	*slash = 0;
+	if (do_cd (p)) {
+	    printf ("cd: wrong path element: %s\n", p);
+	    return 1;
+	}
+	p = slash + 1;
+    }
+    if (do_cd (p)) {
+    }
+*/
+    while (1) {
+	slash = strchr (p, '/');
+	if (slash)
+	    *slash = 0;	
+	if (do_cd (p)) {
+	    printf ("cd: wrong path element: %s\n", p);
+	    return 1;
+	}
+	if (!slash)
+	    break;
+	p = slash + 1;
+    }
+    return 0;
+}
+
+
+#include <dirent.h>
+
+void do_dcopy (char * args)
+{
+  char name[256], * p;
+  char command [256];
+  DIR * d;
+  struct dirent * de;
+  struct stat st;
+
+  if (sscanf (args, "%255s", name) != 1) {
+    reiserfs_warning ("do_dcopy: usage: dcopy dirname\n");
+    return;
+  }
+  if ((d = opendir (name)) == NULL || chdir (name) == -1) {
+    printf ("%s\n", strerror (errno));
+    return;
+  }
+
+  p = strrchr (name, '/');
+  p ++;
+  do_mkdir (p);
+  if (do_cd (p))
+    return;
+
+  while ((de = readdir (d)) != NULL) {
+    if (stat (de->d_name, &st) == -1) {
+      printf ("%s\n", strerror (errno));
+      return;
+    }
+    if (!S_ISREG (st.st_mode)) {
+      printf ("%s skipped\n", de->d_name);
+      continue;
+    }
+    printf ("%s/%s\n", name, de->d_name);
+    sprintf (command, "%s/%s %s\n", name, de->d_name, de->d_name);
+    do_fcopy (command);
+  }
+  
+}
+
+
+char buf1[1024], buf2[1024];
+
+void do_diff (char * args)
+{
+  char orig[256];
+  int fd, rd1, rd2;
+  struct file file;
+  struct dentry de;
+
+  if (sscanf (args, "%80s %255s", de.d_iname, orig) != 2) {
+    reiserfs_warning ("diff: usage: diff filename sourcefilename\n");
+    return;
+  }
+
+  fd = open (orig, O_RDONLY);
+  if (fd == -1) {
+    printf ("%s\n", strerror (errno));
+    return;
+  }
+
+  /* open file on reiserfs */
+  if (get_inode_by_name (pwd, &de)) {
+    file.f_dentry = &de;
+    file.f_flags = 0;
+    file.f_pos = 0;
+    /* if regular file */
+    file.f_op = reiserfs_file_inode_operations.default_file_ops;
+  } else {
+    printf ("No such file or directory\n");
+    return;
+  }
+  while ((rd1 = read (fd, buf1, 1024)) > 0) {
+    rd2 = file.f_op->read (&file, buf2, 1024, &file.f_pos);
+    if (rd1 != rd2) {
+      printf ("Read error 1\n");
+      return;
+    }
+    if (memcmp (buf1, buf2, rd1)) {
+      printf ("Read error 2\n");
+      return;
+    }
+  }
+}
+
+
+int do_delete (char * args)
+{
+  struct dentry de;
+
+  if (sscanf (args, "%255s", de.d_iname) != 1) {
+    reiserfs_warning ("delete: usage: delete filename\n");
+    return 1;
+  }
+  if (get_inode_by_name (pwd, &de) == 0 || !S_ISREG (de.d_inode->i_mode)) {
+    reiserfs_warning ("delete: file %s does not exist or not a directory\n",
+		      de.d_name.name);
+    return 1;
+  }	
+  reiserfs_unlink (pwd, &de);
+  reiserfs_delete_inode (de.d_inode);
+  return 0;
+}
+
+
+void do_for_each_name (void)
+{
+  struct dentry de;
+  struct file file;
+  char * buf;
+  struct linux_dirent * p;
+
+  de.d_inode = pwd;
+  file.f_dentry = &de;
+  file.f_pos = 0;
+  file.f_op = reiserfs_dir_inode_operations.default_file_ops;
+
+  buf = (char *)malloc (1024);
+  while (emu_getdents (&file, buf, 1024) != 0) {
+    p = (struct linux_dirent *)buf;
+    while (p->d_reclen && (char *)p + p->d_reclen < (buf + 1024)) {
+      printf ("Deleting %s.. %s\n", p->d_name, 
+	      do_delete (p->d_name) ? "skipped" : "done");
+      
+      p = (struct linux_dirent *)((char *)p + p->d_reclen);
+    }
+  }
+
+  free (buf);
+}
+
+
+void do_rm_rf (char * args)
+{
+  struct dentry de;
+
+  if (sscanf (args, "%255s", de.d_iname) != 1) {
+    reiserfs_warning ("rm_rf: usage: rm_rf dirname\n");
+    return;
+  }
+
+  if (do_cd (de.d_iname))
+    return;
+  do_for_each_name ();
+}
+
+
+static void do_cd_root (void)
+{
+    if (pwd)
+	iput (pwd);
+    pwd = reiserfs_iget (&g_sb, &root_key);
+    //pwd = iget4 (&g_sb, REISERFS_ROOT_OBJECTID, 0, REISERFS_ROOT_PARENT_OBJECTID);
+}
+
+
+/* args is name of file which contains list of files to be copied and
+   directories to be created */
+void do_batch (char * args)
+{
+    FILE * list;
+    char * path;
+    char * name;
+
+    args[strlen (args) - 1] = 0;
+    list = fopen (args, "r");
+    if (list == 0) {
+	printf ("do_batch: fopen failed on \'%s\': %s\n", args, 
+		strerror (errno));
+	return;
+    }
+    while (fgets (buf1, sizeof (buf1), list) != 0) {
+	do_cd_root ();
+
+	/* remove ending \n */
+       	buf1[strlen (buf1) - 1] = 0;
+	
+	/* select last name */
+	path = buf1;
+	name = path + strlen (buf1) - 1;
+	if (*name == '/')
+	    name --;
+	while (*name != '/' && name != path)
+	    name --;
+	if (*name == '/')
+	    *name++ = 0;
+	if (name == path)
+	    path = 0;
+
+	printf ("cd to %s..", path);
+	if (path && do_path_cd (path)) {
+	    printf ("do_batch: cd failed\n");
+	    return;
+	}
+	printf ("ok, ");
+
+	if (name [strlen (name) - 1] == '/') {
+	    name [strlen (name) - 1] = 0;
+	    printf ("mkdir %s..", name);
+	    do_mkdir (name);
+	} else {
+	    printf ("cp %s..", name);
+	    sprintf (buf2, "%s/%s\n", path, name);
+	    do_fcopy (buf2);
+	}
+	printf ("done\n");
+    }
+    printf ("Ok\n");
+    fclose (list);
+}
+
+
+
+void do_help (void)
+{
+  printf (" create <file_name>                   - create the file\n");
+  printf (" mkdir <dir_name>                    - create the directory\n");
+  printf (" rmdir <dir_name>                    - remove the directory\n");
+  printf (" write <file_name> <offset> <count>  - write to the file\n");  
+  printf (" read <file_name> <offset> <count>  - read from the file\n");  
+  printf (" fcopy  <source> <dest>               - copy files: source(ext2) to dest(reiserfs)\n");  
+  printf (" ls                                   - read current directory\n");
+  printf (" cd <dir_name>                        - change directory\n");
+  printf (" dcopy  <source> - copy directory to cwd with the same name (regular files only)\n");
+  printf (" diff file1 file2       - compare reiserfs file2 with file1\n");
+  printf (" delete file\n");
+  printf (" rm_rf dirname          - delete all files in the directory\n");
+  printf (" batch filelist\n");
+  printf (" q                                    - quit emu\n");
+}
+
+
+void release_bitmaps (struct super_block * s)
+{
+  int i;
+
+  for (i = 0; i < SB_BMAP_NR (s); i ++) {
+    /* brelse (SB_AP_CAUTIOUS_BITMAP (s)[i]); */
+    brelse (SB_AP_BITMAP (s)[i]);
+  }
+  
+  kfree (SB_AP_BITMAP (s));
+  /* reiserfs_kfree (SB_AP_CAUTIOUS_BITMAP (s), sizeof (struct buffer_head *) * SB_BMAP_NR (s), s); */
+}
+
+
+void init_pwd (void)
+{
+  struct path path;
+  
+  path.path_length = ILLEGAL_PATH_ELEMENT_OFFSET;
+  pwd = reiserfs_iget (&g_sb, &root_key);
+}
+
+int is_block_used (__u32 b)
+{
+  return 1;
+}
+
+int is_formatted_pointed_by_indirect (__u32 b)
+{
+  return 0;
+}
+
+
+int main (int argc, char * argv [])
+{
+    char cmd[81];
+    char * file_name;
+    int dev;
+
+    printf ("\n<-----------REISERFS EMU, version 0.91a, 1999----------->\n");
+
+    if(argc < 2) 
+	die ("Usage: emu <device>\n");
+
+    file_name = argv[1];
+
+    /* open_device will die if it could not open device */
+    dev = open (file_name, O_RDWR);
+    if (dev == -1)
+	reiserfs_panic (0, "emu: can not open '%s': %s", file_name, strerror (errno));
+
+    g_sb.s_dev = dev;
+    set_super(&g_sb) ;
+    if (uread_super_block (&g_sb))
+	die ("emu: no reiserfs found on %s", file_name);
+
+    if (uread_bitmaps (&g_sb))
+	die ("emu: read_bitmap failed");
+
+
+    journal_init(&g_sb) ;
+ 
+    /* check whether device contains mounted tree file system */
+    if (is_mounted (file_name))
+	reiserfs_panic (0, "emu: '%s' contains a not mounted file system\n", file_name);
+
+    init_pwd ();
+
+
+    while (1) {
+	printf ("Enter command: >");
+	fgets (cmd, 80, stdin);
+	if (strncasecmp (cmd, "create ", 7) == 0)
+	    do_create (cmd + 7);
+	else if (strncasecmp (cmd, "delete ", 7) == 0)
+	    do_delete (cmd + 7);
+	else if (strncasecmp (cmd, "write ", 6) == 0)
+	    do_write (cmd + 6);    
+	else if (strncasecmp (cmd, "read ", 5) == 0)
+	    do_read (cmd + 5);    
+	else if (strncasecmp (cmd, "mkdir ", 6) == 0)
+	    do_mkdir (cmd + 6);    
+	else if (strncasecmp (cmd, "rmdir ", 6) == 0)
+	    do_rmdir (cmd + 6);    
+	else if (strncasecmp (cmd, "dcopy ", 6) == 0)
+	    do_dcopy (cmd + 6);
+	else if (strncasecmp (cmd, "fcopy ", 6) == 0)
+	    do_fcopy (cmd + 6);    
+	else if (strncasecmp (cmd, "ls", 2) == 0)
+	    do_readdir ();
+	else if (strncasecmp (cmd, "cd ", 3) == 0)
+	    do_cd (cmd + 3);
+	else if (strncasecmp (cmd, "diff ", 5) == 0)
+	    do_diff (cmd + 5);
+	else if (strncasecmp (cmd, "rm_rf ", 6) == 0)
+	    do_rm_rf (cmd + 6);
+	else if (strncasecmp (cmd, "batch ", 6) == 0)
+	    do_batch (cmd + 6);
+	else if (strncmp (cmd, "QUIT", strlen ("QUIT")) == 0)
+	    break;
+	else if (strncmp (cmd, "q", strlen ("q")) == 0)
+	    break;
+	else {
+	    do_help ();
+	}
+    }
+    sync_inodes ();
+    release_bitmaps (&g_sb);
+    brelse (g_sb.u.reiserfs_sb.s_sbh);
+    journal_release(0, &g_sb) ;
+    fsync_dev(dev) ;
+    check_and_free_mem ();
+    return 0;
+}
+
Index: empeg/kernel/fs/reiserfs/utils/emu/makefile
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/emu/makefile:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/emu/makefile	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,27 @@
+VPATH = ../bin
+
+OBJS = emu.o
+
+EMU = $(TMPBINDIR)/emu
+
+all: $(EMU)
+
+.c.o:
+	$(CC) $(CFLAGS) $<
+
+#$(EMU): $(OBJS) libreiserfs1.a libreiserfs2.a libmisc.a
+$(EMU): $(OBJS) libreiserfs.a libmisc.a libbitmap.a
+	$(CC) $(LFLAGS) -o $(EMU) $(OBJS) -lmisc -lreiserfs -lbitmap
+
+clean:
+	rm -f *.o $(EMU) *~ TAGS .depend
+
+dep:
+	gcc -MM $(IDIRS) *.c > .depend
+
+
+install:
+
+ifeq (.depend,$(wildcard .depend))
+include .depend
+endif
Index: empeg/kernel/fs/reiserfs/utils/fsck/check.c
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/fsck/check.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/fsck/check.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,483 @@
+/*
+ * Copyright 1996, 1997 Hans Reiser
+ */
+
+#include "fsck.h"
+#include "reiserfs.h"
+
+
+int check_file_system ()
+{
+  return 0;
+}
+
+/* this goes through buffers checking delimiting keys
+ */
+
+struct buffer_head * g_left = 0;
+struct buffer_head * g_right = 0;
+struct key * g_dkey = 0;
+
+
+static void check_directory_item (struct item_head * ih, struct buffer_head * bh)
+{
+  int i;
+  struct reiserfs_de_head * deh;
+
+  for (i = 0, deh = B_I_DEH (bh, ih); i < I_ENTRY_COUNT (ih) - 1; i ++)
+    if (deh[i].deh_offset > deh[i + 1].deh_offset)
+      die ("check_directory_item: entries are not sorted properly");
+}
+
+
+static void check_items (struct buffer_head * bh)
+{
+  int i;
+  struct item_head * ih;
+
+  for (i = 0, ih = B_N_PITEM_HEAD (bh, i); i < B_NR_ITEMS (bh); i ++, ih) {
+    if (I_IS_DIRECTORY_ITEM (ih))
+      check_directory_item (ih, bh);
+  }
+}
+
+
+static void compare_neighboring_leaves_in_pass1 (void)
+{
+  struct key * left = B_N_PKEY (g_left, B_NR_ITEMS (g_left) - 1);
+
+
+  if (comp_keys (left, B_N_PKEY (g_right, 0)) != SECOND_GREATER)
+    die ("compare_neighboring_leaves_in_pass1: left key is greater, that the right one");
+
+  if (/*comp_keys (B_PRIGHT_DELIM_KEY (g_left), g_dkey) == FIRST_GREATER ||*/
+      comp_keys (g_dkey, B_N_PKEY (g_right, 0)) != KEYS_IDENTICAL) {
+    reiserfs_panic (0, "compare_neighboring_leaves_in_pass1: left's rdkey %k, dkey %k, first key in right %k",
+		    B_PRIGHT_DELIM_KEY (g_left), g_dkey, B_N_PKEY (g_right, 0));
+  }
+  
+  check_items (g_left);
+
+/*&&&&&&&&&&&&&&&&&&&&&&&&&&
+  for (i = 0, ih = B_N_PITEM_HEAD (g_left, i); i < B_NR_ITEMS (g_left); i ++, ih ++)
+    if (is_item_accessed (ih) == YES)
+      die ("compare_neighboring_leaves_in_pass1: item marked as accessed in g_left");
+  for (i = 0, ih = B_N_PITEM_HEAD (g_right, i); i < B_NR_ITEMS (g_right); i ++, ih ++)
+    if (is_item_accessed (ih) == YES)
+      die ("compare_neighboring_leaves_in_pass1: item marked as accessed in g_right");
+&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
+    
+}
+
+
+static void is_there_unaccessed_items (struct buffer_head * bh)
+{
+  int i;
+  struct item_head * ih;
+
+  ih = B_N_PITEM_HEAD (bh, 0);
+  for (i = 0; i < B_NR_ITEMS (bh); i ++, ih ++) {
+    if (is_objectid_used (ih->ih_key.k_objectid) == 0)
+      die ("is_there_unaccessed_items: %lu is not marked as used", ih->ih_key.k_objectid);
+      
+    if (is_item_accessed (ih) == 0) {
+      print_block (bh, 1, -1, -1);
+      die ("is_there_unaccessed_items: unaccessed item found");
+    }
+  }
+}
+
+
+static void compare_neighboring_leaves_after_all (void)
+{
+  struct key * left = B_N_PKEY (g_left, B_NR_ITEMS (g_left) - 1);
+  struct key * right = B_N_PKEY (g_right, 0);
+
+  if (comp_keys (left, B_PRIGHT_DELIM_KEY (g_left)) != SECOND_GREATER)
+    die ("compare_neighboring_leaves_after_all: invalid right delimiting key");
+
+  if (comp_keys (left, B_N_PKEY (g_right, 0)) != SECOND_GREATER)
+    die ("compare_neighboring_leaves_after_all: left key is greater, that the right one");
+
+  if (comp_keys (B_PRIGHT_DELIM_KEY (g_left), g_dkey) != KEYS_IDENTICAL ||
+      comp_keys (g_dkey, B_N_PKEY (g_right, 0)) != KEYS_IDENTICAL) {
+    reiserfs_panic (0, "compare_neighboring_leaves_after all: invalid delimiting keys from left to right (%k %k %k)",
+		    B_PRIGHT_DELIM_KEY (g_left), g_dkey, B_N_PKEY (g_right, 0));
+  }
+
+  if (comp_short_keys (left, right) == KEYS_IDENTICAL) {
+    if (KEY_IS_DIRECT_KEY (left) || KEY_IS_INDIRECT_KEY (left))
+      if (right->k_offset != left->k_offset + I_BYTES_NUMBER (B_N_PITEM_HEAD (g_left, B_NR_ITEMS (g_left) - 1), g_sb.s_blocksize))
+	die ("compare_neighboring_leaves_after all: hole between items or items are overlapped");
+  }
+
+  is_there_unaccessed_items (g_left);
+  
+}
+
+
+typedef	void (check_function_t)(void);
+
+static void reiserfsck_check_tree (int dev, int block, int size, check_function_t comp_func)
+{
+  struct buffer_head * bh;
+
+  bh = bread (dev, block, size);
+
+  if (!B_IS_IN_TREE (bh)) {
+    reiserfs_panic (0, "reiserfsck_check_tree: buffer (%b %z) not in tree", bh, bh);
+  }
+
+  if (not_formatted_node (bh->b_data, bh->b_size))
+    die ("Not formatted node");
+  if (!is_block_used (bh->b_blocknr))
+    die ("Not marked as used");
+  if (is_leaf_node (bh->b_data) && is_leaf_bad (bh))
+    die ("Bad leaf");
+  if (is_internal_node (bh->b_data) && is_internal_bad (bh))
+    die ("bad internal");
+
+#if 0
+    || !is_block_used (bh->b_blocknr) ||
+      (is_leaf_node (bh->b_data) && is_leaf_bad (bh)) ||
+      (is_internal_node (bh->b_data) && is_internal_bad (bh)))
+    die ("reiserfsck_check_tree: bad node in the tree");
+#endif
+
+  if (B_IS_KEYS_LEVEL (bh)) {
+    int i;
+    struct disk_child * dc;
+
+    dc = B_N_CHILD (bh, 0);
+    for (i = 0; i <= B_NR_ITEMS (bh); i ++, dc ++) {
+      reiserfsck_check_tree (dev, dc->dc_block_number, size, comp_func);
+      g_dkey = B_N_PDELIM_KEY (bh, i);
+    }
+  } else if (B_IS_ITEMS_LEVEL (bh)) {
+    g_right = bh;
+    if (g_left != 0 && g_dkey != 0) {
+      comp_func ();
+      brelse (g_left);
+    }
+    g_left = g_right;
+    return;
+  } else {
+    print_block (bh, 0, -1, -1);
+    reiserfs_panic (0, "reiserfsck_check_tree: bad block type");
+  }
+  brelse (bh);
+}
+
+static void reiserfsck_check_cached_tree (int dev, int block, int size)
+{
+  struct buffer_head * bh;
+
+  bh = find_buffer (dev, block, size);
+  if (bh == 0)
+    return;
+  if (!buffer_uptodate (bh)) {
+    die ("reiserfsck_check_cached_tree: found notuptodate buffer");
+  }
+  bh->b_count ++;
+
+  if (!B_IS_IN_TREE (bh)) {
+    die ("reiserfsck_check_cached_tree: buffer (%b %z) not in tree", bh, bh);
+  }
+
+  if (not_formatted_node (bh->b_data, bh->b_size) || !is_block_used (bh->b_blocknr) ||
+      (is_leaf_node (bh->b_data) && is_leaf_bad (bh)) ||
+      (is_internal_node (bh->b_data) && is_internal_bad (bh)))
+    die ("reiserfsck_check_cached_tree: bad node in the tree");
+  if (B_IS_KEYS_LEVEL (bh)) {
+    int i;
+    struct disk_child * dc;
+
+    dc = B_N_CHILD (bh, 0);
+    for (i = 0; i <= B_NR_ITEMS (bh); i ++, dc ++) {
+      reiserfsck_check_cached_tree (dev, dc->dc_block_number, size);
+      g_dkey = B_N_PDELIM_KEY (bh, i);
+    }
+  } else if (B_IS_ITEMS_LEVEL (bh)) {
+    /*    g_right = bh;
+    if (g_left != 0 && g_dkey != 0) {
+      comp_func ();
+      brelse (g_left);
+    }
+    g_left = g_right;*/
+    brelse (bh);
+    return;
+  } else {
+    print_block (bh, 0, -1, -1);
+    reiserfs_panic (0, "reiserfsck_check_cached_tree: bad block type");
+  }
+  brelse (bh);
+}
+
+
+void reiserfsck_tree_check (check_function_t how_to_compare_neighbors)
+{
+  g_left = 0;
+  g_dkey = 0;
+  reiserfsck_check_tree (g_sb.s_dev, SB_ROOT_BLOCK (&g_sb), g_sb.s_blocksize, how_to_compare_neighbors);
+  brelse (g_right);
+}
+
+
+void reiserfsck_check_pass1 ()
+{
+/*  if (opt_check == 1)*/
+    reiserfsck_tree_check (compare_neighboring_leaves_in_pass1);
+}
+
+void check_cached_tree ()
+{
+  reiserfsck_check_cached_tree (g_sb.s_dev, SB_ROOT_BLOCK (&g_sb), g_sb.s_blocksize);
+}
+
+void reiserfsck_check_after_all ()
+{
+  reiserfsck_tree_check (compare_neighboring_leaves_after_all);
+}
+
+
+#if 0
+/* returns 1 if buf looks like a leaf node, 0 otherwise */
+static int is_leaf (char * buf, int blocksize)
+{
+  struct block_head * blkh;
+  struct item_head * ih;
+  int used_space;
+  int prev_location;
+  int i;
+
+  blkh = (struct block_head *)buf;
+  ih = (struct item_head *)(buf + BLKH_SIZE) + blkh->blk_nr_item - 1;
+  used_space = BLKH_SIZE + IH_SIZE * blkh->blk_nr_item + (blocksize - ih->ih_item_location);
+  if (used_space != blocksize - blkh->blk_free_space)
+    return 0;
+  ih = (struct item_head *)(buf + BLKH_SIZE);
+  prev_location = blocksize;
+  for (i = 0; i < blkh->blk_nr_item; i ++, ih ++) {
+    if (ih->ih_item_location >= blocksize || ih->ih_item_location < IH_SIZE * blkh->blk_nr_item)
+      return 0;
+    if (ih->ih_item_len < 1 || ih->ih_item_len > MAX_ITEM_LEN (blocksize))
+      return 0;
+    if (prev_location - ih->ih_item_location != ih->ih_item_len)
+      return 0;
+    prev_location = ih->ih_item_location;
+  }
+
+  return 1;
+}
+
+
+/* returns 1 if buf looks like an internal node, 0 otherwise */
+static int is_internal (char * buf, int blocksize)
+{
+  struct block_head * blkh;
+  int used_space;
+
+  blkh = (struct block_head *)buf;
+  used_space = BLKH_SIZE + KEY_SIZE * blkh->blk_nr_item + DC_SIZE * (blkh->blk_nr_item + 1);
+  if (used_space != blocksize - blkh->blk_free_space)
+    return 0;
+  return 1;
+}
+
+
+/* sometimes unfomatted node looks like formatted, if we check only
+   block_header. This is the reason, why it is so complicated. We
+   believe only when free space and item locations are ok 
+   */
+int not_formatted_node (char * buf, int blocksize)
+{
+  struct block_head * blkh;
+
+  blkh = (struct block_head *)buf;
+
+  if (blkh->blk_level == FREE_LEVEL ||
+      blkh->blk_level < DISK_LEAF_NODE_LEVEL || blkh->blk_level > MAX_HEIGHT)
+    /* blk_level is out of range */
+    return 1;
+
+  if (blkh->blk_nr_item < 1 || blkh->blk_nr_item > (blocksize - BLKH_SIZE) / IH_SIZE)
+    /* item number is out of range */
+    return 1;
+
+  if (blkh->blk_free_space > blocksize - BLKH_SIZE - IH_SIZE)
+    /* free space is out of range */
+    return 1;
+
+  /* check format of nodes, such as we are not sure, that this is formatted node */
+  if (blkh->blk_level == DISK_LEAF_NODE_LEVEL)
+    return (is_leaf (buf, blocksize) == 1) ? 0 : 1;
+  return (is_internal (buf, blocksize) == 1) ? 0 : 1;
+}
+#endif
+
+
+
+int is_internal_node (char * buf)
+{
+  struct block_head * blkh;
+  
+  blkh = (struct block_head *)buf;
+  if (blkh->blk_level != DISK_LEAF_NODE_LEVEL)
+    return 1;
+  return 0;
+}
+
+int is_leaf_node (char * buf)
+{
+  struct block_head * blkh;
+
+  blkh = (struct block_head *)buf;
+  if (blkh->blk_level == DISK_LEAF_NODE_LEVEL)
+    return 1;
+  return 0;
+}
+
+static int is_bad_sd (struct item_head * ih, char * item)
+{
+  struct stat_data * sd = (struct stat_data *)item;
+
+  if (!S_ISDIR (sd->sd_mode) && !S_ISREG(sd->sd_mode) &&
+      !S_ISCHR (sd->sd_mode) && !S_ISBLK(sd->sd_mode) &&
+      !S_ISLNK (sd->sd_mode) && !S_ISFIFO(sd->sd_mode) &&
+      !S_ISSOCK(sd->sd_mode)) {
+    if (opt_verbose)
+      reiserfs_warning ("file %k unexpected mode encountered 0%o\n", &ih->ih_key, sd->sd_mode);
+  }
+  return 0;
+}
+
+
+
+static int is_bad_directory (struct item_head * ih, char * item, int blocksize)
+{
+  int i;
+  int namelen;
+  struct reiserfs_de_head * deh = (struct reiserfs_de_head *)item;
+  __u32 prev_offset = 0;
+  __u16 prev_location = 0xffff;
+
+  for (i = 0; i < I_ENTRY_COUNT (ih); i ++) {
+    namelen = I_DEH_N_ENTRY_FILE_NAME_LENGTH (ih, deh + i, i);
+    if (namelen > REISERFS_MAX_NAME_LEN (blocksize)) {
+      return 1;
+    }
+    if (deh[i].deh_offset <= prev_offset) {
+      return 1;
+    }
+    prev_offset = deh[i].deh_offset;
+
+    if (deh[i].deh_location >= prev_location) {
+      return 1;
+    }
+  }
+
+  return 0;
+}
+
+
+#include <sys/ioctl.h>
+#include <sys/mount.h>
+
+
+int blocks_on_device (int dev, int blocksize)
+{
+int size;
+
+  if (ioctl (dev, BLKGETSIZE, &size) >= 0) {
+    return  size / (blocksize / 512);
+  }
+  if (ioctl (dev, BLKGETSIZE, &size) >= 0) {
+    return  size / (blocksize / 512);
+  } else {
+    struct stat stat_buf;
+    memset(&stat_buf, '\0', sizeof(struct stat));
+    if(fstat(dev, &stat_buf) >= 0) {
+      return stat_buf.st_size / (blocksize / 512);
+    } else {
+      die ("can not calculate device size\n");
+    }
+  }
+  return 0;
+}
+
+
+/* change incorrect block adresses by 0. Do not consider such item as incorrect */
+static int is_bad_indirect (struct item_head * ih, char * item, int dev, int blocksize)
+{
+  int i;
+  int bad = 0;
+  int blocks;
+
+  if (ih->ih_item_len % UNFM_P_SIZE) {
+    if (opt_verbose)
+      reiserfs_warning ("indirect item of %h of invalid length");
+    return 1;
+  }
+  blocks = blocks_on_device (dev, blocksize);
+  
+  for (i = 0; i < I_UNFM_NUM (ih); i ++) {
+    __u32 * ind = (__u32 *)item;
+
+    if (ind[i] >= blocks) {
+      bad ++;
+      ind[i] = 0;
+      continue;
+    }
+  }
+  return 0;
+}
+
+
+int is_bad_item (struct item_head * ih, char * item, int blocksize, int dev)
+{
+  if (I_IS_STAT_DATA_ITEM (ih))
+    return is_bad_sd (ih, item);
+
+  if (I_IS_DIRECTORY_ITEM (ih))
+    return is_bad_directory (ih, item, blocksize);
+
+  if (I_IS_INDIRECT_ITEM (ih))
+    return is_bad_indirect (ih, item, dev, blocksize);
+
+  return 0;
+}
+
+
+/* only directory item can be fatally bad */
+int is_leaf_bad (struct buffer_head * bh)
+{
+  int i;
+  struct item_head * ih;
+
+  if (!is_leaf_node (bh->b_data))
+    return 0;
+  for (i = 0, ih = B_N_PITEM_HEAD (bh,  0); i < B_NR_ITEMS (bh); i ++, ih ++)
+    if (is_bad_item (ih, B_I_PITEM (bh, ih), bh->b_size, bh->b_dev))
+      return 1;
+  return 0;
+}
+
+int is_internal_bad (struct buffer_head * bh)
+{
+  struct key * key;
+  int i;
+  
+  if (!is_internal_node (bh->b_data))
+    return 0;
+  for (i = 0; i < B_NR_ITEMS (bh); i ++) {
+    key = B_N_PDELIM_KEY (bh, i);
+    if (//key->k_dir_id >= key->k_objectid ||
+	(key->k_uniqueness != 500 && key->k_uniqueness != (__u32)-1 && key->k_uniqueness != (__u32)-2 &&
+	 key->k_uniqueness != 0))
+      return 1;
+  }
+  return 0;
+
+}
+
+
Index: empeg/kernel/fs/reiserfs/utils/fsck/check_tree.c
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/fsck/check_tree.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/fsck/check_tree.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,693 @@
+/*
+ * Copyright 1999 Hans Reiser
+ */
+
+#include "fsck.h"
+#include "reiserfs.h"
+
+
+//
+//
+//  check S+ tree of the file system 
+//
+// check_fs_tree stops and recommends to run fsck --rebuild-tree when:
+// 1. read fails
+// 2. node of wrong level found in the tree
+// 3. something in the tree points to wrong block number
+//      out of filesystem boundary is pointed by tree
+//      to block marked as free in bitmap
+//      the same block is pointed from more than one place
+//      not data blocks (journal area, super block, bitmaps)
+// 4. bad formatted node found
+// 5. delimiting keys are incorrect
+//      
+
+
+
+/* to make sure, that no blocks are pointed to from more than one
+   place we use additional bitmap (control_bitmap). If we see pointer
+   to a block we set corresponding bit to 1. If it is set already -
+   run fsck with --rebuild-tree */
+static char ** control_bitmap;
+/* will compare with what does super_block say */
+int used_blocks = 0;
+
+
+/* 1 if block is not marked as used in the bitmap */
+static int is_block_free (struct super_block * s, blocknr_t block)
+{
+    int i, j;
+    char * bitmap;
+
+    i = block / (s->s_blocksize * 8);
+    j = block % (s->s_blocksize * 8);
+
+    if (opt_fsck_mode == FSCK_DEFAULT)
+	bitmap = SB_AP_BITMAP (s)[i]->b_data;
+    else
+	bitmap = g_new_bitmap[i];
+    return !test_bit (j, bitmap);
+    
+}
+
+
+/* we have seen this block in the tree, mark corresponding bit in the
+   control bitmap */
+static void we_met_it (struct super_block * s, blocknr_t block)
+{
+    int i, j;
+    
+    used_blocks ++;
+    i = block / (s->s_blocksize * 8);
+    j = block % (s->s_blocksize * 8);
+    return set_bit (j, control_bitmap [i]);
+}
+
+
+/* have we seen this block somewhere in the tree before? */
+static int did_we_meet_it (struct super_block * s, blocknr_t block)
+{
+    int i, j;
+    
+    i = block / (s->s_blocksize * 8);
+    j = block % (s->s_blocksize * 8);
+    return test_bit (j, control_bitmap [i]);
+}
+
+
+static void init_control_bitmap (struct super_block * s)
+{
+    int i;
+
+    control_bitmap = getmem (sizeof (char *) * SB_BMAP_NR (s));
+    for (i = 0; i < SB_BMAP_NR (s); i ++) {
+	control_bitmap[i] = getmem (s->s_blocksize);
+	memset (control_bitmap[i], 0, s->s_blocksize);
+    }
+    
+    /* skipped and super block */
+    for (i = 0; i <= SB_BUFFER_WITH_SB (s)->b_blocknr; i ++)
+	we_met_it (s, i);
+    
+    /* bitmaps */
+    for (i = 0; i < SB_BMAP_NR (s); i ++)
+	we_met_it (s, SB_AP_BITMAP (s)[i]->b_blocknr);
+
+    for (i = 0; i < get_journal_size (s) + 1; i ++)
+	we_met_it (s, i + get_journal_start (s));
+
+
+    /* unused space of last bitmap is filled by 1s */
+    for (i = SB_BMAP_NR (s) * s->s_blocksize * 8; --i >= SB_BLOCK_COUNT (s); ) {
+	we_met_it (s, i);
+	used_blocks --;
+    }
+}
+
+
+static void print_bmap_block (int i, char * data, int silent)
+{
+    int j, k;
+    int bits = g_sb.s_blocksize * 8;
+    int zeros = 0, ones = 0;
+  
+    printf ("#%d: ", i);
+
+    if (test_bit (0, data)) {
+	/* first block addressed by this bitmap block is used */
+	ones ++;
+	if (!silent)
+	    printf ("Busy (%d-", i * bits);
+	for (j = 1; j < bits; j ++) {
+	    while (test_bit (j, data)) {
+		ones ++;
+		if (j == bits - 1) {
+		    if (!silent)
+			printf ("%d)\n", j + i * bits);
+		    goto end;
+		}
+		j++;
+	    }
+	    if (!silent)
+		printf ("%d) Free(%d-", j - 1 + i * bits, j + i * bits);
+
+	    while (!test_bit (j, data)) {
+		zeros ++;
+		if (j == bits - 1) {
+		    if (!silent)
+			printf ("%d)\n", j + i * bits);
+		    goto end;
+		}
+		j++;
+	    }
+	    if (!silent)
+		printf ("%d) Busy(%d-", j - 1 + i * bits, j + i * bits);
+
+	    j --;
+	end:
+	}
+    } else {
+	/* first block addressed by this bitmap is free */
+	zeros ++;
+	if (!silent)
+	    printf ("Free (%d-", i * bits);
+	for (j = 1; j < bits; j ++) {
+	    k = 0;
+	    while (!test_bit (j, data)) {
+		k ++;
+		if (j == bits - 1) {
+		    if (!silent)
+			printf ("%d)\n", j + i * bits);
+		    zeros += k;
+		    goto end2;
+		}
+		j++;
+	    }
+	    zeros += k;
+	    if (!silent)
+		printf ("%d) Busy(%d-", j - 1 + i * bits, j + i * bits);
+	    
+	    k = 0;
+	    while (test_bit (j, data)) {
+		ones ++;
+		if (j == bits - 1) {
+		    if (!silent)
+			printf ("%d)\n", j + i * bits);
+		    ones += k;
+		    goto end2;
+		}
+		j++;
+	    }
+	    ones += k;
+	    if (!silent)
+		printf ("%d) Busy(%d-", j - 1 + i * bits, j + i * bits);
+	
+	    j --;
+	end2:
+	}
+    }
+
+    printf ("used %d, free %d\n", ones, zeros);
+}
+
+
+static void show_diff (int n, char * disk, char * control, int bits)
+{
+    int i;
+    int last_diff = 0;
+    int from, num;
+    
+    for (i = 0; i < bits; i ++) {
+	if (test_bit (i, disk) && !test_bit (i, control)) {
+	    if (last_diff == 1) {
+		num ++;
+		continue;
+	    } else if (last_diff == 2) {
+		printf ("Block [%d-%d] free in disk bitmap, used in control\n", from, from + num - 1);
+	    }
+	    num = 1;
+	    from = n * bits + i;
+	    last_diff = 1;
+	    continue;
+	}
+	if (!test_bit (i, disk) && test_bit (i, control)) {
+	    if (last_diff == 2) {
+		num ++;
+		continue;
+	    } else if (last_diff == 1) {
+		printf ("Block [%d-%d] used in disk bitmap, free in control\n", from, from + num - 1);
+	    }
+	    num = 1;
+	    from = n * bits + i;
+	    last_diff = 2;
+	    continue;
+	}
+	/* the same bits */
+	if (last_diff == 1)
+	    printf ("Block [%d-%d] used in disk bitmap, free in control\n", from, from + num - 1);
+	if (last_diff == 2)
+	    printf ("Block [%d-%d] free in disk bitmap, used in control\n", from, from + num - 1);
+	    
+	num = 0;
+	from = 0;
+	last_diff = 0;
+	continue;
+    }
+}
+
+static void compare_bitmaps (struct super_block * s)
+{
+    int i, wrong_bitmap = 0;
+    char * bitmap;
+
+    printf ("Comparing bitmaps..");
+
+    if (SB_FREE_BLOCKS (s) != SB_BLOCK_COUNT (s) - used_blocks) {
+	printf ("\nUsed blocks %d, super block version %d",
+		used_blocks, SB_BLOCK_COUNT (s) - SB_FREE_BLOCKS (s));
+	wrong_bitmap = 1;
+    }
+
+    for (i = 0; i < SB_BMAP_NR (s); i ++) {
+	if (opt_fsck_mode == FSCK_DEFAULT)
+	    /* we are read-only checking the partition, check this
+               bitmap */
+	    bitmap = SB_AP_BITMAP(s)[i]->b_data;
+	else
+	    /* we are re-building the tree, bitmap for check is here */
+	    bitmap = g_new_bitmap [i];
+
+	if (memcmp (bitmap, control_bitmap[i], s->s_blocksize)) {
+	    printf ("\nbitmap %d does not match to the correct one", i);
+	    if (opt_verbose) {
+		printf ("\nSee diff");
+		show_diff (i, bitmap, control_bitmap[i], s->s_blocksize * 8);
+	    }
+	    wrong_bitmap = 1;
+	}
+    }
+    if (wrong_bitmap)
+	reiserfs_panic (s, "\nRun reiserfsck with --rebuild-tree (or rewrite correct bitmap)\n");
+    
+    printf ("ok\n");
+}
+
+
+
+
+
+
+/* is this block legal to be pointed to by some place of the tree? */
+static int bad_block_number (struct super_block * s, blocknr_t block)
+{
+    if (block >= SB_BLOCK_COUNT (s)) {
+	reiserfs_warning ("block out of filesystem boundary found\n");
+	return 1;
+    }
+
+    if (not_data_block (s, block)) {
+	reiserfs_warning ("not data block is used in the tree\n");
+	return 1;
+    }
+
+    if (is_block_free (s, block)) {
+	reiserfs_warning ("block %lu is not marked as used in the disk bitmap\n",
+			  block);
+	return 1;
+    }
+
+    if (did_we_meet_it (s, block)) {
+	reiserfs_warning ("block %lu is in tree already\n", block);
+	return 1;
+    }
+
+    we_met_it (s, block);
+    return 0;
+}
+
+
+/* 1 if some of fields in the block head of bh look bad */
+static int bad_block_head (struct buffer_head * bh)
+{
+    struct block_head * blkh;
+
+    blkh = B_BLK_HEAD (bh);
+    if (__le16_to_cpu (blkh->blk_nr_item) > (bh->b_size - BLKH_SIZE) / IH_SIZE) {
+	reiserfs_warning ("block %lu has wrong blk_nr_items (%z)\n", 
+			  bh->b_blocknr, bh);
+	return 1;
+    }
+    if (__le16_to_cpu (blkh->blk_free_space) > 
+	bh->b_size - BLKH_SIZE - IH_SIZE * __le16_to_cpu (blkh->blk_nr_item)) {
+	reiserfs_warning ("block %lu has wrong blk_free_space %z\n", 
+			  bh->b_blocknr, bh);
+	return 1;
+    }
+    return 0;
+}
+
+
+/* 1 if it does not look like reasonable stat data */
+static int bad_stat_data (struct buffer_head * bh, struct item_head * ih)
+{
+    if (!is_objectid_used (ih->ih_key.k_objectid)) {
+	// FIXME: this could be cured right here
+	reiserfs_warning ("%lu is marked free, but used by an object");
+	return 1;
+    }
+    return 0;
+}
+
+
+/* it looks like we can check item length only */
+static int bad_direct_item (struct buffer_head * bh, struct item_head * ih)
+{
+    return 0;
+}
+
+
+/* each unformatted node pointer*/
+static int bad_indirect_item (struct super_block * s, struct buffer_head * bh,
+			      struct item_head * ih)
+{
+    int i;
+    __u32 * ind = (__u32 *)B_I_PITEM (bh, ih);
+
+    if (__le16_to_cpu (ih->ih_item_len) % 4)
+	return 1;
+    for (i = 0; i < I_UNFM_NUM (ih); i ++) {
+	/* check unformatted node pointer and mark it used in the
+           control bitmap */
+	if (ind[i] && bad_block_number (s, __le32_to_cpu (ind[i])))
+	    return 1;
+    }
+    /* delete this check for 3.6 */
+    if (ih->u.ih_free_space > s->s_blocksize - 1)
+	reiserfs_warning ("%h has wrong wong ih_free_space\n");
+    return 0;
+}
+
+
+/* check entry count and locations of all names */
+static int bad_directory_item (struct buffer_head * bh, struct item_head * ih)
+{
+    int i;
+    struct reiserfs_de_head * deh;
+
+
+    if (I_ENTRY_COUNT (ih) > __le16_to_cpu (ih->ih_item_len) / (DEH_SIZE + 1))
+	return 1;
+
+    deh = B_I_DEH (bh, ih);
+    for (i = 0; i < I_ENTRY_COUNT (ih); i ++, deh ++) {
+	if (__le16_to_cpu (deh->deh_location) >= __le16_to_cpu (ih->ih_item_len))
+	    return 1;
+	if (i && __le16_to_cpu (deh->deh_location) >= __le16_to_cpu ((deh-1)->deh_location))
+	    return 1;
+	if ((ih->ih_key.k_objectid != REISERFS_ROOT_OBJECTID && deh_dir_id (deh) == 0) ||
+	    deh_offset (deh) == 0 || deh_objectid (deh) == 0 || 
+	    deh_dir_id (deh) == deh_objectid (deh))
+	    return 1;
+    }
+    return 0;
+}
+
+
+static int bad_item (struct super_block * s, struct buffer_head * bh, int i)
+{
+    struct item_head * ih;
+
+    ih = B_N_PITEM_HEAD (bh, i);
+
+    if (I_IS_STAT_DATA_ITEM (ih))
+	return bad_stat_data (bh, ih);
+
+    if (I_IS_DIRECT_ITEM (ih))
+	return bad_direct_item (bh, ih);
+
+    if (I_IS_INDIRECT_ITEM (ih))
+	return bad_indirect_item (s, bh, ih);
+    
+    return bad_directory_item (bh, ih);
+}
+
+
+/* 1 if i-th and (i-1)-th items can not be neighbors */
+static int bad_pair (struct super_block * s, struct buffer_head * bh, int i)
+{
+    struct item_head * ih;
+
+    ih = B_N_PITEM_HEAD (bh, i);
+
+    if (comp_keys (&((ih - 1)->ih_key), &ih->ih_key) != -1)
+	return 1;
+
+    if (I_IS_STAT_DATA_ITEM (ih))
+	/* left item must be of another object */
+	if (comp_short_keys (&((ih - 1)->ih_key), &ih->ih_key) != -1)
+	    return 1;
+    
+    if (I_IS_DIRECT_ITEM (ih)) {
+	/* left item must be indirect or stat data item of the same
+	   file */
+	if (comp_short_keys (&((ih - 1)->ih_key), &ih->ih_key) != 0)
+	    return 1;
+	if (!((I_IS_STAT_DATA_ITEM (ih - 1) && ih->ih_key.k_offset == 1) ||
+	      (I_IS_INDIRECT_ITEM (ih - 1) && 
+	       (ih - 1)->ih_key.k_offset + I_BYTES_NUMBER (ih - 1, s->s_blocksize) == 
+	       ih->ih_key.k_offset)))
+	    return 1;
+    }
+
+    if (I_IS_INDIRECT_ITEM (ih) || I_IS_DIRECTORY_ITEM (ih)) {
+	/* left item must be stat data of the same object */
+	if (comp_short_keys (&((ih - 1)->ih_key), &ih->ih_key) != 0)
+	    return 1;
+	if (!I_IS_STAT_DATA_ITEM (ih - 1))
+	    return 1;
+    }
+    
+    return 0;
+}
+ 
+
+/* 1 if block head or any of items is bad */
+static int bad_leaf (struct super_block * s, struct buffer_head * bh)
+{
+    int i;
+
+    if (bad_block_head (bh))
+	return 1;
+    
+    for (i = 0; i < B_NR_ITEMS (bh); i ++) {
+	if (bad_item (s, bh, i)) {
+	    reiserfs_warning ("block %lu has invalid item %d: %h\n",
+			      bh->b_blocknr, i, B_N_PITEM_HEAD (bh, i));
+	    return 1;
+	}
+	
+	if (i && bad_pair (s, bh, i)) {
+	    reiserfs_warning ("block %lu has wrong order of items\n", 
+			      bh->b_blocknr);
+	    return 1;
+	}
+    }
+    return 0;
+}
+
+
+/* 1 if bh does not look like internal node */
+static int bad_internal (struct super_block * s, struct buffer_head * bh)
+{
+    return 0;
+}
+
+
+/* bh must be formatted node. blk_level must be tree_height - h + 1 */
+static int bad_node (struct super_block * s, struct buffer_head * bh,
+		     int level)
+{
+    if (B_LEVEL (bh) != level) {
+	reiserfs_warning ("node with wrong level found in the tree\n");
+	return 1;
+    }
+
+    if (bad_block_number (s, bh->b_blocknr))
+	return 1;
+    
+    if (B_IS_ITEMS_LEVEL (bh))
+	return bad_leaf (s, bh);
+
+    return bad_internal (s, bh);
+}
+
+
+/* internal node bh must point to block */
+static int get_pos (struct buffer_head * bh, blocknr_t block)
+{
+    int i;
+
+    for (i = 0; i <= B_NR_ITEMS (bh); i ++) {
+	if (B_N_CHILD (bh, i)->dc_block_number == block)
+	    return i;
+    }
+    die ("get_pos: position for block %lu not found", block);
+    return 0;
+}
+
+
+/* path[h] - leaf node */
+static struct key * lkey (struct buffer_head ** path, int h)
+{
+    int pos;
+
+    while (h > 0) {
+	pos = get_pos (path[h - 1], path[h]->b_blocknr);
+	if (pos)
+	    return B_N_PDELIM_KEY(path[h - 1], pos - 1);
+	h --;
+    }
+    return 0;
+}
+
+
+/* path[h] - leaf node */
+static struct key * rkey (struct buffer_head ** path, int h)
+{
+    int pos;
+
+    while (h > 0) {
+	pos = get_pos (path[h - 1], path[h]->b_blocknr);
+	if (pos != B_NR_ITEMS (path[h - 1]))
+	    return B_N_PDELIM_KEY (path[h - 1], pos);
+	h --;
+    }
+    return 0;
+}
+
+
+/* are all delimiting keys correct */
+static int bad_path (struct buffer_head ** path)
+{
+    int h;
+    struct key * dk;
+    
+    h = -1;
+    while (path[h])
+	h ++;    
+
+    dk = lkey (path, h);
+    if (dk && comp_keys (dk, B_N_PKEY (path[h], 0)))
+	return 1;
+    dk = rkey (path, h);
+    if (dk && comp_keys (dk, B_PRIGHT_DELIM_KEY (path[h])))
+	return 1;
+   
+    return 0;
+}
+
+
+static inline blocknr_t first_child (struct buffer_head * bh)
+{
+    return B_N_CHILD (bh, 0)->dc_block_number;
+}
+
+
+static inline blocknr_t last_child (struct buffer_head * bh)
+{
+    return B_N_CHILD (bh, B_NR_ITEMS (bh))->dc_block_number;
+}
+
+
+static inline blocknr_t next_child (struct buffer_head * child,
+				    struct buffer_head * parent)
+{
+    int i;
+    
+    for (i = 0; i < B_NR_ITEMS (parent); i ++) {
+	if (B_N_CHILD (parent, i)->dc_block_number == child->b_blocknr)
+	    return B_N_CHILD (parent, i + 1)->dc_block_number;
+    }
+    die ("next_child: no child found: should not happen");
+    return 0;
+}
+
+
+/* h == 0 for root level. block head's level == 1 for leaf level  */
+static inline int h_to_level (struct super_block * s, int h)
+{
+    return SB_TREE_HEIGHT (s) - h - 1;
+}
+
+
+static inline int leaf_level (struct buffer_head * bh)
+{
+    return B_LEVEL(bh) == DISK_LEAF_NODE_LEVEL;
+}
+
+
+static void print (int cur, int total)
+{
+  printf ("/%3d (of %3d)", cur, total);fflush (stdout);
+}
+
+
+/* erase /XXX(of XXX) */
+static void erase (void)
+{
+    printf ("\b\b\b\b\b\b\b\b\b\b\b\b\b");
+    printf ("             ");
+    printf ("\b\b\b\b\b\b\b\b\b\b\b\b\b");
+    fflush (stdout);
+}
+
+
+/* pass the S+ tree of filesystem */
+void check_fs_tree (struct super_block * s)
+{
+    struct buffer_head * path[MAX_HEIGHT] = {0,};
+    int total[MAX_HEIGHT] = {0,};
+    int cur[MAX_HEIGHT] = {0,};
+    int h = 0;
+    blocknr_t block = SB_ROOT_BLOCK (s);
+
+    uread_bitmaps (s);
+
+    init_control_bitmap (s);
+
+    printf ("Checking S+tree..");
+
+    while ( 1 ) {
+	if (path[h])
+	    die ("check_fs_tree: empty slot expected");
+	
+	if (h)
+	    print (cur[h - 1], total[h - 1]);
+
+	path[h] = bread (s->s_dev, block, s->s_blocksize);
+	if (path[h] == 0 || bad_node (s, path[h], h_to_level (s, h)))
+	    reiserfs_panic (s, "Run reiserfsck with --rebuild-tree\n");
+
+ 	if (leaf_level (path[h])) {
+	    if (bad_path (path))
+		reiserfs_panic (s, "Run reiserfsck with --rebuild-tree\n");
+
+	    brelse (path[h]);
+	    if (h)
+	      erase ();
+
+	    while (h && path[h]->b_blocknr == last_child (path[h - 1])) { 
+		path[h] = 0;
+		h --;
+/*		check_internal (path[h]);*/
+		brelse (path[h]);
+		if (h)
+		  erase ();
+	    }
+
+	    if (h == 0) {
+		path[h] = 0;
+		break;
+	    }
+
+	    cur[h - 1] ++;
+	    block = next_child (path[h], path[h-1]);
+	    path[h] = 0;
+	    continue; 
+	}
+	total[h] = B_NR_ITEMS (path[h]) + 1;
+	cur[h] = 1;
+	block = first_child (path[h]);
+	h ++;
+    }
+
+    /* S+ tree is correct (including all objects have correct
+       sequences of items) */
+    printf ("ok\n");
+    
+    /* compare created bitmap with the original */
+    compare_bitmaps (s);
+
+}
+
+
Index: empeg/kernel/fs/reiserfs/utils/fsck/info.c
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/fsck/info.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/fsck/info.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,122 @@
+
+/*
+ * Copyright 1996-1999 Hans Reiser
+ */
+#include "fsck.h"
+
+struct fsck_stat g_fsck_info = {0, };
+
+
+void add_event (int event)
+{
+  switch (event) {
+    /* tree building (pass 1 and 2) info */
+  case GOOD_LEAVES:
+    g_fsck_info.fs_good_leaves ++; break;
+  case UNINSERTABLE_LEAVES:
+    g_fsck_info.fs_uninsertable_leaves ++; break;
+  case REWRITTEN_FILES:
+    g_fsck_info.fs_rewritten_files ++; break;
+  case LEAVES_USED_BY_INDIRECT_ITEMS:
+    g_fsck_info.fs_leaves_used_by_indirect_items ++; break;
+  case UNFM_OVERWRITING_UNFM:
+    g_fsck_info.fs_unfm_overwriting_unfm ++; break;
+  case INDIRECT_TO_DIRECT:
+    g_fsck_info.fs_indirect_to_direct ++; break;
+
+    /* pass 3 info (semantic) */
+  case FIXED_SIZE_DIRECTORIES:
+    g_fsck_info.fs_fixed_size_directories ++; break;
+  case INCORRECT_REGULAR_FILES:
+    /* file has incorrect sequence of items (incorrect items are truncated) */
+    g_fsck_info.fs_incorrect_regular_files ++; break;
+  case FIXED_SIZE_FILES:
+    g_fsck_info.fs_fixed_size_files ++; break;
+
+    /* pass 4 info */
+  case UNACCESSED_ITEMS:
+    g_fsck_info.fs_unaccessed_items ++; break;
+  case FIXED_RIGHT_DELIM_KEY:
+    g_fsck_info.fs_fixed_right_delim_key ++; break;
+
+    /* file system info */
+  case STAT_DATA_ITEMS:
+    g_fsck_info.fs_stat_data_items ++; break;
+  case REGULAR_FILES:
+    g_fsck_info.fs_regular_files ++; break;
+  case DIRECTORIES:
+    g_fsck_info.fs_directories ++; break;
+  case SYMLINKS:
+    g_fsck_info.fs_symlinks ++; break;
+  case OTHERS:
+    g_fsck_info.fs_others ++; break;
+  }
+}
+
+
+int get_event (int event)
+{
+  switch (event) {
+  case GOOD_LEAVES:
+    return g_fsck_info.fs_good_leaves;
+  case UNINSERTABLE_LEAVES:
+    return g_fsck_info.fs_uninsertable_leaves;
+  case REGULAR_FILES:
+    return g_fsck_info.fs_regular_files;
+  case INCORRECT_REGULAR_FILES:
+    return g_fsck_info.fs_incorrect_regular_files;
+  case DIRECTORIES:
+    return g_fsck_info.fs_directories;
+  case FIXED_SIZE_DIRECTORIES:
+    return g_fsck_info.fs_fixed_size_directories;
+  case STAT_DATA_ITEMS:
+    return g_fsck_info.fs_stat_data_items;
+  }
+  return 0;
+}
+
+/* outputs information about inconsistencies */
+void output_information ()
+{
+  FILE * fp;
+  char buf[160];
+/*
+  if (opt_verbose == 0)
+    return;
+*/
+  fp = stderr;
+
+/*  time (&t);
+  fputs ("**** This is reiserfsck log file: created ", fp); fputs (ctime (&t), fp); fputs ("\n", fp);*/
+  fputs ("Building S+ tree info\n", fp);
+  sprintf (buf, "\tGood leaves: %d\n", g_fsck_info.fs_good_leaves); fputs (buf, fp);
+  sprintf (buf, "\tBad leaves: %d\n", g_fsck_info.fs_uninsertable_leaves); fputs (buf, fp);
+  sprintf (buf, "\tRewritten files: %d\n", g_fsck_info.fs_rewritten_files); fputs (buf, fp);
+  sprintf (buf, "\tLeaves pointed by indirect item: %d\n", g_fsck_info.fs_leaves_used_by_indirect_items); fputs (buf, fp);
+  sprintf (buf, "\tUnformatted nodes overwritten by direct items\nand then by other unformatted node: %d\n",
+	   g_fsck_info.fs_unfm_overwriting_unfm); fputs (buf, fp);
+  sprintf (buf, "\tIndirect_to_direct conversions: %d\n", g_fsck_info.fs_indirect_to_direct); fputs (buf, fp);
+
+  fputs ("Semantic pass info\n", fp);
+  sprintf (buf, "\tFiles with fixed size: %d\n", g_fsck_info.fs_fixed_size_files); fputs (buf, fp);
+  sprintf (buf, "\tDirectories with fixed size: %d\n", g_fsck_info.fs_fixed_size_directories); fputs (buf, fp);
+  sprintf (buf, "\tEntries pointing to nowhere (deleted): %d\n", g_fsck_info.fs_deleted_entries); fputs (buf, fp);
+
+  fputs ("Pass 4 info\n", fp);
+  sprintf (buf, "\tUnaccessed items found (and deleted): %d\n", g_fsck_info.fs_unaccessed_items); fputs (buf, fp);
+  sprintf (buf, "\tFixed right delimiting keys: %d\n", g_fsck_info.fs_fixed_right_delim_key); fputs (buf, fp);
+  sprintf (buf, "\tStat datas: %d\n", g_fsck_info.fs_stat_data_items); fputs (buf, fp);
+
+
+  fputs ("File system info\n", fp);
+  sprintf (buf, "\tFiles found: %d\n", g_fsck_info.fs_regular_files); fputs (buf, fp);
+  sprintf (buf, "\tDirectories found: %d\n", g_fsck_info.fs_directories); fputs (buf, fp);
+  sprintf (buf, "\tSymlinks found: %d\n", g_fsck_info.fs_symlinks); fputs (buf, fp);
+  sprintf (buf, "\tOthers: %d\n", g_fsck_info.fs_others); fputs (buf, fp);
+
+  /*fclose (fp);*/
+}
+
+
+
+
Index: empeg/kernel/fs/reiserfs/utils/fsck/journal.c
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/fsck/journal.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/fsck/journal.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,536 @@
+/*
+ * Copyright 2000 Hans Reiser
+ */
+
+#include "fsck.h"
+#include <limits.h>
+#include "reiserfs.h"
+
+
+/* compares description block with commit block.  returns 1 if they differ, 0 if they are the same */
+static int journal_compare_desc_commit(struct super_block *p_s_sb, struct reiserfs_journal_desc *desc, 
+			               struct reiserfs_journal_commit *commit) {
+  if (commit->j_trans_id != desc->j_trans_id || commit->j_len != desc->j_len || commit->j_len > JOURNAL_TRANS_MAX || 
+      commit->j_len <= 0 
+  ) {
+    return 1 ;
+  }
+  return 0 ;
+}
+
+
+//
+// set up start journal block and journal size
+// make journal unreplayable by kernel replay routine
+//
+void reset_journal (struct super_block * s)
+{
+    int i ;
+    struct buffer_head *bh ;
+    int done = 0;
+    int len;
+    int start;
+
+    /* first block of journal */
+    s->u.reiserfs_sb.s_rs->s_journal_block = get_journal_start (s);
+    start = s->u.reiserfs_sb.s_rs->s_journal_block;
+
+    /* journal size */
+    s->u.reiserfs_sb.s_rs->s_orig_journal_size = get_journal_size (s);
+    len = s->u.reiserfs_sb.s_rs->s_orig_journal_size + 1;
+
+    printf ("Resetting journal - "); fflush (stdout);
+
+    for (i = 0 ; i < len ; i++) {
+	print_how_far (&done, len);
+	bh = getblk (s->s_dev, start + i, s->s_blocksize) ;
+	memset(bh->b_data, 0, s->s_blocksize) ;
+	mark_buffer_dirty(bh,0) ;
+	mark_buffer_uptodate(bh,0) ;
+	bwrite (bh);
+	brelse(bh) ;
+    }
+    printf ("\n"); fflush (stdout);
+    
+#if 0 /* need better way to make journal unreplayable */
+
+
+    /* have journal_read to replay nothing: look for first non-desc
+       block and set j_first_unflushed_offset to it */
+    {   
+	int offset;
+	struct buffer_head * bh, *jh_bh;
+	struct reiserfs_journal_header * j_head;
+	struct reiserfs_journal_desc * desc;
+
+
+	jh_bh = bread (s->s_dev, s->u.reiserfs_sb.s_rs->s_journal_block + s->u.reiserfs_sb.s_rs->s_orig_journal_size,
+		       s->s_blocksize);
+	j_head = (struct reiserfs_journal_header *)(jh_bh->b_data);
+
+	for (offset = 0; offset < s->u.reiserfs_sb.s_rs->s_orig_journal_size; offset ++) {
+	    bh = bread (s->s_dev, s->u.reiserfs_sb.s_rs->s_journal_block + offset, s->s_blocksize);
+	    desc = (struct reiserfs_journal_desc *)((bh)->b_data);
+	    if (memcmp(desc->j_magic, JOURNAL_DESC_MAGIC, 8)) {
+		/* not desc block found */
+		j_head->j_first_unflushed_offset = offset;
+		brelse (bh);
+		break;
+	    }
+	    brelse (bh);
+	}
+
+	mark_buffer_uptodate (jh_bh, 1);
+	mark_buffer_dirty (jh_bh, 1);
+	bwrite (jh_bh);
+	brelse (jh_bh);
+    }
+#endif
+}
+
+//
+// end of stolen from ./fs/reiserfs/journal.c
+//
+
+
+#define bh_desc(bh) ((struct reiserfs_journal_desc *)((bh)->b_data))
+#define bh_commit(bh) ((struct reiserfs_journal_commit *)((bh)->b_data))
+
+
+
+
+
+static int desc_block (struct buffer_head * bh)
+{
+    struct reiserfs_journal_desc * desc = (struct reiserfs_journal_desc *)bh->b_data;
+    if (!memcmp(desc->j_magic, JOURNAL_DESC_MAGIC, 8))
+	return 1;
+    return 0;
+}
+
+static int next_expected_desc (struct super_block * s, struct buffer_head * d_bh)
+{
+    int offset;
+    struct reiserfs_journal_desc * desc;
+
+    desc = (struct reiserfs_journal_desc *)d_bh->b_data;
+    offset = d_bh->b_blocknr - get_journal_start (s);
+    return get_journal_start (s) + ((offset + desc->j_len + 1 + 1) % JOURNAL_BLOCK_COUNT);
+}
+
+
+static int is_valid_transaction (struct super_block * s, struct buffer_head * d_bh)
+{
+    struct buffer_head * c_bh;
+    int offset;
+    struct reiserfs_journal_desc *desc  = (struct reiserfs_journal_desc *)d_bh->b_data;
+    struct reiserfs_journal_commit *commit ;
+
+
+    offset = d_bh->b_blocknr - get_journal_start (s);
+    
+    /* ok, we have a journal description block, lets see if the transaction was valid */
+    c_bh = bread (s->s_dev, next_expected_desc (s, d_bh) - 1,
+		  s->s_blocksize) ;
+    
+    commit = (struct reiserfs_journal_commit *)c_bh->b_data ;
+    if (journal_compare_desc_commit (s, desc, commit)) {
+/*	printf ("desc and commit block do not match\n");*/
+	brelse (c_bh) ;
+	return 0;
+    }
+    brelse (c_bh);
+    return 1;
+}
+
+
+int next_desc (struct super_block * s, int this)
+{
+    int j;
+    struct buffer_head * bh;
+    int retval;
+
+    j = this + 1;
+    do {
+	bh = bread (s->s_dev, (j % JOURNAL_BLOCK_COUNT), s->s_blocksize);
+	if (!desc_block (bh)) {
+	    j ++;
+	    brelse (bh);
+	    continue;
+	}
+/*	printf ("desc block found %lu, trans_id %ld, len %ld\n",
+		bh->b_blocknr, bh_desc(bh)->j_trans_id, bh_desc(bh)->j_len);*/
+	retval = (j % JOURNAL_BLOCK_COUNT);
+	brelse (bh);
+	break;
+    } while (1);
+
+    return retval;
+}
+
+
+void replay_all (struct super_block * s)
+{
+    int first_journal_block = get_journal_start (s);
+    int journal_size = get_journal_size (s);
+    struct buffer_head * d_bh, * c_bh;
+    struct reiserfs_journal_desc *desc ;
+    struct reiserfs_journal_commit *commit ;
+    int i;
+    int the_most_old_transaction = INT_MAX;
+    int the_most_young_transaction = 0;
+    int valid_transactions = 0;
+    int last_replayed;
+    int start_replay = 0;
+
+
+    /* look for oldest valid transaction */
+    printf ("Looking for the oldest transaction to start with %4d", valid_transactions);
+    for (i = first_journal_block; i < first_journal_block + journal_size; i ++) {
+	d_bh = bread (s->s_dev, i, s->s_blocksize);
+	if (desc_block (d_bh)) {
+	    desc = (struct reiserfs_journal_desc *)d_bh->b_data;
+	    /*printf ("block %ld is desc block of the transaction (trans_id %ld, len %ld, mount_id %ld) - ", 
+		    d_bh->b_blocknr, desc->j_trans_id, desc->j_len, desc->j_mount_id);*/
+	    if (!is_valid_transaction (s, d_bh)) {
+		i += desc->j_len + 1;
+		brelse (d_bh);
+		continue;
+	    }
+	    valid_transactions ++;
+	    printf ("\b\b\b\b    \b\b\b\b%4d", valid_transactions); fflush (stdout);
+	    
+	    /*printf ("good\n");*/
+	    if (the_most_old_transaction > desc->j_trans_id) {
+		the_most_old_transaction = desc->j_trans_id;
+		start_replay = d_bh->b_blocknr;
+	    }
+	    if (the_most_young_transaction < desc->j_trans_id) {
+		the_most_young_transaction = desc->j_trans_id;
+		start_replay = d_bh->b_blocknr;
+	    }
+	    i += desc->j_len + 1;
+	}
+	brelse (d_bh);
+	continue;
+    }
+
+    printf ("\b\b\b\b     \b\b\b\bok\n"
+	    "%d valid trans found. Will replay from %d to %d\n", valid_transactions,
+	    the_most_old_transaction, the_most_young_transaction);
+
+
+    printf ("Replaying transaction..%4d left..\b\b\b\b\b\b\b", valid_transactions);
+
+    /* replay all valid transaction */
+    last_replayed = 0;
+
+    while (1) {
+	d_bh = bread (s->s_dev, start_replay, s->s_blocksize);
+	if (!desc_block (d_bh)) {
+/*	    printf ("No desc block found at the expected place %lu\n", d_bh->b_blocknr);*/
+	    brelse (d_bh);
+	    start_replay = next_desc (s, start_replay);
+	    continue;
+	}
+
+	desc = bh_desc (d_bh);
+
+	if (!is_valid_transaction (s, d_bh)) {
+/*	    printf ("skip invalid transaction %ld (length %ld) starting from %lu\n", desc->j_trans_id, desc->j_len, d_bh->b_blocknr);*/
+	    brelse (d_bh);
+	    start_replay = next_desc (s, start_replay);
+	    continue;
+	}
+	
+	if (desc->j_trans_id < last_replayed) {
+	    /* we found transaction that has been replayed already */
+	    brelse (d_bh);
+/*	    printf ("Found transaction %ld. last replayed %d\n", desc->j_trans_id, last_replayed);*/
+	    break;
+	}
+/*	printf ("Replay transaction %ld (length %ld)-", desc->j_trans_id, desc->j_len);*/
+
+
+	/* replay transaction */
+	{
+	    int trans_offset = d_bh->b_blocknr - get_journal_start (s);
+	    struct buffer_head * log_bh, * in_place;
+
+
+	    c_bh = bread (s->s_dev, get_journal_start (s) + ((trans_offset + desc->j_len + 1) % JOURNAL_BLOCK_COUNT), 
+			  s->s_blocksize) ;
+	
+	    desc = bh_desc (d_bh);
+	    commit = bh_commit (c_bh);
+	    if (journal_compare_desc_commit(s, desc, commit))
+		die ("read_journal: invalid transaction");
+
+	    for (i = 0; i < desc->j_len; i ++) {
+		/* read from log record */
+		log_bh = bread (s->s_dev, get_journal_start (s) + (trans_offset + 1 + i) % JOURNAL_BLOCK_COUNT,
+				s->s_blocksize);
+		if (log_bh->b_blocknr == 8199)
+		    printf ("block 8199 put in-placen\n");
+		/* write in-place */
+		if (i < JOURNAL_TRANS_HALF) {
+		    in_place = getblk(s->s_dev, desc->j_realblock[i], s->s_blocksize) ;
+		} else {
+		    in_place = getblk(s->s_dev, commit->j_realblock[i - JOURNAL_TRANS_HALF], s->s_blocksize) ;
+		}
+		if (log_bh->b_blocknr == 8199) {
+		    printf ("Put 8199 to %lu\n", in_place->b_blocknr);
+		}
+		memcpy (in_place->b_data, log_bh->b_data, s->s_blocksize);
+		mark_buffer_dirty (in_place, 0);
+		mark_buffer_uptodate (in_place, 1);
+		bwrite (in_place);
+		brelse (in_place);
+		brelse (log_bh);
+	    }
+	    brelse (c_bh);
+	}
+	valid_transactions --;
+	printf ("\b\b\b\b    \b\b\b\b%4d", valid_transactions); fflush (stdout);
+	last_replayed = desc->j_trans_id;
+	start_replay = next_expected_desc (s, d_bh);
+	brelse (d_bh);
+    }
+    printf (" left .. ok\n");
+}
+
+
+//
+// these duplicate the same from fsck/check_tree.c
+//
+static inline blocknr_t first_child (struct buffer_head * bh)
+{
+    return B_N_CHILD (bh, 0)->dc_block_number;
+}
+
+
+static inline blocknr_t last_child (struct buffer_head * bh)
+{
+    return B_N_CHILD (bh, B_NR_ITEMS (bh))->dc_block_number;
+}
+
+
+static inline blocknr_t next_child (struct buffer_head * child,
+				    struct buffer_head * parent)
+{
+    int i;
+    
+    for (i = 0; i < B_NR_ITEMS (parent); i ++) {
+	if (B_N_CHILD (parent, i)->dc_block_number == child->b_blocknr)
+	    return B_N_CHILD (parent, i + 1)->dc_block_number;
+    }
+    die ("next_child: no child found: should not happen");
+    return 0;
+}
+
+
+/* h == 0 for root level. block head's level == 1 for leaf level  */
+static inline int h_to_level (struct super_block * s, int h)
+{
+    return SB_TREE_HEIGHT (s) - h - 1;
+}
+
+
+static inline int leaf_level (struct buffer_head * bh)
+{
+    return B_LEVEL(bh) == DISK_LEAF_NODE_LEVEL;
+}
+
+
+static void print (int cur, int total)
+{
+  printf ("/%3d (of %3d)", cur, total);fflush (stdout);
+}
+
+
+/* erase /XXX(of XXX) */
+static void erase (void)
+{
+    printf ("\b\b\b\b\b\b\b\b\b\b\b\b\b");
+    printf ("             ");
+    printf ("\b\b\b\b\b\b\b\b\b\b\b\b\b");
+    fflush (stdout);
+}
+
+
+/* the simplest scanning for free block., This should be rare */
+__u32 alloc_block (void)
+{
+    int i, j;
+    int bits = g_sb.s_blocksize * 8;
+    int start = get_journal_start (&g_sb) + get_journal_size (&g_sb) + 1;
+
+    for (i = 0; i < SB_BMAP_NR (&g_sb); i ++) {
+	j = find_next_zero_bit (g_new_bitmap[i], bits, start);
+	if (j < bits) {
+	    mark_block_used (j + i * bits);
+	    return j + i * bits;
+	}
+	start = 0;
+    }
+    die ("allocate_block: no free blocks");
+    return 0;
+	
+}
+
+struct buffer_head * copy_contents (struct buffer_head * from)
+{
+    struct buffer_head * bh;
+    __u32 new;
+
+    new = alloc_block ();
+    bh = getblk (from->b_dev, new, from->b_size);
+    memcpy (bh->b_data, from->b_data, bh->b_size);
+    mark_buffer_uptodate (bh, 1);
+    mark_buffer_dirty (bh, 1);
+    bwrite (bh);
+    return bh;
+}
+
+
+static void update_pointer (struct buffer_head * parent, __u32 new, __u32 old)
+{
+    int i;
+       
+    for (i = 0; i <= B_NR_ITEMS (parent); i ++) {
+	if (B_N_CHILD (parent, i)->dc_block_number == old) {
+	    B_N_CHILD (parent, i)->dc_block_number = new;
+	    mark_buffer_dirty (parent, 1);
+	    return;
+	}
+    }
+    die ("update_pointer: old pointer not found");
+}
+
+
+static int block_from_journal (struct super_block * s, __u32 block)
+{
+    if(block && block < get_journal_start (s)) {
+	printf ("not data block (%d) got into tree. Should not appear, but fixable\n", block);
+	return 0;
+    }
+    if (block >= get_journal_start (s) && block <= get_journal_start (s) + get_journal_size (s))
+	/* <= must_journal_end due to journal header */
+	return 1;
+    return 0;
+}
+
+
+/* sometimes indirect items point to blocks from journal. Replace them
+   with data blocks. I believe this is rare case */
+static void correct_indirect_items (struct super_block * s, struct buffer_head * bh)
+{
+    int i, j;
+    struct item_head * ih;
+    __u32 * unfm;
+
+    ih = B_N_PITEM_HEAD (bh, 0);
+    for (i = 0; i < B_NR_ITEMS (bh); i ++, ih ++) {
+	if (!I_IS_INDIRECT_ITEM (ih))
+	    continue;
+	unfm = (__u32 *)B_I_PITEM (bh, ih);
+	for (j = 0; j < I_UNFM_NUM (ih); j++) {
+	    if (block_from_journal (s, unfm[j])) {
+		struct buffer_head * from, * to;
+
+		from = bread (bh->b_dev, unfm[j], bh->b_size);
+		to = copy_contents (from);
+		unfm[j] = to->b_blocknr;
+		mark_buffer_dirty (bh, 1);
+		brelse (from);
+		brelse (to);
+	    }
+	}
+    }
+}
+
+
+
+/* sometimes, (hopefully very rare) we have to use journal blocks to
+   complete tree building. In this case we have to find all those
+   blocks and replace them with data blocks (Those must exist to this
+   time. We have to look such blocks also when start of  */
+void release_journal_blocks (struct super_block * s)
+{
+    struct buffer_head * path[MAX_HEIGHT] = {0,};
+    int total[MAX_HEIGHT] = {0,};
+    int cur[MAX_HEIGHT] = {0,};
+    int h = 0;
+
+
+    blocknr_t block = SB_ROOT_BLOCK (s);
+
+    printf ("%d blocks from journal area [%d %d] has been used to perform repairing. Will release them. This may take a while\nScanning tree..",
+	    from_journal, get_journal_start (s), 
+	    get_journal_start (s) + get_journal_size (s));
+
+
+    while ( 1 ) {
+	if (path[h])
+	    die ("release_journal_blocks: empty slot expected");
+	
+	if (h)
+	    print (cur[h - 1], total[h - 1]);
+
+	path[h] = bread (s->s_dev, block, s->s_blocksize);
+	if (path[h] == 0)
+	    die ("release_journal_blocks: bread failed");
+
+	if (block_from_journal (s, path[h]->b_blocknr)) {
+	    /* copy block to newly allocated, adjust pointer in the
+               parent, replace on the path */
+	    struct buffer_head * bh;
+	    __u32 old = path[h]->b_blocknr;
+
+	    bh = copy_contents (path[h]);
+	    brelse (path[h]);
+	    path[h] = bh;
+	    if (h) {
+		/* adjust corresponding dc_child_num in the parent*/
+		update_pointer (path[h - 1], bh->b_blocknr, old);
+	    } else {
+		/* change pointer from super block */
+		SB_ROOT_BLOCK (s) = bh->b_blocknr;
+	    }
+	}
+
+ 	if (leaf_level (path[h])) {
+	    /* correct unformatted node pointers if they point to the
+               journal area */
+	    correct_indirect_items (s, path[h]);
+
+	    brelse (path[h]);
+	    if (h)
+	      erase ();
+
+	    while (h && path[h]->b_blocknr == last_child (path[h - 1])) { 
+		path[h] = 0;
+		h --;
+		brelse (path[h]);
+		if (h)
+		  erase ();
+	    }
+
+	    if (h == 0) {
+		path[h] = 0;
+		break;
+	    }
+
+	    cur[h - 1] ++;
+	    block = next_child (path[h], path[h-1]);
+	    path[h] = 0;
+	    continue; 
+	}
+	total[h] = B_NR_ITEMS (path[h]) + 1;
+	cur[h] = 1;
+	block = first_child (path[h]);
+	h ++;
+    }
+    
+    printf ("ok\n");
+}
Index: empeg/kernel/fs/reiserfs/utils/fsck/lost+found.c
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/fsck/lost+found.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/fsck/lost+found.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,340 @@
+/*
+ * Copyright 2000 Hans Reiser
+ */
+#include "fsck.h"
+#include "reiserfs.h"
+
+
+//
+// this will probably eventually replace pass4 in fsck
+//
+
+
+//
+// FIXME: there is no way to know what hash function is used to order
+// names in directory
+//
+#define MAX_GEN_NUMBER  127
+#define SET_GENERATION_NUMBER(offset,gen_number) (GET_HASH_VALUE(offset)|(gen_number))
+static __u32 get_third_component (char * name, int len)
+{
+    unsigned long res;
+
+    if (!len || (len == 1 && name[0] == '.'))
+	return DOT_OFFSET;
+    if (len == 2 && name[0] == '.' && name[1] == '.')
+	return DOT_DOT_OFFSET;
+
+    res = keyed_hash (name, len);
+    res = GET_HASH_VALUE(res);
+    if (res == 0)
+	res = 128;
+    return res + MAX_GEN_NUMBER;
+    
+}
+
+
+//
+// looks for name in the directory dir, return 1 if name found, 0
+// otherwise
+//
+static objectid_t find_entry (struct key * dir, char * name)
+{
+    struct key entry_key;
+    struct path path;
+    int retval;
+    int i;
+
+    init_path (&path);
+
+    entry_key.k_dir_id = dir->k_dir_id;
+    entry_key.k_objectid = dir->k_objectid;
+    entry_key.k_offset = get_third_component (name, strlen (name));
+    entry_key.k_uniqueness = DIRENTRY_UNIQUENESS;
+    
+    while (1) {
+	struct buffer_head * bh;
+	struct item_head * ih;
+	struct reiserfs_de_head * deh;
+
+	retval = usearch_by_key (&g_sb, &entry_key, &path, 0, DISK_LEAF_NODE_LEVEL, 
+				 READ_BLOCKS, comp_keys);
+	if (retval == ITEM_NOT_FOUND)
+	    PATH_LAST_POSITION (&path) --;
+	
+	bh = PATH_PLAST_BUFFER (&path);
+	ih = PATH_PITEM_HEAD (&path);
+	deh = B_I_DEH (bh, ih);
+	for (i = ih->u.ih_entry_count - 1; i >= 0; i --) {
+	    if (strlen (name) != I_DEH_N_ENTRY_LENGTH (ih, deh + i, i))
+		continue;
+	    if (!memcmp (B_I_E_NAME (i, bh, ih), name, strlen (name))) {
+		pathrelse (&path);
+		return deh[i].deh_objectid;;
+	    }
+	}
+	pathrelse (&path);
+	if (ih->ih_key.k_offset == DOT_OFFSET)
+	    return 0;
+	entry_key.k_offset --;
+    }
+    die ("find_entry: endless loop broken");
+    return 0;
+}
+    
+
+//
+// add name pointing to 'key' to the directory 'dir'. FIXME: this will
+// not work if there is a name in directory with the same value of
+// hash function
+//
+static void add_entry (struct key * dir, char * name, struct key * key)
+{
+    struct path path;
+    struct key entry_key;
+    char * entry;
+    struct reiserfs_de_head * deh;
+    int retval;
+
+    init_path (&path);
+    
+    entry_key.k_dir_id = dir->k_dir_id;
+    entry_key.k_objectid = dir->k_objectid;
+    entry_key.k_offset = SET_GENERATION_NUMBER (get_third_component (name, strlen (name)), 0);
+    entry_key.k_uniqueness = DIRENTRY_UNIQUENESS;
+
+    retval = usearch_by_entry_key (&g_sb, &entry_key, &path);
+    if (retval == ENTRY_FOUND)
+	die ("add_entry: can not add name %s", name);
+
+    entry = getmem (DEH_SIZE + strlen (name));
+    deh = (struct reiserfs_de_head *)entry;
+    deh->deh_location = 0;
+    deh->deh_offset = entry_key.k_offset;
+    deh->deh_state = 0;
+    mark_de_visible (deh);
+    /* put key (ino analog) to de */
+    deh->deh_dir_id = key->k_dir_id;
+    deh->deh_objectid = key->k_objectid;
+    memcpy ((char *)(deh + 1), name, strlen (name));
+   
+    reiserfsck_paste_into_item (&path, entry, DEH_SIZE + strlen (name));
+}
+
+
+/* mkreiserfs should have created this */
+static objectid_t make_lost_found_dir (void)
+{
+    int retval;
+    struct path path;
+    struct key key;
+    struct stat_data sd;
+    struct item_head ih;
+    char empty [EMPTY_DIR_SIZE];
+    objectid_t lost_found;
+
+    lost_found = find_entry (&root_key, "lost+found");
+    if (lost_found)
+	return lost_found;
+
+    key.k_dir_id = REISERFS_ROOT_OBJECTID;
+    key.k_objectid = get_unused_objectid (&g_sb);
+    key.k_offset = SD_OFFSET;
+    key.k_uniqueness = SD_UNIQUENESS;
+
+    /* stat data */
+    make_dir_stat_data (&key, &ih, &sd);
+
+    retval = usearch_by_key (&g_sb, &key, &path, 0, DISK_LEAF_NODE_LEVEL, READ_BLOCKS, comp_keys);
+    if (retval != KEY_NOT_FOUND)
+	die ("make_lost_found_dir: can not create stat data of \'lost+found\'");
+
+    reiserfsck_insert_item (&path, &ih, (char *)&sd);
+
+    
+    /* empty dir item */
+    ih.ih_key.k_offset = DOT_OFFSET;
+    ih.ih_key.k_uniqueness = DIRENTRY_UNIQUENESS;
+    ih.ih_item_len = EMPTY_DIR_SIZE;
+    ih.u.ih_entry_count = 2;
+
+    make_empty_dir_item (empty, key.k_dir_id, key.k_objectid, 
+			 REISERFS_ROOT_PARENT_OBJECTID, REISERFS_ROOT_OBJECTID);
+
+    retval = usearch_by_key (&g_sb, &(ih.ih_key), &path, 0, DISK_LEAF_NODE_LEVEL, READ_BLOCKS, comp_keys);
+    if (retval != KEY_NOT_FOUND)
+	die ("make_lost_found_dir: can not create empty dir body of \'lost+found\'");
+
+    reiserfsck_insert_item (&path, &ih, empty);
+
+    add_entry (&root_key, "lost+found", &key);
+
+    {
+	struct stat_data * root;
+
+	/* update root directory */
+	if (usearch_by_key (&g_sb, &root_key, &path, 0, DISK_LEAF_NODE_LEVEL,
+			    READ_BLOCKS, comp_keys) != ITEM_FOUND)
+	    die ("make_lost_found_dir: can not find root directory");
+	root = B_I_STAT_DATA (PATH_PLAST_BUFFER (&path), PATH_PITEM_HEAD (&path));
+	root->sd_size += DEH_SIZE + strlen ("lost+found");
+	mark_buffer_dirty (PATH_PLAST_BUFFER (&path), 1);
+	pathrelse (&path);
+    }
+
+    return key.k_objectid;
+}
+
+
+
+char lost_name[80];
+
+static void link_lost (struct key * lost_found, struct buffer_head * bh)
+{
+    int i;
+    struct item_head * ih;
+
+
+    ih = B_N_PITEM_HEAD (bh, 0);
+    for (i = 0; i < B_NR_ITEMS (bh); i ++, ih++) {
+	if (I_IS_STAT_DATA_ITEM (ih) && ih->ih_reserved == 0xffff && S_ISDIR (B_I_STAT_DATA (bh, ih)->sd_mode)) {
+	    struct key key;
+	    
+	    sprintf (lost_name, "%u_%u", ih->ih_key.k_dir_id, ih->ih_key.k_objectid);
+	    /* entry in lost+found directory will point to this key */
+	    key.k_dir_id = ih->ih_key.k_dir_id;
+	    key.k_objectid = ih->ih_key.k_objectid;
+	    add_entry (lost_found, lost_name, &key);
+	}
+    }
+}
+
+
+
+static inline blocknr_t first_child (struct buffer_head * bh)
+{
+    return B_N_CHILD (bh, 0)->dc_block_number;
+}
+
+
+static inline blocknr_t last_child (struct buffer_head * bh)
+{
+    return B_N_CHILD (bh, B_NR_ITEMS (bh))->dc_block_number;
+}
+
+
+static inline blocknr_t next_child (struct buffer_head * child,
+				    struct buffer_head * parent)
+{
+    int i;
+    
+    for (i = 0; i < B_NR_ITEMS (parent); i ++) {
+	if (B_N_CHILD (parent, i)->dc_block_number == child->b_blocknr)
+	    return B_N_CHILD (parent, i + 1)->dc_block_number;
+    }
+    die ("next_child: no child found: should not happen");
+    return 0;
+}
+
+
+/* h == 0 for root level. block head's level == 1 for leaf level  */
+static inline int h_to_level (struct super_block * s, int h)
+{
+    return SB_TREE_HEIGHT (s) - h - 1;
+}
+
+
+static inline int leaf_level (struct buffer_head * bh)
+{
+    return B_LEVEL(bh) == DISK_LEAF_NODE_LEVEL;
+}
+
+
+static void print (int cur, int total)
+{
+  printf ("/%3d (of %3d)", cur, total);fflush (stdout);
+}
+
+
+/* erase /XXX(of XXX) */
+static void erase (void)
+{
+    printf ("\b\b\b\b\b\b\b\b\b\b\b\b\b");
+    printf ("             ");
+    printf ("\b\b\b\b\b\b\b\b\b\b\b\b\b");
+    fflush (stdout);
+}
+
+
+void pass4 (struct super_block * s)
+{
+    struct buffer_head * path[MAX_HEIGHT] = {0,};
+    int total[MAX_HEIGHT] = {0,};
+    int cur[MAX_HEIGHT] = {0,};
+    int h = 0;
+    blocknr_t block = SB_ROOT_BLOCK (s);
+    struct key lost_found;
+
+
+    if (opt_stop_point != STOP_DEFAULT || opt_lost_found == NO_LOST_FOUND)
+	return ;
+
+
+    /* create lost+found directory (if it is not there) */
+    lost_found.k_dir_id = root_key.k_objectid;
+    lost_found.k_objectid = make_lost_found_dir ();
+    lost_found.k_offset = lost_found.k_uniqueness = 0;
+
+
+    printf ("Looking for lost files..");
+
+    while ( 1 ) {
+	if (path[h])
+	    die ("pass4: empty slot expected");
+	
+	if (h)
+	    print (cur[h - 1], total[h - 1]);
+
+	path[h] = bread (s->s_dev, block, s->s_blocksize);
+	if (path[h] == 0)
+	    die ("pass4: bread failed");
+
+ 	if (leaf_level (path[h])) {
+	    link_lost (&lost_found, path[h]);
+
+	    brelse (path[h]);
+	    if (h)
+	      erase ();
+
+	    while (h && path[h]->b_blocknr == last_child (path[h - 1])) { 
+		path[h] = 0;
+		h --;
+		brelse (path[h]);
+		if (h)
+		  erase ();
+	    }
+
+	    if (h == 0) {
+		path[h] = 0;
+		break;
+	    }
+
+	    cur[h - 1] ++;
+	    block = next_child (path[h], path[h-1]);
+	    path[h] = 0;
+	    continue; 
+	}
+	total[h] = B_NR_ITEMS (path[h]) + 1;
+	cur[h] = 1;
+	block = first_child (path[h]);
+	h ++;
+    }
+
+    /* we have passed whole tree once again. Something have been added
+       to the lost+found directory. Do semantic pass for it */
+
+    printf ("Checking lost+found directory.."); fflush (stdout);
+    check_semantic_tree (&lost_found, &root_key, 0);
+    printf ("ok\n");
+    
+}
Index: empeg/kernel/fs/reiserfs/utils/fsck/main.c
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/fsck/main.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/fsck/main.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,649 @@
+/*
+ * Copyright 1996, 1997, 1998, 1999  Hans Reiser
+ */
+#include "fsck.h"
+#include <stdio.h>
+#include <getopt.h>
+#include <sys/mount.h>
+
+#include "reiserfs.h"
+
+//
+// by default journal will be replayed via mount -o replay-only
+// --replay-whole-journal
+// --no-replay-journal - journal replaying will be skipped
+// --scan-whole-partition - will scan whole parititon looking for the leaves
+//
+
+
+#define print_usage_and_exit() die ("Usage: %s [-aprvy] [--rebuild-tree]\n"\
+"[--scan-whole-partition] [--no-journal-replay]\n"\
+"[--replay-whole-journal] device\n"\
+"\n"\
+"Long options:\n"\
+"\tModes:\n"\
+"\t--check                  consistency checking (default)\n"\
+"\t--rebuild-tree           force fsck to rebuild filesystem from scratch\n"\
+"\t                         (takes a long time)\n"\
+"\t--search-key             will search for key you specify\n"\
+"\n"\
+"\tArea to scan:\n"\
+"\t--scan-used-part-only    scan what is marked used in bitmap (default)\n"\
+"\t--scan-whole-partition   scan whole partition\n"\
+"\n"\
+"\tJournal replay options:\n"\
+"\t--replay-by-mount        replay by calling mount -o replay-only (default)\n"\
+"\t--no-journal-replay      skip journal replaying\n"\
+"\t--replay-whole-journal   replay all valid transaction found in the journal\n"\
+"\n"\
+"\tStop point specifying\n"\
+"\t--do-not-stop            (default)\n"\
+"\t--stop-after-replay\n"\
+"\t--stop-after-pass1\n"\
+"\t--stop-after-pass2\n"\
+"\t--stop-after-semantic-pass\n"\
+"Short options:\n"\
+"\t-v verbose mode\n"\
+"\t-a supress progress information\n"\
+"\t-y\n"\
+"\t-p do nothing, exist for compatibility with fsck(8)\n"\
+"\t-r\n", argv[0]);
+
+
+int opt_verbose = 0;
+int opt_fsck = 0; /* called with -a by fsck - the front-end for the
+		     various file system checkers */
+
+
+//
+// fsck has three modes: default one - is check, other two are rebuild
+// and find items
+//
+int opt_fsck_mode = FSCK_DEFAULT;
+
+/* in mode FSCK_FIND_ITEM keu for search is stored here */
+struct key key_to_find;
+
+//
+// replay journal modes
+//
+#define REPLAY_DEFAULT 0
+#define REPLAY_ALL 1
+#define NO_REPLAY 2
+int opt_journal_replay = REPLAY_DEFAULT;
+
+
+//
+// fsck may stop after any of its phases: after journal replay or
+// after any of passes. Default is do not stop
+//
+int opt_stop_point = STOP_DEFAULT;
+
+
+//
+// 
+//
+int opt_what_to_scan = SCAN_USED_PART;
+
+
+//
+//
+//
+int opt_lost_found = NO_LOST_FOUND;
+
+
+
+/* fsck is called with one non-optional argument - file name of device
+   containing reiserfs. This function parses other options, sets flags
+   based on parsing and returns non-optional argument */
+static char * parse_options (int argc, char * argv [])
+{
+    int c;
+
+    while (1) {
+	static struct option options[] = {
+	    // mode options
+	    {"check", no_argument, &opt_fsck_mode, FSCK_DEFAULT},
+	    {"rebuild-tree", no_argument, &opt_fsck_mode, FSCK_REBUILD},
+	    {"search-key", no_argument, &opt_fsck_mode, FSCK_FIND_ITEM},
+
+	    // journal replay options
+	    {"replay-by-mount", no_argument, &opt_journal_replay, REPLAY_DEFAULT},
+	    {"no-journal-replay", no_argument, &opt_journal_replay, NO_REPLAY},
+	    {"replay-whole-journal", no_argument, &opt_journal_replay, REPLAY_ALL},
+
+	    // stop point options
+	    {"do-not-stop", no_argument, &opt_stop_point, STOP_DEFAULT},
+	    {"stop-after-replay", no_argument, &opt_stop_point, STOP_AFTER_REPLAY},
+	    {"stop-after-pass1", no_argument, &opt_stop_point, STOP_AFTER_PASS1},
+	    {"stop-after-pass2", no_argument, &opt_stop_point, STOP_AFTER_PASS2},
+	    {"stop-after-semantic-pass", no_argument, &opt_stop_point, STOP_AFTER_SEMANTIC},
+
+	    // scanned area option
+	    {"scan-used-part-only", no_argument, &opt_what_to_scan, SCAN_USED_PART},
+	    {"scan-whole-partition", no_argument, &opt_what_to_scan, SCAN_WHOLE_PARTITION},
+
+	    // lost+found
+	    {"no-lost+found", no_argument, &opt_lost_found, NO_LOST_FOUND},
+	    {"lost+found",  no_argument, &opt_lost_found, DO_LOST_FOUND},
+	    {0, 0, 0, 0}
+	};
+	int option_index;
+      
+	c = getopt_long (argc, argv, "yapv", options, &option_index);
+	if (c == -1)
+	    break;
+
+	switch (c) {
+	case 0:
+	    switch (option_index) {
+	    case 0: /* check */
+	    case 1: /* rebuild */
+	    case 2: /* find */
+		break;
+
+	    case 3: /* replay by mount */
+	    case 4: /* no journal replay */
+	    case 5: /* replay whole journal */
+		break;
+
+	    case 6: /* do not stop */
+	    case 7: /* stop after replay */
+	    case 8: /* stop after pass 1 */
+	    case 9: /* stop after pass 2 */
+	    case 10: /* stop after semantic */
+		break;
+	    case 11: /* scan used part of partition */
+	    case 12: /* scan whole partition */
+		break;
+		
+	    }
+	    break;
+
+	case 'y':
+	case 'p': /* these do nothing */
+	case 'r':
+	    break;
+
+	case 'a':
+	    opt_fsck = 1;
+	    break;
+
+	case 'v':
+	    /* output fsck statistics to stdout on exit */
+	    opt_verbose = 1;
+	    break;
+
+	default:
+	    print_usage_and_exit();
+	}
+    }
+
+  if (optind != argc - 1)
+    /* only one non-option argument is permitted */
+    print_usage_and_exit();
+  
+  return argv[optind];
+}
+
+
+struct super_block g_sb;
+struct buffer_head * g_sbh;
+struct reiserfs_super_block * g_old_rs;
+
+
+static void reset_super_block (struct super_block * s)
+{
+    unsigned long * oids;
+
+    g_old_rs = (struct reiserfs_super_block *)getmem (s->s_blocksize);
+    memcpy (g_old_rs, SB_BUFFER_WITH_SB (s)->b_data, s->s_blocksize);
+
+    /* reset few fields in */
+    SB_FREE_BLOCKS (s) = SB_BLOCK_COUNT (s);
+    SB_TREE_HEIGHT (s) = ~0;
+    SB_ROOT_BLOCK (s) = ~0;
+    s->u.reiserfs_sb.s_mount_state = REISERFS_ERROR_FS;
+    s->u.reiserfs_sb.s_rs->s_oid_cursize = 2;
+    oids = (unsigned long *)(s->u.reiserfs_sb.s_rs + 1);
+    if (oids[0] != 1) {
+	printf ("reset_super_block: invalid objectid map\n");
+	oids[0] = 1;
+    }
+    oids[1] = 2;
+    s->s_dirt = 1;
+
+    mark_buffer_dirty (SB_BUFFER_WITH_SB (s), 0);
+}
+
+static void update_super_block (void)
+{
+    SB_REISERFS_STATE (&g_sb) = REISERFS_VALID_FS;
+    
+    reset_journal (&g_sb);
+
+    mark_buffer_dirty (SB_BUFFER_WITH_SB (&g_sb), 0);
+}
+
+
+char ** g_disk_bitmap;
+char ** g_new_bitmap;
+char ** g_uninsertable_leaf_bitmap;
+char ** g_formatted;
+char ** g_unformatted;
+int g_blocks_to_read;
+
+
+/* read bitmaps (new or old format), create data blocks for new
+   bitmap, mark non-data blocks in it (skipped, super block, journal
+   area, bitmaps) used, create other auxiliary bitmaps */
+static void init_bitmaps (struct super_block * s)
+{
+    int i, j;
+
+    /* read disk bitmap */
+    if (uread_bitmaps (s))
+	die ("init_bitmap: unable to read bitmap");
+
+    g_disk_bitmap = getmem (sizeof (char *) * SB_BMAP_NR (s));
+    for (i = 0; i < SB_BMAP_NR (s); i ++) {
+	g_disk_bitmap[i] = SB_AP_BITMAP (s)[i]->b_data;
+
+	if (opt_what_to_scan == SCAN_WHOLE_PARTITION)
+	    /* mark all blocks busy */
+	    memset (g_disk_bitmap[i], 0xff, s->s_blocksize);
+    }
+
+
+    /* g_blocks_to_read is used to report progress */
+    if (opt_what_to_scan == SCAN_WHOLE_PARTITION)
+	/* all blocks will be scanned */
+	g_blocks_to_read = SB_BLOCK_COUNT (s);
+    else {
+	/* blocks marked used in bitmap will be scanned */
+	g_blocks_to_read = 0;
+	for (i = 0; i < SB_BMAP_NR (s); i ++) {
+	    for (j = 0; j < s->s_blocksize * 8; j ++)
+		if (i * s->s_blocksize * 8 + j < SB_BLOCK_COUNT (s) &&
+		    test_bit (j, SB_AP_BITMAP (s)[i]->b_data))
+		    g_blocks_to_read ++;
+	}
+    }
+
+    /* this bitmap will contain valid bitmap when fsck will have done */
+    g_new_bitmap = getmem (sizeof (char *) * SB_BMAP_NR (s));
+    for (i = 0; i < SB_BMAP_NR (s); i ++)
+	g_new_bitmap[i] = getmem (s->s_blocksize);
+
+    /* mark skipped blocks and super block used */
+    for (i = 0; i <= SB_BUFFER_WITH_SB (s)->b_blocknr; i ++)
+	mark_block_used (i);
+
+    /* mark bitmap blocks as used */
+    for (i = 0; i < SB_BMAP_NR (s); i ++)
+	mark_block_used (SB_AP_BITMAP (s)[i]->b_blocknr);
+
+    /* mark journal area as used */
+    for (i = 0; i < JOURNAL_BLOCK_COUNT + 1; i ++)
+	mark_block_used (i + get_journal_start (s));
+
+    /* fill by 1s the unused part of last bitmap */
+    if (SB_BLOCK_COUNT (s) % (s->s_blocksize * 8))
+	for (j = SB_BLOCK_COUNT (s) % (s->s_blocksize * 8); j < s->s_blocksize * 8; j ++)
+	    set_bit (j, g_new_bitmap[SB_BMAP_NR (s) - 1]);
+
+    /* allocate space for bitmap of uninsertable leaves */
+    g_uninsertable_leaf_bitmap = getmem (sizeof (char *) * SB_BMAP_NR (s));
+    for (i = 0; i < SB_BMAP_NR (s); i ++) {
+	g_uninsertable_leaf_bitmap[i] = getmem (s->s_blocksize);
+	memset (g_uninsertable_leaf_bitmap[i], 0xff, s->s_blocksize);
+    }
+
+    /* bitmap of formatted nodes */
+    g_formatted = getmem (sizeof (char *) * SB_BMAP_NR (s));
+    for (i = 0; i < SB_BMAP_NR (s); i ++) {
+	g_formatted[i] = getmem (s->s_blocksize);
+	memset (g_formatted[i], 0, s->s_blocksize);
+    }
+    /* bitmap of unformatted nodes */
+    g_unformatted = getmem (sizeof (char *) * SB_BMAP_NR (s));
+    for (i = 0; i < SB_BMAP_NR (s); i ++) {
+	g_unformatted[i] = getmem (s->s_blocksize);
+	memset (g_unformatted[i], 0, s->s_blocksize);
+    }
+}
+
+
+/* write bitmaps and brelse them */
+static void update_bitmap (struct super_block * s)
+{
+    int i;
+
+    /* journal area could be used, reset it */
+    for (i = 0; i < get_journal_start (s) + get_journal_size (s) + 1; i ++)
+	if (!is_block_used (i))
+	    mark_block_used (i);
+
+    for (i = 0; i < SB_BMAP_NR (s); i ++) {
+
+	/* copy newly built bitmap to cautious bitmap */
+	memcpy (SB_AP_BITMAP (s)[i]->b_data, g_new_bitmap[i], s->s_blocksize);
+	mark_buffer_dirty (SB_AP_BITMAP (s)[i], 0);
+	bwrite (SB_AP_BITMAP (s)[i]);
+    
+
+	freemem (g_new_bitmap[i]);
+	/* g_disk_bitmap[i] points to corresponding cautious bitmap's b_data */
+	freemem (g_uninsertable_leaf_bitmap[i]);
+    }
+
+    freemem (g_disk_bitmap);
+    freemem (g_new_bitmap);
+    freemem (g_uninsertable_leaf_bitmap);
+
+}
+
+
+static void release_bitmap (void)
+{
+    int i;
+
+    for (i = 0; i < SB_BMAP_NR (&g_sb); i ++) {
+	brelse (SB_AP_BITMAP (&g_sb)[i]);
+    }
+}
+
+static void release_super_block (void)
+{
+    bwrite (SB_BUFFER_WITH_SB (&g_sb));
+    freemem (SB_AP_BITMAP (&g_sb));
+    brelse (SB_BUFFER_WITH_SB (&g_sb));
+
+    freemem (g_old_rs);
+}
+
+
+
+static void mount_replay (char * devname1)
+{
+    int retval;
+    char * tmpdir;
+
+    printf ("Replaying journal.."); fflush (stdout);
+
+    tmpdir = tmpnam (0);
+    if (!tmpdir || mkdir (tmpdir, 0644))
+	die ("replay_journal: tmpnam or mkdir failed: %s", strerror (errno));
+ 
+    retval = mount (devname1, tmpdir, "reiserfs", MS_MGC_VAL, "replayonly");
+    if (retval != -1 || errno != EINVAL) {
+	printf ("\nMAKE SURE, THAT YOUR KERNEL IS ABLE TO MOUNT REISERFS\n");
+	die ("replay_journal: mount returned unexpected value: %s", 
+	     strerror (errno));
+    }
+
+    if (rmdir (tmpdir) == -1)
+	die ("replay_journal: rmdir failed: %s", strerror (errno));
+
+    printf ("ok\n"); fflush (stdout);
+}
+
+
+static inline int nothing_todo (struct super_block * s)
+{
+    if (opt_fsck)
+	return 1;
+    return 0;
+}
+
+
+void write_dirty_blocks (void)
+{
+  fsync_dev (0);
+}
+
+
+#define WARNING \
+"Don't run this program unless something is broken.  You may want\n\
+to backup first.  Some types of random FS damage can be recovered\n\
+from by this program, which basically throws away the internal nodes\n\
+of the tree and then reconstructs them.  This program is for use only\n\
+by the desperate, and is of only beta quality.  Email\n\
+reiserfs@devlinux.com with bug reports. \n"
+
+/* 
+   warning #2
+   you seem to be running this automatically.  you are almost
+   certainly doing it by mistake as a result of some script that
+   doesn't know what it does.  doing nothing, rerun without -p if you
+   really intend to do this.  */
+
+void warn_what_will_be_done (void)
+{
+    char * answer = 0;
+    size_t n = 0;
+
+    /* warn about fsck mode */
+    switch (opt_fsck_mode) {
+    case FSCK_DEFAULT:
+	printf ("Will read-only check consistency of the partition\n");
+	break;
+
+    case FSCK_REBUILD:
+	printf (WARNING);
+	break;
+
+    case FSCK_FIND_ITEM:
+	printf ("Will look for the item with key\n");
+	break;
+    }
+
+    /* warn about replay */
+    switch (opt_journal_replay) {
+    case REPLAY_DEFAULT:
+	printf ("Will replay just like mounting would\n");
+	break;
+	
+    case REPLAY_ALL:
+	printf ("Will replay all valid transactions\n"); break;
+
+    case NO_REPLAY:
+	printf ("Will not replay journal\n"); break;
+    }
+
+    /* warn about stop point */
+    switch (opt_stop_point) {
+    case STOP_AFTER_REPLAY:
+	printf ("Will stop after journal replay\n"); break;
+    case STOP_AFTER_PASS1:
+	printf ("Will stop after pass 1\n"); break;
+
+    case STOP_AFTER_PASS2:
+	printf ("Will stop after pass 2\n"); break;
+
+    case STOP_AFTER_SEMANTIC:
+	printf ("Will stop after semantic pass\n"); break;
+    }
+
+
+    /* warn about scanned area */
+    if (opt_what_to_scan == SCAN_WHOLE_PARTITION)
+	printf ("Will scan whole partition\n");
+    
+    printf ("Do you want to run this "
+	    "program?[N/Yes] (note need to type Yes):");
+    if (getline (&answer, &n, stdin) != 4 || strcmp ("Yes\n", answer)) {
+	exit (0);
+    }
+
+    if (opt_fsck_mode == FSCK_FIND_ITEM) {
+	printf ("Specify key to search:");
+	if (scanf ("%d %d %d %d", &(key_to_find.k_dir_id), &(key_to_find.k_objectid),
+		   &(key_to_find.k_offset), &(key_to_find.k_uniqueness)) != 4)
+	    die ("parse_options: specify a key through stdin");
+    }
+}
+
+
+void end_fsck (char * file_name)
+{
+    update_super_block ();
+    update_bitmap (&g_sb);
+    release_bitmap ();
+    release_super_block ();
+    
+    if (opt_verbose == 1)
+	output_information ();
+
+    printf ("Syncing.."); fflush (stdout);
+    
+    write_dirty_blocks ();
+    sync ();
+    
+    printf ("done\n"); fflush (stdout);
+    
+    if (opt_verbose == 1)
+	printf ("Checking mem..");
+    
+    free_overwritten_unfms ();
+    check_and_free_buffer_mem ();
+
+    if (opt_verbose == 1)
+	printf ("done\n");
+
+    if (opt_fsck == 1)
+	printf("ReiserFS : done checking %s\n", file_name);
+    else
+	printf ("Ok\n");
+    exit (0);
+}
+
+
+static void open_device (char * file_name, int flag)
+{
+    g_sb.s_dev = open (file_name, flag);
+    if (g_sb.s_dev == -1)
+	die ("reiserfsck: can not open '%s': %s", file_name, strerror (errno));
+}  
+
+static void reopen_read_only (char * file_name)
+{
+    close (g_sb.s_dev);
+    open_device (file_name, O_RDONLY);
+}
+
+static void reopen_read_write (char * file_name)
+{
+    close (g_sb.s_dev);
+    open_device (file_name, O_RDWR);
+}
+
+
+/* ubitmap.c: */extern int from_journal;
+
+
+int main (int argc, char * argv [])
+{
+    char * file_name;
+ 
+    if (opt_fsck == 0)
+	printf ("\n\n<-----------REISERFSCK, 1999----------->\n\n");
+
+
+    file_name = parse_options (argc, argv);
+    if (is_mounted (file_name))
+	/* do not work on mounted filesystem for now */
+	die ("reiserfsck: '%s' contains a mounted file system\n", file_name);
+
+
+    warn_what_will_be_done (); /* and ask confirmation Yes */
+
+
+    if (opt_journal_replay == REPLAY_DEFAULT)
+	mount_replay (file_name);
+
+    open_device (file_name, O_RDONLY);
+    
+    if (uread_super_block (&g_sb))
+	die ("reiserfsck: no reiserfs found");
+
+    if (opt_journal_replay == REPLAY_ALL) {
+	/* read-write permissions are needed */
+	reopen_read_write (file_name);
+	replay_all (&g_sb);
+	reopen_read_only (file_name);
+    }
+
+
+    if (nothing_todo (&g_sb)) {
+	/* this should work when fsck is called by fsck -a */
+	printf ("%s: clean, %d/%d %ldk blocks\n", file_name,
+		SB_BLOCK_COUNT (&g_sb) - SB_FREE_BLOCKS(&g_sb), SB_BLOCK_COUNT (&g_sb), g_sb.s_blocksize / 1024);
+	brelse (SB_BUFFER_WITH_SB (&g_sb));
+	return 0;
+    }
+
+
+    if (opt_fsck_mode == FSCK_DEFAULT) {
+	check_fs_tree (&g_sb);
+	release_bitmap ();
+	release_super_block ();
+	check_and_free_buffer_mem ();
+	exit (0);
+    }
+
+    if (opt_stop_point == STOP_AFTER_REPLAY) {
+	release_super_block ();
+	check_and_free_buffer_mem ();
+	exit (0);	
+    }
+	
+
+    if (opt_fsck_mode == FSCK_REBUILD) {
+	reopen_read_write (file_name);
+
+	if (opt_fsck == 1)
+	    printf ("ReiserFS : checking %s\n",file_name);
+	else
+	    printf ("Rebuilding..\n");
+
+	reset_super_block (&g_sb);
+	init_bitmaps (&g_sb);
+	
+	/* make file system invalid unless fsck done */
+	SB_REISERFS_STATE (&g_sb) = REISERFS_ERROR_FS;
+	bwrite (SB_BUFFER_WITH_SB (&g_sb));
+	/* 1,2. building of the tree */
+	build_the_tree ();
+
+	/* 3. semantic pass */
+	semantic_pass ();
+
+	/* if --lost+found is set - link unaccessed directories to
+           lost+found directory */
+	pass4 (&g_sb);
+
+	/* 4. look for unaccessed items in the leaves */
+	check_unaccessed_items ();
+
+
+	if (from_journal)
+	    /* blocks from journal area could get into tree, fix that */
+	    release_journal_blocks (&g_sb);
+
+	end_fsck (file_name);
+    }
+
+
+    if (opt_fsck_mode == FSCK_FIND_ITEM) {
+	init_bitmaps (&g_sb);
+	build_the_tree ();
+	release_bitmap ();
+	release_super_block ();
+	check_and_free_buffer_mem ();
+	exit (0);
+    }
+
+
+    return 0;
+}
Index: empeg/kernel/fs/reiserfs/utils/fsck/makefile
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/fsck/makefile:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/fsck/makefile	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,44 @@
+VPATH = ../bin
+vpath %.c ../..:../bin
+
+OBJS = main.o pass1.o pass2.o semantic.o pass4.o noname.o ubitmap.o info.o check.o ufile.o ustree.o fix_node.o do_balan.o lbalance.o ibalance.o teahash3.o uobjectid.o segments.o check_tree.o journal.o lost+found.o
+#OBJS = main.o
+
+
+FSCK = $(TMPBINDIR)/reiserfsck
+
+.c.o:
+	$(CC)  -DREISERFS_FSCK $(CFLAGS) $<
+
+all: $(FSCK)
+
+
+$(FSCK): $(OBJS) libmisc.a libreiserfs.a
+	$(CC) $(LFLAGS) -o $(FSCK) $(OBJS) -lmisc -lreiserfs
+
+clean:
+	rm -f *.o $(FSCK) *~ TAGS .depend
+
+dep:
+	gcc -MM $(IDIRS) *.c ../../*.c > .depend
+
+install:
+	cp -f $(FSCK) $(SBIN)
+	if [ -d $(MANDIR) ] ; then cp reiserfsck.8 $(MANDIR) ; gzip -f -9 $(MANDIR)/reiserfsck.8 ; fi
+
+uninstall:
+	rm -f $(MANDIR)/reiserfsck.8.gz $(SBIN)/reiserfsck
+
+
+ifeq (.depend,$(wildcard .depend))
+include .depend
+endif
+
+
+
+
+
+
+
+
+
Index: empeg/kernel/fs/reiserfs/utils/fsck/noname.c
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/fsck/noname.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/fsck/noname.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,309 @@
+/*
+ * Copyright 1996, 1997, 1998 Hans Reiser
+ */
+
+/*#include <stdio.h>*/
+/*#include <string.h>*/
+/*#include <sys/types.h>*/
+/*#include <asm/bitops.h>
+#include "../include/reiserfs_fs.h"
+#include "../include/reiserfs_fs_sb.h"
+#include "../include/reiserfslib.h"*/
+#include "fsck.h"
+
+
+void get_max_buffer_key (struct buffer_head * bh, struct key * key)
+{
+  struct item_head * ih;
+
+  ih = B_N_PITEM_HEAD (bh, B_NR_ITEMS (bh) - 1);
+  copy_key (key, &(ih->ih_key));
+
+  if (KEY_IS_DIRECTORY_KEY (key)) {
+    /* copy 3-rd and 4-th key components of the last entry */
+    key->k_offset = B_I_DEH (bh, ih)[I_ENTRY_COUNT (ih) - 1].deh_offset;
+    key->k_uniqueness = DIRENTRY_UNIQUENESS;
+  } else if (!KEY_IS_STAT_DATA_KEY (key))
+    /* get key of the last byte, which is contained in the item */
+    key->k_offset += I_BYTES_NUMBER (ih, bh->b_size) - 1;
+
+}
+
+
+#if 0
+int are_items_mergeable (struct item_head * left, struct item_head * right, int bsize)
+{
+  if (comp_keys (&left->ih_key, &right->ih_key) != SECOND_GREATER) {
+    print_key (&(left->ih_key));
+    print_key (&(right->ih_key));
+    die ("are_items_mergeable: second key is not greater");
+  }
+
+  if (comp_short_keys (&left->ih_key, &right->ih_key) != KEYS_IDENTICAL)
+    return NO;
+
+  if (I_IS_DIRECTORY_ITEM (left)) {
+    if (!I_IS_DIRECTORY_ITEM (right))
+      die ("are_items_mergeable: right item must be of directory type");
+    return 1;
+  }
+
+  if ((I_IS_DIRECT_ITEM (left) && I_IS_DIRECT_ITEM (right)) || 
+      (I_IS_INDIRECT_ITEM (left) && I_IS_INDIRECT_ITEM (right)))
+    return (left->ih_key.k_offset + I_BYTES_NUMBER (left, bsize) == right->ih_key.k_offset) ? 1 : 0;
+
+  return 0;
+}
+
+
+static void decrement_key (struct key * key)
+{
+  unsigned long * key_field = (unsigned long *)key + REISERFS_FULL_KEY_LEN - 1;
+  int i;
+
+  for (i = 0; i < REISERFS_FULL_KEY_LEN; i ++, key_field--)
+    if (*key_field) {
+      (*key_field)--;
+      break;
+    }
+
+  if (i == REISERFS_FULL_KEY_LEN)
+    die ("decrement_key: zero key found");
+}
+
+
+/* get left neighbor of the leaf node */
+static struct buffer_head * get_left_neighbor (struct path * path)
+{
+  struct key key;
+  struct path path_to_left_neighbor;
+  struct buffer_head * bh;
+
+  copy_key (&key, B_N_PKEY (PATH_PLAST_BUFFER (path), 0));
+  decrement_key (&key);  
+
+  reiserfsck_search_by_key (&g_sb, &key, &path_to_left_neighbor, comp_keys);
+  if (PATH_LAST_POSITION (&path_to_left_neighbor) == 0) {
+    pathrelse (&path_to_left_neighbor);
+    return 0;
+  }
+  bh = PATH_PLAST_BUFFER (&path_to_left_neighbor);
+  bh->b_count ++;
+  pathrelse (&path_to_left_neighbor);
+  return bh;
+}
+
+
+int is_left_mergeable (struct path * path)
+{
+  struct item_head * right;
+  struct buffer_head * bh;
+  int retval;
+  
+  right = B_N_PITEM_HEAD (PATH_PLAST_BUFFER (path), 0);
+
+  bh = get_left_neighbor (path);
+  if (bh == 0) {
+    return 0;
+  }
+  retval = are_items_mergeable (B_N_PITEM_HEAD (bh, B_NR_ITEMS (bh) - 1), right, bh->b_size);
+  brelse (bh);
+  return retval;
+}
+
+
+static struct buffer_head * get_right_neighbor (struct path * path)
+{
+  struct key key;
+  struct key * rkey;
+  struct path path_to_right_neighbor;
+  struct buffer_head * bh;
+  struct key maxkey = {0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff};
+
+  rkey = get_right_dkey (path);
+  if (rkey == 0)
+    copy_key (&key, &maxkey);
+  else
+    copy_key (&key, rkey);
+
+  reiserfsck_search_by_key (&g_sb, &key, &path_to_right_neighbor, comp_keys);
+  if (PATH_PLAST_BUFFER (&path_to_right_neighbor) == PATH_PLAST_BUFFER (path)) {
+    pathrelse (&path_to_right_neighbor);
+    return 0;
+  }
+  bh = PATH_PLAST_BUFFER (&path_to_right_neighbor);
+  bh->b_count ++;
+  pathrelse (&path_to_right_neighbor);
+  return bh;
+}
+
+
+int is_right_mergeable (struct path * path)
+{
+  struct item_head * left;
+  struct buffer_head * bh;
+  int retval;
+  
+  left = B_N_PITEM_HEAD (PATH_PLAST_BUFFER (path), B_NR_ITEMS (PATH_PLAST_BUFFER (path)) - 1);
+
+  bh = get_right_neighbor (path);
+  if (bh == 0) {
+    return 0;
+  }
+  retval = are_items_mergeable (left, B_N_PITEM_HEAD (bh, 0), bh->b_size);
+  brelse (bh);
+  return retval;
+}
+
+#endif /*0*/
+
+
+#if 0
+/* retunrs 1 if buf looks like a leaf node, 0 otherwise */
+static int is_leaf (char * buf)
+{
+  struct block_head * blkh;
+  struct item_head * ih;
+  int used_space;
+  int prev_location;
+  int i;
+
+  blkh = (struct block_head *)buf;
+  ih = (struct item_head *)(buf + BLKH_SIZE) + blkh->blk_nr_item - 1;
+  used_space = BLKH_SIZE + IH_SIZE * blkh->blk_nr_item + (g_sb.s_blocksize - ih->ih_item_location);
+  if (used_space != g_sb.s_blocksize - blkh->blk_free_space)
+    return 0;
+  ih = (struct item_head *)(buf + BLKH_SIZE);
+  prev_location = g_sb.s_blocksize;
+  for (i = 0; i < blkh->blk_nr_item; i ++, ih ++) {
+    if (ih->ih_item_location >= g_sb.s_blocksize || ih->ih_item_location < IH_SIZE * blkh->blk_nr_item)
+      return 0;
+    if (ih->ih_item_len < 1 || ih->ih_item_len > MAX_ITEM_LEN (g_sb.s_blocksize))
+      return 0;
+    if (prev_location - ih->ih_item_location != ih->ih_item_len)
+      return 0;
+    prev_location = ih->ih_item_location;
+  }
+
+  return 1;
+}
+
+
+/* retunrs 1 if buf looks like an internal node, 0 otherwise */
+static int is_internal (char * buf)
+{
+  struct block_head * blkh;
+  int used_space;
+
+  blkh = (struct block_head *)buf;
+  used_space = BLKH_SIZE + KEY_SIZE * blkh->blk_nr_item + DC_SIZE * (blkh->blk_nr_item + 1);
+  if (used_space != g_sb.s_blocksize - blkh->blk_free_space)
+    return 0;
+  return 1;
+}
+
+
+/* sometimes unfomatted node looks like formatted, if we check only
+   block_header. This is the reason, why it is so complicated. We
+   believe only when free space and item locations are ok 
+   */
+int not_formatted_node (char * buf)
+{
+  struct block_head * blkh;
+
+  blkh = (struct block_head *)buf;
+
+  if (blkh->blk_level < DISK_LEAF_NODE_LEVEL || blkh->blk_level > MAX_HEIGHT)
+    /* blk_level is out of range */
+    return 1;
+
+  if (blkh->blk_nr_item < 1 || blkh->blk_nr_item > (g_sb.s_blocksize - BLKH_SIZE) / IH_SIZE)
+    /* item number is out of range */
+    return 1;
+
+  if (blkh->blk_free_space > g_sb.s_blocksize - BLKH_SIZE - IH_SIZE)
+    /* free space is out of range */
+    return 1;
+
+  /* check format of nodes, such as we are not sure, that this is formatted node */
+  if (blkh->blk_level == DISK_LEAF_NODE_LEVEL)
+    return (is_leaf (buf) == 1) ? 0 : 1;
+  return (is_internal (buf) == 1) ? 0 : 1;
+}
+
+
+int is_internal_node (char * buf)
+{
+  struct block_head * blkh;
+  
+  blkh = (struct block_head *)buf;
+  if (blkh->blk_level != DISK_LEAF_NODE_LEVEL)
+    return 1;
+  return 0;
+}
+
+#endif /*0*/
+
+/*
+int ready_preserve_list (struct tree_balance * tb, struct buffer_head * bh)
+{
+  return 0;
+}
+
+
+void	preserve_shifted (
+			  struct tree_balance * tb,
+			  struct buffer_head **bh,
+			  struct buffer_head * parent,
+			  int position,
+			  struct buffer_head * dest)
+{
+  return;
+}
+*/
+
+#if 0
+
+char * strs[] =
+{"0%",".",".",".",".","20%",".",".",".",".","40%",".",".",".",".","60%",".",".",".",".","80%",".",".",".",".","100%"};
+
+char progress_to_be[1024];
+char current_progress[1024];
+
+void str_to_be (char * buf, int prosents)
+{
+  int i;
+  prosents -= prosents % 4;
+  buf[0] = 0;
+  for (i = 0; i <= prosents / 4; i ++)
+    strcat (buf, strs[i]);
+}
+
+
+void print_how_far (unsigned long * passed, unsigned long total)
+{
+  int n;
+
+  if (*passed == 0)
+    current_progress[0] = 0;
+
+  if (*passed >= total) {
+    printf/*die*/ ("print_how_far: total %lu has been reached already. cur=%lu\n", total, ++(*passed));
+    return;
+  }
+
+  (*passed) ++;
+  n = ((double)((double)(*passed) / (double)total) * (double)100);
+
+  str_to_be (progress_to_be, n);
+
+  if (strlen (current_progress) != strlen (progress_to_be))
+    printf ("%s", progress_to_be + strlen (current_progress));
+
+  strcat (current_progress, progress_to_be + strlen (current_progress));
+
+
+  fflush (stdout);
+}
+#endif
+
Index: empeg/kernel/fs/reiserfs/utils/fsck/pass1.c
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/fsck/pass1.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/fsck/pass1.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,547 @@
+/*
+ * Copyright 1996-1999 Hans Reiser
+ */
+#include "fsck.h"
+#include <stdlib.h>
+#include "reiserfs.h"
+
+
+void build_the_tree (void);
+int is_item_accessed (struct item_head * ih);
+void mark_item_unaccessed (struct item_head * ih);
+void mark_item_accessed (struct item_head * ih, struct buffer_head * bh);
+
+
+/* allocates buffer head and copy buffer content */
+static struct buffer_head * make_buffer (int dev, int blocknr, int size, char * data)
+{
+  struct buffer_head * bh;
+
+  bh = getblk (dev, blocknr, size);
+  if (buffer_uptodate (bh))
+    die ("make_buffer: uptodate buffer found");
+  memcpy (bh->b_data, data, size);
+  set_bit (BH_Uptodate, (char *)&bh->b_state);
+  return bh;
+}
+
+
+static void find_a_key (struct key * key, struct buffer_head * bh)
+{
+  int i;
+  struct item_head * ih;
+  struct reiserfs_de_head * deh;
+
+  for (i = 0; i < B_NR_ITEMS (bh); i ++) {
+    ih = B_N_PITEM_HEAD (bh, i);
+    if (comp_short_keys (key, &(ih->ih_key)))
+      continue;
+
+    if (key->k_offset == MAX_KEY_OFFSET && key->k_uniqueness == MAX_KEY_OFFSET) {
+      /* look for all items of this file */
+      reiserfs_warning ("\nblock %d contains item of this file %k (item %d)\n", bh->b_blocknr, key, i);
+      return;
+    }
+
+    /* key is specified precisely */
+    if (!comp_keys (key, &(ih->ih_key))) {
+      reiserfs_warning ("\nblock %d contains key %k (item %d)\n", bh->b_blocknr, key, i);
+      return;
+    }
+    if (KEY_IS_DIRECTORY_KEY (key) && I_IS_DIRECTORY_ITEM (ih)) {
+      int j;
+      
+      deh = B_I_DEH (bh, ih);
+      for (j = 0; j < I_ENTRY_COUNT (ih); j ++, deh ++)
+	if (deh->deh_offset == key->k_offset) {
+	  reiserfs_warning ("\nblock %d contains key %k (item_pos %d, pos_in_item %d)\n", bh->b_blocknr, key, i, j);
+	  return;
+	}
+    }
+  }
+}
+
+
+/* analyse contents of indirect items. If it points to used blocks or
+   to uninsertable node, which has to be inserted by items - we free
+   those slots (putting 0-s), if not - mark pointed blocks as used */
+static void handle_indirect_items (struct buffer_head * bh)
+{
+  int i, j;
+  struct item_head * ih;
+
+  for (i = 0, ih = B_N_PITEM_HEAD (bh, 0); i < B_NR_ITEMS (bh); i ++, ih ++) {
+    if (I_IS_INDIRECT_ITEM(ih)) {
+      __u32 * unp;
+      
+      /* check each pointer to unformatted node, if it is in the tree already, put 0 here */
+      unp = (__u32 *)B_I_PITEM (bh, ih);
+      for (j = 0; j < ih->ih_item_len / UNFM_P_SIZE; j ++) {
+	if (unp[j] >= SB_BLOCK_COUNT (&g_sb) || /* invalid data block */
+	    !was_block_used (unp[j]) ||	/* block is marked free in on
+					   disk bitmap */
+	    is_block_used (unp[j]) ||	/* that is either it looked
+					   like leaf or other indirect
+					   item contains this pointer
+					   already */
+	    is_block_uninsertable (unp[j])) {	/* block contains leaf
+						   node, its insertion
+						   has been postponed */
+	  unp[j] = 0;
+	  mark_buffer_dirty (bh, 0);
+	  continue;
+	}
+	/* ok, mark that block is in tree and that it is unformatted node */
+	mark_block_used (unp[j]);
+
+	/* this is for check only */
+	mark_block_unformatted (unp[j]);
+      }
+    }
+  }
+}
+
+int g_unaccessed_items = 0;
+
+int is_item_accessed (struct item_head * ih)
+{
+  return (ih->ih_reserved == 0) ? 1 : 0;
+}
+
+
+void mark_item_unaccessed (struct item_head * ih)
+{
+  g_unaccessed_items ++;
+  ih->ih_reserved = MAX_US_INT;
+}
+
+
+void mark_item_accessed (struct item_head * ih, struct buffer_head * bh)
+{
+  g_unaccessed_items --;
+  ih->ih_reserved = 0;
+  mark_buffer_dirty (bh, 0);
+}
+
+
+/* used when leaf is inserted into tree by pointer
+   1. set sd_nlinks to 0 in all stat data items
+   2. mark all items as unaccessed
+   */
+static void reset_nlinks (struct buffer_head * bh)
+{ 
+  int i;
+  struct item_head * ih;
+
+  ih = B_N_PITEM_HEAD (bh, 0);
+  for (i = 0; i < B_NR_ITEMS (bh); i ++, ih ++) {
+    mark_item_unaccessed (ih);
+    if (I_IS_STAT_DATA_ITEM (ih)) {
+      add_event (STAT_DATA_ITEMS);
+      B_I_STAT_DATA (bh, ih)->sd_nlink = 0;
+    }
+  }
+
+  mark_buffer_dirty (bh, 0);
+}
+
+
+/* ubitmap.c */
+extern int from_journal;
+
+static void insert_pointer (struct buffer_head * bh, struct path * path)
+{
+  struct tree_balance tb;
+  struct item_head * ih;
+  char * body;
+  int memmode;
+  int zeros_number;
+  int retval;
+
+  init_tb_struct (&tb, &g_sb, path, 0x7fff);
+  tb.preserve_mode = NOTHING_SPECIAL;
+
+  /* fix_nodes & do_balance must work for internal nodes only */
+  ih = 0;
+  retval = fix_nodes (0, M_INTERNAL, &tb, PATH_LAST_POSITION (path), ih);
+  if (retval != CARRY_ON)
+    die ("insert_pointer: no free space on device (retval == %d, used blocks from journal %d",
+	 retval, from_journal);
+
+  /* child_pos: we insert after position child_pos: this feature of the insert_child */
+  /* there is special case: we insert pointer after
+     (-1)-st key (before 0-th key) in the parent */
+  if (PATH_LAST_POSITION (path) == 0 && path->pos_in_item == 0)
+    PATH_H_B_ITEM_ORDER (path, 0) = -1;
+  else {
+    if (PATH_H_PPARENT (path, 0) == 0)
+      PATH_H_B_ITEM_ORDER (path, 0) = 0;
+/*    PATH_H_B_ITEM_ORDER (path, 0) = PATH_H_PPARENT (path, 0) ? PATH_H_B_ITEM_ORDER (path, 0) : 0;*/
+  }
+
+  ih = 0;
+  body = (char *)bh;
+  memmode = 0;
+  zeros_number = 0;
+
+  do_balance (0, &tb, path->pos_in_item, ih, body, M_INTERNAL, memmode, zeros_number);
+
+  /* mark as used block itself and pointers to unformatted nodes */
+  mark_block_used (bh->b_blocknr);
+
+  /* this is for check only */
+  mark_block_formatted (bh->b_blocknr);
+  reset_nlinks (bh);
+  handle_indirect_items (bh);
+
+  /* statistic */
+  add_event (GOOD_LEAVES);
+
+}
+
+
+/* return 1 if left and right can be joined. 0 otherwise */
+int balance_condition_fails (struct buffer_head * left, struct buffer_head * right)
+{
+  if (B_FREE_SPACE (left) >= B_CHILD_SIZE (right) - 
+      (are_items_mergeable (B_N_PITEM_HEAD (left, B_NR_ITEMS (left) - 1), B_N_PITEM_HEAD (right, 0), left->b_size) ? IH_SIZE : 0))
+    return 1;
+  return 0;
+}
+
+
+/* return 1 if new can be joined with last node on the path or with
+   its right neighbor, 0 otherwise */
+int balance_condition_2_fails (struct buffer_head * new, struct path * path)
+{
+  struct buffer_head * bh;
+  struct key * right_dkey;
+  int pos, used_space;
+  struct path path_to_right_neighbor;
+
+  bh = PATH_PLAST_BUFFER (path);
+
+
+  if (balance_condition_fails (bh, new))
+    /* new node can be joined with last buffer on the path */
+    return 1;
+
+  /* new node can not be joined with its left neighbor */
+
+  right_dkey = uget_rkey (path);
+  if (right_dkey == 0)
+    /* there is no right neighbor */
+    return 0;
+  
+  pos = PATH_H_POSITION (path, 1);
+  if (pos == B_NR_ITEMS (bh = PATH_H_PBUFFER (path, 1))) {
+    /* we have to read parent of right neighbor. For simplicity we
+       call search_by_key, which will read right neighbor as well */
+    init_path (&path_to_right_neighbor);
+    if (usearch_by_key (&g_sb, right_dkey, &path_to_right_neighbor, 0, 
+			DISK_LEAF_NODE_LEVEL, 0, comp_keys) != ITEM_FOUND)
+      die ("get_right_neighbor_free_space: invalid right delimiting key");
+    used_space =  B_CHILD_SIZE (PATH_PLAST_BUFFER (&path_to_right_neighbor));
+    pathrelse (&path_to_right_neighbor);
+  }
+  else
+    used_space = B_N_CHILD (bh, pos + 1)->dc_size;
+  
+
+  if (B_FREE_SPACE (new) >= used_space - 
+      (are_items_mergeable (B_N_PITEM_HEAD (new, B_NR_ITEMS (new) - 1), (struct item_head *)right_dkey, new->b_size) ? IH_SIZE : 0))
+    return 1;
+  
+  return 0;
+}
+
+
+
+/* inserts pointer to leaf into tree if possible. If not, marks node as uninsrtable */
+static void try_to_insert_pointer_to_leaf (struct buffer_head * new_bh)
+{
+  struct path path;
+  struct buffer_head * bh;			/* last path buffer */
+  struct key * first_bh_key, last_bh_key;	/* first and last keys of new buffer */
+  struct key last_path_buffer_last_key, * right_dkey;
+  int ret_value;
+
+  path.path_length = ILLEGAL_PATH_ELEMENT_OFFSET;
+
+  if (is_block_used (new_bh->b_blocknr))
+    /* block could get into tree already if its number was used by
+       some indirect item */
+    goto cannot_insert;
+
+  first_bh_key = B_N_PKEY (new_bh, 0);
+
+  /* try to find place in the tree for the first key of the coming node */
+/*
+  if (KEY_IS_DIRECTORY_KEY (first_bh_key))
+    ret_value = search_by_entry_key (&g_sb, first_bh_key, &path);
+  else if (KEY_IS_STAT_DATA_KEY (first_bh_key)) {
+    ret_value = reiserfsck_search_by_key (&g_sb, first_bh_key, &path, comp_keys);
+    path.pos_in_item = 0;
+  } else
+    ret_value = search_by_position (&g_sb, first_bh_key, &path);
+  if (ret_value == KEY_FOUND || ret_value == ENTRY_FOUND || ret_value == BYTE_FOUND)
+    goto cannot_insert;
+*/
+  ret_value = usearch_by_key (&g_sb, first_bh_key, &path, 0, DISK_LEAF_NODE_LEVEL, READ_BLOCKS, comp_keys);
+  if (ret_value == KEY_FOUND)
+    goto cannot_insert;
+
+
+  /* get max key in the new node */
+  get_max_buffer_key (new_bh, &last_bh_key);
+  bh = PATH_PLAST_BUFFER (&path);
+  if (comp_keys ((unsigned long *)B_N_PKEY (bh, 0), (unsigned long *)&last_bh_key) == FIRST_GREATER) {
+    /* new buffer falls before the leftmost leaf */
+    if (balance_condition_fails (new_bh, bh))
+      goto cannot_insert;
+
+    if (uget_lkey (&path) != 0 || PATH_LAST_POSITION (&path) != 0)
+      die ("try_to_insert_pointer_to_leaf: bad search result");
+
+    path.pos_in_item = 0;
+    goto insert;
+  }
+
+  /* get max key of buffer, that is in tree */
+  get_max_buffer_key (bh, &last_path_buffer_last_key);
+  if (comp_keys (&last_path_buffer_last_key, first_bh_key) != SECOND_GREATER)
+    /* first key of new buffer falls in the middle of node that is in tree */
+    goto cannot_insert;
+
+  right_dkey = uget_rkey (&path);
+  if (right_dkey && comp_keys (right_dkey, &last_bh_key) != FIRST_GREATER) {
+    goto cannot_insert;
+  }
+
+  if (balance_condition_2_fails (new_bh, &path))
+    goto cannot_insert;
+
+insert:
+  insert_pointer (new_bh, &path);
+
+  goto out;
+
+cannot_insert:
+  /* statistic */
+  add_event (UNINSERTABLE_LEAVES);
+  mark_block_uninsertable (new_bh->b_blocknr);
+
+out:
+  pathrelse (&path);
+  brelse (new_bh);
+  return;
+}
+
+
+
+
+static int tree_is_empty (void)
+{
+  return (SB_ROOT_BLOCK (&g_sb) == ~0) ? 1 : 0;
+}
+
+
+static void make_single_leaf_tree (struct buffer_head * bh)
+{
+  /* tree is empty, make tree root */
+  SB_ROOT_BLOCK (&g_sb) = bh->b_blocknr;
+  SB_TREE_HEIGHT (&g_sb) = 2;
+
+  mark_block_used (bh->b_blocknr);
+
+  /* this is for check only */
+  mark_block_formatted (bh->b_blocknr);
+  
+  /* set stat data nlinks fields to 0, mark all items as unaccessed, analyse contents of indirect
+     items */
+  reset_nlinks (bh);
+  handle_indirect_items (bh);
+
+  /* statistic */
+  add_event (GOOD_LEAVES);
+
+  brelse (bh);
+}
+
+/*
+int g_found_internals, g_freed_internals, g_allocated, g_freed, g_new_internals, g_really_freed;
+*/
+
+/* reads the device by set of 8 blocks, takes leaves and tries to
+   insert them into tree */
+
+void build_the_tree (void)
+{
+    int i, j, k;
+    struct buffer_head * bbh, * bh;
+    __u32 handled_blocks = 0;
+    struct si * saved_items = 0;
+
+    if ( opt_fsck == 0 )
+	fprintf (stderr, "Pass 1 - ");
+
+    for (i = 0; i < SB_BMAP_NR (&g_sb); i ++)
+	for (j = 0; j < g_sb.s_blocksize; j ++) {
+	    /* make sure, that we are not out of the device */
+	    if (i * g_sb.s_blocksize * 8 + j * 8 == SB_BLOCK_COUNT (&g_sb))
+		goto out_of_bitmap;
+
+	    if (i * g_sb.s_blocksize * 8 + j * 8 + 8 > SB_BLOCK_COUNT (&g_sb))
+		die ("build_the_tree: Out of bitmap");
+
+	    if (SB_AP_BITMAP (&g_sb)[i]->b_data[j] == 0) {
+		/* all blocks are free */
+		if (opt_what_to_scan == SCAN_USED_PART)
+		    continue;
+	    }
+
+	    bbh = bread (g_sb.s_dev, i * g_sb.s_blocksize + j, g_sb.s_blocksize * 8);
+	    for (k = 0; k < 8; k ++) {
+		unsigned long block;
+
+		if ((SB_AP_BITMAP (&g_sb)[i]->b_data[j] & (1 << k)) == 0) {
+		    /* k-th block is free */
+		    if (opt_what_to_scan == SCAN_USED_PART)
+			continue;
+		}
+
+		if ( opt_fsck == 0 )
+		    print_how_far (&handled_blocks, g_blocks_to_read);
+
+		block = i * g_sb.s_blocksize * 8 + j * 8 + k;
+		if (not_data_block (&g_sb, block)) {
+		    /* skip not data area of the filesystem (journal,
+                       bitmaps, reserved space) */
+		    continue;
+		}
+
+		if (not_formatted_node (bbh->b_data + k * g_sb.s_blocksize, g_sb.s_blocksize))
+		    continue;
+		if (is_internal_node (bbh->b_data + k * g_sb.s_blocksize) == 1 && opt_fsck_mode == FSCK_REBUILD) {
+/*		    g_found_internals ++;*/
+		    if (!is_block_used (block)) {
+/*			g_freed_internals ++;*/
+			reiserfs_free_internal_block (&g_sb, i * g_sb.s_blocksize * 8 + j * 8 + k);
+		    } else
+			/* block is used in new tree already. There was an
+			   indirect item, pointing to it. We keep information
+			   about it for check only */
+			/*mark_formatted_pointed_by_indirect (block)*/;
+
+		    continue;
+		}
+	  
+		/* leaf node found */
+		bh = make_buffer (g_sb.s_dev, block, g_sb.s_blocksize, bbh->b_data + k * g_sb.s_blocksize);
+
+		/* */
+		if (opt_fsck_mode == FSCK_FIND_ITEM) {
+		    find_a_key (&key_to_find, bh);
+		    brelse (bh);
+		    continue;
+		}
+
+	  
+		if (is_block_used (block)) {
+		    /* block is used in new tree already. There was an indirect
+		       item, pointing to it. We keep information about it for
+		       check only */
+		    /*	  mark_formatted_pointed_by_indirect (block);*/
+
+		    add_event (LEAVES_USED_BY_INDIRECT_ITEMS);
+		    /* Rather than try to find UNP to this block we save its
+		       items and will put them into tree at the end of pass 1 */
+		    for_all_items_in_node (save_item, &saved_items, bh);
+		    brelse (bh);
+		    continue;
+		}
+
+		if (is_leaf_bad (bh)) {
+		    /* leaf is bad: directory item structure corrupted, or something else */
+		    /*	  mark_formatted_pointed_by_indirect (block);*/
+		    if (opt_verbose)
+			reiserfs_warning ("\nbuild_the_tree: bad leaf encountered: %lu\n", bh->b_blocknr);
+		    add_event (LEAVES_USED_BY_INDIRECT_ITEMS);
+		    /* Save good items only to put them into tree at the end of this pass */
+		    for_all_items_in_node (save_item, &saved_items, bh);
+		    brelse (bh);
+		    continue;
+		}
+
+		if (tree_is_empty () == 1) {
+		    make_single_leaf_tree (bh);
+		    continue;
+		}
+
+		/* if the leaf node can not be inserted into tree by pointer,
+		   we postpone its insertion at the end of the pass 1 */
+		try_to_insert_pointer_to_leaf (bh);
+
+/*
+		if (opt_check == 1)
+		    reiserfsck_check_pass1 ();
+*/
+	    }
+
+	    bforget (bbh);
+	}
+
+
+ out_of_bitmap:
+
+/*
+    check_bitmaps (&g_sb);
+
+    printf ("bitmap scanning completed: allocated %d, freed %d *really freed %d, new internals %d, found internals %d (freed %d)\n",
+	    g_allocated, g_freed, g_really_freed, g_new_internals, g_found_internals, g_freed_internals);fflush (stdout);
+*/
+
+    if (opt_fsck_mode == FSCK_FIND_ITEM)
+	return;
+
+    /* this checks what has been built (if -c option is set) */
+/*    reiserfsck_check_pass1 ();*/
+
+    /* put saved items into tree. These items were in leaves, those
+       could not be inserted into tree because some indirect items point
+       to those leaves. Rather than lookup for corresponding unfm
+       pointers in the tree, we save items of those leaves and put them
+       into tree separately */
+    if ( opt_fsck == 0 )
+	printf ("\nPass 1a - ");
+    put_saved_items_into_tree (saved_items);
+    if ( opt_fsck == 0 )
+	printf ("done\n");
+
+    /* end of pass 1 */
+    if ( opt_fsck == 0 )
+	printf ("\n");
+
+    /* this works only if -c specified  */
+    reiserfsck_check_pass1 ();
+
+
+    if (opt_stop_point == STOP_AFTER_PASS1)
+	return;
+
+    /* pass 2 */
+    take_bad_blocks_put_into_tree ();
+
+    reiserfsck_check_pass1 ();
+
+}
+
+
+
+
+
+
+
+
+
+
Index: empeg/kernel/fs/reiserfs/utils/fsck/pass2.c
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/fsck/pass2.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/fsck/pass2.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,235 @@
+/*
+ * Copyright 1996-1999 Hans Reiser
+ */
+#include "fsck.h"
+
+#include "reiserfs.h"
+
+void for_all_items_in_node (action_on_item_t action, struct si ** si, struct buffer_head * bh)
+{
+  int i;
+  struct item_head * ih;
+
+  for (i = 0, ih = B_N_PITEM_HEAD (bh, 0); i < B_NR_ITEMS (bh); i ++, ih ++)
+    action (si, ih, B_I_PITEM (bh,ih));
+#if 0
+  int j;
+
+  for (i = B_NR_ITEMS (bh) / 2, j = i + 1; ; i --, j ++) {
+    if (i >= 0) {
+      ih = B_N_PITEM_HEAD (bh, i);
+      action (si, ih, B_I_PITEM (bh,ih));
+    }
+    if (j < B_NR_ITEMS (bh)) {
+      ih = B_N_PITEM_HEAD (bh, j);
+      action (si, ih, B_I_PITEM (bh,ih));
+    }
+
+/*    check_buffer_queues ();*/
+
+    if (i <= 0 && j >= B_NR_ITEMS (bh) - 1)
+      break;
+  }
+#endif
+}
+
+
+/* insert sd item if it does not exist, overwrite it otherwise */
+static void put_sd_item_into_tree (struct item_head * comingih, char * item)
+{
+  struct item_head ih;
+  struct path path;
+  struct buffer_head * path_bh;
+  int path_item_num;
+  struct stat_data * psd;
+
+  copy_key (&(ih.ih_key), &(comingih->ih_key));
+  if (usearch_by_key (&g_sb, &(ih.ih_key), &path, 0, DISK_LEAF_NODE_LEVEL, READ_BLOCKS, comp_keys) == ITEM_FOUND) {
+    /* overwrite stat data in the tree */
+    path_bh = PATH_PLAST_BUFFER (&path);
+    path_item_num = PATH_LAST_POSITION (&path);
+    psd = B_N_STAT_DATA (path_bh, path_item_num);
+    if (psd->sd_nlink != 0)
+      die ("put_sd_item_into_tree: all stat data in the tree (at this moment) must have nllinks == 0 (not %d)",
+	   psd->sd_nlink);
+    if (psd->sd_mtime > ((struct stat_data *)item)->sd_mtime) {
+      /* new sd is newer than the found one */
+      memcpy (psd, item, SD_SIZE);
+      psd->sd_nlink = 0;
+      psd->sd_first_direct_byte = NO_BYTES_IN_DIRECT_ITEM;
+      mark_buffer_dirty (PATH_PLAST_BUFFER (&path), 0);
+    }
+    pathrelse (&path);
+  } else {
+    struct stat_data sd;
+
+    ih.ih_item_len = SD_SIZE;
+    ih.u.ih_free_space = MAX_US_INT;
+    mark_item_unaccessed (&ih);
+    memcpy (&sd, item, SD_SIZE);
+    sd.sd_nlink = 0;
+    sd.sd_first_direct_byte = NO_BYTES_IN_DIRECT_ITEM;
+    reiserfsck_insert_item (&path, &ih, (const char *)&sd);
+
+    add_event (STAT_DATA_ITEMS);
+  }
+}
+
+
+/* Keyed 32-bit hash function using TEA in a Davis-Meyer function */
+/*
+static unsigned long get_third_component (char * name, int len)
+{
+  if (!len || (len == 1 && name[0] == '.'))
+    return DOT_OFFSET;
+  if (len == 2 && name[0] == '.' && name[1] == '.')
+    return DOT_DOT_OFFSET;
+  return keyed_hash (name, len);
+}
+*/
+
+static int reiserfsck_find_entry (struct key * key, struct reiserfs_de_head * deh, struct path * path)
+{
+  struct key entry_key;
+
+  copy_key (&entry_key, key);
+  entry_key.k_offset = deh->deh_offset;
+  entry_key.k_uniqueness = DIRENTRY_UNIQUENESS;
+
+  return usearch_by_entry_key (&g_sb, &entry_key, path);
+}
+
+
+/* this tries to put each item entry to the tree, if there is no items of
+   the directory, insert item containing 1 entry */
+static void put_directory_item_into_tree (struct item_head * comingih, char * item)
+{
+  /*  struct item_head * ih;*/
+  struct reiserfs_de_head * deh;
+  int i, retval;
+  struct path path;
+  int size;
+  char * buf, * entry;
+  struct item_head tmpih;
+
+  /*ih = B_N_PITEM_HEAD (bh, item_num);*/
+  deh = (struct reiserfs_de_head *)item;/*B_I_DEH (bh, comingih);*/
+
+  for (i = 0; i < I_ENTRY_COUNT (comingih); i ++, deh ++) {
+    entry = item + deh->deh_location;
+    retval = reiserfsck_find_entry (&(comingih->ih_key), deh, &path);
+    switch (retval) {
+    case ENTRY_FOUND:
+      pathrelse (&path);
+      break;
+
+    case ENTRY_NOT_FOUND:
+      /* paste_into_item accepts entry to paste as buffer, beginning
+         with entry header and body, that follows it */
+      buf = getmem (size = I_DEH_N_ENTRY_LENGTH (comingih, deh, i) + DEH_SIZE);
+      memcpy (buf, deh, DEH_SIZE);
+      ((struct reiserfs_de_head *)buf)->deh_location = 0;
+      memcpy (buf + DEH_SIZE, entry, size - DEH_SIZE);
+
+      reiserfsck_paste_into_item (&path, buf, size);
+
+      freemem (buf);
+      break;
+
+    case DIRECTORY_NOT_FOUND:
+      buf = getmem (size = I_DEH_N_ENTRY_LENGTH (comingih, deh, i) + DEH_SIZE);
+      memcpy (buf, deh, DEH_SIZE);
+      ((struct reiserfs_de_head *)buf)->deh_location = DEH_SIZE;
+      memcpy (buf + DEH_SIZE, entry, size - DEH_SIZE);
+      copy_key (&(tmpih.ih_key), &(comingih->ih_key));
+      tmpih.ih_item_len = size;
+      tmpih.u.ih_entry_count = 1;
+      mark_item_unaccessed (&tmpih);
+      
+      reiserfsck_insert_item (&path, &tmpih, buf);
+
+      freemem (buf);
+      break;
+
+    case REGULAR_FILE_FOUND:
+      /* this should never happen. */
+      goto end;
+    }
+
+    /*&&&&&&&&&&&&&&&&&*/
+/*    reiserfsck_check_pass1 ();*/
+    /*&&&&&&&&&&&&&&&&&*/
+  }
+ end:
+
+}
+
+
+/* If item is item of regular file (direct or indirect item) - this
+   file is in tree (with first byte) - write to it. If this file is in
+   tree (without first byte) - delete what we have in tree, create
+   file again keeping what we already had in tree this file is not in
+   tree - create hole at the beginning of file if necessary and write
+   to file */
+void put_regular_file_item_into_tree (struct item_head * ih, char * item)
+{
+  reiserfsck_file_write (ih, item);
+}
+
+
+void insert_item_separately (struct si ** si, struct item_head * ih, char * item)
+{
+  if (I_IS_STAT_DATA_ITEM (ih)) {
+    put_sd_item_into_tree (ih, item);
+  } else if (I_IS_DIRECTORY_ITEM (ih)) {
+    put_directory_item_into_tree (ih, item);
+  } else {
+    put_regular_file_item_into_tree (ih, item);
+  }
+
+  
+}
+
+
+/* uninsertable blocks are marked by 0s in
+   g_uninsertable_leaf_bitmap during the pass 1. They still must be not in the tree */
+void take_bad_blocks_put_into_tree (void)
+{
+  struct buffer_head * bh;
+  int i, j;
+  __u32 bb_counter = 0;
+
+  if ( opt_fsck == 0 )
+    fprintf (stderr, "Pass 2 - ");
+
+
+  for (i = 0; i < SB_BMAP_NR (&g_sb); i ++) {
+    j = find_first_zero_bit (g_uninsertable_leaf_bitmap[i], g_sb.s_blocksize * 8);
+    while (j < g_sb.s_blocksize * 8) {
+      bh = bread (g_sb.s_dev, i * g_sb.s_blocksize * 8 + j, g_sb.s_blocksize);
+
+      if (is_block_used (bh->b_blocknr))
+	die ("take_bad_blocks_put_into_tree: block %d can not be in tree", bh->b_blocknr);
+      /* this must be leaf */
+      if (not_formatted_node (bh->b_data, g_sb.s_blocksize) || is_internal_node (bh->b_data)) {
+	reiserfs_panic (0, "take_bad_blocks_put_into_tree: buffer (%b %z) must contain leaf", bh, bh);
+      }
+
+      for_all_items_in_node (insert_item_separately, 0, bh);
+
+      if ( opt_fsck == 0 )
+	print_how_far (&bb_counter, get_event (UNINSERTABLE_LEAVES));
+
+      brelse (bh);
+
+      j = find_next_zero_bit (g_uninsertable_leaf_bitmap[i], g_sb.s_blocksize * 8, j + 1);
+    }
+  }
+
+  if (bb_counter != get_event (UNINSERTABLE_LEAVES))
+    die ("take_bad_blocks_put_into_tree: found bad block %d, must be %d", 
+	 bb_counter, get_event (UNINSERTABLE_LEAVES));
+
+  if ( opt_fsck == 0 )
+    printf ("\n");
+}
Index: empeg/kernel/fs/reiserfs/utils/fsck/pass4.c
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/fsck/pass4.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/fsck/pass4.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,92 @@
+/*
+ * Copyright 1996, 1997, 1998 Hans Reiser
+ */
+#include "fsck.h"
+
+
+static void get_next_key (struct path * path, int i, struct key * key)
+{
+    struct buffer_head * bh = PATH_PLAST_BUFFER (path);
+    struct key maxkey = {0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff};
+    struct key * rkey;
+
+    if (i < B_NR_ITEMS (bh) - 1) {
+	copy_key (key, B_N_PKEY (bh, i + 1));
+	return;
+    }
+
+    rkey = uget_rkey (path);
+    if (rkey) {
+	copy_key (key, rkey);
+	if (comp_keys (key, B_PRIGHT_DELIM_KEY (bh)) != KEYS_IDENTICAL) {
+	    add_event (FIXED_RIGHT_DELIM_KEY);
+	    copy_key (B_PRIGHT_DELIM_KEY (bh), key);
+	    mark_buffer_dirty (bh, 0);
+	}
+    } else {
+	if (comp_keys (&maxkey, B_PRIGHT_DELIM_KEY (bh)) != KEYS_IDENTICAL) {
+	    /*printf ("get_next_key: Hmm, max key not found in the tree\n");*/
+	    copy_key (B_PRIGHT_DELIM_KEY (bh), &maxkey);
+	    mark_buffer_dirty (bh, 0);
+	}
+	copy_key (key, &maxkey);
+    }
+}
+
+/* this is pass 4 */
+int check_unaccessed_items (void)
+{
+    struct key key;
+    struct path path;
+    int i;
+    struct buffer_head * bh;
+    struct item_head * ih;
+    __u32 passed = 0;
+
+    if (opt_stop_point != STOP_DEFAULT)
+	return 0;
+
+    path.path_length = ILLEGAL_PATH_ELEMENT_OFFSET;
+    copy_key (&key, &g_root_directory_key);
+
+    if ( opt_fsck == 0 )
+	fprintf (stderr, "Pass 4 - ");
+
+    while (/*reiserfsck_*/usearch_by_key (&g_sb, &key, &path, 0, DISK_LEAF_NODE_LEVEL, READ_BLOCKS, comp_keys) == ITEM_FOUND) {
+	bh = PATH_PLAST_BUFFER (&path);
+	for (i = PATH_LAST_POSITION (&path), ih = PATH_PITEM_HEAD (&path); i < B_NR_ITEMS (bh); i ++, ih ++) {
+	    if (is_item_accessed (ih) == 0) {
+
+		get_next_key (&path, i, &key);
+
+		add_event (UNACCESSED_ITEMS);
+		if (I_IS_STAT_DATA_ITEM (ih))
+		    g_fsck_info.fs_stat_data_items --;
+	
+		PATH_LAST_POSITION (&path) = i;
+		reiserfsck_delete_item (&path);
+
+		goto cont;
+	    }
+	    if ((I_IS_STAT_DATA_ITEM (ih)) && opt_fsck == 0) {
+		print_how_far (&passed, get_event (STAT_DATA_ITEMS));
+	    }
+	}
+	get_next_key (&path, i - 1, &key);
+	pathrelse (&path);
+
+/*fu_check ();*/
+
+    cont:
+    }
+    if (key.k_dir_id != MAX_UL_INT || key.k_objectid != MAX_UL_INT ||
+	key.k_offset != MAX_UL_INT || key.k_uniqueness != MAX_UL_INT) {
+	reiserfs_panic (0, "check_unaccessed_items: invalid exit key %k", &key);
+    }
+    pathrelse (&path);
+
+    if ( opt_fsck == 0 )
+	printf ("\n");
+
+    return 0;
+}
Index: empeg/kernel/fs/reiserfs/utils/fsck/reiserfsck.8
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/fsck/reiserfsck.8:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/fsck/reiserfsck.8	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,60 @@
+.\" -*- nroff -*-
+.\" Copyright 1996, 1997 Hans Reiser.
+.\" 
+.TH REISERFSCK 8 "February 1999" "Reiserfs utilities"
+.SH NAME
+reiserfsck \- check a Linux Reiserfs file system
+.SH SYNOPSIS
+.B reiserfsck
+[
+.B \-aprvfy
+]
+.I device
+.SH DESCRIPTION
+.B reiserfsck
+is used to perform a consistency check for the Linux Reiserfs file
+system.
+.TP
+.I device
+is the special file corresponding to the device (e.g /dev/hdXX for
+IDE disk partition or /dev/sdXX for SCSI disk partition).
+.SH OPTIONS
+.TP
+.I -a 
+This is provided for backwards compatibility only. It does the same
+thing as the
+.I -p
+option described below; it is recommended to use
+.I -p 
+option when possible.
+.TP
+.I -f
+Force checking even if the file system seems clean.
+.TP
+.I -p
+Automatically repair ("preen") the file system without any questions.
+.TP
+.I -r
+This option does nothing at all; it is provided only for backwards
+compatibility.
+.TP
+.I -v
+Verbose mode.
+.TP
+.I -y
+Assume an answer of ``yes'' to all questions; allows 
+.B reiserfsck
+to be used non-interactively.
+.\" .SH AUTHOR
+.\" This version of
+.\" .B reiserfsck
+.\" has been written by Hans Reiser <reiser@idiom.com>.
+.SH BUGS
+Not known yet.
+Please, report bugs to Hans Reiser <reiser@idiom.com>.
+.SH AVAILABILITY
+.B reiserfsck
+sources are available for anonymous ftp from namesys.botik.ru
+in /pub/linux+reiserfs/reiserfs-utils.tgz
+.SH SEE ALSO
+.BR mkreiserfs (8)
Index: empeg/kernel/fs/reiserfs/utils/fsck/segments.c
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/fsck/segments.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/fsck/segments.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,223 @@
+/*
+ * Copyright 1998 Hans Reiser
+ */
+/*#include <stdio.h>
+#include <string.h>*/
+/*#include <asm/bitops.h>
+#include "../include/reiserfs_fs.h"
+#include "../include/reiserfs_fs_sb.h"
+#include "../include/reiserfslib.h"*/
+#include "fsck.h"
+
+
+/* there is a situation, when we overwrite contents of unformatted
+   node with direct item. One unformatted node can be overwritten
+   several times by direct items */
+/*
+struct overwritten_unfm_segment {
+  int ous_begin;
+  int ous_end;
+  struct overwritten_unfm_segment * ous_next;  
+};
+*/
+struct overwritten_unfm {
+  unsigned long ou_unfm_ptr;	/* block number of unfm node */
+  unsigned long ou_dir_id;
+  unsigned long ou_objectid; 	/* key corresponding to an unfm node */
+  unsigned long ou_offset;
+
+  struct overwritten_unfm_segment * ou_segments;	/* list of segmens, than have been overwritten in ths unfm node */
+};
+
+struct overwritten_unfm ** g_overwritten_unfms;
+int g_overwritten_unfms_amount;	/* number of unformatted nodes, which contain direct items */
+
+
+/* adds segment to the single linked list of segments sorted by begin
+   field. Retuns pointer to first element of list */
+static struct overwritten_unfm_segment * add_segment (struct overwritten_unfm_segment * first, int begin, int end)
+{
+  struct overwritten_unfm_segment * new, * next, * prev;
+
+  new = getmem (sizeof (struct overwritten_unfm_segment));
+  new->ous_begin = begin;
+  new->ous_end = end;
+  new->ous_next = 0;
+
+  next = first;
+  prev = 0;
+  while (next) {
+    if (next->ous_begin > begin)
+      break;
+    prev = next;
+    next = next->ous_next;
+  }
+
+  if (prev == 0) {
+    /* insert into head of list */
+    first = new;
+  } else {
+    prev->ous_next = new;
+  }
+  new->ous_next = next;
+  return first;
+}
+
+
+/* input parameter 
+   `list_head` - first element of overlapping segments sorted by left edge
+   `unoverwritten_segment` - returned by previous call of get_unoverwritten_segment or (-2,-2) if called first time
+   */
+/* returns
+   1 and segment unoverwritten by elements of list `list_head`
+   0 if there isno such segment
+   */
+int get_unoverwritten_segment (struct overwritten_unfm_segment * list_head, struct overwritten_unfm_segment * unoverwritten_segment)
+{
+  int end;
+
+  /* look for segment, which has begin field greater than end of previous interval */
+  while (list_head->ous_begin <= unoverwritten_segment->ous_end) {
+    list_head = list_head->ous_next;
+  }
+  /* look for the end of the continuous region covered by otrezkami */
+  end = list_head->ous_end;
+  while (list_head->ous_next) {
+    if (list_head->ous_next->ous_begin > end + 1)
+      /* intreval found */
+      break;
+    if (list_head->ous_next->ous_end > end)
+      end = list_head->ous_next->ous_end;
+    list_head = list_head->ous_next;
+  }
+  /* ok, between segment and segment->next we have an interval (segment->next != 0) */
+  if (list_head->ous_next != 0) {
+    unoverwritten_segment->ous_begin = end + 1;
+    unoverwritten_segment->ous_end = list_head->ous_next->ous_begin - 1;
+    return 1;
+  }
+  return 0;
+}
+
+
+void print_segments (struct overwritten_unfm_segment * list_head)
+{
+  struct overwritten_unfm_segment * cur;
+
+  cur = list_head;
+  while (cur) {
+    printf ("%s%d %d%s", cur == list_head ? "(" : "", cur->ous_begin, cur->ous_end, cur->ous_next ? ", " : ")\n");
+    cur = cur->ous_next;
+  }
+}
+
+
+/* this prepare list of segments to extracting of unoverwritten segments */
+struct overwritten_unfm_segment * find_overwritten_unfm (unsigned long unfm, int length, struct overwritten_unfm_segment * segment_to_init)
+{
+  int i;
+
+  for (i = 0; i < g_overwritten_unfms_amount && g_overwritten_unfms[i] != 0; i ++)
+    if (g_overwritten_unfms[i]->ou_unfm_ptr == unfm) {
+      if (g_overwritten_unfms[i]->ou_segments == 0)
+	die ("find_overwritten_unfm: no segment found");
+      g_overwritten_unfms[i]->ou_segments = add_segment (g_overwritten_unfms[i]->ou_segments, -1, -1);
+      add_segment (g_overwritten_unfms[i]->ou_segments, length, length);
+      segment_to_init->ous_begin = -2;
+      segment_to_init->ous_end = -2;
+      return g_overwritten_unfms[i]->ou_segments;
+    }
+  return 0;
+}
+
+struct overwritten_unfm * look_for_overwritten_unfm (__u32 unfm)
+{
+  int i;
+
+  for (i = 0; i < g_overwritten_unfms_amount && g_overwritten_unfms[i] != 0; i ++)
+    if (g_overwritten_unfms[i]->ou_unfm_ptr == unfm)
+      return g_overwritten_unfms[i];
+    return 0;
+}
+
+#define GROW_BY 10
+struct overwritten_unfm * add_overwritten_unfm (unsigned long unfm, struct item_head * direct_ih)
+{
+  int i;
+
+  for (i = 0; i < g_overwritten_unfms_amount && g_overwritten_unfms[i] != 0; i ++) {
+    if (g_overwritten_unfms[i]->ou_unfm_ptr == unfm)
+      return g_overwritten_unfms[i];
+  }
+
+  if (i == g_overwritten_unfms_amount) {
+    g_overwritten_unfms = expandmem (g_overwritten_unfms, sizeof (struct overwritten_unfm *) * i, 
+				     sizeof (struct overwritten_unfm *) * GROW_BY);
+    g_overwritten_unfms_amount += GROW_BY;
+  }
+  g_overwritten_unfms[i] = getmem (sizeof (struct overwritten_unfm));
+  g_overwritten_unfms[i]->ou_unfm_ptr = unfm;
+  g_overwritten_unfms[i]->ou_dir_id = direct_ih->ih_key.k_dir_id;
+  g_overwritten_unfms[i]->ou_objectid = direct_ih->ih_key.k_objectid;
+  g_overwritten_unfms[i]->ou_offset = direct_ih->ih_key.k_offset - (direct_ih->ih_key.k_offset - 1) % g_sb.s_blocksize;
+  return g_overwritten_unfms[i];
+}
+
+
+void save_unfm_overwriting (unsigned long unfm, struct item_head * direct_ih)
+{
+  struct overwritten_unfm * ov_unfm;
+
+  /* add new overwritten unfm or return existing one */
+  ov_unfm = add_overwritten_unfm (unfm, direct_ih);
+  ov_unfm->ou_segments = add_segment (ov_unfm->ou_segments, (direct_ih->ih_key.k_offset - 1) % g_sb.s_blocksize,
+				      (direct_ih->ih_key.k_offset - 1) % g_sb.s_blocksize + direct_ih->ih_item_len - 1);
+}
+
+
+void free_overwritten_unfms (void)
+{
+  int i;
+
+  for (i = 0; i < g_overwritten_unfms_amount && g_overwritten_unfms[i]; i ++) {
+    /* free all segments */
+    while (g_overwritten_unfms[i]->ou_segments) {
+      struct overwritten_unfm_segment * tmp;
+
+      tmp = g_overwritten_unfms[i]->ou_segments->ous_next;
+      freemem (g_overwritten_unfms[i]->ou_segments);
+      g_overwritten_unfms[i]->ou_segments = tmp;
+    }
+    /* free struct overwritten_unfm */
+    freemem (g_overwritten_unfms[i]);
+  }
+
+  /* free array of pointers to overwritten unfms */
+  if (g_overwritten_unfms)
+    freemem (g_overwritten_unfms);
+}
+
+#if 0
+static int formatted_pointed_by_indirect;
+static __u32 * stored;
+static int length;
+void mark_formatted_pointed_by_indirect (__u32 block)
+{
+  if (stored == 0 || length == formatted_pointed_by_indirect) {
+    stored = expandmem (stored, sizeof (__u32) * length, sizeof (__u32) * 1000);
+    length += 1000;
+  }
+  stored [formatted_pointed_by_indirect ++] = block;
+}
+
+int is_formatted_pointed_by_indirect (__u32 block)
+{
+  int i;
+
+  for (i = 0; i < formatted_pointed_by_indirect; i ++)
+    if (stored [i] == block)
+      return 1;
+
+  return 0;
+}
+#endif
Index: empeg/kernel/fs/reiserfs/utils/fsck/semantic.c
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/fsck/semantic.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/fsck/semantic.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,460 @@
+/*
+ * Copyright 1996-1999 Hans Reiser
+ */
+#include "fsck.h"
+#include <time.h>
+
+
+
+
+/* path is path to stat data */
+static void check_regular_file (struct path * path, struct stat_data * sd)
+{
+    int mark_passed_items;
+    struct key key;
+    unsigned long size;
+    struct buffer_head * bh = PATH_PLAST_BUFFER (path);/* contains stat data */
+    struct item_head * ih = PATH_PITEM_HEAD (path);/* stat data item */
+
+    if (sd->sd_nlink == 0) {
+
+/*    print_how_far (&stat_datas, get_event (STAT_DATA_ITEMS));*/
+	if ((sd->sd_mode & S_IFMT) == S_IFREG)
+	    add_event (REGULAR_FILES);
+	else if ((sd->sd_mode & S_IFMT) == S_IFLNK)
+	    add_event (SYMLINKS);
+	else
+	    add_event (OTHERS);
+	sd->sd_nlink ++;
+	mark_item_accessed (ih, bh);
+	mark_objectid_as_used (ih->ih_key.k_objectid);
+
+	copy_key (&key, &(ih->ih_key));
+	if (are_file_items_correct (&key, &size, mark_passed_items = 1, path, &sd) != 1) {
+	    /* unpassed items will be deleted in pass 4 as they left unaccessed */
+	    add_event (INCORRECT_REGULAR_FILES);
+	}
+	/* are_file_items_correct could perform indirect_to_direct, bh could be changed */
+	bh = PATH_PLAST_BUFFER (path);
+	/* set correct size */
+	if (sd->sd_size != size) {
+	    add_event (FIXED_SIZE_FILES);
+	    sd->sd_size = size;
+	    mark_buffer_dirty (bh, 0);
+	}
+	/* set first direct byte field of stat data (if it is set incorrect) */
+	if (size == 0 || KEY_IS_INDIRECT_KEY(&key)) {
+	    /* there are no direct items in file */
+	    if (sd->sd_first_direct_byte != NO_BYTES_IN_DIRECT_ITEM) {
+		sd->sd_first_direct_byte = NO_BYTES_IN_DIRECT_ITEM;
+		mark_buffer_dirty (bh, 0);
+	    }
+	} else {
+	    /* there is at least one direct item */
+	    if (sd->sd_first_direct_byte != key.k_offset - (key.k_offset % g_sb.s_blocksize - 1)) {
+		sd->sd_first_direct_byte = key.k_offset - (key.k_offset % g_sb.s_blocksize - 1);
+		mark_buffer_dirty (bh, 0);
+	    }
+	}
+    } else {
+	if (is_item_accessed (ih) == 0)
+	    die ("check_regular_file: stat data item must be accessed");
+	sd->sd_nlink ++;
+	mark_buffer_dirty (bh, 0);
+    }
+}
+
+
+static int is_rootdir_key (struct key * key)
+{
+    if (comp_keys (key, &root_key))
+	return 0;
+    return 1;
+}
+
+static int is_rootdir_entry_key (struct key * key)
+{
+    if (comp_short_keys (key, &root_key))
+	return 0;
+    return 1;
+}
+
+
+/* when root direcotry can not be found */
+static void create_root_directory (struct path * path)
+{
+    struct item_head ih;
+    struct stat_data sd;
+
+    /* insert stat data item */
+    copy_key (&(ih.ih_key), &root_key);
+    ih.ih_item_len = SD_SIZE;
+    ih.u.ih_free_space = MAX_US_INT;
+    mark_item_unaccessed (&ih);
+
+    sd.sd_mode = S_IFDIR + 0755;
+    sd.sd_nlink = 0;
+    sd.sd_uid = 0;
+    sd.sd_gid = 0;
+    sd.sd_size = EMPTY_DIR_SIZE;
+    sd.sd_atime = sd.sd_ctime = sd.sd_mtime = time (NULL);
+    sd.u.sd_blocks = 0;
+    sd.sd_first_direct_byte = MAX_UL_INT;
+  
+    reiserfsck_insert_item (path, &ih, (char *)(&sd));
+}
+
+
+static void paste_dot_and_dot_dot (struct path * path)
+{
+    char dir[EMPTY_DIR_SIZE];
+    struct reiserfs_de_head * deh;
+    struct key key;
+  
+    copy_key (&key, &root_key);
+
+    deh = (struct reiserfs_de_head *)dir;
+    deh[0].deh_offset = DOT_OFFSET;
+    deh[0].deh_dir_id = root_key.k_dir_id;
+    deh[0].deh_objectid = root_key.k_objectid;
+    deh[0].deh_state = 0;
+    set_bit (DEH_Visible, &(deh[0].deh_state));
+    dir[DEH_SIZE] = '.';
+    reiserfsck_paste_into_item (path, dir, DEH_SIZE + 1);
+
+    key.k_offset = DOT_DOT_OFFSET;
+    key.k_uniqueness = DIRENTRY_UNIQUENESS;
+    if (usearch_by_entry_key (&g_sb, &key, path) == ENTRY_FOUND) {
+	reiserfs_warning ("paste_dot_and_dot_dot: \"..\" found\n");
+	pathrelse (path);
+	return;
+    }
+    deh[0].deh_offset = DOT_DOT_OFFSET;
+    deh[0].deh_dir_id = 0;
+    deh[0].deh_objectid = root_key.k_dir_id;
+    deh[0].deh_state = 0;
+    set_bit (DEH_Visible, &(deh[0].deh_state));
+    dir[DEH_SIZE] = '.';
+    dir[DEH_SIZE + 1] = '.';
+
+    reiserfsck_paste_into_item (path, dir, DEH_SIZE + 2);
+}
+
+
+static void insert_dot_and_dot_dot (struct path * path)
+{
+    struct item_head ih;
+    char dir[EMPTY_DIR_SIZE];
+    struct reiserfs_de_head * deh;
+   
+    copy_key (&(ih.ih_key), &root_key);
+    ih.ih_key.k_offset = DOT_OFFSET;
+    ih.ih_key.k_uniqueness = DIRENTRY_UNIQUENESS;
+    ih.ih_item_len = EMPTY_DIR_SIZE;
+    ih.u.ih_entry_count = 2;
+    mark_item_unaccessed (&ih);
+
+    deh = (struct reiserfs_de_head *)dir;
+    deh[0].deh_offset = DOT_OFFSET;
+    deh[0].deh_dir_id = root_key.k_dir_id;
+    deh[0].deh_objectid = root_key.k_objectid;
+    deh[0].deh_location = ih.ih_item_len - strlen (".");
+    deh[0].deh_state = 0;
+    set_bit (DEH_Visible, &(deh[0].deh_state));
+
+    deh[1].deh_offset = DOT_DOT_OFFSET;
+    deh[1].deh_dir_id = 0;
+    deh[1].deh_objectid = root_key.k_dir_id;
+    deh[1].deh_location = deh[0].deh_location - strlen ("..");
+    deh[1].deh_state = 0;
+    set_bit (DEH_Visible, &(deh[1].deh_state));
+    dir[DEH_SIZE * 2] = '.';
+    dir[DEH_SIZE * 2 + 1] = '.';
+    dir[DEH_SIZE * 2 + 2] = '.';
+
+    reiserfsck_insert_item (path, &ih, dir);
+}
+
+
+/* returns buffer, containing found directory item.*/
+char * get_next_directory_item (struct path * path, struct key * key, struct key * parent, struct item_head * ih)
+{
+    char * dir_item;
+    struct key * rdkey;
+    struct buffer_head * bh;
+    struct reiserfs_de_head * deh;
+    int i;
+    int retval;
+
+    if ((retval = usearch_by_entry_key (&g_sb, key, path)) != ENTRY_FOUND) {
+	if (key->k_offset != DOT_OFFSET)
+	    die ("get_next_directory_item: entry not found");
+
+	/* first directory item not found */
+	if (is_rootdir_entry_key (key)) {
+	    /* add "." and ".." to the root directory */
+	    if (retval == ENTRY_NOT_FOUND)
+		paste_dot_and_dot_dot (path);
+	    else if (retval == DIRECTORY_NOT_FOUND)
+		insert_dot_and_dot_dot (path);
+	    else
+		die ("get_next_directory_item: invalid return value");
+	    usearch_by_entry_key (&g_sb, key, path);
+	} else {
+	    /* it is ok for directories but the root one that "." is not found */
+	    pathrelse (path);
+	    return 0;
+	}
+    }
+    /* leaf containing directory item */
+    bh = PATH_PLAST_BUFFER (path);
+
+    memcpy (ih, PATH_PITEM_HEAD (path), IH_SIZE);
+
+    /* make sure, that ".." exists as well */
+    if (key->k_offset == DOT_OFFSET) {
+	if (I_ENTRY_COUNT (ih) < 2) {
+	    pathrelse (path);
+	    return 0;
+	}
+	deh = B_I_DEH (bh, ih) + 1;
+	if (I_DEH_N_ENTRY_FILE_NAME_LENGTH (ih, deh, 1) != strlen ("..") ||
+	    memcmp ("..", B_I_E_NAME (1, bh, ih), 2)) {
+	    printf ("******get_next_directory_item: \"..\" not found***********\n");
+	    pathrelse (path);
+	    return 0;
+	}
+    }
+
+    deh = B_I_DEH (bh, ih);
+
+    /* mark hidden entries as visible, reset ".." correctly */
+    for (i = 0; i < I_ENTRY_COUNT (ih); i ++, deh ++) {
+	if (de_hidden (deh)) {
+	    if (opt_verbose)
+		reiserfs_warning ("\nget_next_directory_item: hidden entry %d\n", i);
+
+	    mark_de_visible (deh);
+	    mark_buffer_dirty (bh, 0);
+	}
+	if (deh->deh_offset == DOT_DOT_OFFSET) {
+	    /* set ".." so that it points to the correct parent directory */
+	    if (comp_short_keys (&(deh->deh_dir_id), parent) && 
+		deh->deh_objectid != REISERFS_ROOT_PARENT_OBJECTID) {
+		if (opt_verbose)
+		    reiserfs_warning ("\nget_next_directory_item: \"..\" fixed\n");
+		deh->deh_dir_id = key->k_dir_id;
+		deh->deh_objectid = key->k_objectid;
+		mark_buffer_dirty (bh, 0);
+	    }
+	}
+    }
+
+    /* copy directory item to the temporary buffer */
+    dir_item = getmem (ih->ih_item_len); 
+    memcpy (dir_item, B_I_PITEM (bh, ih), ih->ih_item_len);
+
+    /* next item key */
+    if (PATH_LAST_POSITION (path) == (B_NR_ITEMS (PATH_PLAST_BUFFER (path)) - 1) &&
+	(rdkey = uget_rkey (path)))
+	copy_key (key, rdkey);
+    else {
+	key->k_dir_id = 0;
+	key->k_objectid = 0;
+    }
+
+    mark_item_accessed (PATH_PITEM_HEAD (path), PATH_PLAST_BUFFER (path));
+    return dir_item;
+}
+
+
+static void get_object_key (struct reiserfs_de_head * deh, struct key * key, struct key * entry_key, struct item_head * ih)
+{
+    key->k_dir_id = deh->deh_dir_id;
+    key->k_objectid = deh->deh_objectid;
+    key->k_offset = SD_OFFSET;
+    key->k_uniqueness = SD_UNIQUENESS;
+
+    entry_key->k_dir_id = ih->ih_key.k_dir_id;
+    entry_key->k_objectid = ih->ih_key.k_objectid;
+    entry_key->k_offset = deh->deh_offset;
+    entry_key->k_uniqueness = DIRENTRY_UNIQUENESS;
+}
+
+
+static void reiserfsck_cut_entry (struct key * key)
+{
+    struct path path;
+
+    if (usearch_by_entry_key (&g_sb, key, &path) != ENTRY_FOUND || key->k_offset == DOT_OFFSET)
+	die ("reiserfsck_cut_entry: entry not found");
+
+    if (I_ENTRY_COUNT (PATH_PITEM_HEAD (&path)) == 1)
+	reiserfsck_delete_item (&path);
+    else {
+	struct reiserfs_de_head * deh = B_I_DEH (PATH_PLAST_BUFFER (&path), PATH_PITEM_HEAD (&path)) + path.pos_in_item;
+	reiserfsck_cut_from_item (&path, -(DEH_SIZE + I_DEH_N_ENTRY_LENGTH (PATH_PITEM_HEAD (&path), deh, path.pos_in_item)));
+    }
+}
+
+
+
+/* check recursively the semantic tree. Returns 0 if entry points to
+   good object, and -1 or -2 if this entry must be deleted (stat data
+   not found or directory does have any items).  Hard links are not
+   allowed, but if directory rename has been interrupted by the system
+   crash, it is possible, that fsck will find two entries (not "..") 
+   pointing to the same directory. In this case fsck keeps only the
+   first one. */
+#define OK 0
+#define STAT_DATA_NOT_FOUND -1
+#define DIRECTORY_HAS_NO_ITEMS -2
+
+static __u32 stat_datas = 0;
+
+
+
+int check_semantic_tree (struct key * key, struct key * parent, int is_dot_dot)
+{
+    struct path path;
+    struct stat_data * sd;
+
+    if (!KEY_IS_STAT_DATA_KEY (key))
+	die ("check_semantic_tree: key must be key of a stat data");
+
+    /* look for stat data of an object */
+    if (usearch_by_key (&g_sb, key, &path, 0, DISK_LEAF_NODE_LEVEL, READ_BLOCKS, comp_keys) == ITEM_NOT_FOUND) {
+	if (is_rootdir_key (key)) {
+	    /* stat data of the root directory not found. Make it */
+	    create_root_directory (&path);
+	    usearch_by_key (&g_sb, key, &path, 0, DISK_LEAF_NODE_LEVEL, READ_BLOCKS, comp_keys);
+	} else {
+	    pathrelse (&path);
+	    return STAT_DATA_NOT_FOUND;
+	}
+    }
+
+    sd = B_N_STAT_DATA (PATH_PLAST_BUFFER (&path), PATH_LAST_POSITION (&path));
+    if ((sd->sd_nlink == 0) && ( opt_fsck == 0 ))
+	print_how_far (&stat_datas, get_event (STAT_DATA_ITEMS));
+
+    if ((sd->sd_mode & S_IFMT) != S_IFDIR) {
+	/* object is not a directory (regular, symlink, device file) */
+	/*if ((sd->sd_mode & S_IFMT) == S_IFLNK)
+	  printf ("Symlink found\n");*/
+
+	check_regular_file (&path, sd);
+	pathrelse (&path);
+	return OK;
+    }
+
+    /* object is directory */
+    sd->sd_nlink ++;
+    mark_buffer_dirty (PATH_PLAST_BUFFER (&path), 0);
+    if (sd->sd_nlink == 1) {
+	char * dir_item;
+	struct item_head ih;
+	struct key item_key, entry_key, object_key;
+	unsigned long dir_size = 0;
+
+	/*print_how_far (&stat_datas, get_event (STAT_DATA_ITEMS));*/
+
+	if (key->k_objectid == REISERFS_ROOT_OBJECTID)
+	    sd->sd_nlink ++;
+
+	add_event (DIRECTORIES);
+	copy_key (&item_key, key);
+	item_key.k_offset = DOT_OFFSET;
+	item_key.k_uniqueness = DIRENTRY_UNIQUENESS;
+	pathrelse (&path);
+	while ((dir_item = get_next_directory_item (&path, &item_key, parent, &ih)) != 0) {
+	    /* dir_item is copy of the item in separately allocated memory */
+	    int i;
+	    int retval;
+	    struct reiserfs_de_head * deh = (struct reiserfs_de_head *)dir_item + path.pos_in_item;
+
+/*&&&&&&&&&&&&&&&*/
+	    if (dir_size == 0) {
+		if (deh->deh_offset != DOT_OFFSET || (deh + 1)->deh_offset != DOT_DOT_OFFSET)
+		    die ("check_semantic_tree: Directory without \".\" or \"..\"");
+	    }
+/*&&&&&&&&&&&&&&&*/
+
+	    for (i = path.pos_in_item; i < I_ENTRY_COUNT (&ih); i ++, deh ++) {
+		get_object_key (deh, &object_key, &entry_key, &ih);
+		retval = check_semantic_tree (&object_key, key,
+					      (deh->deh_offset == DOT_OFFSET ||deh->deh_offset == DOT_DOT_OFFSET) ? 1 : 0);
+		if (retval != OK) {
+		    if (entry_key.k_offset == DOT_DOT_OFFSET && object_key.k_objectid == REISERFS_ROOT_PARENT_OBJECTID) {
+			/* ".." of root directory can not be found */
+			if (retval != STAT_DATA_NOT_FOUND)
+			    die ("check_semantic_tree: stat data of parent directory of root directory found");
+			dir_size += DEH_SIZE + strlen ("..");
+			continue;
+		    }
+		    add_event (DELETED_ENTRIES);
+		    reiserfsck_cut_entry (&entry_key);
+		} else {
+		    /* OK */
+		    dir_size += DEH_SIZE + I_DEH_N_ENTRY_LENGTH (&ih, deh, i);
+		}
+	    }
+
+	    freemem (dir_item);
+
+	    if (comp_short_keys (&item_key, key) != KEYS_IDENTICAL) {
+		pathrelse (&path);
+		break;
+	    }
+	    pathrelse (&path);
+	}
+
+	if (dir_size == 0)
+	    return DIRECTORY_HAS_NO_ITEMS;
+
+	if (usearch_by_key (&g_sb, key, &path, 0, DISK_LEAF_NODE_LEVEL, READ_BLOCKS, comp_keys) != ITEM_FOUND)
+	    die ("check_semantic_tree: stat data not found");
+
+	mark_objectid_as_used (PATH_PITEM_HEAD (&path)->ih_key.k_objectid);
+
+	if (dir_size != (sd = B_N_STAT_DATA (PATH_PLAST_BUFFER (&path), PATH_LAST_POSITION (&path)))->sd_size) {
+	    add_event (FIXED_SIZE_DIRECTORIES);
+	    sd->sd_size = dir_size;
+	}
+	/* stat data of a directory is accessed */
+	mark_item_accessed (PATH_PITEM_HEAD (&path), PATH_PLAST_BUFFER (&path));
+    } else {
+	/* we have accessed directory stat data not for the first time. we
+	   can come here only from "." or "..". Other names must be removed
+	   to avoid creation of hard links */
+	if (!is_dot_dot) {
+	    sd->sd_nlink --;
+	    if (opt_verbose)
+		reiserfs_warning ("\ncheck_semantic_tree: more than one name (neither \".\" nor \"..\") of a directory. Removed\n");
+	    pathrelse (&path);
+	    return STAT_DATA_NOT_FOUND;
+	}
+    }
+    pathrelse (&path);
+
+
+    return OK;
+}
+
+
+struct key g_root_directory_key = {REISERFS_ROOT_PARENT_OBJECTID, REISERFS_ROOT_OBJECTID, 0, 0};
+struct key g_parent_root_directory_key = {0, REISERFS_ROOT_PARENT_OBJECTID, 0, 0};
+
+void semantic_pass (void)
+{
+    if (opt_stop_point == STOP_AFTER_PASS1 || opt_stop_point == STOP_AFTER_PASS2)
+	return;
+
+    if ( opt_fsck == 0 )
+	fprintf (stderr, "Pass 3 (semantic) - ");
+    check_semantic_tree (&g_root_directory_key, &g_parent_root_directory_key, 0);
+    if ( opt_fsck == 0 )
+	printf ("\n");
+}
+
+
Index: empeg/kernel/fs/reiserfs/utils/fsck/ubitmap.c
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/fsck/ubitmap.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/fsck/ubitmap.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,453 @@
+/*
+ * Copyright 1996-1999 Hans Reiser
+ */
+
+#include "fsck.h"
+#include "reiserfs.h"
+
+/* g_disk_bitmap initially contains copy of disk bitmaps
+   (cautious version of it);
+
+   g_new_bitmap initially has marked only super block, bitmap blocks
+   and bits after the end of bitmap
+
+   in pass 1 we go through g_disk_bitmap. 
+
+   If block does not look like formatted node, we skip it.
+
+   If block contains internal node, put 0 in g_disk_bitmap if block is
+   not used in new tree yet.
+
+   If block contains leaf and is used already (by an indirect item
+   handled already to this time) save all items. They will be inserted
+   into tree after pass 1.
+
+   If block looking like leaf is not used in the new tree, try to
+   insert in into tree. If it is not possible, mark block in
+   g_uninsertable_leaf_bitmap. Blocks marked in this bitmap will be inserted into tree in pass 2. They can not be
+
+  This means, that in pass 1 when we have
+   found block containing the internal nodes we mark it in
+   g_disk_bitmap as free (reiserfs_free_internal_block). When block
+   gets into new tree it is marked in g_new_bitmap (mark_block_used)
+   When collecting resources for do_balance, we mark new blocks with
+   mark_block_used. After do_balance we unmark unused new blocks in
+   g_new_bitmap (bitmap.c:/reiserfs_free_block)
+
+   Allocating of new blocks: look for 0 bit in g_disk_bitmap
+   (find_zero_bit_in_bitmap), make sure, that g_new_bitmap contains 0
+   at the corresponding bit (is_block_used).
+      
+ */
+
+
+
+int was_block_used (unsigned long block)
+{
+  int i, j;
+
+  if (block >= SB_BLOCK_COUNT (&g_sb))
+    die ("was_block_used: %d is too big (%d)\n", block, SB_BLOCK_COUNT (&g_sb));
+
+  if (opt_what_to_scan == SCAN_WHOLE_PARTITION)
+      /* this function is used to set 0 into indirect item entry when
+         it points to a block which was marked free in the
+         bitmap. When we scan whole partition we must gather as much
+         as possible. So, take it */
+      return 1;
+
+  i = block / (g_sb.s_blocksize * 8);
+  j = block % (g_sb.s_blocksize * 8);
+  return test_bit (j, g_disk_bitmap[i]);
+}
+
+
+/* is blocks used (marked by 1 in new bitmap) in the tree which is being built (as leaf, internal,
+   bitmap, or unformatted node) */
+int is_block_used (unsigned long block)
+{
+  int i, j;
+
+  if(g_new_bitmap == 0)
+    return 0;
+  if (block >= SB_BLOCK_COUNT (&g_sb)) {
+    printf ("is_block_used: %ld is too big (%d)\n", block, SB_BLOCK_COUNT (&g_sb));
+    return 1;
+  }
+
+  i = block / (g_sb.s_blocksize * 8);
+  j = block % (g_sb.s_blocksize * 8);
+  return test_bit (j, g_new_bitmap[i]);
+}
+
+
+void mark_block_used (unsigned long block)
+{
+  int i, j;
+
+  if (is_block_used (block))
+    die ("mark_block_used: (%lu) used already", block);
+
+  i = block / (g_sb.s_blocksize * 8);
+  j = block % (g_sb.s_blocksize * 8);
+  set_bit (j, g_new_bitmap[i]);
+  SB_FREE_BLOCKS (&g_sb)--;
+}
+
+/*%%%%%%%%%%%%%%%%%%%%%%*/
+int is_block_formatted (unsigned long block)
+{
+  int i, j;
+
+  i = block / (g_sb.s_blocksize * 8);
+  j = block % (g_sb.s_blocksize * 8);
+  return test_bit (j, g_formatted[i]);
+}
+int is_block_unformatted (unsigned long block)
+{
+  int i, j;
+
+  i = block / (g_sb.s_blocksize * 8);
+  j = block % (g_sb.s_blocksize * 8);
+  return test_bit (j, g_unformatted[i]);
+}
+void mark_block_formatted (unsigned long block)
+{
+  int i, j;
+
+  if (is_block_formatted (block) || is_block_unformatted (block))
+    die ("mark_block_formatted: (%lu) used already", block);
+
+  i = block / (g_sb.s_blocksize * 8);
+  j = block % (g_sb.s_blocksize * 8);
+  set_bit (j, g_formatted[i]);
+}
+void mark_block_unformatted (unsigned long block)
+{
+  int i, j;
+
+  if (is_block_formatted (block) || is_block_unformatted (block))
+    die ("mark_block_unformatted: (%lu) used already", block);
+
+
+  i = block / (g_sb.s_blocksize * 8);
+  j = block % (g_sb.s_blocksize * 8);
+  set_bit (j, g_unformatted[i]);
+}
+void unmark_block_formatted (unsigned long block)
+{
+  int i, j;
+
+  if (!is_block_formatted (block) || is_block_unformatted (block))
+    die ("unmark_block_formatted: (%lu) used already", block);
+
+  i = block / (g_sb.s_blocksize * 8);
+  j = block % (g_sb.s_blocksize * 8);
+  clear_bit (j, g_formatted[i]);
+}
+void unmark_block_unformatted (unsigned long block)
+{
+  int i, j;
+
+  if (is_block_formatted (block) || !is_block_unformatted (block))
+    die ("unmark_block_unformatted: (%lu) used already", block);
+
+  i = block / (g_sb.s_blocksize * 8);
+  j = block % (g_sb.s_blocksize * 8);
+  clear_bit (j, g_unformatted[i]);
+}
+/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
+
+/* uninsertable block is marked by bit clearing */
+void mark_block_uninsertable (unsigned long block)
+{
+  int i, j;
+
+  if (is_block_used (block))
+    die ("mark_block_uninsertable: (%lu) used already", block);
+
+  i = block / (g_sb.s_blocksize * 8);
+  j = block % (g_sb.s_blocksize * 8);
+  clear_bit (j, g_uninsertable_leaf_bitmap[i]);
+}
+
+int is_block_uninsertable (unsigned long block)
+{
+  int i, j;
+  
+  if (is_block_used (block))
+    die ("is_block_uninsertable: (%lu) used already", block);
+
+  i = block / (g_sb.s_blocksize * 8);
+  j = block % (g_sb.s_blocksize * 8);
+  return !test_bit (j, g_uninsertable_leaf_bitmap[i]);
+}
+
+static inline void get_bit_address (struct super_block * s, unsigned long block, int * bmap_nr, int * offset)
+{
+  *bmap_nr = block / (s->s_blocksize << 3);
+  *offset = block % (s->s_blocksize << 3);
+  return;
+}
+
+static inline int find_prev_zero_bit (void * addr, int offset)
+{
+  char * start;			/* byte pointer to starting byte of search */
+  int bit_offset;		/* bit offset within starting byte of starting point */
+  char mask;
+
+  start = (char *)addr + (offset >> 3);
+  bit_offset = (offset % 8);
+
+  mask = (unsigned int)0xff >> (7 - bit_offset);
+  while (start >= (char *)addr) {
+    if ((*start & mask) != mask) {
+      /* there is at least one 0 bit in current byte */
+      for (; bit_offset >= 0; bit_offset --) {
+	if (!((1 << bit_offset) & *start))
+	  return ((start - (char *)addr) << 3) + bit_offset;
+      }
+      die ("find_prev_zero_bit: must be at least 1 zero bit");
+    }
+    bit_offset = 7;
+    mask = (unsigned int)0xff;
+    start --;
+  }
+  /* there is no zero bit when we go from offset to the left up to addr */
+  return -1;
+
+}
+
+
+/* beginning from offset-th bit in bmap_nr-th bitmap block,
+   find_forward finds the closest zero bit. It returns 1 and zero
+   bit address (bitmap, offset) if zero bit found or 1 if there is no
+   zero bits in forward direction */
+static int find_forward (struct super_block * s, int * bmap_nr, int * offset)
+{
+  int i, j;
+  struct buffer_head * bh;
+
+  for (i = *bmap_nr; i < SB_BMAP_NR (s); i ++, *offset = 0) {
+    /* get corresponding bitmap block */
+    bh = SB_AP_BITMAP (s)[i];/*g_disk_bitmap[i];*/
+    while (*offset < (s->s_blocksize << 3)) {
+      j = find_next_zero_bit ((unsigned long *)bh->b_data, s->s_blocksize << 3, *offset);
+      if (j < (s->s_blocksize << 3)) {
+	*bmap_nr = i;
+	*offset = j;
+	
+	/* we found free block in disk bitmap, make sure, that it is
+           not used in new built tree yet */
+	if (is_block_used (i * (s->s_blocksize << 3) + j)) {
+	  (*offset) ++;
+	  continue;
+	}
+	return 1;
+      }
+      break; /* while */
+    }
+  }	/* for */
+
+  /* zero bit not found */
+  return 0;
+}
+
+
+/* this does the same as find_forward does, but in backward direction */
+static int find_backward (struct super_block * s, int * bmap_nr, int * offset)
+{
+  int i, j;
+  struct buffer_head * bh;
+
+  for (i = *bmap_nr; i > -1; i --, *offset = (s->s_blocksize << 3) - 1) {
+    /* get corresponding bitmap block */
+    bh = SB_AP_BITMAP (s)[i];/*g_disk_bitmap[i];*/
+    
+    /* at first we start from position, in next bitmap block we start from 0th position */
+    while (*offset > -1) {
+      j = find_prev_zero_bit ((unsigned long *)bh->b_data, *offset);
+      if (j != -1) {
+	*bmap_nr = i;
+	*offset = j;
+	
+	/* we found free block in disk bitmap, make sure, that it is not used in new built tree yet */
+	if (is_block_used (i * (s->s_blocksize << 3) + j)) {
+	  (*offset) --;
+	  continue;
+	}
+	return 1;
+      }
+      break;	/* from while */
+    }
+    
+    /* in previous bitmap block we start from the end */
+/*    *offset = (s->s_blocksize << 3) - 1;*/
+  }	/* for */
+  
+  /* zero bit not found */
+  return 0;
+}
+
+
+static unsigned long find_zero_bit_in_bitmap (struct super_block * s, unsigned long search_start)
+{
+  int bmap_nr, offset;
+
+  /* get bit location (bitmap number and bit offset) of search_start block */
+  get_bit_address (s, search_start, &bmap_nr, &offset);
+
+  /* first we are going to the right (as elevator_direction requires) */
+  if (find_forward (s, &bmap_nr, &offset) == 0) {
+    /* there wasn't a free block with number greater than our
+       starting point, so we are going to do find_backward */
+    get_bit_address (s, search_start, &bmap_nr, &offset);
+    if (find_backward (s, &bmap_nr, &offset) == 0)
+      return 0;
+  }
+
+  /* ok, mark block in new bitmap */
+  mark_block_used (bmap_nr * (s->s_blocksize << 3) + offset);
+  return (bmap_nr * (s->s_blocksize << 3)) + offset;
+}
+
+
+/* mark block free in bitmap we use to build the tree */
+void reiserfs_free_internal_block (struct super_block * s, unsigned long block)
+{
+  int i, j;
+
+  i = block / (s->s_blocksize * 8);
+  j = block % (s->s_blocksize * 8);
+
+  if (test_bit (j, SB_AP_BITMAP (s)[i]->b_data) == 0)
+    die ("reiserfs_free_internal_block: Block %lu is free", block);
+
+  clear_bit (j, SB_AP_BITMAP (s)[i]->b_data);
+  g_old_rs->s_free_blocks ++;
+}
+
+
+/* try to find 'to_free' internal nodes and mark corresponding blocks
+   free. Return number of freed blocks */
+static int try_to_free_unused_internal_blocks (int to_free)
+{
+    int i, j, k;
+    int freed = 0;
+    struct buffer_head * bh;
+    int block;
+
+    /* just to do not waste time: onthe partition sent by Petru there
+       is no internal nodes */
+    return 0;
+
+    printf ("Trying to find internal nodes which are not used in new tree..");fflush (stdout);
+    for (i = 0; i < SB_BMAP_NR (&g_sb); i ++)
+	for (j = 0; j < g_sb.s_blocksize; j ++) {
+	    if (i * g_sb.s_blocksize * 8 + j * 8 == SB_BLOCK_COUNT (&g_sb))
+		goto out_of_bitmap;
+	    for (k = 0; k < 8; k ++) {
+		block = i * g_sb.s_blocksize * 8 + j * 8 + k;
+		if (is_block_used (block/*i * g_sb.s_blocksize * 8 + j * 8 + k*/))
+		    continue;
+		bh = bread (g_sb.s_dev, i * g_sb.s_blocksize * 8 + j * 8 + k, g_sb.s_blocksize);
+		if (not_formatted_node (bh->b_data, g_sb.s_blocksize)) {
+		    brelse (bh);
+		    continue;
+		}
+		/* this node is formatted node. we can free internal node  */
+		if (is_internal_node (bh->b_data)) {
+		    reiserfs_free_internal_block (&g_sb, bh->b_blocknr);
+		    printf (".");fflush (stdout);
+		    freed ++;
+		    if (freed == to_free) {
+			brelse (bh);
+			goto out_of_bitmap;
+		    }
+		}
+		brelse (bh);
+	    }
+	}
+ out_of_bitmap:
+    printf ("\n");
+    return freed;
+}
+
+
+int from_journal;
+
+int reiserfs_new_blocknrs (struct reiserfs_transaction_handle *th, struct super_block * s, 
+			   unsigned long * free_blocknrs, unsigned long start, int amount_needed, int notused)
+{
+    while (amount_needed --) {
+	*free_blocknrs = find_zero_bit_in_bitmap (s, start);
+	if (*free_blocknrs == 0) {
+	    /* if we still did not take journal space lets try to find
+               internal nodes and free them */
+	    if (from_journal == 0 && try_to_free_unused_internal_blocks (10))
+		/* got some space */
+		continue;
+
+	    /* ok, no free space on device. There are no internal
+	       nodes which could be freed. This is especially very
+	       likely when you specify --scan-whole-partition. Take
+	       journal space! */
+
+	    /* take blocks starting from must journal start but not
+               over the journal partition had before recovering */
+	    if (from_journal == get_journal_size (s))
+		/* whole journal is used already */
+		die ("Journal space is used. No idea where to get free space");
+
+	    if (from_journal == 0)
+		printf ("Start using journal space\n");
+	    *free_blocknrs = from_journal + get_journal_start (s);
+	    from_journal ++;
+	}
+
+	free_blocknrs ++;
+    }
+    
+    return CARRY_ON;
+}
+
+
+int reiserfs_new_unf_blocknrs(struct reiserfs_transaction_handle *th, struct super_block * s, unsigned long * free_blocknrs,
+				 unsigned long search_start, int amount_needed, int for_preserve_list) {
+  return reiserfs_new_blocknrs(th, s, free_blocknrs, search_start, amount_needed, for_preserve_list) ;
+}
+
+
+
+struct buffer_head * reiserfsck_get_new_buffer (unsigned long start)
+{
+  unsigned long blocknr = 0;
+  struct buffer_head * bh;
+
+  reiserfs_new_blocknrs (0, &g_sb, &blocknr, start, 1, 0);
+  
+  bh = getblk (g_sb.s_dev, blocknr, g_sb.s_blocksize);
+  if (buffer_uptodate (bh))
+    die ("reiserfsck_get_new_buffer: found uptodate buffer for new blocknr");
+
+  return bh;
+}
+
+
+/* free block in new bitmap */
+void reiserfs_free_block (struct reiserfs_transaction_handle *th, struct super_block * s, unsigned long block)
+{
+  int i, j;
+
+  i = block / (s->s_blocksize * 8);
+  j = block % (s->s_blocksize * 8);
+
+  if (test_bit (j, g_new_bitmap[i]) == 0)
+    die ("reiserfs_free_block: Block %lu is free", block);
+
+  clear_bit (j, g_new_bitmap[i]);
+  SB_FREE_BLOCKS (&g_sb)++;
+}
+
+
+
Index: empeg/kernel/fs/reiserfs/utils/fsck/ufile.c
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/fsck/ufile.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/fsck/ufile.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,1042 @@
+/*
+ * Copyright 1996, 1997, 1998 Hans Reiser
+ */
+#include "fsck.h"
+
+#if 0
+static int is_bad_sd (struct item_head * ih, char * item)
+{
+  struct stat_data * sd = (struct stat_data *)item;
+
+  if (!S_ISDIR (sd->sd_mode) && !S_ISREG(sd->sd_mode) &&
+      !S_ISCHR (sd->sd_mode) && !S_ISBLK(sd->sd_mode) &&
+      !S_ISLNK (sd->sd_mode)) {
+    reiserfs_warning ("is_bad_sd: \
+stat data item (%h) has sd_mode 0%o. Skipped\n", ih, sd->sd_mode);
+    return 1;
+  }
+  if ((sd->sd_first_direct_byte != NO_BYTES_IN_DIRECT_ITEM &&
+       sd->sd_first_direct_byte >= sd->sd_size) ||
+      sd->sd_size > MAX_INT) {
+    reiserfs_warning ("is_bad_sd: \
+stat data item (%h) has sd_size %d, first direct byte %d\n", ih, sd->sd_size,
+		      sd->sd_first_direct_byte);
+    return 1;
+  }
+  if (sd->sd_nlink > 100) {
+    reiserfs_warning ("is_bad_sd: \
+stat data item (%h) has sd_nlink %d\n", sd->sd_nlink);
+    return 1;
+  }
+  return 0;
+}
+
+
+static int is_bad_directory (struct item_head * ih, char * item)
+{
+  int i;
+  int namelen;
+  struct reiserfs_de_head * deh = (struct reiserfs_de_head *)item;
+  __u32 prev_offset = 0;
+  __u16 prev_location = 0xffff;
+
+  for (i = 0; i < I_ENTRY_COUNT (ih); i ++) {
+    namelen = I_DEH_N_ENTRY_FILE_NAME_LENGTH (ih, deh + i, i);
+    if (namelen > REISERFS_MAX_NAME_LEN (g_sb.s_blocksize)) {
+      reiserfs_warning ("is_bad_directory: dir item %h has too long name (%d)\n", ih, namelen);
+      return 1;
+    }
+    if (deh[i].deh_offset <= prev_offset) {
+      reiserfs_warning ("is_bad_directory: dir item %h has invalid header array \
+(offsets: prev %u, %d-th cur %u)\n", ih, prev_offset, i, deh[i].deh_offset);
+      return 1;
+    }
+    prev_offset = deh[i].deh_offset;
+
+    if (deh[i].deh_location >= prev_location) {
+      reiserfs_warning ("is_bad_directory: dir item %h has invalid header array \
+(locations: prev %u, %d-th cur %u)\n", ih, prev_location, i, deh[i].deh_location);
+      return 1;
+    }
+  }
+
+  return 0;
+}
+
+
+/* change incorrect block adresses by 0. Do not consider such item as incorrect */
+static int is_bad_indirect (struct item_head * ih, char * item)
+{
+  int i;
+
+  for (i = 0; i < I_UNFM_NUM (ih); i ++) {
+    __u32 * ind = (__u32 *)item;
+
+    if (ind[i] >= SB_BLOCK_COUNT (&g_sb)) {
+      /*reiserfs_warning ("is_bad_indirect: block address (%lu) in indirect item. Super block block count == %u\n",
+	      ind[i], SB_BLOCK_COUNT (&g_sb));*/
+      ind[i] = 0;
+      continue;
+    }
+    if (is_block_used (ind[i])) {
+      ind[i] = 0;
+      continue;
+    }
+  }
+  return 0;
+}
+
+
+int is_bad_item (struct item_head * ih, char * item)
+{
+  if (I_IS_STAT_DATA_ITEM (ih))
+    return is_bad_sd (ih, item);
+
+  if (I_IS_DIRECTORY_ITEM (ih))
+    return is_bad_directory (ih, item);
+
+  if (I_IS_INDIRECT_ITEM (ih))
+    return is_bad_indirect (ih, item);
+
+  return 0;
+}
+#endif /* 0 */
+
+int is_bad_item (struct item_head *, char *, int, int);
+
+/* append item to end of list. Set head if it is 0. For indirect item
+   set wrong unformatted node pointers to 0 */
+void save_item (struct si ** head, struct item_head * ih, char * item)
+{
+    struct si * si, * cur;
+    int i;
+
+    if (is_bad_item (ih, item, g_sb.s_blocksize, g_sb.s_dev)) {
+	return;
+    }
+
+    if (I_IS_INDIRECT_ITEM (ih))
+	for (i = 0; i < I_UNFM_NUM (ih); i ++) {
+	    __u32 * ind = (__u32 *)item;
+
+	    if (ind[i] >= SB_BLOCK_COUNT (&g_sb) ||
+		!was_block_used (ind[i]) ||
+		is_block_used (ind[i]) ||
+		is_block_uninsertable (ind[i])) {
+		ind[i] = 0;
+		continue;
+	    }
+	}
+
+    si = getmem (sizeof (*si));
+    si->si_dnm_data = getmem (ih->ih_item_len);
+    memcpy (&(si->si_ih), ih, IH_SIZE);
+    memcpy (si->si_dnm_data, item, ih->ih_item_len);
+
+
+    if (*head == 0)
+	*head = si;
+    else {
+	cur = *head;
+	while (cur->si_next)
+	    cur = cur->si_next;
+	cur->si_next = si;
+    }
+    return;
+}
+
+
+/* this item is in tree. All unformatted pointer are correct. Do not
+   check them */
+static void save_item_2 (struct si ** head, struct item_head * ih, char * item)
+{
+    struct si * si, * cur;
+
+    if (is_bad_item (ih, item, g_sb.s_blocksize, g_sb.s_dev)) {
+	return;
+    }
+
+    si = getmem (sizeof (*si));
+    si->si_dnm_data = getmem (ih->ih_item_len);
+    memcpy (&(si->si_ih), ih, IH_SIZE);
+    memcpy (si->si_dnm_data, item, ih->ih_item_len);
+
+
+    if (*head == 0)
+	*head = si;
+    else {
+	cur = *head;
+	while (cur->si_next)
+	    cur = cur->si_next;
+	cur->si_next = si;
+    }
+    return;
+}
+
+
+
+static struct si * save_and_delete_file_item (struct si * si, struct path * path)
+{
+    struct buffer_head * bh = PATH_PLAST_BUFFER (path);
+    struct item_head * ih = PATH_PITEM_HEAD (path);
+
+    save_item_2 (&si, ih, B_I_PITEM (bh, ih));
+
+    reiserfsck_delete_item (path);
+    return si;
+}
+
+
+static struct si * remove_saved_item (struct si * si)
+{
+  struct si * tmp = si->si_next;
+
+  freemem (si->si_dnm_data);
+  freemem (si);
+  return tmp;
+}
+
+
+void put_saved_items_into_tree (struct si * si)
+{
+  while (si) {
+    insert_item_separately (&si, &(si->si_ih), si->si_dnm_data);
+/*    reiserfsck_file_write (&(si->si_ih), si->si_dnm_data);*/
+    si = remove_saved_item (si);
+  }
+}
+
+
+/* path points to an item or behind last item of the node */
+/*
+static int next_item_of_other_object (struct key * key, struct path * path)
+{
+  struct key * next_key;
+
+  if (PATH_LAST_POSITION (path) < B_NR_ITEMS (PATH_PLAST_BUFFER (path)))
+    next_key = B_N_PKEY (PATH_PLAST_BUFFER (path), PATH_LAST_POSITION (path));
+  else
+    next_key = get_right_dkey (path);
+
+  if (next_key == 0 || comp_short_keys (key, next_key) != KEYS_IDENTICAL)
+    return YES;
+  return NO;
+}
+*/
+
+
+static int do_items_have_the_same_type (struct key * key1, struct key * key2)
+{
+  return (key1->k_uniqueness == key2->k_uniqueness) ? 1 : 0;
+}
+
+static int are_items_in_the_same_node (struct path * path)
+{
+  return (PATH_LAST_POSITION (path) < B_NR_ITEMS (PATH_PLAST_BUFFER (path)) - 1) ? 1 : 0;
+}
+
+
+static struct key * get_next_key (struct path * path)
+{
+  if (PATH_LAST_POSITION (path) < B_NR_ITEMS (PATH_PLAST_BUFFER (path)) - 1)
+    return B_N_PKEY (PATH_PLAST_BUFFER (path), PATH_LAST_POSITION (path) + 1);
+  return uget_rkey (path);
+}
+
+
+/* whether last unfm pointer must be and can be converted to direct item */
+static int can_indirect_item_be_converted (struct item_head * ih)
+{
+  unsigned long file_size = ih->ih_key.k_offset + I_BYTES_NUMBER (ih, g_sb.s_blocksize) - 1;
+  unsigned long tail_size = g_sb.s_blocksize - ih->u.ih_free_space;
+
+  if (!STORE_TAIL_IN_UNFM (file_size, tail_size, g_sb.s_blocksize) &&
+      I_IS_INDIRECT_ITEM (ih)/* && tail_size <= MAX_DIRECT_ITEM_LEN (g_sb.s_blocksize)*/)
+    return 1;
+  return 0;
+}
+
+
+int do_make_tails ()
+{
+  return 1;/*SB_MAKE_TAIL_FLAG (&g_sb) == MAKE_TAILS ? YES : NO;*/
+}
+
+
+static void cut_last_unfm_pointer (struct path * path, struct item_head * ih)
+{
+  ih->u.ih_free_space = 0;
+  if (I_UNFM_NUM (ih) == 1)
+    reiserfsck_delete_item (path);
+  else
+    reiserfsck_cut_from_item (path, -UNFM_P_SIZE);
+}
+
+
+static unsigned long indirect_to_direct (struct path * path)
+{
+  struct buffer_head * bh = PATH_PLAST_BUFFER (path);
+  struct item_head * ih = PATH_PITEM_HEAD (path);
+  unsigned long unfm_ptr;
+  struct buffer_head * unfm_bh = 0;
+  struct item_head ins_ih;
+  char * buf;
+  int len;
+  unsigned long offset;
+
+
+  add_event (INDIRECT_TO_DIRECT);
+
+  unfm_ptr = B_I_POS_UNFM_POINTER (bh, ih, I_UNFM_NUM (ih) - 1);
+
+
+  /* direct item to insert */
+  ins_ih.ih_key.k_dir_id = ih->ih_key.k_dir_id;
+  ins_ih.ih_key.k_objectid = ih->ih_key.k_objectid;
+  ins_ih.ih_key.k_offset = ih->ih_key.k_offset + (I_UNFM_NUM (ih) - 1) * bh->b_size;
+  offset = ins_ih.ih_key.k_offset;
+  ins_ih.ih_key.k_uniqueness = TYPE_DIRECT;
+  ins_ih.ih_item_len = g_sb.s_blocksize - ih->u.ih_free_space;
+  len = ins_ih.ih_item_len;
+  ins_ih.u.ih_free_space = MAX_US_INT;
+  ins_ih.ih_reserved = 0;
+
+  /* get buffer filled with 0s */
+  buf = getmem (len);
+  if (unfm_ptr) {
+    unfm_bh = bread (bh->b_dev, unfm_ptr, bh->b_size);
+    memcpy (buf, unfm_bh->b_data, ins_ih.ih_item_len);
+    brelse (unfm_bh);
+  }
+
+
+  path->pos_in_item = I_UNFM_NUM (ih) - 1;
+  cut_last_unfm_pointer (path, ih);
+
+  /* insert direct item */
+  if (usearch_by_key (&g_sb, &(ins_ih.ih_key), path, 0, DISK_LEAF_NODE_LEVEL, READ_BLOCKS, comp_keys) == ITEM_FOUND)
+    die ("indirect_to_direct: key must be not found");
+  reiserfsck_insert_item (path, &ins_ih, (const char *)(buf));
+
+
+  freemem (buf);
+  
+  /* put to stat data offset of first byte in direct item */
+  return offset;
+}
+
+
+/* when it returns, key->k_offset is offset of the last item of file */
+int are_file_items_correct (struct key * key, unsigned long * size, int mark_passed_items, 
+			    struct path * path_to_sd, struct stat_data ** sd)
+{
+    struct path path;
+    int retval;
+    struct item_head * ih;
+    struct key * next_key;
+    int symlink = 0;
+
+    if (sd && ((*sd)->sd_mode & S_IFMT) == S_IFLNK)
+	symlink = 1;
+
+    *size = 0;
+    key->k_offset = 1;
+    key->k_uniqueness = TYPE_DIRECT;
+    path.path_length = ILLEGAL_PATH_ELEMENT_OFFSET;
+
+    do {
+	retval = usearch_by_position (&g_sb, key, &path);
+	if (retval == BYTE_FOUND && path.pos_in_item != 0)
+	    die ("are_file_items_correct: all bytes we look for must be found at position 0");
+
+	switch (retval) {
+	case BYTE_FOUND:/**/
+	    ih = PATH_PITEM_HEAD (&path);
+	    key->k_uniqueness = ih->ih_key.k_uniqueness;
+	    if (mark_passed_items == 1) {
+		mark_item_accessed (ih, PATH_PLAST_BUFFER (&path));
+	    }
+	    next_key = get_next_key (&path);
+	    if (next_key == 0 || comp_short_keys (key, next_key) != KEYS_IDENTICAL || 
+		(!KEY_IS_INDIRECT_KEY (next_key) && !KEY_IS_DIRECT_KEY (next_key))) {
+		/* next item does not exists or is of another object, therefore all items of file are correct */
+		*size = key->k_offset + I_BYTES_NUMBER (ih, g_sb.s_blocksize) - 1;
+
+		/* here is a problem: if file system being repaired
+                   was full enough, then we should avoid
+                   indirect_to_direct conversions. This is because
+                   unformatted node we have to free will not get into
+                   pool of free blocks, but new direct item is very
+                   likely of big size, therefore it may require
+                   allocation of new blocks. So, skip it for now */
+		if (symlink && I_IS_INDIRECT_ITEM (ih)) {
+/*
+		if (0 && mark_passed_items == 1 && 
+		    do_make_tails () == 1 && can_indirect_item_be_converted (ih) == 1) {
+*/	    
+		    struct key sd_key;
+		    unsigned long first_direct_byte;
+
+		    first_direct_byte = indirect_to_direct (&path);
+		    /* we have to research stat data of object after converting */
+		    pathrelse (path_to_sd);
+		    copy_key (&sd_key, key);
+		    sd_key.k_offset = SD_OFFSET;
+		    sd_key.k_uniqueness = SD_UNIQUENESS;
+		    if (usearch_by_key (&g_sb, &(sd_key), path_to_sd, 0, DISK_LEAF_NODE_LEVEL, READ_BLOCKS, comp_keys) != ITEM_FOUND)
+			die ("are_file_items_correct: stat data not found");
+		    *sd = B_N_STAT_DATA (PATH_PLAST_BUFFER (path_to_sd), PATH_LAST_POSITION (path_to_sd));
+		    /* last item of the file is direct item */
+		    key->k_offset = first_direct_byte;
+		    key->k_uniqueness = TYPE_DIRECT;
+		} else
+		    pathrelse (&path);
+		return 1;
+	    }
+	    /* next item is item of this file */
+	    if ((I_IS_INDIRECT_ITEM (ih) &&
+		 ih->ih_key.k_offset + g_sb.s_blocksize * I_UNFM_NUM (ih) != next_key->k_offset) ||
+		(I_IS_DIRECT_ITEM (ih) && ih->ih_key.k_offset + ih->ih_item_len != next_key->k_offset)) {
+		/* next item has incorrect offset (hole or overlapping) */
+		*size = key->k_offset + I_BYTES_NUMBER (ih, g_sb.s_blocksize) - 1;
+		pathrelse (&path);
+		return 0;
+	    }
+	    if (do_items_have_the_same_type (&(ih->ih_key), next_key) == 1 && are_items_in_the_same_node (&path) == 1) {
+		/* two indirect items or two direct items in the same leaf */
+		*size = key->k_offset + I_BYTES_NUMBER (ih, g_sb.s_blocksize) - 1;
+		pathrelse (&path);
+		return 0;
+	    }
+	    /* items are of different types or are in different nodes */
+	    if (ih->ih_key.k_offset + I_BYTES_NUMBER (ih, g_sb.s_blocksize) != next_key->k_offset) {
+		/* indirect item free space is not set properly */
+		if (!I_IS_INDIRECT_ITEM (ih) || ih->u.ih_free_space == 0)
+		    die ("are_file_items_correct: item must be indirect and must have invalid free space (%d)",
+			 ih->u.ih_free_space);
+	
+		ih->u.ih_free_space = 0;
+		mark_buffer_dirty (PATH_PLAST_BUFFER (&path), 0);
+		if (ih->ih_key.k_offset + I_BYTES_NUMBER (ih, g_sb.s_blocksize) != next_key->k_offset)
+		    die ("are_file_items_correct: invalid offset");
+	    }
+	    /* next item exists */
+	    key->k_offset = next_key->k_offset;
+	    pathrelse (&path);
+	    break;
+
+	case BYTE_NOT_FOUND:
+	    if (key->k_offset != 1)
+		die ("are_file_items_correct: byte can be not found only when it is first byte of file");
+	    pathrelse (&path);
+	    return 0;
+      
+	case FILE_NOT_FOUND:
+	    if (key->k_offset != 1)
+		die ("are_file_items_correct: there is no items of this file, byte 0 found though");
+	    pathrelse (&path);
+	    return 1;
+
+	case DIRECTORY_FOUND:
+	    pathrelse (&path);
+	    return 0;
+	}
+    } while (1);
+
+    die ("are_file_items_correct: code can not reach here");
+    return 0;
+}
+
+
+/* file must have correct sequence of items and tail must be stored in
+   unformatted pointer */
+static int make_file_writeable (struct item_head * ih)
+{
+  struct key key;
+  struct key * rkey;
+  struct path path;
+  struct item_head * path_ih;
+  struct si * si = 0;
+  unsigned long size;
+  int mark_passed_items;
+  int retval;
+
+  copy_key (&key, &(ih->ih_key));
+
+  if ((retval = are_file_items_correct (&key, &size, mark_passed_items = 0, 0, 0)) == 1)
+    /* this file looks good (or there is no any items of it) */
+    return 1;
+
+  if (retval == -1) {
+    /* there is an object with this key and it is directory */
+    return -1;
+  }
+
+  /* rewrite file */
+
+
+  /* look for all items of file, store them and delete */
+  key.k_offset = 1;
+  while (1) {
+    usearch_by_key (&g_sb, &key, &path, 0, DISK_LEAF_NODE_LEVEL, READ_BLOCKS, comp_keys_3);
+    if (PATH_LAST_POSITION (&path) == B_NR_ITEMS (PATH_PLAST_BUFFER (&path))) {
+      rkey = uget_rkey (&path);
+      if (rkey && comp_short_keys (&key, rkey) == KEYS_IDENTICAL) {
+	/* file continues in the right neighbor */
+	copy_key (&key, rkey);
+	pathrelse (&path);
+	continue;
+      }
+      /* there is no more items of file */
+      pathrelse (&path);
+      break;
+    }
+    path_ih = PATH_PITEM_HEAD (&path);
+    if (comp_short_keys (&key, &(path_ih->ih_key)) != KEYS_IDENTICAL) {
+      pathrelse (&path);
+      break;
+    }
+    si = save_and_delete_file_item (si, &path);
+  }
+
+  /* put all items back into tree */
+  put_saved_items_into_tree (si);
+
+  add_event (REWRITTEN_FILES);
+
+/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
+  copy_key (&key, &(ih->ih_key));
+  size = 0;
+  if (are_file_items_correct (&key, &size, mark_passed_items = 0, 0, 0) == 0) {
+    die ("file still incorrect\n");
+  }
+/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
+
+  return 1;
+
+}
+
+
+/* this inserts __first__ indirect item (having k_offset == 1 and only
+   one unfm pointer) into tree */
+static int create_first_item_of_file (struct item_head * ih, char * item, struct path * path, int *pos_in_coming_item)
+{
+  unsigned long unfm_ptr;
+  struct buffer_head * unbh;
+  struct item_head indih;
+  int retval;
+
+  if (ih->ih_key.k_offset > g_sb.s_blocksize) {
+    /* insert indirect item containing 0 unfm pointer */
+    unfm_ptr = 0;
+    indih.u.ih_free_space = 0;
+    retval = 0;
+  } else {
+    if (I_IS_DIRECT_ITEM (ih)) {
+      /* copy direct item to new unformatted node. Save information about it */
+      
+      unbh = reiserfsck_get_new_buffer (PATH_PLAST_BUFFER (path)->b_blocknr);
+      unfm_ptr = unbh->b_blocknr;
+
+/* this is for check only */
+mark_block_unformatted (unfm_ptr);
+      memcpy (unbh->b_data + ih->ih_key.k_offset - 1, item, ih->ih_item_len);
+
+      save_unfm_overwriting (unfm_ptr, ih);
+
+      indih.u.ih_free_space = g_sb.s_blocksize - ih->ih_item_len - (ih->ih_key.k_offset - 1);
+      mark_buffer_dirty (unbh, 0);
+      mark_buffer_uptodate (unbh, 0);
+      brelse (unbh);
+      retval = ih->ih_item_len;
+    } else {
+      /* take first unformatted pointer from an indirect item */
+      unfm_ptr = *(unsigned long *)item;/*B_I_POS_UNFM_POINTER (bh, ih, 0);*/
+      if (!is_block_used (unfm_ptr) && !is_block_uninsertable (unfm_ptr)) {
+	mark_block_used (unfm_ptr);
+/* this is for check only */
+mark_block_unformatted (unfm_ptr);
+      } else {
+	unfm_ptr = 0;
+      }
+      indih.u.ih_free_space = (ih->ih_item_len == UNFM_P_SIZE) ? ih->u.ih_free_space : 0;
+      retval = g_sb.s_blocksize - indih.u.ih_free_space;
+      (*pos_in_coming_item) ++;
+    }
+  }
+  copy_key (&(indih.ih_key), &(ih->ih_key));
+  indih.ih_key.k_offset = 1;
+  indih.ih_key.k_uniqueness = TYPE_INDIRECT;
+  indih.ih_item_len = UNFM_P_SIZE;
+  mark_item_unaccessed (&indih);
+  reiserfsck_insert_item (path, &indih, (const char *)&unfm_ptr);
+  return retval;
+}
+
+
+/* path points to first part of tail. Function copies file tail into unformatted node and returns
+   its block number. If we are going to overwrite direct item then keep free space (keep_free_space
+   == YES). Else (we will append file) set free space to 0 */
+/* we convert direct item that is on the path to indirect. we need a number of free block for
+   unformatted node. reiserfs_new_blocknrs will start from block number returned by this function */
+static unsigned long block_to_start (struct path * path)
+{
+  struct buffer_head * bh;
+  struct item_head * ih;
+
+  bh = PATH_PLAST_BUFFER (path);
+  ih = PATH_PITEM_HEAD (path);
+  if (ih->ih_key.k_offset == 1 || PATH_LAST_POSITION (path) == 0)
+    return bh->b_blocknr;
+
+  ih --;
+  return (B_I_POS_UNFM_POINTER (bh, ih, I_UNFM_NUM (ih) - 1)) ?: bh->b_blocknr;
+}
+
+
+static void direct2indirect (unsigned long unfm, struct path * path, int keep_free_space)
+{
+  struct item_head * ih;
+  struct key key;
+  struct buffer_head * unbh;
+  struct unfm_nodeinfo ni;
+  int copied = 0;
+  
+  copy_key (&key, &(PATH_PITEM_HEAD (path)->ih_key));
+
+  if (key.k_offset % g_sb.s_blocksize != 1) {
+    /* look for first part of tail */
+    pathrelse (path);
+    key.k_offset -= (key.k_offset % g_sb.s_blocksize - 1);
+    if (usearch_by_key (&g_sb, &key, path, 0, DISK_LEAF_NODE_LEVEL, READ_BLOCKS, comp_keys) != ITEM_FOUND)
+      die ("direct2indirect: can not find first part of tail");
+  }
+
+  unbh = reiserfsck_get_new_buffer (unfm ?: block_to_start (path));
+
+  /* delete parts of tail coping their contents to new buffer */
+  do {
+    ih = PATH_PITEM_HEAD (path);
+    memcpy (unbh->b_data + copied, B_I_PITEM (PATH_PLAST_BUFFER (path), ih), ih->ih_item_len);
+
+    save_unfm_overwriting (unbh->b_blocknr, ih);
+
+    copied += ih->ih_item_len;
+    key.k_offset += ih->ih_item_len;
+    reiserfsck_delete_item (path);
+  } while (/*reiserfsck_*/usearch_by_key (&g_sb, &key, path, 0, DISK_LEAF_NODE_LEVEL, READ_BLOCKS, comp_keys) == ITEM_FOUND);
+
+  pathrelse (path);
+
+  /* paste or insert pointer to the unformatted node */
+  key.k_offset -= copied;
+  ni.unfm_nodenum = unbh->b_blocknr;
+  ni.unfm_freespace = (keep_free_space == 1) ? (g_sb.s_blocksize - copied) : 0;
+
+/* this is for check only */
+mark_block_unformatted (ni.unfm_nodenum);
+
+  if (usearch_by_position (&g_sb, &key, path) == FILE_NOT_FOUND) {
+    struct item_head insih;
+
+    copy_key (&(insih.ih_key), &key);
+    insih.ih_key.k_uniqueness = TYPE_INDIRECT;
+    insih.u.ih_free_space = ni.unfm_freespace;
+    mark_item_unaccessed (&insih);
+    insih.ih_item_len = UNFM_P_SIZE;
+    reiserfsck_insert_item (path, &insih, (const char *)&(ni.unfm_nodenum));
+  } else {
+    ih = PATH_PITEM_HEAD (path);
+    if (!I_IS_INDIRECT_ITEM (ih) || ih->ih_key.k_offset + I_BYTES_NUMBER (ih, g_sb.s_blocksize) != key.k_offset)
+      die ("direct2indirect: incorrect item found");
+    reiserfsck_paste_into_item (path, (const char *)&ni, UNFM_P_SIZE);
+  }
+
+  mark_buffer_dirty (unbh, 0);
+  mark_buffer_uptodate (unbh, 0);
+  brelse (unbh);
+
+  if (usearch_by_position (&g_sb, &key, path) != BYTE_FOUND || !I_IS_INDIRECT_ITEM (PATH_PITEM_HEAD (path)))
+    die ("direct2indirect: position not found");
+  return;
+}
+
+
+
+
+static int append_to_unformatted_node (struct item_head * comingih, struct item_head * ih, char * item, struct path * path)
+{
+  struct buffer_head * bh, * unbh;
+  int end_of_data = g_sb.s_blocksize - ih->u.ih_free_space;
+  int offset = comingih->ih_key.k_offset % g_sb.s_blocksize - 1;
+  int zero_number = offset - end_of_data;
+  __u32 unfm_ptr;
+
+  /* append to free space of the last unformatted node of indirect item ih */
+  if (ih->u.ih_free_space < comingih->ih_item_len)
+    die ("reiserfsck_append_file: there is no enough free space in unformatted node");
+
+  bh = PATH_PLAST_BUFFER (path);
+
+  unfm_ptr = B_I_POS_UNFM_POINTER (bh, ih, I_UNFM_NUM (ih) - 1);
+  if (unfm_ptr == 0 || unfm_ptr >= SB_BLOCK_COUNT (&g_sb)) {
+    unbh = reiserfsck_get_new_buffer (bh->b_blocknr);
+    B_I_POS_UNFM_POINTER (bh, ih, I_UNFM_NUM (ih) - 1) = unbh->b_blocknr;
+    mark_block_unformatted (unbh->b_blocknr);
+    mark_buffer_dirty (bh, 0);
+  } else {
+    unbh = bread (g_sb.s_dev, unfm_ptr, g_sb.s_blocksize);
+    if (!is_block_used (unfm_ptr))
+      die ("append_to_unformatted_node:  unused block %d", unfm_ptr);
+
+  }
+  memset (unbh->b_data + end_of_data, 0, zero_number);
+  memcpy (unbh->b_data + offset, item, comingih->ih_item_len);
+
+  save_unfm_overwriting (unbh->b_blocknr, comingih);
+
+  ih->u.ih_free_space -= (zero_number + comingih->ih_item_len);
+  memset (unbh->b_data + offset + comingih->ih_item_len, 0, ih->u.ih_free_space);
+  mark_buffer_uptodate (unbh, 0);
+  mark_buffer_dirty (unbh, 0);
+  brelse (unbh);
+  pathrelse (path);
+  return comingih->ih_item_len;
+}
+
+
+static void adjust_free_space (struct buffer_head * bh, struct item_head * ih, struct item_head * comingih)
+{
+  if (I_IS_INDIRECT_ITEM (comingih)) {
+    ih->u.ih_free_space = 0;
+  } else {
+    if (comingih->ih_key.k_offset < ih->ih_key.k_offset + g_sb.s_blocksize * I_UNFM_NUM (ih))
+      /* append to the last unformatted node */
+      ih->u.ih_free_space = g_sb.s_blocksize - ih->ih_key.k_offset % g_sb.s_blocksize + 1;
+    else
+      ih->u.ih_free_space = 0;
+  }
+
+  mark_buffer_dirty (bh, 0);
+}
+
+
+/* this appends file with one unformatted node pointer (since balancing algorithm limitation). This
+   pointer can be 0, or new allocated block or pointer from indirect item that is being inserted
+   into tree */
+int reiserfsck_append_file (struct item_head * comingih, char * item, int pos, struct path * path)
+{
+  struct unfm_nodeinfo ni;
+  struct buffer_head * unbh;
+  int retval;
+/*  int keep_free_space;*/
+  struct item_head * ih = PATH_PITEM_HEAD (path);
+
+  if (!I_IS_INDIRECT_ITEM (ih))
+    die ("reiserfsck_append_file: can not append to non-indirect item");
+
+  if (ih->ih_key.k_offset + I_BYTES_NUMBER (ih, g_sb.s_blocksize) != comingih->ih_key.k_offset) {
+    adjust_free_space (PATH_PLAST_BUFFER (path), ih, comingih);
+  }
+
+  if (I_IS_DIRECT_ITEM (comingih)) {
+    if (comingih->ih_key.k_offset < ih->ih_key.k_offset + g_sb.s_blocksize * I_UNFM_NUM (ih)) {
+      /* direct item fits to free space of indirect item */
+      return append_to_unformatted_node (comingih, ih, item, path);
+    }
+
+    unbh = reiserfsck_get_new_buffer (PATH_PLAST_BUFFER (path)->b_blocknr);
+    /* this is for check only */
+    mark_block_unformatted (unbh->b_blocknr);
+    memcpy (unbh->b_data + comingih->ih_key.k_offset % unbh->b_size - 1, item, comingih->ih_item_len);
+
+    save_unfm_overwriting (unbh->b_blocknr, comingih);
+
+    mark_buffer_dirty (unbh, 0);
+    mark_buffer_uptodate (unbh, 0);
+
+    ni.unfm_nodenum = unbh->b_blocknr;
+    ni.unfm_freespace = g_sb.s_blocksize - comingih->ih_item_len - (comingih->ih_key.k_offset % unbh->b_size - 1);
+    brelse (unbh);
+    retval = comingih->ih_item_len;
+  } else {
+    /* coming item is indirect item */
+    if (comingih->ih_key.k_offset + pos * g_sb.s_blocksize != ih->ih_key.k_offset + I_BYTES_NUMBER (ih, g_sb.s_blocksize))
+      die ("reiserfsck_append_file: can not append indirect item (%lu) to position (%lu + %lu)",
+	   comingih->ih_key.k_offset, ih->ih_key.k_offset, I_BYTES_NUMBER (ih, g_sb.s_blocksize));
+
+    /* take unformatted pointer from an indirect item */
+    ni.unfm_nodenum = *(unsigned long *)(item + pos * UNFM_P_SIZE);/*B_I_POS_UNFM_POINTER (bh, ih, pos);*/
+    if (!is_block_used (ni.unfm_nodenum) && !is_block_uninsertable (ni.unfm_nodenum)) {
+      mark_block_used (ni.unfm_nodenum);
+
+      /* this is for check only */
+      mark_block_unformatted (ni.unfm_nodenum);
+    } else {
+      ni.unfm_nodenum = 0;
+    }
+    ni.unfm_freespace = ((pos == (I_UNFM_NUM (comingih) - 1)) ? comingih->u.ih_free_space : 0);
+    retval = g_sb.s_blocksize - ni.unfm_freespace;
+  }
+
+  reiserfsck_paste_into_item (path, (const char *)&ni, UNFM_P_SIZE);
+  return retval;
+}
+
+
+int must_there_be_a_hole (struct item_head * comingih, struct path * path)
+{
+  struct item_head * ih = PATH_PITEM_HEAD (path);
+  int keep_free_space;
+
+  if (I_IS_DIRECT_ITEM (ih)) {
+    direct2indirect (0, path, keep_free_space = 1);
+    ih = PATH_PITEM_HEAD (path);
+  }
+
+  path->pos_in_item = I_UNFM_NUM (ih);
+  if (ih->ih_key.k_offset + (I_UNFM_NUM (ih) + 1) * g_sb.s_blocksize <= comingih->ih_key.k_offset)
+    return 1;
+
+  return 0;
+}
+
+
+int reiserfs_append_zero_unfm_ptr (struct path * path)
+{
+  struct unfm_nodeinfo ni;
+  int keep_free_space;
+
+  ni.unfm_nodenum = 0;
+  ni.unfm_freespace = 0;
+
+  if (I_IS_DIRECT_ITEM (PATH_PITEM_HEAD (path)))
+    /* convert direct item to indirect */
+    direct2indirect (0, path, keep_free_space = 0);
+
+  reiserfsck_paste_into_item (path, (const char *)&ni, UNFM_P_SIZE);
+  return 0;
+}
+
+
+/* write direct item to unformatted node */
+static int overwrite_by_direct_item (struct item_head * comingih, char * item, struct path * path)
+{
+  unsigned long unfm_ptr;
+  struct buffer_head * unbh, * bh;
+  struct item_head * ih;
+  int offset;
+
+  bh = PATH_PLAST_BUFFER (path);
+  ih = PATH_PITEM_HEAD (path);
+  unfm_ptr = B_I_POS_UNFM_POINTER (bh, ih, path->pos_in_item);
+  if (unfm_ptr == 0 || unfm_ptr >= SB_BLOCK_COUNT (&g_sb)) {
+    unbh = reiserfsck_get_new_buffer (PATH_PLAST_BUFFER (path)->b_blocknr);
+    B_I_POS_UNFM_POINTER (bh, ih, path->pos_in_item) = unbh->b_blocknr;
+/* this is for check only */
+mark_block_unformatted (unbh->b_blocknr);
+    mark_buffer_dirty (bh, 0);
+  }
+  else {
+    unbh = bread (g_sb.s_dev, unfm_ptr, bh->b_size);
+    if (!is_block_used (unfm_ptr))
+      die ("overwrite_by_direct_item: unused block %d", unfm_ptr);
+  }
+
+  offset = comingih->ih_key.k_offset % bh->b_size - 1;
+  if (offset + comingih->ih_item_len > MAX_DIRECT_ITEM_LEN (bh->b_size))
+    die ("overwrite_by_direct_item: direct item too long (offset=%lu, length=%u)", comingih->ih_key.k_offset, comingih->ih_item_len);
+
+  memcpy (unbh->b_data + offset, item, comingih->ih_item_len);
+
+  save_unfm_overwriting (unbh->b_blocknr, comingih);
+
+  if (path->pos_in_item == I_UNFM_NUM (ih) - 1 && (bh->b_size - ih->u.ih_free_space) < (offset + comingih->ih_item_len)) {
+    ih->u.ih_free_space = bh->b_size - (offset + comingih->ih_item_len);
+    mark_buffer_dirty (bh, 0);
+  }
+  mark_buffer_dirty (unbh, 0);
+  mark_buffer_uptodate (unbh, 0);
+  brelse (unbh);
+  return comingih->ih_item_len;
+}
+
+
+
+void overwrite_unfm_by_unfm (unsigned long unfm_in_tree, unsigned long coming_unfm, int bytes_in_unfm)
+{
+  struct overwritten_unfm_segment * unfm_os_list;/* list of overwritten segments of the unformatted node */
+  struct overwritten_unfm_segment unoverwritten_segment;
+  struct buffer_head * bh_in_tree, * coming_bh;
+
+  if (!test_bit (coming_unfm % (g_sb.s_blocksize * 8), SB_AP_BITMAP (&g_sb)[coming_unfm / (g_sb.s_blocksize * 8)]->b_data))
+    /* block (pointed by indirect item) is free, we do not have to keep its contents */
+    return;
+
+  /* coming block is marked as used in disk bitmap. Put its contents to block in tree preserving
+     everything, what has been overwritten there by direct items */
+  unfm_os_list = find_overwritten_unfm (unfm_in_tree, bytes_in_unfm, &unoverwritten_segment);
+  if (unfm_os_list) {
+    add_event (UNFM_OVERWRITING_UNFM);
+    bh_in_tree = bread (g_sb.s_dev, unfm_in_tree, g_sb.s_blocksize);
+    coming_bh = bread (g_sb.s_dev, coming_unfm, g_sb.s_blocksize);
+    
+    while (get_unoverwritten_segment (unfm_os_list, &unoverwritten_segment)) {
+      if (unoverwritten_segment.ous_begin < 0 || unoverwritten_segment.ous_end > bytes_in_unfm - 1 ||
+	  unoverwritten_segment.ous_begin > unoverwritten_segment.ous_end)
+	die ("overwrite_unfm_by_unfm: invalid segment found (%d %d)", unoverwritten_segment.ous_begin, unoverwritten_segment.ous_end);
+
+      memcpy (bh_in_tree->b_data + unoverwritten_segment.ous_begin, coming_bh->b_data + unoverwritten_segment.ous_begin,
+	      unoverwritten_segment.ous_end - unoverwritten_segment.ous_begin + 1);
+      mark_buffer_dirty (bh_in_tree, 0);
+    }
+
+    brelse (bh_in_tree);
+    brelse (coming_bh);
+  }
+}
+
+
+/* put unformatted node pointers from incoming item over the in-tree ones */
+static int overwrite_by_indirect_item (struct item_head * comingih, unsigned long * coming_item, struct path * path, int * pos_in_coming_item)
+{
+  struct buffer_head * bh = PATH_PLAST_BUFFER (path);
+  struct item_head * ih = PATH_PITEM_HEAD (path);
+  int written;
+  unsigned long * item_in_tree;
+  int src_unfm_ptrs, dest_unfm_ptrs, to_copy;
+  int i;
+
+
+  item_in_tree = (unsigned long *)B_I_PITEM (bh, ih) + path->pos_in_item;
+  coming_item += *pos_in_coming_item;
+
+  dest_unfm_ptrs = I_UNFM_NUM (ih) - path->pos_in_item;
+  src_unfm_ptrs = I_UNFM_NUM (comingih) - *pos_in_coming_item;
+  
+  if (dest_unfm_ptrs >= src_unfm_ptrs) {
+    /* whole coming item (comingih) fits into item in tree (ih) starting with path->pos_in_item */
+    written = I_BYTES_NUMBER (comingih, g_sb.s_blocksize) - *pos_in_coming_item * g_sb.s_blocksize;
+    *pos_in_coming_item = I_UNFM_NUM (comingih);
+    to_copy = src_unfm_ptrs;
+    if (dest_unfm_ptrs == src_unfm_ptrs)
+      ih->u.ih_free_space = comingih->u.ih_free_space;/*??*/
+  } else {
+    /* only part of coming item overlaps item in the tree */
+    *pos_in_coming_item += dest_unfm_ptrs;
+    written = dest_unfm_ptrs * g_sb.s_blocksize;
+    to_copy = dest_unfm_ptrs;
+    ih->u.ih_free_space = 0;
+  }
+  
+  for (i = 0; i < to_copy; i ++) {
+    if (!is_block_used (coming_item[i]) && !is_block_uninsertable (coming_item[i])) {
+      if (item_in_tree[i]) {
+	/* do not overwrite unformatted pointer. We must save everything what is there already from
+           direct items */
+	overwrite_unfm_by_unfm (item_in_tree[i], coming_item[i], g_sb.s_blocksize);
+      } else {
+	item_in_tree[i] = coming_item[i];
+	mark_block_used (coming_item[i]);
+/* this is for check only */
+mark_block_unformatted (coming_item[i]);
+      }
+    }
+  }
+  mark_buffer_dirty (bh, 0);
+  return written;
+}
+
+
+int reiserfsck_overwrite_file (struct item_head * comingih, char * item, struct path * path, int * pos_in_coming_item)
+{
+  __u32 unfm_ptr;
+  int written = 0;
+  int keep_free_space;
+  struct item_head * ih = PATH_PITEM_HEAD (path);
+
+  if (comp_short_keys (ih, &(comingih->ih_key)) != KEYS_IDENTICAL)
+    die ("reiserfsck_overwrite_file: found [%lu %lu], new item [%lu %lu]", ih->ih_key.k_dir_id, ih->ih_key.k_objectid,
+	 comingih->ih_key.k_dir_id, comingih->ih_key.k_objectid);
+  
+  if (I_IS_DIRECT_ITEM (ih)) {
+    unfm_ptr = 0;
+    if (I_IS_INDIRECT_ITEM (comingih)) {
+      if (ih->ih_key.k_offset % g_sb.s_blocksize != 1)
+	die ("reiserfsck_overwrite_file: second part of tail can not be overwritten by indirect item");
+      /* use pointer from coming indirect item */
+      unfm_ptr = *(__u32 *)(item + *pos_in_coming_item * UNFM_P_SIZE);
+      if (unfm_ptr >= SB_BLOCK_COUNT (&g_sb) || is_block_used (unfm_ptr) || 
+	  !was_block_used (unfm_ptr) || is_block_uninsertable (unfm_ptr))
+	unfm_ptr = 0;
+    }
+    /* */
+    direct2indirect (unfm_ptr, path, keep_free_space = 1);
+  }
+
+  if (I_IS_DIRECT_ITEM (comingih)) {
+    written = overwrite_by_direct_item (comingih, item, path);
+  } else {
+    written = overwrite_by_indirect_item (comingih, (unsigned long *)item, path, pos_in_coming_item);
+  }
+
+  return written;
+}
+
+
+/*
+ */
+int reiserfsck_file_write (struct item_head * ih, char * item)
+{
+  struct path path;
+  struct item_head * path_ih;
+  int count, pos_in_coming_item;
+  int retval;
+  struct key key;
+  int written;
+
+  if (make_file_writeable (ih) == -1)
+    /* write was not completed. Skip that item. Maybe it should be
+       saved to lost_found */
+    return 0;
+
+  count = I_BYTES_NUMBER (ih, g_sb.s_blocksize);
+  pos_in_coming_item = 0;
+
+  copy_key (&key, &(ih->ih_key));
+  while (count) {
+    retval = usearch_by_position (&g_sb, &key, &path);
+    if (retval == DIRECTORY_FOUND) {
+      pathrelse (&path);
+      return 0;
+    }
+    if (retval == BYTE_FOUND) {
+      written = reiserfsck_overwrite_file (ih, item, &path, &pos_in_coming_item);
+      count -= written;
+      key.k_offset += written;
+    }
+    if (retval == FILE_NOT_FOUND) {
+      written = create_first_item_of_file (ih, item, &path, &pos_in_coming_item);
+      count -= written;
+      key.k_offset += written;
+    }
+    if (retval == BYTE_NOT_FOUND) {
+      path_ih = PATH_PITEM_HEAD (&path);
+      if (must_there_be_a_hole (ih, &path) == 1)
+	reiserfs_append_zero_unfm_ptr (&path);
+      else {
+	count -= reiserfsck_append_file (ih, item, pos_in_coming_item, &path);
+	key.k_offset += g_sb.s_blocksize;
+	pos_in_coming_item ++;
+      }
+    }
+    if (count < 0)
+      die ("reiserfsck_file_write: count < 0 (%d)", count);
+    pathrelse (&path);
+  }
+  
+  return I_BYTES_NUMBER (ih, g_sb.s_blocksize);
+}
+
+
+
Index: empeg/kernel/fs/reiserfs/utils/fsck/uobjectid.c
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/fsck/uobjectid.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/fsck/uobjectid.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,236 @@
+/*
+ * Copyright 1996, 1997, 2000 Hans Reiser
+ */
+#include "fsck.h"
+
+
+#if 0 /* original function */
+//
+// FIXME: we are going to turn reuse of objectids back
+//
+objectid_t get_unused_objectid (struct super_block * s)
+{
+    objectid_t * map, objectid;
+
+    map = (objectid_t *)(SB_DISK_SUPER_BLOCK (s) + 1);
+    objectid = map[1];
+    if (objectid == TYPE_INDIRECT)
+	die ("get_unused_objectid: no more objectids");
+
+    map[1] ++;
+    return objectid;
+}
+#endif
+
+/* stolen from reiserfs/objectid.c  --clm */
+objectid_t get_unused_objectid (struct super_block * s)
+{
+  objectid_t unused_objectid;
+  struct reiserfs_super_block * disk_sb;
+  objectid_t * objectid_map;
+
+
+  disk_sb = SB_DISK_SUPER_BLOCK (s);
+
+  /* The objectid map follows the superblock. */
+  objectid_map = (objectid_t *)(disk_sb + 1); 
+ 
+  unused_objectid = objectid_map[1]; /* commented more below */
+  if (unused_objectid == TYPE_INDIRECT) {
+    printf ("REISERFS: get_objectid: no more object ids\n");
+    return 0;
+  }
+
+  /* This incrementation allocates the first unused objectid. That is to say, 
+     the first entry on the objectid map is the first unused objectid, and 
+     by incrementing it we use it.  See below where we check to see if we 
+     eliminated a sequence of unused objectids.... */
+
+  objectid_map[1] ++;
+
+  /* Now we check to see if we eliminated the last remaining member of
+     the first even sequence (and can eliminate the sequence by
+     eliminating its last objectid from oids), and can collapse the
+     first two odd sequences into one sequence.  If so, then the net
+     result is to eliminate a pair of objectids from oids.  We do this
+     by shifting the entire map to the left. */
+  if (disk_sb->s_oid_cursize > 2 && objectid_map[1] == objectid_map[2]) {
+    memmove (objectid_map + 1, objectid_map + 3, (disk_sb->s_oid_cursize - 3) * sizeof(unsigned long));
+    disk_sb->s_oid_cursize -= 2;
+  }
+
+  return unused_objectid;
+}
+
+int is_objectid_used (unsigned long objectid)
+{
+  unsigned long * objectid_map;
+  int i = 0;
+
+  objectid_map = (unsigned long *)(SB_DISK_SUPER_BLOCK (&g_sb) + 1);
+
+  while (i < SB_DISK_SUPER_BLOCK (&g_sb)->s_oid_cursize) {
+    if (objectid == objectid_map[i]) {
+      return 1;      /* objectid is used */
+    }
+    
+    if (objectid > objectid_map[i] && objectid < objectid_map[i+1]) {
+      return 1;	/* objectid is used */
+    }
+
+    if (objectid < objectid_map[i])
+      break;
+
+    i += 2;
+  }
+  
+  /* objectid is free */
+  return 0;
+}
+
+
+/* we mark objectid as used. Additionally, some unused objectids can
+   become used. It is ok. What is unacceptable, it is when used
+   objectids are marked as unused */
+void mark_objectid_as_used (unsigned long objectid)
+{
+  int i;
+  unsigned long * objectid_map;
+
+  if (is_objectid_used (objectid) == 1) {
+    
+    /*print_objectid_map (&g_sb);*/
+    /*printf ("mark_objectid_as_used: objectid %lu is used", objectid);*/
+    return;
+  }
+
+  objectid_map = (unsigned long *)(SB_DISK_SUPER_BLOCK (&g_sb) + 1);
+
+  for (i = 0; i < SB_DISK_SUPER_BLOCK (&g_sb)->s_oid_cursize; i += 2) {
+    if (objectid >= objectid_map [i] && objectid < objectid_map [i + 1])
+      /* it is used */
+      return;
+
+    if (objectid + 1 == objectid_map[i]) {
+      /* size of objectid map is the same */
+      objectid_map[i] = objectid;
+      return;
+    }
+
+    if (objectid == objectid_map[i + 1]) {
+      /* size of objectid map is decreased */
+      objectid_map[i + 1] ++;
+      if (i + 2 < SB_DISK_SUPER_BLOCK (&g_sb)->s_oid_cursize) {
+	if (objectid_map[i + 1] == objectid_map[i + 2]) {
+	  memmove (objectid_map + i + 1, objectid_map + i + 1 + 2, 
+		   (SB_DISK_SUPER_BLOCK (&g_sb)->s_oid_cursize - (i + 2 + 2 - 1)) * sizeof (unsigned long));
+	  SB_DISK_SUPER_BLOCK (&g_sb)->s_oid_cursize -= 2;
+	}
+      }
+      return;
+    }
+    
+    if (objectid < objectid_map[i]) {
+      /* size of objectid map must be increased */
+      if (SB_DISK_SUPER_BLOCK (&g_sb)->s_oid_cursize == SB_DISK_SUPER_BLOCK (&g_sb)->s_oid_maxsize) {
+	/* here all objectids between objectid and objectid_map[i] get used */
+	objectid_map[i] = objectid;
+	return;
+      } else {
+	memmove (objectid_map + i + 2, objectid_map + i, (SB_DISK_SUPER_BLOCK (&g_sb)->s_oid_cursize - i) * sizeof (unsigned long));
+	SB_DISK_SUPER_BLOCK (&g_sb)->s_oid_cursize += 2;
+      }
+      
+      objectid_map[i] = objectid;
+      objectid_map[i+1] = objectid + 1;
+      return;
+    }
+
+  }
+  
+  /* write out of current objectid map, if we have space */
+  if (i < SB_DISK_SUPER_BLOCK (&g_sb)->s_oid_maxsize) {
+    objectid_map[i] = objectid;
+    objectid_map[i + 1] = objectid + 1;
+    SB_DISK_SUPER_BLOCK (&g_sb)->s_oid_cursize += 2;
+  } else if (i == SB_DISK_SUPER_BLOCK (&g_sb)->s_oid_maxsize) {
+    objectid_map[i - 1] = objectid + 1;
+  } else
+    die ("mark_objectid_as_used: objectid map corrupted");
+  
+  return;
+}
+
+
+#if 0 /* haven't checked this code carefully enough yet */
+void mark_objectid_as_free (unsigned long objectid)
+{
+  unsigned long * oids; /* pointer to objectid map */
+  int i = 0;
+
+  oids = (unsigned long *)(SB_DISK_SUPER_BLOCK (&g_sb) + 1);
+
+  while (i < SB_DISK_SUPER_BLOCK (&g_sb)->s_oid_cursize)
+    {
+      if (objectid == oids[i])
+	{
+	  if (i == 0)
+	    die ("mark_objectid_as_free: trying to free root object id");
+	  oids[i]++;
+
+	  if (oids[i] == oids[i+1])
+	    {
+	      /* shrink objectid map */
+	      if (SB_DISK_SUPER_BLOCK (&g_sb)->s_oid_cursize < i + 2)
+		die ("mark_objectid_as_free: bad cur size");
+
+	      memmove (oids + i, oids + i + 2, (SB_DISK_SUPER_BLOCK (&g_sb)->s_oid_cursize - i - 2) * sizeof (unsigned long));
+	      SB_DISK_SUPER_BLOCK (&g_sb)->s_oid_cursize -= 2;
+	      if (SB_DISK_SUPER_BLOCK (&g_sb)->s_oid_cursize < 2 || SB_DISK_SUPER_BLOCK (&g_sb)->s_oid_cursize > SB_DISK_SUPER_BLOCK (&g_sb)->s_oid_maxsize)
+		die("mark_objectid_as_free: bad cur size");
+	    }
+	  return;
+	}
+
+      if (objectid > oids[i] && objectid < oids[i+1])
+	{
+	  /* size of objectid map is not changed */
+	  if (objectid + 1 == oids[i+1])
+	    {
+	      oids[i+1]--;
+	      return;
+	    }
+
+	  if (SB_DISK_SUPER_BLOCK (&g_sb)->s_oid_cursize == SB_DISK_SUPER_BLOCK (&g_sb)->s_oid_maxsize)
+	    /* objectid map must be expanded, but there is no space */
+	    return;
+
+	  /* expand the objectid map*/
+	  memmove (oids + i + 3, oids + i + 1, (SB_DISK_SUPER_BLOCK (&g_sb)->s_oid_cursize - i - 1) * sizeof (unsigned long));
+	  oids[i+1] = objectid;
+	  oids[i+2] = objectid + 1;
+	  SB_DISK_SUPER_BLOCK (&g_sb)->s_oid_cursize += 2;
+	  if (SB_DISK_SUPER_BLOCK (&g_sb)->s_oid_cursize < 2 || SB_DISK_SUPER_BLOCK (&g_sb)->s_oid_cursize > SB_DISK_SUPER_BLOCK (&g_sb)->s_oid_maxsize)
+	    die ("objectid_release: bad cur size");
+	  return;
+	}
+      i += 2;
+    }
+
+  die ("objectid_release: trying to free free object id (%lu)", objectid);
+}
+
+/* original function that does not use the objectid map */
+void mark_objectid_as_used (unsigned long objectid)
+{
+  unsigned long * objectid_map;
+  
+
+  objectid_map = (unsigned long *)(SB_DISK_SUPER_BLOCK (&g_sb) + 1);
+  if (objectid >= objectid_map[1]) {
+      objectid_map[1] = objectid + 1;
+  }
+
+}
+
+#endif 
Index: empeg/kernel/fs/reiserfs/utils/fsck/ustree.c
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/fsck/ustree.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/fsck/ustree.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,443 @@
+/*
+ * Copyright 1996, 1997 Hans Reiser
+ */
+/*#include <stdio.h>
+#include <string.h>*/
+/*#include <asm/bitops.h>
+#include "../include/reiserfs_fs.h"
+#include "../include/reiserfs_fs_sb.h"
+#include "../include/reiserfslib.h"*/
+#include "fsck.h"
+
+static inline int compare_keys (unsigned long * key1, unsigned long * key2, int length)
+{
+  for (; length--; ++key1, ++key2) {
+    if ( *key1 < *key2 )
+      return SECOND_GREATER;
+    if ( *key1 > *key2 )
+      return FIRST_GREATER;
+  }
+  
+  return KEYS_IDENTICAL;
+}
+
+
+/* compare 3 components of key */
+int comp_keys_3 (void * key1, void * key2)
+{
+  return compare_keys (key1, key2, 3);
+}
+
+
+/* compare 4 components of key */
+int comp_dir_entries (void * key1, void * key2)
+{
+  return compare_keys (key1, key2, 1);
+}
+
+void init_tb_struct (struct tree_balance * tb, struct super_block  * s, struct path * path, int size)
+{
+  memset (tb, '\0', sizeof(struct tree_balance));
+  tb->tb_sb = s;
+  tb->tb_path = path;
+  PATH_OFFSET_PBUFFER(path, ILLEGAL_PATH_ELEMENT_OFFSET) = NULL;
+  PATH_OFFSET_POSITION(path, ILLEGAL_PATH_ELEMENT_OFFSET) = 0;
+  tb->insert_size[0] = size;
+}
+
+struct tree_balance * cur_tb = 0;
+
+void reiserfsck_paste_into_item (struct path * path, const char * body, int size)
+{
+  struct tree_balance tb;
+  
+  init_tb_struct (&tb, &g_sb, path, size);
+  if (fix_nodes (0/*th*/, M_PASTE, &tb, path->pos_in_item, 0) != CARRY_ON)
+    die ("reiserfsck_paste_into_item: fix_nodes failed");
+
+  do_balance (0/*th*/, &tb, path->pos_in_item, 0, body, M_PASTE, REISERFS_KERNEL_MEM, 0);
+}
+
+
+void reiserfsck_insert_item (struct path * path, struct item_head * ih, const char * body)
+{
+  struct tree_balance tb;
+
+  init_tb_struct (&tb, &g_sb, path, IH_SIZE + ih->ih_item_len);
+  if (fix_nodes (0/*th*/, M_INSERT, &tb, 0, ih) != CARRY_ON)
+    die ("reiserfsck_insert_item: fix_nodes failed");
+
+  do_balance (0/*th*/, &tb, 0, ih, body, M_INSERT, REISERFS_KERNEL_MEM, 0);
+}
+
+
+static void free_unformatted_nodes (struct item_head * ih, struct buffer_head * bh)
+{
+  unsigned long * punfm = (unsigned long *)B_I_PITEM (bh, ih);
+  int i;
+
+  for (i = 0; i < I_UNFM_NUM (ih); i ++, punfm ++)
+    if (*punfm) {
+      struct buffer_head * to_be_forgotten;
+
+      to_be_forgotten = find_buffer (g_sb.s_dev, *punfm, g_sb.s_blocksize);
+      if (to_be_forgotten) {
+	to_be_forgotten->b_count ++;
+	bforget (to_be_forgotten);
+      }
+      reiserfs_free_block (0/*th*/, &g_sb, *punfm);
+/* this is for check only */
+      unmark_block_unformatted (*punfm);
+    }
+}
+
+
+void reiserfsck_delete_item (struct path * path)
+{
+  struct tree_balance tb;
+  struct item_head * ih = PATH_PITEM_HEAD (path);
+
+  if (I_IS_INDIRECT_ITEM (ih))
+    free_unformatted_nodes (ih, PATH_PLAST_BUFFER (path));
+
+  init_tb_struct (&tb, &g_sb, path, -(IH_SIZE + ih->ih_item_len));
+  if (fix_nodes (0/*th*/, M_DELETE, &tb, 0, 0) != CARRY_ON)
+    die ("reiserfsck_delete_item: fix_nodes failed");
+
+  do_balance (0/*th*/, &tb, 0, 0, 0, M_DELETE, REISERFS_KERNEL_MEM, 0);
+}
+
+
+void reiserfsck_cut_from_item (struct path * path, int cut_size)
+{
+  struct tree_balance tb;
+  struct item_head * ih;
+
+  if (cut_size >= 0)
+    die ("reiserfsck_cut_from_item: cut size == %d", cut_size);
+
+  if (I_IS_INDIRECT_ITEM (ih = PATH_PITEM_HEAD (path))) {
+    __u32 unfm_ptr = B_I_POS_UNFM_POINTER (PATH_PLAST_BUFFER (path), ih, I_UNFM_NUM (ih) - 1);
+    if (unfm_ptr) {
+      struct buffer_head * to_be_forgotten;
+
+      to_be_forgotten = find_buffer (g_sb.s_dev, unfm_ptr, g_sb.s_blocksize);
+      if (to_be_forgotten) {
+        to_be_forgotten->b_count ++;
+        bforget (to_be_forgotten);
+      }
+      reiserfs_free_block (0/*th*/, &g_sb, unfm_ptr);
+/* this is for check only */
+      unmark_block_unformatted (unfm_ptr);
+    }
+  }
+
+
+  init_tb_struct (&tb, &g_sb, path, cut_size);
+  if (fix_nodes (0/*th*/, M_CUT, &tb, path->pos_in_item, 0) != CARRY_ON)
+    die ("reiserfsck_cut_from_item: fix_nodes failed");
+
+  do_balance (0/*th*/, &tb, path->pos_in_item, 0, 0, M_CUT, REISERFS_KERNEL_MEM, 0);
+}
+
+
+/* uget_lkey is utils clone of stree.c/get_lkey */
+struct key * uget_lkey (struct path * path)
+{
+  int pos, offset = path->path_length;
+  struct buffer_head * bh;
+  
+  if (offset < FIRST_PATH_ELEMENT_OFFSET)
+    die ("uget_lkey: illegal offset in the path (%d)", offset);
+
+
+  /* While not higher in path than first element. */
+  while (offset-- > FIRST_PATH_ELEMENT_OFFSET) {
+    if (! buffer_uptodate (PATH_OFFSET_PBUFFER (path, offset)) )
+      die ("uget_lkey: parent is not uptodate");
+
+    /* Parent at the path is not in the tree now. */
+    if (! B_IS_IN_TREE (bh = PATH_OFFSET_PBUFFER (path, offset)))
+      die ("uget_lkey: buffer on the path is not in tree");
+
+    /* Check whether position in the parent is correct. */
+    if ((pos = PATH_OFFSET_POSITION (path, offset)) > B_NR_ITEMS (bh))
+      die ("uget_lkey: invalid position (%d) in the path", pos);
+
+    /* Check whether parent at the path really points to the child. */
+    if (B_N_CHILD_NUM (bh, pos) != PATH_OFFSET_PBUFFER (path, offset + 1)->b_blocknr)
+      die ("uget_lkey: invalid block number (%d). Must be %d",
+	   B_N_CHILD_NUM (bh, pos), PATH_OFFSET_PBUFFER (path, offset + 1)->b_blocknr);
+
+    /* Return delimiting key if position in the parent is not equal to zero. */
+    if (pos)
+      return B_N_PDELIM_KEY(bh, pos - 1);
+  }
+
+  /* we must be in the root */
+/*
+  if (PATH_OFFSET_PBUFFER (path, FIRST_PATH_ELEMENT_OFFSET)->b_blocknr != SB_ROOT_BLOCK (&g_sb))
+    die ("get_left_dkey: path does not start with the root");
+*/
+
+  /* there is no left delimiting key */
+  return 0;
+}
+
+
+/* uget_rkey is utils clone of stree.c/get_rkey */
+struct key * uget_rkey (struct path * path)
+{
+  int pos, offset = path->path_length;
+  struct buffer_head * bh;
+
+  if (offset < FIRST_PATH_ELEMENT_OFFSET)
+    die ("uget_rkey: illegal offset in the path (%d)", offset);
+
+  while (offset-- > FIRST_PATH_ELEMENT_OFFSET) {
+    if (! buffer_uptodate (PATH_OFFSET_PBUFFER (path, offset)))
+      die ("uget_rkey: parent is not uptodate");
+
+    /* Parent at the path is not in the tree now. */
+    if (! B_IS_IN_TREE (bh = PATH_OFFSET_PBUFFER (path, offset)))
+      die ("uget_rkey: buffer on the path is not in tree");
+
+    /* Check whether position in the parrent is correct. */
+    if ((pos = PATH_OFFSET_POSITION (path, offset)) > B_NR_ITEMS (bh))
+      die ("uget_rkey: invalid position (%d) in the path", pos);
+
+    /* Check whether parent at the path really points to the child. */
+    if (B_N_CHILD_NUM (bh, pos) != PATH_OFFSET_PBUFFER (path, offset + 1)->b_blocknr)
+      die ("uget_rkey: invalid block number (%d). Must be %d",
+	   B_N_CHILD_NUM (bh, pos), PATH_OFFSET_PBUFFER (path, offset + 1)->b_blocknr);
+
+    /* Return delimiting key if position in the parent is not the last one. */
+    if (pos != B_NR_ITEMS (bh))
+      return B_N_PDELIM_KEY(bh, pos);
+  }
+
+  /* we must be in the root */
+/*
+  if (PATH_OFFSET_PBUFFER (path, FIRST_PATH_ELEMENT_OFFSET)->b_blocknr != SB_ROOT_BLOCK (&g_sb))
+    die ("get_left_dkey: path does not start with the root");
+*/
+  /* there is no right delimiting key */
+  return 0;
+}
+
+
+static inline int ubin_search (void * key, void * base, int num, int width, int *ppos, comp_function_t comp_func)
+{
+  int   rbound, lbound, j;
+  
+  lbound = 0;
+  rbound = num - 1;
+  for (j = (rbound + lbound) / 2; lbound <= rbound; j = (rbound + lbound) / 2) {
+    switch (comp_func ((void *)((char *)base + j * width), key ) ) {
+    case SECOND_GREATER:
+      lbound = j + 1; 
+      continue;
+
+    case FIRST_GREATER:
+      rbound = j - 1;
+      continue;
+
+    case KEYS_IDENTICAL:
+      *ppos = j;
+      return KEY_FOUND;
+    }
+  }
+
+  *ppos = lbound;
+  return KEY_NOT_FOUND;
+}
+
+
+/* this searches in tree through items */
+int usearch_by_key (struct super_block * s, struct key * key, struct path * path, int * repeat, int stop_level, int bread_par, 
+		   comp_function_t comp_func)
+{
+  struct buffer_head * bh;
+  unsigned long block = s->u.reiserfs_sb.s_rs->s_root_block;
+  struct path_element * curr;
+
+  if (comp_func == 0)
+    comp_func = comp_keys;
+  if (repeat)
+    *repeat = CARRY_ON;
+
+  path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;
+  while (1) {
+    curr = PATH_OFFSET_PELEMENT (path, ++ path->path_length);
+    bh = curr->pe_buffer = bread (s->s_dev, block, s->s_blocksize);
+    if (ubin_search (key, B_N_PKEY (bh, 0), B_NR_ITEMS (bh),
+		    B_IS_ITEMS_LEVEL (bh) ? IH_SIZE : KEY_SIZE, &(curr->pe_position), comp_func) == KEY_FOUND) {
+      /* key found, return if this is leaf level */
+      if (B_BLK_HEAD (bh)->blk_level <= stop_level) {
+	path->pos_in_item = 0;
+	return KEY_FOUND;
+      }
+      curr->pe_position ++;
+    } else {
+      /* key not found in the node */
+      if (B_BLK_HEAD (bh)->blk_level <= stop_level)
+	return KEY_NOT_FOUND;
+    }
+    block = B_N_CHILD_NUM (bh, curr->pe_position);
+  }
+  die ("search_by_key: you can not get here");
+  return 0;
+}
+
+
+/* key is key of directory entry. This searches in tree through items
+   and in the found directory item as well */
+int usearch_by_entry_key (struct super_block * s, struct key * key, struct path * path)
+{
+  struct buffer_head * bh;
+  struct item_head * ih;
+  struct key tmpkey;
+
+  if (usearch_by_key (s, key, path, 0, DISK_LEAF_NODE_LEVEL, 0, comp_keys) == KEY_FOUND) {
+    path->pos_in_item = 0;
+    return ENTRY_FOUND;
+  }
+
+  bh = PATH_PLAST_BUFFER (path);
+  if (PATH_LAST_POSITION (path) == 0) {
+    /* previous item does not exist, that means we are in leftmost
+       leaf of the tree */
+    if (uget_lkey (path) != 0)
+      die ("search_by_entry_key: invalid position after search_by_key");
+    if (comp_short_keys ((unsigned long *)B_N_PKEY (bh, 0), (unsigned long *)key) == KEYS_IDENTICAL) {
+      path->pos_in_item = 0;
+      return ENTRY_NOT_FOUND;
+    }
+    path->pos_in_item = 0;
+    return DIRECTORY_NOT_FOUND;
+  }
+
+  /* take previous item */
+  PATH_LAST_POSITION (path) --;
+  ih = PATH_PITEM_HEAD (path);
+  if (comp_short_keys ((unsigned long *)ih, (unsigned long *)key) != KEYS_IDENTICAL || !I_IS_DIRECTORY_ITEM (ih)) {
+    struct key * next_key;
+
+    PATH_LAST_POSITION (path) ++;
+    /* previous item belongs to another object or is stat data, check next item */
+    if (PATH_LAST_POSITION (path) < B_NR_ITEMS (PATH_PLAST_BUFFER (path))) {
+      /* found item is not last item of the node */
+      next_key = B_N_PKEY (PATH_PLAST_BUFFER (path), PATH_LAST_POSITION (path));
+      if (comp_short_keys ((unsigned long *)next_key, (unsigned long *)key) != KEYS_IDENTICAL) {
+	path->pos_in_item = 0;
+	return DIRECTORY_NOT_FOUND;
+      }
+      if (!KEY_IS_DIRECTORY_KEY (next_key))
+	/* there is an item in the tree, but it is not a directory item */
+	return REGULAR_FILE_FOUND;
+    } else {
+      /* found item is last item of the node */
+      next_key = uget_rkey (path);
+      if (next_key == 0 || comp_short_keys ((unsigned long *)next_key, (unsigned long *)key) != KEYS_IDENTICAL) {
+	/* there is not any part of such directory in the tree */
+	path->pos_in_item = 0;
+	return DIRECTORY_NOT_FOUND;
+      }
+      if (!KEY_IS_DIRECTORY_KEY (next_key))
+	/* there is an item in the tree, but it is not a directory item */
+	return REGULAR_FILE_FOUND;    
+      
+      copy_key (&tmpkey, next_key);
+      pathrelse (path);
+      if (usearch_by_key (s, &tmpkey, path, 0, DISK_LEAF_NODE_LEVEL, 0, comp_keys) != KEY_FOUND || PATH_LAST_POSITION (path) != 0)
+	die ("search_by_entry_key: item not found by corresponding delimiting key");
+    }
+    /* next item is the part of this directory */
+    path->pos_in_item = 0;
+    return ENTRY_NOT_FOUND;
+  }
+
+  /* previous item is part of desired directory */
+  if (ubin_search (&(key->k_offset), B_I_DEH (bh, ih), I_ENTRY_COUNT (ih), DEH_SIZE, &(path->pos_in_item), comp_dir_entries) == KEY_FOUND)
+    return ENTRY_FOUND;
+  return ENTRY_NOT_FOUND;
+}
+
+
+/* key is key of byte in the regular file. This searches in tree
+   through items and in the found item as well */
+int usearch_by_position (struct super_block * s, struct key * key, struct path * path)
+{
+  struct buffer_head * bh;
+  struct item_head * ih;
+
+  if (usearch_by_key (s, key, path, 0, DISK_LEAF_NODE_LEVEL, 0, comp_keys_3) == KEY_FOUND) {
+    ih = PATH_PITEM_HEAD (path);
+    if (!I_IS_DIRECT_ITEM (ih) && !I_IS_INDIRECT_ITEM (ih))
+      return DIRECTORY_FOUND;
+    path->pos_in_item = 0;
+    return BYTE_FOUND;
+  }
+
+  bh = PATH_PLAST_BUFFER (path);
+  ih = PATH_PITEM_HEAD (path);
+  if (PATH_LAST_POSITION (path) == 0) {
+    /* previous item does not exist, that means we are in leftmost leaf of the tree */
+    if (comp_short_keys ((unsigned long *)B_N_PKEY (bh, 0), (unsigned long *)key) == KEYS_IDENTICAL) {
+      if (!I_IS_DIRECT_ITEM (ih) && !I_IS_INDIRECT_ITEM (ih))
+	return DIRECTORY_FOUND;
+      return BYTE_NOT_FOUND;
+    }
+    return FILE_NOT_FOUND;
+  }
+
+  /* take previous item */
+  PATH_LAST_POSITION (path) --;
+  ih = PATH_PITEM_HEAD (path);
+  if (comp_short_keys ((unsigned long *)&ih->ih_key, (unsigned long *)key) != KEYS_IDENTICAL ||
+      I_IS_STAT_DATA_ITEM (ih)) {
+    struct key * next_key;
+
+    /* previous item belongs to another object or is a stat data, check next item */
+    PATH_LAST_POSITION (path) ++;
+    if (PATH_LAST_POSITION (path) < B_NR_ITEMS (PATH_PLAST_BUFFER (path)))
+      /* next key is in the same node */
+      next_key = B_N_PKEY (PATH_PLAST_BUFFER (path), PATH_LAST_POSITION (path));
+    else
+      next_key = uget_rkey (path);
+    if (next_key == 0 || comp_short_keys ((unsigned long *)next_key, (unsigned long *)key) != KEYS_IDENTICAL) {
+      /* there is no any part of such file in the tree */
+      path->pos_in_item = 0;
+      return FILE_NOT_FOUND;
+    }
+
+    if (KEY_IS_DIRECTORY_KEY (next_key)) {
+      reiserfs_warning ("\ndirectory with the same key %d found\n", next_key);
+      return DIRECTORY_FOUND;
+    }
+    /* next item is the part of this file */
+    path->pos_in_item = 0;
+    return BYTE_NOT_FOUND;
+  }
+
+  if (I_IS_DIRECTORY_ITEM (ih)) {
+    return DIRECTORY_FOUND;
+  }
+  if (I_IS_STAT_DATA_ITEM (ih)) {
+    PATH_LAST_POSITION (path) ++;
+    return FILE_NOT_FOUND;
+  }
+
+  /* previous item is part of desired file */
+  if (I_K_KEY_IN_ITEM (ih, key, bh->b_size)) {
+    path->pos_in_item = key->k_offset - ih->ih_key.k_offset;
+    if ( I_IS_INDIRECT_ITEM (ih) )
+      path->pos_in_item /= bh->b_size;
+    return BYTE_FOUND;
+  }
+
+  path->pos_in_item = I_IS_INDIRECT_ITEM (ih) ? I_UNFM_NUM (ih) : ih->ih_item_len;
+  return BYTE_NOT_FOUND;
+}
+
+
Index: empeg/kernel/fs/reiserfs/utils/include/fsck.h
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/include/fsck.h:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/include/fsck.h	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,262 @@
+/*
+ * Copyright 1996, 1997, 1998 Hans Reiser
+ */
+#include <stdio.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <asm/types.h>
+#include <sys/vfs.h>
+#include <errno.h>
+#include <unistd.h>
+#include <asm/byteorder.h>
+#include <asm/types.h>
+
+#include "inode.h"
+#include "io.h"
+#include "sb.h"
+#include "misc.h"
+#include "reiserfs_fs.h"
+
+
+typedef __u32 blocknr_t;
+
+/* searches.c */
+#define KEY_FOUND 1
+#define KEY_NOT_FOUND 0
+
+#define DIRECTORY_NOT_FOUND -1
+
+#define FILE_NOT_FOUND -1
+
+
+#define reiserfsck_search_by_key(s,key,path,comp_func) search_by_key (s, key, path, 0, DISK_LEAF_NODE_LEVEL, READ_BLOCKS, comp_func)
+
+
+/* main.c */
+int main (int argc, char * argv []);
+
+
+//
+// options
+//
+extern int opt_verbose;
+extern int opt_fsck;
+
+#define FSCK_DEFAULT 0
+#define FSCK_REBUILD 1
+#define FSCK_FIND_ITEM 2
+extern int opt_fsck_mode;
+
+extern struct key key_to_find;
+
+#define STOP_DEFAULT 0
+#define STOP_AFTER_PASS1 1
+#define STOP_AFTER_PASS2 2
+#define STOP_AFTER_SEMANTIC 3
+#define STOP_AFTER_REPLAY 4
+extern int opt_stop_point;
+
+#define SCAN_USED_PART 0
+#define SCAN_WHOLE_PARTITION 1
+extern int opt_what_to_scan;
+
+#define NO_LOST_FOUND 0
+#define DO_LOST_FOUND 1
+extern int opt_lost_found;
+
+
+extern struct super_block g_sb;
+extern struct reiserfs_super_block * g_old_rs;
+extern char ** g_disk_bitmap;
+extern char ** g_new_bitmap;
+extern char ** g_uninsertable_leaf_bitmap;
+extern char ** g_formatted;
+extern char ** g_unformatted;
+extern int g_blocks_to_read;
+
+
+/* pass1.c */
+void build_the_tree (void);
+extern int g_unaccessed_items;
+int is_item_accessed (struct item_head * ih);
+void mark_item_accessed (struct item_head * ih, struct buffer_head * bh);
+void mark_item_unaccessed (struct item_head * ih);
+
+
+/* file.c */
+struct si {
+  struct item_head si_ih;
+  char * si_dnm_data;
+  struct si * si_next;
+};
+void put_saved_items_into_tree (struct si *);
+int reiserfsck_file_write (struct item_head * ih, char * item);
+int are_file_items_correct (struct key * key, unsigned long * size, int mark_passed_items, struct path *, struct stat_data **);
+
+
+/* pass2.c */
+typedef	void (action_on_item_t)(struct si **, struct item_head *, char *);
+action_on_item_t save_item;
+action_on_item_t insert_item_separately;
+void for_all_items_in_node (action_on_item_t action, struct si ** si, struct buffer_head * bh);
+void take_bad_blocks_put_into_tree ();
+void insert_each_item_separately (struct buffer_head *);
+
+
+/* semantic.c */
+extern struct key g_root_directory_key;
+void semantic_pass (void);
+int check_semantic_tree (struct key * key, struct key * parent, int is_dot_dot);
+
+
+
+/* pass4.c */
+int check_unaccessed_items (void);
+void pass4 (struct super_block *);
+
+
+/* check.c */
+int check_file_system (void);
+void reiserfsck_check_pass1 (void);
+void reiserfsck_check_after_all (void);
+int is_leaf_bad (struct buffer_head * bh);
+int is_internal_bad (struct buffer_head * bh);
+
+void check_fs_tree (struct super_block * s);
+
+
+
+/* noname.c */
+void get_max_buffer_key (struct buffer_head * bh, struct key * key);
+
+/* ustree.c */
+void init_tb_struct (struct tree_balance * tb, struct super_block  * s, struct path * path, int size);
+void reiserfsck_paste_into_item (struct path * path, const char * body, int size);
+void reiserfsck_insert_item (struct path * path, struct item_head * ih, const char * body);
+void reiserfsck_delete_item (struct path * path);
+void reiserfsck_cut_from_item (struct path * path, int cut_size);
+typedef	int (comp_function_t)(void * key1, void * key2);
+int usearch_by_key (struct super_block * s, struct key * key, struct path * path, int * repeat, int stop_level, int bread_par, 
+		   comp_function_t comp_func);
+int usearch_by_entry_key (struct super_block * s, struct key * key, struct path * path);
+int usearch_by_position (struct super_block * s, struct key * key, struct path * path);
+struct key * uget_lkey (struct path * path);
+struct key * uget_rkey (struct path * path);
+int comp_keys_3 (void * key1, void * key2);
+int comp_dir_entries (void * key1, void * key2);
+
+
+/* bitmap.c */
+extern int from_journal;
+int reiserfs_new_blocknrs (struct reiserfs_transaction_handle *th, struct super_block * s, unsigned long * free_blocknrs, unsigned long start, int amount_needed, int for_preserve_list);
+void reiserfs_free_block (struct reiserfs_transaction_handle *th, struct super_block * s, unsigned long block);
+void reiserfs_free_internal_block (struct super_block * s, unsigned long block);
+struct buffer_head * reiserfsck_get_new_buffer (unsigned long start);
+void force_freeing (void);
+int is_block_used (unsigned long block);
+int was_block_used (unsigned long block);
+void mark_block_used (unsigned long block);
+void mark_block_uninsertable (unsigned long block);
+int is_block_uninsertable (unsigned long block);
+void mark_block_unformatted (unsigned long block);
+void mark_block_formatted (unsigned long block);
+void unmark_block_unformatted (unsigned long block);
+void unmark_block_formatted (unsigned long block);
+
+/* objectid.c */
+int is_objectid_used (unsigned long objectid);
+void mark_objectid_as_used (unsigned long objectid);
+void mark_objectid_as_free (unsigned long objectid);
+objectid_t get_unused_objectid (struct super_block * s);
+
+
+
+/* segments.c */
+struct overwritten_unfm_segment {
+  int ous_begin;
+  int ous_end;
+  struct overwritten_unfm_segment * ous_next;  
+};
+struct overwritten_unfm * look_for_overwritten_unfm (__u32);
+struct overwritten_unfm_segment * find_overwritten_unfm (unsigned long unfm, int length, struct overwritten_unfm_segment * segment_to_init);
+int get_unoverwritten_segment (struct overwritten_unfm_segment * list_head, struct overwritten_unfm_segment * unoverwritten_segment);
+void save_unfm_overwriting (unsigned long unfm, struct item_head * direct_ih);
+void free_overwritten_unfms (void);
+void mark_formatted_pointed_by_indirect (__u32);
+int is_formatted_pointed_by_indirect (__u32);
+
+
+/* do_balan.c */
+/* lbalance.c */
+/* ibalance.c */	/* links to fs/reiser */
+/* fix_node.c */
+/* teahash3.c */
+
+
+/* info.c */
+struct fsck_stat {
+  /* pass 1,2 */
+  int fs_good_leaves;
+  int fs_uninsertable_leaves;
+  int fs_rewritten_files;
+  int fs_leaves_used_by_indirect_items;
+  int fs_unfm_overwriting_unfm;
+  int fs_indirect_to_direct;
+  /* pass 3 */
+  int fs_incorrect_regular_files;
+  int fs_fixed_size_directories;
+  int fs_fixed_size_files;
+  int fs_deleted_entries;
+  /* pass 4 */
+  int fs_unaccessed_items;
+  int fs_fixed_right_delim_key;
+  /* fs stat */
+  int fs_stat_data_items;
+  int fs_regular_files;
+  int fs_directories;
+  int fs_symlinks;
+  int fs_others;
+};
+  
+
+extern struct fsck_stat g_fsck_info;
+
+/* pass 1,2 */
+#define GOOD_LEAVES 0
+#define UNINSERTABLE_LEAVES 1
+#define REWRITTEN_FILES 2
+#define LEAVES_USED_BY_INDIRECT_ITEMS 3
+#define UNFM_OVERWRITING_UNFM 4		/* overwrite contents of unformatted node keeping what has been written there from direct items */
+
+/* pass 3 (semantic) */
+#define INCORRECT_REGULAR_FILES 5
+#define FIXED_SIZE_DIRECTORIES 6
+#define FIXED_SIZE_FILES 7
+#define DELETED_ENTRIES 8
+#define INDIRECT_TO_DIRECT 9
+
+/* pass 4 */
+#define UNACCESSED_ITEMS 10
+#define FIXED_RIGHT_DELIM_KEY 11
+
+/* fs stat */
+#define STAT_DATA_ITEMS 12
+#define REGULAR_FILES 13
+#define SYMLINKS 14
+#define OTHERS 15
+#define DIRECTORIES 16
+
+void add_event (int event);
+int get_event (int event);
+void output_information ();
+
+
+/* journal.c */
+void replay_all (struct super_block * s);
+/*int get_journal_size (struct super_block * s);
+int get_journal_start (struct super_block * s);*/
+void release_journal_blocks (struct super_block * s);
+void reset_journal (struct super_block * s);
+
Index: empeg/kernel/fs/reiserfs/utils/include/inode.h
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/include/inode.h:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/include/inode.h	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,275 @@
+//
+// ./include/linux/kdev_t.h>
+//
+typedef unsigned long long kdev_t;
+
+//
+// include/asm-i386/spinlock.h
+//
+typedef struct { } spinlock_t;
+#define spin_lock(lock) do {} while (0)
+#define spin_lock_irq(lock) do {} while (0)
+#define spin_unlock(lock) do {} while (0)
+#define spin_unlock_irq(lock) do {} while (0)
+#define read_lock(lock) do {} while (0)
+#define read_unlock(lock) do {} while (0)
+#define write_lock(lock) do {} while (0)
+#define write_unlock(lock) do {} while (0)
+#define spin_lock_init(lock) do {} while(0)
+typedef struct { } rwlock_t;
+
+//
+// include/asm-i386/atomic.h
+//
+typedef struct { int counter; } atomic_t;
+#define atomic_read(v) ((v)->counter)
+#define atomic_set(v,i) (((v)->counter) = i)
+#define atomic_inc(v) (((v)->counter)++)
+#define atomic_dec(v) (((v)->counter)--)
+
+//
+// include/linux/signal.h
+//
+#define sigfillset(set) do {} while (0)
+typedef unsigned long sigset_t; 
+
+
+//
+// ??
+//
+struct qstr {
+  const unsigned char * name;
+  unsigned int len;
+  unsigned int hash;
+};
+
+struct dentry {
+  struct inode * d_inode;
+  struct qstr d_name;
+  unsigned char d_iname[256];
+};
+
+struct pipe_inode_info {
+  int reserved;
+};
+
+#include "reiserfs_fs_i.h"
+
+struct semaphore {
+};
+
+
+struct inode {
+  struct super_block * i_sb;
+  struct inode_operations * i_op;
+  unsigned long i_blksize;
+  unsigned long	i_blocks;
+  unsigned int i_flags;
+  unsigned int i_count;
+  int i_dirt;
+  kdev_t i_dev;
+  off_t i_size;
+  unsigned long i_ino;
+  umode_t i_mode;
+  time_t i_mtime;
+  time_t i_ctime;
+  time_t i_atime;
+  uid_t	i_uid;
+  gid_t	i_gid;
+  nlink_t i_nlink;
+  kdev_t i_rdev;
+  int i_state;
+  struct semaphore i_sem;
+  struct inode * i_next;
+  struct inode * i_prev;
+  union {
+    struct reiserfs_inode_info reiserfs_i;
+  } u;
+};
+/* #define CURRENT_TIME 0 */
+
+#define mark_inode_dirty(inode) ((inode)->i_dirt = 1)
+
+
+struct file {
+  struct dentry	* f_dentry;
+  unsigned int f_flags;
+  loff_t f_pos;
+  struct file_operations * f_op;
+  int f_error;
+};
+
+struct iattr {
+};
+
+struct page {
+  int offset;
+  int count;
+  int flags;
+};
+#define PG_uptodate 1
+
+typedef int (*filldir_t)(void *, const char *, int, off_t, ino_t);
+
+struct vm_area_struct {
+};
+
+struct file_operations {
+  int *llseek;
+  ssize_t (*read) (struct file *, char *, size_t, loff_t *);
+  ssize_t (*write) (struct file *, const char *, size_t, loff_t *);
+  int (*readdir) (struct file *, void *, filldir_t);
+  int *poll;
+  int *ioctl;
+  int (*mmap) (struct file *, struct vm_area_struct *);
+  int *open;
+  int *flush;
+  int (*release) (struct inode *, struct file *);
+  int (*fsync) (struct file *, struct dentry *);
+  int *fasync;
+  int *check_media_change;
+  int *revalidate;
+  int *lock;
+};
+
+struct wait_queue {
+};
+
+
+extern int generic_file_mmap(struct file *, struct vm_area_struct *);
+struct inode_operations {
+  struct file_operations * default_file_ops;
+  int (*create) (struct inode *,struct dentry *,int);
+  struct dentry * (*lookup) (struct inode *,struct dentry *);
+  int (*link) (struct dentry *,struct inode *,struct dentry *);
+  int (*unlink) (struct inode *,struct dentry *);
+  int (*symlink) (struct inode *,struct dentry *,const char *);
+  int (*mkdir) (struct inode *,struct dentry *,int);
+  int (*rmdir) (struct inode *,struct dentry *);
+  int (*mknod) (struct inode *,struct dentry *,int,int);
+  int (*rename) (struct inode *, struct dentry *,
+		 struct inode *, struct dentry *);
+  int (*readlink) (struct dentry *, char *,int);
+  struct dentry * (*follow_link) (struct dentry *, struct dentry *, unsigned int);
+  int (*readpage) (struct file *, struct page *);
+  int *writepage;
+  int (*bmap) (struct inode *,int);
+  void (*truncate) (struct inode *);
+  int (*permission) (struct inode *, int);
+  int *smap;
+  int *updatepage;
+  int *revalidate;
+};
+
+struct fs_struct {
+  int umask;
+};
+
+#define RLIMIT_FSIZE    1
+#define RLIM_NLIMITS     10
+struct rlimit {
+	long	rlim_cur;
+	long	rlim_max;
+};
+
+//
+// include/linux/sched.h
+//
+struct task_struct {
+  int pid;
+  int counter;
+  int fsuid;
+  int fsgid;
+  int need_resched ;
+  int policy;
+  struct fs_struct * fs;
+  struct rlimit rlim[RLIM_NLIMITS];
+  spinlock_t sigmask_lock;
+  sigset_t blocked;
+  pid_t session;
+  pid_t pgrp;
+  char comm[16];
+};
+
+static inline void recalc_sigpending(struct task_struct *t)
+{
+}
+
+#define SCHED_YIELD		0x10
+
+#define CLONE_VM	0x00000100
+#define CLONE_FS        0x00000200
+#define CLONE_FILES	0x00000400
+
+extern struct task_struct cur_task;
+
+#define current (&cur_task)
+int schedule (void);
+int fsuser (void);
+#define ERR_PTR(err)	((void *)((long)(err)))
+
+/* inode.c */
+#define I_DIRTY	1
+#define I_LOCK 	2
+void insert_inode_hash (struct inode * inode);
+struct inode * get_empty_inode (void);
+struct inode * iget (struct super_block *sb, unsigned long ino);
+void iput (struct inode * inode);
+int generic_readpage(struct file * file, struct page * page);
+void sync_inodes (void);
+int is_subdir (struct dentry *, struct dentry *);
+void sleep_on (struct wait_queue **);
+void wake_up (struct wait_queue **);
+
+/*int not_formatted_node (char * buf, int blocksize);*/
+int is_internal_node (char * buf);
+int is_leaf_node (char * buf);
+/*int is_bad_item (struct item_head * ih, char * item, int blocksize, int dev);*/
+/*int is_leaf_bad (struct buffer_head * bh);*/
+
+
+#define	EHASHCOLLISION	125
+
+
+//
+// mm/vmalloc.c
+//
+#define vfree freemem
+#define vmalloc getmem
+
+
+
+//
+// include/linux/tqueue.h
+//
+struct tq_struct {
+    struct tq_struct *next;		/* linked list of active bh's */
+    unsigned long sync;		/* must be initialized to zero */
+    void (*routine)(void *);	/* function to call */
+    void *data;			/* argument to function */
+};
+typedef struct tq_struct * task_queue; 
+#define queue_task(a,b) do {} while (0)
+extern __inline__ void run_task_queue(task_queue *list)
+{
+}
+
+//
+// include/asm/smplock.h
+//
+#define lock_kernel() do {} while (0)
+#define unlock_kernel() do {} while (0)
+
+//
+// kernel/exit.c
+#define exit_files(tsk) do {} while (0)
+#define exit_mm(tsk) do {} while (0)
+
+
+
+//
+// include/asm-i386/processor.h
+//
+int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags);
+
+
Index: empeg/kernel/fs/reiserfs/utils/include/io.h
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/include/io.h:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/include/io.h	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,56 @@
+struct buffer_head {
+  unsigned long b_blocknr;
+  unsigned short b_dev;
+  unsigned long b_size;
+  char * b_data;
+  unsigned long b_state;
+  unsigned int b_count;
+  unsigned int b_list ;
+  void (*b_end_io)(struct buffer_head *bh, int uptodate);
+
+  struct buffer_head * b_next;
+  struct buffer_head * b_prev;
+  struct buffer_head * b_hash_next;
+  struct buffer_head * b_hash_prev;
+};
+
+#define BH_Uptodate	0
+#define BH_Dirty	1
+#define BH_Lock		2
+#define BUF_DIRTY	1
+
+
+#define buffer_uptodate(bh) test_bit(BH_Uptodate, &(bh)->b_state)
+#define buffer_dirty(bh) test_bit(BH_Dirty, &(bh)->b_state)
+#define buffer_locked(bh) test_bit(BH_Lock, &(bh)->b_state)
+#define buffer_clean(bh) !test_bit(BH_Dirty, &(bh)->b_state)
+#define mark_buffer_dirty(bh,i) set_bit(BH_Dirty, &(bh)->b_state)
+#define mark_buffer_uptodate(bh,i) set_bit(BH_Uptodate, &(bh)->b_state)
+#define mark_buffer_clean(bh) clear_bit(BH_Dirty, &(bh)->b_state)
+
+
+
+void __wait_on_buffer (struct buffer_head * bh);
+struct buffer_head * getblk (int dev, int block, int size);
+struct buffer_head * find_buffer (int dev, int block, int size);
+struct buffer_head * get_hash_table(kdev_t dev, int block, int size);
+struct buffer_head * bread (int dev, unsigned long block, size_t size);
+int bwrite (struct buffer_head * bh);
+void brelse (struct buffer_head * bh);
+void bforget (struct buffer_head * bh);
+void init_buffer_cache (void);
+void refile_buffer (struct buffer_head * bh);
+void file_buffer (struct buffer_head * bh, int list);
+int fsync_dev (int dev);
+void ll_rw_block (int rw, int nr, struct buffer_head * bh[]);
+void check_and_free_buffer_mem (void);
+
+#ifdef __alpha__
+
+#define reiserfs_llseek lseek
+
+#else
+
+loff_t reiserfs_llseek (unsigned int fd, loff_t offset, unsigned int origin);
+
+#endif /* __alpha__ */
Index: empeg/kernel/fs/reiserfs/utils/include/misc.h
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/include/misc.h:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/include/misc.h	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,37 @@
+/*
+ * Copyright 1996-2000 Hans Reiser
+ */
+
+/* nothing abount reiserfs here */
+
+void die (char * fmt, ...);
+void * getmem (int size);
+void freemem (void * p);
+void * expandmem (void * p, int size, int by);
+int is_mounted (char * device_name);
+void check_and_free_mem (void);
+char * kdevname (int dev);
+
+
+#ifdef __alpha__
+
+int set_bit (int nr, void * addr);
+int clear_bit (int nr, void * addr);
+int test_bit(int nr, const void * addr);
+int find_first_zero_bit (const void *vaddr, unsigned size);
+int find_next_zero_bit (const void *vaddr, unsigned size, unsigned offset);
+
+#else
+
+#include <asm/bitops.h>
+
+#endif
+
+void print_how_far (__u32 * passed, __u32 total);
+
+
+
+/*
+int test_and_set_bit (int nr, void * addr);
+int test_and_clear_bit (int nr, void * addr);
+*/
Index: empeg/kernel/fs/reiserfs/utils/include/nokernel.h
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/include/nokernel.h:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/include/nokernel.h	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,142 @@
+/*
+ * this is to be included by all kernel files if __KERNEL__ undefined
+ */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <asm/types.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <malloc.h>
+#include <sys/vfs.h>
+#include <time.h>
+
+#ifndef __alpha__
+#include <asm/bitops.h>
+#endif
+
+/*#define kdev_t dev_t*/
+
+#include "inode.h"
+#include "io.h"
+#include "sb.h"
+#include "misc.h"
+#include "reiserfs_fs.h"
+#include "reiserfs_fs_sb.h"
+
+#define make_bad_inode(i) {;}
+#define printk printf
+#define le16_to_cpu(x) ((__u16)x)
+#define cpu_to_le16(x) ((__u16)x)
+#define le32_to_cpu(x) ((__u32)x)
+#define cpu_to_le32(x) ((__u32)x)
+#define copy_from_user memcpy
+#define copy_to_user memcpy
+#define put_user(b,a) ((*(a))=b)
+#define GFP_KERNEL 0
+#define GFP_ATOMIC 0
+#define BUF_CLEAN 0
+#define kmalloc(a,b) getmem(a)
+#define kfree freemem
+#define update_vm_cache(a,b,c,d)
+#define wait_on_buffer __wait_on_buffer
+#define NODEV 0
+extern struct inode_operations chrdev_inode_operations;
+extern struct inode_operations blkdev_inode_operations;
+
+#define page_address(page) 0
+void init_fifo(struct inode * inode);
+#define buffer_req(bh) 0
+//#define kdevname(a) "kdevname"
+#define kdev_t_to_nr(a) a
+#define to_kdev_t(a) a
+#define clear_inode(a)
+#define PAGE_SIZE 4096
+#define d_add(a,b) a->d_inode = b
+#define d_instantiate(a,b) a->d_inode = b
+#define d_delete(a)
+#define d_move(a,b)
+#define down(a)
+#define up(a)
+#define MOD_DEC_USE_COUNT
+#define MOD_INC_USE_COUNT
+#define lock_super(a)
+#define unlock_super(a)
+#define set_blocksize(a,b)
+#define d_alloc_root(a,b) 0
+/* #define file_fsync 0 */
+#define set_writetime(a,b)
+
+#define reiserfs_bread(a,b,c,d) bread(a,b,c)
+/* #define reiserfs_getblk(a,b,c,d)  getblk(a,b,c) */
+extern struct inode_operations reiserfs_dir_inode_operations;
+extern struct inode_operations reiserfs_symlink_inode_operations;
+struct buffer_head * reiserfs_getblk (kdev_t n_dev, int n_block, int n_size, int * p_n_repeat);
+
+#ifdef REISERFS_FSCK
+#undef REISERFS_CHECK
+#endif
+
+/* fs.h */
+#define BLOCK_SIZE 1024
+#define READ 0
+#define WRITE 1
+#define MS_RDONLY	 1
+#define UPDATE_ATIME(inode)
+#define MAJOR(dev) ((dev)>>8)
+#define MINOR(dev) ((dev) & 0xff)
+
+#define CURRENT_TIME (time(NULL))
+
+void set_super(struct super_block *s) ;
+int file_fsync(struct file *filp, struct dentry *dentry) ;
+int reiserfs_file_release(struct inode *p_s_inode, struct file *p_s_filp) ;
+int preserve_trace_print_srs(struct super_block *s) ;
+
+
+//
+// fs/reiserfs/buffer.c
+//
+#define reiserfs_file_buffer(bh,state) do {} while (0)
+#define reiserfs_journal_end_io 0
+
+//
+// fs/reiserfs/journal.c
+//
+#define journal_mark_dirty(th,s,bh) mark_buffer_dirty (bh, 1)
+#define journal_mark_dirty_nolog(th,s,bh) mark_buffer_dirty (bh, 1)
+#define mark_buffer_journal_new(bh) mark_buffer_dirty (bh, 1)
+
+#define reiserfs_update_inode_transaction(i) do {} while (0)
+#define reiserfs_inode_in_this_transaction(i) 1
+#define reiserfs_commit_for_inode(i) do {} while(0)
+
+extern inline int flush_old_commits (struct super_block * s, int i)
+{
+  return 0;
+}
+
+#define journal_begin(th,s,n) do {int fu = n;fu++;} while (0)
+#define journal_release(th,s) do {} while (0)
+#define journal_release_error(th,s) do {} while (0)
+#define journal_init(s) 0
+#define journal_end(th,s,n) do {s=0;} while (0)
+#define buffer_journaled(bh) 0
+#define journal_lock_dobalance(s) do {} while (0)
+#define journal_unlock_dobalance(s) do {} while (0)
+#define journal_transaction_should_end(th,n) 1
+#define push_journal_writer(s) 1
+#define pop_journal_writer(n) do {} while (0)
+#define journal_end_sync(th,s,n) do {} while (0)
+#define journal_mark_freed(th,s,n) do {} while (0)
+#define reiserfs_in_journal(a,b,c,d,e,f) 0
+#define flush_async_commits(s,n) do {} while (0)
+
+//
+// fs/reiserfs/resize.c
+//
+#define reiserfs_resize(s,n) do {} while (0)
+#define simple_strtoul strtol
+
+
Index: empeg/kernel/fs/reiserfs/utils/include/reiserfs.h
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/include/reiserfs.h:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/include/reiserfs.h	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,26 @@
+/*
+ * Copyright 2000 Hans Reiser
+ */
+
+
+//
+// ./fs/reiserfs/utils/lib/reiserfs.c
+//
+int not_formatted_node (char * buf, int blocksize);
+int not_data_block (struct super_block * s, b_blocknr_t block);
+int uread_super_block (struct super_block * s);
+int uread_bitmaps (struct super_block * s);
+
+
+#define bh_desc(bh) ((struct reiserfs_journal_desc *)((bh)->b_data))
+#define bh_commit(bh) ((struct reiserfs_journal_commit *)((bh)->b_data))
+int get_journal_start (struct super_block * s);
+int get_journal_size (struct super_block * s);
+int is_desc_block (struct buffer_head * bh);
+int does_desc_match_commit (struct reiserfs_journal_desc * desc, 
+			    struct reiserfs_journal_commit * commit);
+
+void make_dir_stat_data (struct key * dir_key, struct item_head * ih,
+			 struct stat_data * sd);
+void make_empty_dir_item (char * body, objectid_t dirid, objectid_t objid,
+			  objectid_t par_dirid, objectid_t par_objid);
Index: empeg/kernel/fs/reiserfs/utils/include/resize.h
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/include/resize.h:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/include/resize.h	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,49 @@
+/* 
+ * Copyright 1999 Hans Reiser, see README file for licensing details.
+ */
+
+#define print_usage_and_exit()\
+ die ("Usage: %s  -s[+|-]#[M|K] [-fqv] device", argv[0])
+ 
+
+/* reiserfs_resize.c */
+extern struct buffer_head * g_sb_bh;
+
+extern int opt_force;
+extern int opt_verbose;
+extern int opt_nowrite;
+extern int opt_safe;
+
+int expand_fs(void);
+
+/* fe.c */
+int resize_fs_online(char * devname, unsigned long blocks);
+
+/* do_shrink.c */
+int shrink_fs(unsigned long blocks);
+
+/* bitmap.c */
+struct bitmap_head {
+	int bm_nr;
+	int bm_blocksize;
+	unsigned long bm_block_count; 
+	char ** bm_bmap;
+	struct buffer_head ** bm_bh_table;
+};
+
+struct bitmap_head * create_bitmap_from_sb (struct buffer_head * sb_bh);
+struct bitmap_head * create_bitmap (unsigned long size, int blocksize);
+void free_bitmap (struct bitmap_head * bmp);
+int sync_bitmap (struct bitmap_head * bmp);
+void truncate_bitmap (struct bitmap_head * bmp, unsigned long block);
+int is_block_used (struct bitmap_head * bmp, unsigned long block);
+
+#define is_block_free(bmp,block) (!is_block_used(bmp,block))			
+
+void mark_block_free (struct bitmap_head * bmp, unsigned long block);
+void mark_block_used (struct bitmap_head * bmp, unsigned long block);
+unsigned long find_1st_unused_block_right (struct bitmap_head * bmp,
+                                                  unsigned long start);
+unsigned long find_1st_unused_block_left (struct bitmap_head * bmp,
+                                                  unsigned long start);
+			
Index: empeg/kernel/fs/reiserfs/utils/include/sb.h
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/include/sb.h:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/include/sb.h	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,92 @@
+/*
+struct reiserfs_sb_info {
+  struct reiserfs_super_block * s_rs;
+  struct buffer_head * s_sbh;
+  struct buffer_head ** s_ap_true_bitmap;
+  struct buffer_head ** s_ap_cautious_bitmap;
+  int s_mount_state;
+  unsigned long s_mount_opt;
+  int s_direct2indirect;
+  int s_bmaps;
+  int s_suspected_recipient_count;
+  void (*unpreserve)(struct super_block * s, struct buffer_head * bh);
+};
+*/
+/*
+typedef struct {
+  volatile unsigned int lock ;
+} spinlock_t ;
+*/
+/*
+typedef struct {
+  volatile unsigned int lock ;
+  int previous ;
+} rwlock_t ;
+*/
+/*typedef int task_queue ;*/
+
+struct super_operations {
+  void (*read_inode) (struct inode *);
+  void (*write_inode) (struct inode *);
+  void (*put_inode) (struct inode *);
+  void (*delete_inode) (struct inode *);
+  int (*notify_change) (struct dentry *, struct iattr *);
+  void (*put_super) (struct super_block *);
+  void (*write_super) (struct super_block *);
+  int (*statfs) (struct super_block *, struct statfs *, int);
+  int (*remount_fs) (struct super_block *, int *, char *);
+  void (*clear_inode) (struct inode *);
+  void (*umount_begin) (struct super_block *);
+};
+
+#include "reiserfs_fs_sb.h"
+
+struct super_block {
+  kdev_t s_dev;
+  unsigned long s_blocksize;
+  int s_blocksize_bits;
+  int s_dirt;
+  int s_flags;
+  struct dentry * s_root;
+  struct super_operations * s_op;
+  union {
+    struct reiserfs_sb_info reiserfs_sb;
+  } u;
+};
+#if 0
+#define NOTAIL 0  /* mount option -o notail */
+#define NOPRESERVE 1 /*           -o nopreserve */ 
+#define GENERICREAD 2 /*          -o genericread */
+#define dont_have_tails(s) 0
+#define dont_preserve(s) 1
+#define use_genericread(s) 0
+
+#define is_buffer_suspected_recipient(a) 0
+#define is_buffer_preserved(a) 0
+#define is_buffer_unwritten(a) 0
+#define add_to_preserve(a,b) 
+#define unmark_suspected_recipient(a,b)
+#define mark_suspected_recipient(a,b)
+#define preserve_shifted(a,b,c,d,e)
+#define get_space_from_preserve_list(a) 0
+#define preserve_invalidate(a,b,c)
+#define mark_buffer_unwritten(a)
+#define maybe_free_preserve_list(a) 1
+#define ready_preserve_list(a,b) 0
+#define preserve_trace_release_bitmap(a) do {} while (0)
+#define preserve_trace_init_bitmap(a) do {} while (0)
+
+extern int unpreserve;
+
+static void reiserfs_show_buffers(kdev_t a) {}
+static void reiserfs_refile_buffer(struct buffer_head * bh) {}
+static void mark_suspected_recipients_dirty(kdev_t a) {}
+static void invalidate_reiserfs_buffers(kdev_t a) {}
+static int reiserfs_notify_change(struct dentry * dentry, struct iattr * attr) {return 0;}
+
+#endif
+
+#ifndef BLKSIZE_SIZE
+#define BLKSIZE_SIZE
+int *blksize_size[256];
+#endif
Index: empeg/kernel/fs/reiserfs/utils/lib/inode.c
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/lib/inode.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/lib/inode.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,228 @@
+#include "nokernel.h"
+
+struct fs_struct fss = {0};
+struct task_struct cur_task = {0, 0, 0, 0, 0, 0, &fss, {{0,},}};
+
+int generic_readpage(struct file * file, struct page * page)
+{
+  return 0;
+}
+
+int generic_file_mmap (struct file * file, struct vm_area_struct * vma)
+{
+  return 0;
+}
+
+int reiserfs_sync_file (struct file * p_s_filp, struct dentry * p_s_dentry)
+{
+  return 0;
+}
+
+void wait_buffer_until_released (struct buffer_head * bh)
+{
+}
+
+int schedule (void)
+{
+  return 0;
+}
+
+int fsuser (void)
+{
+  return 0;
+}
+
+int is_subdir (struct dentry * old, struct dentry * new)
+{
+  return 0;
+}
+
+void sleep_on (struct wait_queue ** w)
+{
+}
+
+void wake_up (struct wait_queue ** w)
+{
+}
+
+
+struct inode_operations chrdev_inode_operations = {0,};
+struct inode_operations blkdev_inode_operations = {0,};
+/*struct inode_operations reiserfs_dir_inode_operations = {0,};*/
+struct inode_operations reiserfs_symlink_inode_operations = {0,};
+struct super_operations reiserfs_sops = 
+{
+  reiserfs_read_inode,
+  reiserfs_write_inode,
+  NULL,				/* put_inode*/
+  reiserfs_delete_inode,
+  reiserfs_notify_change,
+  reiserfs_put_super,
+  reiserfs_write_super,
+  reiserfs_statfs,
+  reiserfs_remount,
+  NULL, 				/* clear_inode */
+  NULL				/* umount_begin */
+};
+
+
+
+void init_fifo(struct inode * inode)
+{
+}
+
+
+#define NR_INODES 10
+
+struct inode * first_inode;
+int inodes = 0;
+
+struct inode * find_inode (unsigned long ino)
+{
+  struct inode * inode;
+
+  inode = first_inode;
+  if (inode == 0)
+    return 0;
+
+  while (1) {
+    if (inode->i_ino == ino) {
+      inode->i_count ++;
+      return inode;
+    }
+    inode = inode->i_next;
+    if (inode == first_inode)
+      break;
+  }
+  return 0;
+}
+
+
+struct inode * get_empty_inode (void)
+{
+  struct inode * inode, * prev, * next;
+
+  if (inodes == NR_INODES) {
+    first_inode->i_sb->s_op->write_inode (first_inode);
+
+    /* set all but i_next and i_prev to 0 */
+    next = first_inode->i_next;
+    prev = first_inode->i_prev;
+    memset (first_inode, 0, sizeof (struct inode));
+    first_inode->i_next = next;
+    first_inode->i_prev = prev;
+    
+    /* move to end of list */
+    first_inode = first_inode->i_next;
+    return first_inode->i_prev;
+  }
+  /* allocate new inode */
+  inode = getmem (sizeof (struct inode));
+  if (!inode)
+    return 0;
+
+  /* add to end of list */
+  if (first_inode) {
+    inode->i_prev = first_inode->i_prev;
+    inode->i_next = first_inode;
+    first_inode->i_prev->i_next = inode;
+    first_inode->i_prev = inode;
+  } else {
+    first_inode = inode->i_next = inode->i_prev = inode;
+  }
+  inode->i_count = 1;
+  return inode;
+}
+
+
+void insert_inode_hash (struct inode * inode)
+{
+}
+
+struct inode * get_new_inode (struct super_block *sb, unsigned long ino)
+{
+  struct inode * inode;
+
+  inode = get_empty_inode ();
+  if (inode) {
+    inode->i_sb = sb;
+    inode->i_ino = ino;
+    //inode->i_count = 1;
+    sb->s_op->read_inode (inode);
+    return inode;
+  }
+  return 0;
+}
+
+
+struct inode * iget (struct super_block *sb, unsigned long ino)
+{
+  struct inode * inode;
+
+  inode = find_inode (ino);
+  if (inode)
+    return inode;
+  return get_new_inode (sb, ino);
+}
+
+
+void iput (struct inode * inode)
+{
+    if (inode) {
+	if (inode->i_count == 0)
+	    die ("iput: can not free free inode");
+
+	if (inode->i_op->default_file_ops->release)
+	  inode->i_op->default_file_ops->release (inode, 0);
+	if (inode->i_sb->s_op->put_inode)
+	  inode->i_sb->s_op->put_inode (inode);
+	inode->i_count --;
+
+	if (inode->i_nlink == 0) {
+	    inode->i_sb->s_op->delete_inode (inode);
+	    return;
+	}
+	if (inode->i_state & I_DIRTY) {
+	    inode->i_sb->s_op->write_inode (inode);
+	    inode->i_state &= ~I_DIRTY;
+	}
+    }
+}
+
+
+void sync_inodes (void)
+{
+  struct inode * inode, * tmp;
+
+  inode = first_inode;
+  if (inode == 0)
+    return;
+
+  while (1) {
+    if (inode->i_dirt)
+      inode->i_sb->s_op->write_inode (inode);
+
+    tmp = inode;
+    inode = inode->i_next;
+
+    inode->i_prev = tmp->i_prev;
+    tmp->i_prev->i_next = inode;
+    
+    freemem (tmp);
+    if (inode == tmp)
+      break;
+  }
+  return;
+}
+
+
+//
+// arch/i386/kernel/process.c
+//
+int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags)
+{
+  return 0;
+}
+
+
+
Index: empeg/kernel/fs/reiserfs/utils/lib/io.c
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/lib/io.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/lib/io.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,583 @@
+/*
+ * Copyright 1996, 1997 Hans Reiser, see reiserfs/README for licensing and copyright details
+ */
+
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+/*#include <mntent.h>*/
+#include <sys/types.h>
+#include <asm/types.h>
+#include <linux/unistd.h>
+
+
+#include "inode.h"
+#include "io.h"
+#include "misc.h"
+
+
+struct super_block *reiserfs_get_super(int dev) ;
+struct buffer_head * find_buffer (int dev, int block, int size);
+void __wait_on_buffer (struct buffer_head * bh);
+struct buffer_head * getblk (int dev, int block, int size);
+void brelse (struct buffer_head * bh);
+void bforget (struct buffer_head * bh);
+struct buffer_head * bread (int dev, unsigned long block, size_t size);
+int bwrite (struct buffer_head * bh);
+void ll_rw_block (int rw, int nr, struct buffer_head * bh[]);
+void refile_buffer (struct buffer_head * bh);
+/*void init_buffer_mem (void);*/
+void check_and_free_buffer_mem (void);
+int fsync_dev (int dev);
+
+
+
+/* All buffers are in double linked cycled list. Buffers of tree are
+   hashed by their block number.  If getblk found buffer with wanted
+   block number in hash queue it moves buffer to the end of list */
+
+#define BLOCK_SIZE 1024
+#define MAX_NR_BUFFERS 16384
+static int g_nr_buffers;
+
+#define NR_HASH_QUEUES 20
+static struct buffer_head * g_a_hash_queues [NR_HASH_QUEUES];
+static struct buffer_head * g_buffer_list_head;
+static struct buffer_head * g_buffer_heads;
+
+void unlock_buffer(struct buffer_head *bh) {;} 
+static void show_buffers (int dev, int size)
+{
+  int all = 0;
+  int dirty = 0;
+  int in_use = 0; /* count != 0 */
+  int free = 0;
+  struct buffer_head * next = g_buffer_list_head;
+
+  for (;;) {
+    if (!next)
+      die ("show_buffers: buffer list is corrupted");
+    if (next->b_dev == dev && next->b_size == size) {
+      all ++;
+      if (next->b_count != 0) {
+	in_use ++;
+      }
+      if (buffer_dirty (next)) {
+	dirty ++;
+      }
+      if (buffer_clean (next) && next->b_count == 0) {
+	free ++;
+      }
+    }
+    next = next->b_next;
+    if (next == g_buffer_list_head)
+      break;
+  }
+
+  printf ("show_buffers (dev %d, size %d): free %d, count != 0 %d, dirty %d, all %d\n", dev, size, free, in_use, dirty, all);
+}
+
+#if 0
+static void check_hash_queues (void)
+{
+  int i, j;
+  int index;
+  struct buffer_head * next;
+
+  for (i = 0; i < NR_HASH_QUEUES; i ++) {
+    if ((next = g_a_hash_queues[i]) == 0)
+      continue;
+    if (next->b_hash_prev != 0)
+      die ("check_hash_queues: b_hash_prev corrupted");
+
+    index = next->b_blocknr % NR_HASH_QUEUES;
+    for (j = 0; next; j ++) {
+      if (next->b_blocknr % NR_HASH_QUEUES != index)
+	die ("check_hash_queues: bad b_blocknr");
+      next = next->b_hash_next;
+      if (j > g_nr_buffers)
+	die ("check_hash_queues: too many buffers in hash queue");
+    }
+  }
+  for (i = 0; i < NR_HASH_QUEUES; i ++)
+    for (j = 0; j < NR_HASH_QUEUES; j ++) {
+      if (g_a_hash_queues[i] == g_a_hash_queues[j] && i != j && g_a_hash_queues[i] != 0 && g_a_hash_queues[j] != 0)
+	die ("check_hash_queues: g_a_hash_queues array corrupted");
+    }
+      
+}
+#endif /* 0 */
+
+static void insert_into_hash_queue (struct buffer_head * bh)
+{
+  int index = bh->b_blocknr % NR_HASH_QUEUES;
+
+  if (bh->b_hash_prev || bh->b_hash_next)
+    die ("insert_into_hash_queue: hash queue corrupted");
+
+  if (g_a_hash_queues[index]) {
+    g_a_hash_queues[index]->b_hash_prev = bh;
+    bh->b_hash_next = g_a_hash_queues[index];
+  }
+  g_a_hash_queues[index] = bh;
+
+/*  check_hash_queues ();*/
+}
+
+
+static void remove_from_hash_queue (struct buffer_head * bh)
+{
+  if (bh->b_hash_next == 0 && bh->b_hash_prev == 0 && bh != g_a_hash_queues[bh->b_blocknr % NR_HASH_QUEUES])
+    /* (b_dev == 0) ? */
+    return;
+
+  if (bh == g_a_hash_queues[bh->b_blocknr % NR_HASH_QUEUES]) {
+    if (bh->b_hash_prev != 0)
+      die ("remove_from_hash_queue: hash queue corrupted");
+    g_a_hash_queues[bh->b_blocknr % NR_HASH_QUEUES] = bh->b_hash_next;
+/*
+    if (bh->b_hash_next)
+      g_a_hash_queues[bh->b_blocknr % NR_HASH_QUEUES]->b_hash_prev = 0;
+*/
+  }
+  if (bh->b_hash_next)
+    bh->b_hash_next->b_hash_prev = bh->b_hash_prev;
+
+  if (bh->b_hash_prev)
+    bh->b_hash_prev->b_hash_next = bh->b_hash_next;
+/*
+  else
+    g_a_hash_queues[bh->b_blocknr % NR_HASH_QUEUES] = bh->b_hash_next;
+*/
+
+  bh->b_hash_prev = bh->b_hash_next = 0;
+
+/*  check_hash_queues ();*/
+}
+
+
+static void put_buffer_list_end (struct buffer_head * bh)
+{
+  struct buffer_head * last = 0;
+
+  if (bh->b_prev || bh->b_next)
+    die ("put_buffer_list_end: buffer list corrupted");
+
+  if (g_buffer_list_head == 0) {
+    bh->b_next = bh;
+    bh->b_prev = bh;
+    g_buffer_list_head = bh;
+  } else {
+    last = g_buffer_list_head->b_prev;
+    
+    bh->b_next = last->b_next;
+    bh->b_prev = last;
+    last->b_next->b_prev = bh;
+    last->b_next = bh;
+  }
+}
+
+
+static void remove_from_buffer_list (struct buffer_head * bh)
+{
+  if (bh == bh->b_next) {
+    g_buffer_list_head = 0;
+  } else {
+    bh->b_prev->b_next = bh->b_next;
+    bh->b_next->b_prev = bh->b_prev;
+    if (bh == g_buffer_list_head)
+      g_buffer_list_head = bh->b_next;
+  }
+
+  bh->b_next = bh->b_prev = 0;
+}
+
+
+static void put_buffer_list_head (struct buffer_head * bh)
+{
+  put_buffer_list_end (bh);
+  g_buffer_list_head = bh;
+}
+
+
+#define GROW_BUFFERS__NEW_BUFERS_PER_CALL 10
+/* creates number of new buffers and insert them into head of buffer list 
+ */
+static int grow_buffers (int size)
+{
+  int i;
+  struct buffer_head * bh, * tmp;
+
+  if (g_nr_buffers + GROW_BUFFERS__NEW_BUFERS_PER_CALL > MAX_NR_BUFFERS)
+    return 0;
+
+  /* get memory for array of buffer heads */
+  bh = (struct buffer_head *)getmem (GROW_BUFFERS__NEW_BUFERS_PER_CALL * sizeof (struct buffer_head) + sizeof (struct buffer_head *));
+  if (g_buffer_heads == 0)
+    g_buffer_heads = bh;
+  else {
+    /* link new array to the end of array list */
+    tmp = g_buffer_heads;
+    while (*(struct buffer_head **)(tmp + GROW_BUFFERS__NEW_BUFERS_PER_CALL) != 0)
+      tmp = *(struct buffer_head **)(tmp + GROW_BUFFERS__NEW_BUFERS_PER_CALL);
+    *(struct buffer_head **)(tmp + GROW_BUFFERS__NEW_BUFERS_PER_CALL) = bh;
+  }
+
+  for (i = 0; i < GROW_BUFFERS__NEW_BUFERS_PER_CALL; i ++) {
+
+    tmp = bh + i;
+    memset (tmp, 0, sizeof (struct buffer_head));
+    tmp->b_data = getmem (size);
+    if (tmp->b_data == 0)
+      die ("grow_buffers: no memory for new buffer data");
+    tmp->b_dev = 0;
+    tmp->b_size = size;
+    put_buffer_list_head (tmp);
+
+    g_nr_buffers ++;
+  }
+  return GROW_BUFFERS__NEW_BUFERS_PER_CALL;
+}
+
+
+/*
+int test_and_wait_on_buffer (struct buffer_head * bh)
+{
+  return CARRY_ON;
+}
+*/
+
+
+struct buffer_head * find_buffer (int dev, int block, int size)
+{		
+  struct buffer_head * next;
+
+  next = g_a_hash_queues[block % NR_HASH_QUEUES];
+  for (;;) {
+    struct buffer_head *tmp = next;
+    if (!next)
+      break;
+    next = tmp->b_hash_next;
+    if (tmp->b_blocknr != block || tmp->b_size != size || tmp->b_dev != dev)
+      continue;
+    next = tmp;
+    break;
+  }
+  return next;
+}
+
+void __wait_on_buffer (struct buffer_head * bh)
+{
+}
+
+struct buffer_head * get_hash_table(kdev_t dev, int block, int size)
+{
+  struct buffer_head * bh;
+
+  bh = find_buffer (dev, block, size);
+  if (bh) {
+    bh->b_count ++;
+  }
+  return bh;
+}
+
+
+static struct buffer_head * get_free_buffer (int size)
+{
+  struct buffer_head * next = g_buffer_list_head;
+
+  if (!next)
+    return 0;
+  for (;;) {
+    if (!next)
+      die ("get_free_buffer: buffer list is corrupted");
+    if (next->b_count == 0 && buffer_clean (next) && next->b_size == size) {
+      remove_from_hash_queue (next);
+      remove_from_buffer_list (next);
+      put_buffer_list_end (next);
+      return next;
+    }
+    next = next->b_next;
+    if (next == g_buffer_list_head)
+      break;
+  }
+  return 0;
+}
+
+
+void sync_buffers (int size, int to_write)
+{
+  struct buffer_head * next = g_buffer_list_head;
+  int written = 0;
+
+  for (;;) {
+    if (!next)
+      die ("flush_buffer: buffer list is corrupted");
+    
+    if ((!size || next->b_size == size) && buffer_dirty (next) && buffer_uptodate (next)) {
+      written ++;
+      bwrite (next);
+      if (written == to_write)
+	return;
+    }
+    
+    next = next->b_next;
+    if (next == g_buffer_list_head)
+      break;
+  }
+}
+
+void reiserfs_sync_buffers(int dev, int wait) {
+  fsync_dev(dev) ;
+}
+void reiserfs_sync_all_buffers(int dev, int wait) {
+  fsync_dev(dev) ;
+}
+
+struct buffer_head * getblk (int dev, int block, int size)
+{
+  struct buffer_head * bh;
+
+  bh = find_buffer (dev, block, size);
+  if (bh) {
+    if (0 && !buffer_uptodate (bh))
+      die ("getblk: buffer must be uptodate");
+    bh->b_count ++;
+    return bh;
+  }
+
+  bh = get_free_buffer (size);
+  if (bh == 0) {
+    if (grow_buffers (size) == 0) {
+      sync_buffers (size, 10);
+    }
+    bh = get_free_buffer (size);
+    if (bh == 0) {
+      show_buffers (dev, size);
+      die ("getblk: no free buffers after grow_buffers and refill (%d)", g_nr_buffers);
+    }
+  }
+
+  bh->b_count = 1;
+  bh->b_dev = dev;
+  bh->b_size = size;
+  bh->b_blocknr = block;
+  bh->b_end_io = NULL ;
+  memset (bh->b_data, 0, size);
+  clear_bit(BH_Dirty, &bh->b_state);
+  clear_bit(BH_Uptodate, &bh->b_state);
+
+  insert_into_hash_queue (bh);
+
+  return bh;
+}
+
+
+void brelse (struct buffer_head * bh)
+{
+  if (bh == 0)
+    return;
+  if (bh->b_count == 0) {
+    die ("brelse: can not free a free buffer %lu", bh->b_blocknr);
+  }
+  bh->b_count --;
+}
+
+
+void bforget (struct buffer_head * bh)
+{
+  if (bh) {
+    brelse (bh);
+    remove_from_hash_queue (bh);
+    remove_from_buffer_list (bh);
+    put_buffer_list_head (bh);
+  }
+}
+
+
+#ifndef __alpha__
+
+_syscall5 (int,  _llseek,  uint,  fd, ulong, hi, ulong, lo,
+	  loff_t *, res, uint, wh);
+
+loff_t reiserfs_llseek (unsigned int fd, loff_t offset, unsigned int origin)
+{
+  loff_t retval, result;
+  
+  retval = _llseek (fd, ((unsigned long long) offset) >> 32,
+		    ((unsigned long long) offset) & 0xffffffff,
+		    &result, origin);
+  return (retval != 0 ? (loff_t)-1 : result);
+  
+}
+
+#endif	/* ! __alpha__ */
+
+struct buffer_head * bread (int dev, unsigned long block, size_t size)
+{
+  struct buffer_head * bh;
+  loff_t offset;
+  ssize_t bytes;
+
+  bh = getblk (dev, block, size);
+  if (buffer_uptodate (bh))
+    return bh;
+
+  offset = (loff_t)size * (loff_t)block;
+  if (reiserfs_llseek (dev, offset, SEEK_SET) == (loff_t)-1)
+    die ("bread: _llseek to position %ld (block=%d, dev=%d): %s\n", offset, block, dev, strerror (errno));
+
+  bytes = read (bh->b_dev, bh->b_data, size);
+  if (bytes != (ssize_t)size) {
+    die ("bread: read %d bytes returned %d (block=%d, dev=%d)\n", size, bytes, block, dev);
+  }
+
+  mark_buffer_uptodate (bh, 0);
+  return bh;
+}
+
+
+int aux_dev = 0;
+
+
+int bwrite (struct buffer_head * bh)
+{
+    loff_t offset;
+    ssize_t bytes;
+    size_t size;
+
+    if (!buffer_dirty (bh) || !buffer_uptodate (bh))
+	return 0;
+
+    size = bh->b_size;
+    offset = (loff_t)size * (loff_t)bh->b_blocknr;
+/*  off_hi = ((unsigned long long)offset) >> 32;
+    off_lo = offset & 0xffffffff;*/
+
+    if (reiserfs_llseek (bh->b_dev, offset, SEEK_SET) == (loff_t)-1)
+	die ("bwrite: lseek to position %ld (block=%d, dev=%d): %s\n", offset, bh->b_blocknr, bh->b_dev, strerror (errno));
+
+    bytes = write (bh->b_dev, bh->b_data, size);
+    if (bytes != (ssize_t)size) {
+	die ("bwrite: write %ld bytes returned %d (block=%ld, dev=%d): %s\n", size, bytes, bh->b_blocknr, bh->b_dev, strerror (errno));
+    }
+  
+    mark_buffer_clean (bh);
+    if (bh->b_end_io) {
+	bh->b_end_io(bh, 1) ;
+    }
+    return 0;
+}
+
+
+void ll_rw_block (int rw, int nr, struct buffer_head * bh[])
+{
+  int i;
+  long offset, res_lseek;
+  int res_read;
+
+  if (rw) {
+    for(i = 0 ; i < nr ; i++) {
+      bwrite(bh[i]) ;
+    }
+    return;
+  }
+  for(i = 0; i < nr; i ++) {
+    offset = bh[i]->b_size * bh[i]->b_blocknr;
+				/* This might be a problem that it is
+                                   not lseek64 -Hans */
+    res_lseek = lseek (bh[i]->b_dev, offset, SEEK_SET);
+    if (res_lseek != offset) {      
+      die ("bread: lseek to position %ld returned %ld (block=%d, dev=%d)\n", offset, res_lseek, bh[i]->b_blocknr, bh[i]->b_dev);
+    }
+
+    res_read = read (bh[i]->b_dev, bh[i]->b_data, bh[i]->b_size);
+    if (res_read - bh[i]->b_size) {
+      die ("bread: read %d bytes returned %d (block=%d, dev=%d)\n", bh[i]->b_size, res_read, bh[i]->b_blocknr, bh[i]->b_dev);
+    }
+    
+    mark_buffer_uptodate (bh[i], 0);
+  }
+}
+
+
+/*
+void init_buffer_mem ()
+{
+  grow_buffers (BLOCK_SIZE);
+}
+*/
+
+
+void check_and_free_buffer_mem (void)
+{
+  int i = 0;
+  struct buffer_head * next = g_buffer_list_head;
+
+  sync_buffers (0, 0);
+  for (;;) {
+    if (!next)
+      die ("check_and_free_buffer_mem: buffer list is corrupted");
+    if (next->b_count != 0)
+      die ("check_and_free_buffer_mem: not free buffer (%d, %d, %d)",
+	   next->b_blocknr, next->b_size, next->b_count);
+
+    if (buffer_dirty (next) && buffer_uptodate (next))
+      die ("check_and_free_buffer_mem: dirty buffer found");
+
+    freemem (next->b_data);
+    i ++;
+    next = next->b_next;
+    if (next == g_buffer_list_head)
+      break;
+  }
+  if (i != g_nr_buffers)
+    die ("check_and_free_buffer_mem: found %d buffers, must be %d", i, g_nr_buffers);
+
+  /* free buffer heads */
+  while ((next = g_buffer_heads)) {
+    g_buffer_heads = *(struct buffer_head **)(next + GROW_BUFFERS__NEW_BUFERS_PER_CALL);
+    freemem (next);
+  }
+  
+  return;
+}
+
+
+void file_buffer(struct buffer_head *bh, int list) {
+  refile_buffer(bh) ;
+}
+
+void refile_buffer (struct buffer_head * bh)
+{
+  remove_from_buffer_list (bh);
+  put_buffer_list_head (bh);
+  return;
+}
+
+int fsync_dev (int dev)
+{
+  sync_buffers (0, 0);
+  return 0;
+}
+
+int file_fsync(struct file *filp, struct dentry *dentry)  {
+  return 0 ;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
Index: empeg/kernel/fs/reiserfs/utils/lib/makefile
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/lib/makefile:1.2
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/lib/makefile	Fri Oct 20 16:48:40 2000
@@ -0,0 +1,25 @@
+OBJS = misc.o io.o  inode.o  version.o reiserfs.o
+#hlam.o
+
+MISC = $(TMPBINDIR)/libmisc.a
+
+all: $(MISC)
+
+.c.o:
+	$(CC) $(CFLAGS) $<
+
+$(MISC): $(OBJS)
+	$(AR) -r $(MISC)  $(OBJS)
+
+clean:
+	rm -f *.o $(MISC) *~ TAGS .depend ../include/*~ ../include/TAGS
+
+dep:
+	gcc -MM $(IDIRS) *.c > .depend
+
+ifeq (.depend,$(wildcard .depend))
+include .depend
+endif
+
+
+
Index: empeg/kernel/fs/reiserfs/utils/lib/misc.c
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/lib/misc.c:1.2
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/lib/misc.c	Fri Oct 20 16:48:40 2000
@@ -0,0 +1,340 @@
+/*
+ * Copyright 1996, 1997, 1998 Hans Reiser
+ */
+#include <stdio.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <string.h>
+#include <mntent.h>
+#include <asm/types.h>
+#include <sys/vfs.h>
+
+
+#include "inode.h"
+#include "io.h"
+#include "sb.h"
+#include "misc.h"
+
+#if defined(__alpha__) || defined(__arm__)
+/*
+ * These have been stolen somewhere from linux. Anyone is welcome to write it better.
+ */
+void set_bit (int nr, volatile void * addr)
+{
+  __u8 * p, mask;
+  int retval;
+
+  p = (__u8 *)addr;
+  p += nr >> 3;
+  mask = 1 << (nr & 0x7);
+  /*cli();*/
+  retval = (mask & *p) != 0;
+  *p |= mask;
+  /*sti();*/
+}
+
+
+void clear_bit (int nr, volatile void * addr)
+{
+  __u8 * p, mask;
+  int retval;
+
+  p = (__u8 *)addr;
+  p += nr >> 3;
+  mask = 1 << (nr & 0x7);
+  /*cli();*/
+  retval = (mask & *p) != 0;
+  *p &= ~mask;
+  /*sti();*/
+}
+
+int test_bit(int nr, const void * addr)
+{
+  __u8 * p, mask;
+  
+  p = (__u8 *)addr;
+  p += nr >> 3;
+  mask = 1 << (nr & 0x7);
+  return ((mask & *p) != 0);
+}
+
+int find_first_zero_bit (void *vaddr, unsigned size)
+{
+  const __u8 *p = vaddr, *addr = vaddr;
+  int res;
+
+  if (!size)
+    return 0;
+
+  size = (size >> 3) + ((size & 0x7) > 0);
+  while (*p++ == 255) {
+    if (--size == 0)
+      return (p - addr) << 3;
+  }
+  
+  --p;
+  for (res = 0; res < 8; res++)
+    if (!test_bit (res, p))
+      break;
+  return (p - addr) * 8 + res;
+}
+
+
+int find_next_zero_bit (void *vaddr, int size, int offset)
+{
+  __u8 *addr = vaddr;
+  __u8 *p = addr + (offset >> 3);
+  int bit = offset & 7, res;
+  
+  if (offset >= size)
+    return size;
+  
+  if (bit) {
+    /* Look for zero in first char */
+    for (res = bit; res < 8; res++)
+      if (!test_bit (res, p))
+	return (p - addr) * 8 + res;
+    p++;
+  }
+  /* No zero yet, search remaining full bytes for a zero */
+  res = find_first_zero_bit (p, size - 8 * (p - addr));
+  return (p - addr) * 8 + res;
+}
+#endif /* __alpha__ */
+
+
+
+#if defined(__arm__)
+int test_and_set_bit (int nr, volatile void * addr)
+{
+  int oldbit = test_bit (nr, (const void*)addr);
+  set_bit (nr, addr);
+  return oldbit;
+}
+
+
+int test_and_clear_bit (int nr, volatile void * addr)
+{
+  int oldbit = test_bit (nr, (const void*)addr);
+  clear_bit (nr, addr);
+  return oldbit;
+}
+#endif
+
+
+void die (char * fmt, ...)
+{
+  static char buf[1024];
+  va_list args;
+
+  va_start (args, fmt);
+  vsprintf (buf, fmt, args);
+  va_end (args);
+
+  fprintf (stderr, "\n%s\n\n\n", buf);
+  exit (-1);
+}
+
+
+
+#define MEM_BEGIN "membegi"
+#define MEM_END "mem_end"
+#define MEM_FREED "__free_"
+#define CONTROL_SIZE (strlen (MEM_BEGIN) + 1 + sizeof (int) + strlen (MEM_END) + 1)
+
+
+static int get_mem_size (char * p)
+{
+  char * begin;
+
+  begin = p - strlen (MEM_BEGIN) - 1 - sizeof (int);
+  return *(int *)(begin + strlen (MEM_BEGIN) + 1);
+}
+
+
+static void checkmem (char * p, int size)
+{
+  char * begin;
+  char * end;
+  
+  begin = p - strlen (MEM_BEGIN) - 1 - sizeof (int);
+  if (strcmp (begin, MEM_BEGIN))
+    die ("checkmem: memory corrupted - invalid head sign");
+
+  if (*(int *)(begin + strlen (MEM_BEGIN) + 1) != size)
+    die ("checkmem: memory corrupted - invalid size");
+
+  end = begin + size + CONTROL_SIZE - strlen (MEM_END) - 1;
+  if (strcmp (end, MEM_END))
+    die ("checkmem: memory corrupted - invalid end sign");
+}
+
+
+
+void * getmem (int size)
+{
+  char * p;
+  char * mem;
+
+  p = (char *)malloc (CONTROL_SIZE + size);
+  if (!p)
+    die ("getmem: no more memory (%d)", size);
+
+  strcpy (p, MEM_BEGIN);
+  p += strlen (MEM_BEGIN) + 1;
+  *(int *)p = size;
+  p += sizeof (int);
+  mem = p;
+  memset (mem, 0, size);
+  p += size;
+  strcpy (p, MEM_END);
+
+  checkmem (mem, size);
+
+  return mem;
+}
+
+
+void * expandmem (void * vp, int size, int by)
+{
+  int allocated;
+  char * mem, * p = vp;
+  int expand_by = by;
+
+  if (p) {
+    checkmem (p, size);
+    allocated = CONTROL_SIZE + size;
+    p -= (strlen (MEM_BEGIN) + 1 + sizeof (int));
+  } else {
+    allocated = 0;
+    /* add control bytes to the new allocated area */
+    expand_by += CONTROL_SIZE;
+  }
+  p = realloc (p, allocated + expand_by);
+  if (!p)
+    die ("expandmem: no more memory (%d)", size);
+  if (!vp) {
+    strcpy (p, MEM_BEGIN);
+  }
+  mem = p + strlen (MEM_BEGIN) + 1 + sizeof (int);
+
+  *(int *)(p + strlen (MEM_BEGIN) + 1) = size + by;
+  /* fill new allocated area by 0s */
+  memset (mem + size, 0, by);
+  strcpy (mem + size + by, MEM_END);
+
+  checkmem (mem, size + by);
+
+  return mem;
+}
+
+
+void freemem (void * vp)
+{
+  char * p = vp;
+  int size;
+  
+  if (!p)
+    return;
+  size = get_mem_size (vp);
+  checkmem (p, size);
+
+  p -= (strlen (MEM_BEGIN) + 1 + sizeof (int));
+  strcpy (p, MEM_FREED);
+  strcpy (p + size + CONTROL_SIZE - strlen (MEM_END) - 1, MEM_FREED);
+  free (p);
+}
+
+
+int is_mounted (char * device_name)
+{
+  FILE *f;
+  struct mntent *mnt;
+
+  if ((f = setmntent (MOUNTED, "r")) == NULL)
+    return 0;
+
+  while ((mnt = getmntent (f)) != NULL)
+    if (strcmp (device_name, mnt->mnt_fsname) == 0)
+      return 1;
+  endmntent (f);
+
+  return 0;
+}
+
+
+char buf[20];
+
+#include <linux/kdev_t.h>
+#include <sys/stat.h>
+
+char * kdevname (int dev)
+{
+    struct stat st;
+
+    if (fstat (dev, &st) != 0)
+	die ("stat failed");
+    sprintf (buf, "0x%x:0x%x", MAJOR((int)st.st_rdev), MINOR((int)st.st_rdev));
+    return buf;
+}
+
+
+
+void check_and_free_mem (void)
+{
+  check_and_free_buffer_mem ();
+}
+
+
+static char * strs[] =
+{"0%",".",".",".",".","20%",".",".",".",".","40%",".",".",".",".","60%",".",".",".",".","80%",".",".",".",".","100%"};
+
+static char progress_to_be[1024];
+static char current_progress[1024];
+
+static void str_to_be (char * buf, int prosents)
+{
+  int i;
+  prosents -= prosents % 4;
+  buf[0] = 0;
+  for (i = 0; i <= prosents / 4; i ++)
+    strcat (buf, strs[i]);
+}
+
+
+void print_how_far (__u32 * passed, __u32 total)
+{
+  int n;
+
+  if (*passed == 0)
+    current_progress[0] = 0;
+
+  if (*passed >= total) {
+    fprintf/*die*/ (stderr, "\nprint_how_far: total %u has been reached already. cur=%u\n", total, ++(*passed));
+    return;
+  }
+
+  (*passed) ++;
+  n = ((double)((double)(*passed) / (double)total) * (double)100);
+
+  str_to_be (progress_to_be, n);
+
+  if (strlen (current_progress) != strlen (progress_to_be)) {
+    fprintf (stderr, "%s", progress_to_be + strlen (current_progress));
+  }
+
+  strcat (current_progress, progress_to_be + strlen (current_progress));
+
+
+  fflush (stdout);
+}
+
+
+static struct super_block *reiserfs_global_super_journal_hack = NULL ;
+void set_super(struct super_block *s) {
+  reiserfs_global_super_journal_hack =s ;
+}
+
+struct super_block *reiserfs_get_super(int dev) {
+  return reiserfs_global_super_journal_hack ;
+}
Index: empeg/kernel/fs/reiserfs/utils/lib/reiserfs.c
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/lib/reiserfs.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/lib/reiserfs.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,344 @@
+/*
+ * Copyright 1996-2000 Hans Reiser
+ */
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <asm/types.h>
+#include <sys/vfs.h>
+#include <string.h>
+#include <asm/byteorder.h>
+#include <time.h>
+
+#include "misc.h"
+#include "inode.h"
+#include "io.h"
+#include "sb.h"
+#include "reiserfs_fs_sb.h"
+#include "reiserfs_fs.h"
+#include "reiserfs.h"
+
+
+#define reiserfs_sb(buf) ((struct reiserfs_super_block *)(buf))
+
+static int reiserfs_magic_string (char * buf)
+{
+    return (!strncmp (reiserfs_sb (buf)->s_magic, REISERFS_SUPER_MAGIC_STRING, 
+		      strlen ( REISERFS_SUPER_MAGIC_STRING)));
+    
+}
+
+
+
+/* returns 1 if buf looks like a leaf node, 0 otherwise */
+
+static int is_leaf (char * buf, int blocksize)
+{
+  struct block_head * blkh;
+  struct item_head * ih;
+  int used_space;
+  int prev_location;
+  int i;
+
+  blkh = (struct block_head *)buf;
+  if (blkh->blk_level != DISK_LEAF_NODE_LEVEL)
+      return 0;
+
+  if (blkh->blk_nr_item < 1 || 
+      blkh->blk_nr_item > ((blocksize - BLKH_SIZE) / (IH_SIZE + MIN_ITEM_LEN)))
+      /* item number is too big or too small */
+      return 0;
+
+  ih = (struct item_head *)(buf + BLKH_SIZE) + blkh->blk_nr_item - 1;
+  used_space = BLKH_SIZE + IH_SIZE * blkh->blk_nr_item + (blocksize - ih->ih_item_location);
+  if (used_space != blocksize - blkh->blk_free_space)
+      /* free space does not match to calculated amount of use space */
+      return 0;
+
+  /* check tables of item heads */
+  ih = (struct item_head *)(buf + BLKH_SIZE);
+  prev_location = blocksize;
+  for (i = 0; i < blkh->blk_nr_item; i ++, ih ++) {
+    if (ih->ih_item_location >= blocksize || ih->ih_item_location < IH_SIZE * blkh->blk_nr_item)
+      return 0;
+    if (ih->ih_item_len < 1 || ih->ih_item_len > MAX_ITEM_LEN (blocksize))
+      return 0;
+    if (prev_location - ih->ih_item_location != ih->ih_item_len)
+      return 0;
+    prev_location = ih->ih_item_location;
+  }
+
+  /* contents of buf looks like leaf so far */
+  return 1;
+}
+
+
+
+/* returns 1 if buf looks like an internal node, 0 otherwise */
+static int is_internal (char * buf, int blocksize)
+{
+    struct block_head * blkh;
+    int used_space;
+
+    blkh = (struct block_head *)buf;
+    if (blkh->blk_level < DISK_LEAF_NODE_LEVEL || blkh->blk_level > MAX_HEIGHT)
+	/* this level is not possible for internal nodes */
+	return 0;
+
+    if (blkh->blk_nr_item > (blocksize - BLKH_SIZE - DC_SIZE) / (KEY_SIZE + DC_SIZE))
+	/* for internal which is not root we might check min number of keys */
+	return 0;
+
+    used_space = BLKH_SIZE + KEY_SIZE * blkh->blk_nr_item + DC_SIZE * (blkh->blk_nr_item + 1);
+    if (used_space != blocksize - blkh->blk_free_space)
+	return 0;
+
+    return 1;
+}
+
+
+/* sometimes unfomatted node looks like formatted, if we check only
+   block_header. This is the reason, why it is so complicated. We
+   believe only when free space and item locations are ok 
+   */
+int not_formatted_node (char * buf, int blocksize)
+{
+    struct reiserfs_journal_desc * desc;
+
+    if (is_leaf (buf, blocksize))
+	return 0;
+
+    if (is_internal (buf, blocksize))
+	return 0;
+
+    /* super block? */
+    if (reiserfs_magic_string (buf))
+	return 0;
+
+    /* journal descriptor block? */
+    desc = (struct reiserfs_journal_desc *)buf;
+    if (!memcmp(desc->j_magic, JOURNAL_DESC_MAGIC, 8))
+	return 0;
+
+    /* contents of buf does not look like reiserfs metadata. Bitmaps
+       are possible here */
+    return 1;
+}
+
+
+/* is this block bitmap block or block from journal or skipped area or
+   super block? This works for both journal format only yet */
+int not_data_block (struct super_block * s, b_blocknr_t block)
+{
+    int i;
+
+    if (block < SB_JOURNAL_BLOCK (s) + JOURNAL_BLOCK_COUNT + 1)
+	return 1;
+    for (i = 0; i < SB_BMAP_NR (s); i ++)
+	if (block == SB_AP_BITMAP (s)[i]->b_blocknr)
+	    return 1;
+    return 0;
+}
+
+
+
+
+//////////////////////////////////////////////////////////
+//
+// in reiserfs version 0 (undistributed bitmap)
+//
+static int get_journal_old_start_must (struct reiserfs_super_block * s)
+{
+    return 3 + s->s_bmap_nr;
+}
+
+
+//
+// in reiserfs version 1 (distributed bitmap) journal starts at 18-th
+//
+static int get_journal_start_must (struct reiserfs_super_block * s)
+{
+    return REISERFS_DISK_OFFSET_IN_BYTES / s->s_blocksize + 2;
+}
+
+
+int get_journal_start (struct super_block * s)
+{
+    return s->u.reiserfs_sb.s_rs->s_journal_block;
+}
+
+
+int get_journal_size (struct super_block * s)
+{
+    return s->u.reiserfs_sb.s_rs->s_orig_journal_size;
+}
+
+
+int is_desc_block (struct buffer_head * bh)
+{
+    struct reiserfs_journal_desc * desc = bh_desc (bh);
+
+    if (!memcmp(desc->j_magic, JOURNAL_DESC_MAGIC, 8))
+	return 1;
+    return 0;
+}
+
+
+int does_desc_match_commit (struct reiserfs_journal_desc * desc, 
+			    struct reiserfs_journal_commit * commit)
+{
+    if (commit->j_trans_id != desc->j_trans_id || commit->j_len != desc->j_len || 
+	commit->j_len > JOURNAL_TRANS_MAX || commit->j_len <= 0 ) {
+	return 1 ;
+    }
+    return 0 ;
+}
+
+
+
+/* ./lib/inode.c */extern struct super_operations reiserfs_sops;
+
+//
+// 4k only now ! 
+//
+
+int uread_super_block (struct super_block * s)
+{
+    struct buffer_head * bh;
+
+
+    bh = bread (s->s_dev, (REISERFS_DISK_OFFSET_IN_BYTES / 4096), 4096);
+    if (!bh)
+	goto not_found;
+
+    if (reiserfs_magic_string (bh->b_data) && 
+	reiserfs_sb (bh->b_data)->s_journal_block == get_journal_start_must (reiserfs_sb (bh->b_data)))
+	/* new super block found and correct journal start */
+	goto found;
+
+    /* new super block is not the correct one */
+    brelse (bh);
+
+    bh = bread (s->s_dev, 2, 4096);
+    if (!bh)
+	goto not_found;
+
+    if (reiserfs_magic_string (bh->b_data) && 
+	reiserfs_sb (bh->b_data)->s_journal_block == get_journal_old_start_must (reiserfs_sb (bh->b_data)))
+	goto found;
+
+    brelse (bh);
+
+ not_found:
+    printf ("uread_super_block: neither new nor old reiserfs format found on dev %s\n",
+	    kdevname (s->s_dev));
+    return 1;
+
+ found:
+
+    s->s_blocksize = __le16_to_cpu (reiserfs_sb (bh->b_data)->s_blocksize);
+    s->s_blocksize_bits = 0;
+    while ((1 << s->s_blocksize_bits) != s->s_blocksize)
+	s->s_blocksize_bits ++;
+
+    SB_BUFFER_WITH_SB (s) = bh;
+    SB_DISK_SUPER_BLOCK (s) = reiserfs_sb (bh->b_data);
+    s->s_op = &reiserfs_sops;
+    return 0;
+}
+
+
+static int new_format (struct super_block * s)
+{
+    return (SB_JOURNAL_BLOCK (s) == get_journal_start_must (SB_DISK_SUPER_BLOCK (s)));
+}
+
+
+
+int uread_bitmaps (struct super_block * s)
+{
+    int i, bmp ;
+    struct reiserfs_super_block * rs = SB_DISK_SUPER_BLOCK(s);
+
+    
+    SB_AP_BITMAP (s) = getmem (sizeof (struct buffer_head *) * __le16_to_cpu (rs->s_bmap_nr));
+    if (!SB_AP_BITMAP (s)) {
+	printf ("read_bitmaps: malloc failed\n");
+	return 1;
+    }
+
+    bmp = SB_BUFFER_WITH_SB (s)->b_blocknr + 1;
+
+    for (i = 0; i < __le16_to_cpu (rs->s_bmap_nr); i ++) {
+	SB_AP_BITMAP (s)[i] = bread (s->s_dev, bmp, s->s_blocksize);
+	if (!SB_AP_BITMAP (s)[i]) {
+	    printf ("read_bitmaps: bread failed\n");
+	    return 1;
+	}
+	if (new_format (s))
+	    bmp = (i + 1) * (s->s_blocksize * 8);
+	else
+	    bmp ++;
+    }
+    
+    return 0;
+}
+
+
+
+/* prepare stat data of new directory */
+void make_dir_stat_data (struct key * dir_key, struct item_head * ih,
+			 struct stat_data * sd)
+{
+    /* insert stat data item */
+    copy_key (&(ih->ih_key), dir_key);
+    ih->ih_item_len = SD_SIZE;
+    ih->u.ih_free_space = MAX_US_INT;
+/*    mark_item_unaccessed (ih);*/
+    ih->ih_reserved = 0;
+
+    sd->sd_mode = S_IFDIR + 0755;
+    sd->sd_nlink = 0;
+    sd->sd_uid = 0;
+    sd->sd_gid = 0;
+    sd->sd_size = EMPTY_DIR_SIZE;
+    sd->sd_atime = sd->sd_ctime = sd->sd_mtime = time (NULL);
+    sd->u.sd_blocks = 0;
+    sd->sd_first_direct_byte = MAX_UL_INT;
+}
+
+
+/* compose directory item containing "." and ".." entries */
+void make_empty_dir_item (char * body, objectid_t dirid, objectid_t objid,
+			  objectid_t par_dirid, objectid_t par_objid)
+{
+    struct reiserfs_de_head * deh;
+    char * name;
+
+    deh = (struct reiserfs_de_head *)body;
+    
+    /* direntry header of "." */
+    deh[0].deh_offset = __cpu_to_le32 (DOT_OFFSET);
+    deh[0].deh_dir_id = __cpu_to_le32 (dirid);
+    deh[0].deh_objectid = __cpu_to_le32 (objid);
+    deh[0].deh_location = __cpu_to_le16 (EMPTY_DIR_SIZE - 1);
+    deh[0].deh_state = 0;
+    set_bit (DEH_Visible, &(deh[0].deh_state));
+  
+    /* direntry header of ".." */
+    deh[1].deh_offset = __cpu_to_le32 (DOT_DOT_OFFSET);
+    /* key of ".." for the root directory */
+    deh[1].deh_dir_id = __cpu_to_le32 (par_dirid);
+    deh[1].deh_objectid = __cpu_to_le32 (par_objid);
+    deh[1].deh_location = __cpu_to_le16 (__le16_to_cpu (deh[0].deh_location) - strlen (".."));
+    deh[1].deh_state = 0;
+    set_bit (DEH_Visible, &(deh[1].deh_state));
+
+    /* copy ".." and "." */
+    name = (char *)(deh + 2);
+    name[0] = name[1] = name[2] = '.';
+}
+
+
+
Index: empeg/kernel/fs/reiserfs/utils/lib/version.c
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/lib/version.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/lib/version.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,7 @@
+/*
+ * Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
+ */
+
+char *reiserfs_get_version_string(void) {
+  return "ReiserFS version 3.5.18" ;
+}
Index: empeg/kernel/fs/reiserfs/utils/mkreiserfs/makefile
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/mkreiserfs/makefile:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/mkreiserfs/makefile	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,41 @@
+VPATH = ../bin
+
+OBJS = mkreiserfs.o
+
+MKFS = $(TMPBINDIR)/mkreiserfs
+
+all: $(MKFS)
+
+.c.o:
+	$(CC) $(CFLAGS) $<
+
+$(MKFS): $(OBJS) libmisc.a
+	$(CC) $(LFLAGS) -o $(MKFS) $(OBJS) -lmisc
+
+clean:
+	rm -f *.o $(MKFS) *~ TAGS .depend
+
+dep:
+	gcc -MM $(IDIRS) *.c > .depend
+
+install:
+	cp -f $(MKFS) $(SBIN)
+	if [ -d $(MANDIR) ] ; then cp mkreiserfs.8 $(MANDIR) ; gzip -9 -f $(MANDIR)/mkreiserfs.8 ; fi
+
+
+uninstall:
+	rm -f $(MANDIR)/mkreiserfs.8.gz $(SBIN)/mkreiserfs
+
+
+ifeq (.depend,$(wildcard .depend))
+include .depend
+endif
+
+
+
+
+
+
+
+
+
Index: empeg/kernel/fs/reiserfs/utils/mkreiserfs/mkreiserfs.8
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/mkreiserfs/mkreiserfs.8:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/mkreiserfs/mkreiserfs.8	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,50 @@
+.\" -*- nroff -*-
+.\" Copyright 1996, 1997 Hans Reiser.
+.\" 
+.TH MKREISERFS 8 "February 1999" "Reiserfs utilities"
+.SH NAME
+mkreiserfs \- create a Linux Reiserfs file system
+.SH SYNOPSIS
+.B mkreiserfs
+[
+.B \-b
+.I block-size-in-1k-units
+]
+.I device
+[
+.I size-in-blocks
+]
+.SH DESCRIPTION
+.B mkreiserfs
+utility is used to create a Linux Reiserfs file system on a device
+(usually a disk partition).
+.br
+.I device
+is the special file corresponding to the device (e.g /dev/hdXX for
+IDE disk partition or /dev/sdXX for SCSI disk partition).
+.br
+.I size-in-blocks
+is the number of blocks on the device.  If omitted, it will be
+determined by
+.B mkreiserfs
+automatically.
+.SH OPTIONS
+.TP
+.I -b block-size-in-1k-units
+Specify the size of blocks in 1024b units.  In current version
+.B mkreiserfs
+accepts only values of 1, 2, or 4 (i.e. size of blocks can be 1024b,
+2048b, or 4096b correspondingly)
+.\" .SH AUTHOR
+.\" This version of
+.\" .B mkreiserfs
+.\" has been written by Hans Reiser <reiser@idiom.com>.
+.SH BUGS
+Not known yet.
+Please, report bugs to Hans Reiser <reiser@idiom.com>.
+.SH AVAILABILITY
+.B mkreiserfs
+sources are available for anonymous ftp from namesys.botik.ru
+in /pub/linux+reiserfs/reiserfs-utils.tgz
+.SH SEE ALSO
+.BR reiserfsck (8)
Index: empeg/kernel/fs/reiserfs/utils/mkreiserfs/mkreiserfs.c
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/mkreiserfs/mkreiserfs.c:1.2
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/mkreiserfs/mkreiserfs.c	Fri Oct 20 16:48:40 2000
@@ -0,0 +1,597 @@
+/*
+ * Copyright 1996, 1997, 1998, 1999 Hans Reiser
+ */
+
+/* mkreiserfs is very simple. It supports only 4 and 8K blocks. It skip
+   first REISERFS_DISK_OFFSET_IN_BYTES of device, and then writes the super
+   block, the needed amount of bitmap blocks (this amount is calculated
+   based on file system size), and root block. Bitmap policy is
+   primitive: it assumes, that device does not have unreadable blocks,
+   and it occupies first blocks for super, bitmap and root blocks.
+   bitmap blocks are interleaved across the disk, mainly to make
+   resizing faster. */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <asm/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/vfs.h>
+#include <time.h>
+#include <sys/ioctl.h>
+#include <sys/mount.h>
+
+
+#include "inode.h"
+#include "io.h"
+#include "sb.h"
+#include "misc.h"
+#include "reiserfs_fs.h"
+
+#define print_usage_and_exit() die ("Usage: %s [ -f ] device [block-count]\n\n", argv[0])
+
+#define DEFAULT_BLOCKSIZE 4096
+#define MIN_BLOCK_AMOUNT (100+JOURNAL_BLOCK_COUNT+RESERVED_FOR_PRESERVE_LIST)
+
+
+struct buffer_head * g_sb_bh;
+struct buffer_head * g_bitmap_bh;
+struct buffer_head * g_rb_bh;
+struct buffer_head * g_journal_bh ;
+
+
+int g_block_size = DEFAULT_BLOCKSIZE;
+unsigned long int g_block_number;
+
+/* Given a file descriptor and an offset, check whether the offset is
+   a valid offset for the file - return 0 if it isn't valid or 1 if it
+   is */
+int valid_offset( int fd, loff_t offset )
+{
+  char ch;
+
+  if (reiserfs_llseek (fd, offset, 0) < 0)
+    return 0;
+
+  if (read (fd, &ch, 1) < 1)
+    return 0;
+
+  return 1;
+}
+
+
+
+/* calculates number of blocks on device 
+ */
+unsigned long count_blocks (char * filename, int blocksize)
+{
+  loff_t high, low;
+  int fd;
+
+  fd = open (filename, O_RDONLY);
+  if (fd < 0)
+    die ("count_blocks: open failed (%s)", strerror (errno));
+
+#ifdef BLKGETSIZE
+  {
+    long size;
+
+    if (ioctl (fd, BLKGETSIZE, &size) >= 0) {
+      close (fd);
+      return  size / (blocksize / 512);
+    }
+  }
+#endif
+
+  low = 0;
+  for( high = 1; valid_offset (fd, high); high *= 2 )
+    low = high;
+  while (low < high - 1) {
+    const loff_t mid = ( low + high ) / 2;
+      
+    if (valid_offset (fd, mid))
+      low = mid;
+    else
+      high = mid;
+  }
+  valid_offset (fd, 0);
+  close (fd);
+  
+  return (low + 1) / (blocksize);
+}
+
+
+
+/* form super block */
+void make_super_block (int dev)
+{
+  struct reiserfs_super_block * sb;
+  unsigned long * oids;
+
+
+  if (SB_SIZE > g_block_size)
+    die ("mkreiserfs: blocksize (%d) too small", g_block_size);
+    
+
+  /* get buffer for super block */
+  g_sb_bh = getblk (dev, REISERFS_DISK_OFFSET_IN_BYTES / g_block_size, g_block_size);
+
+/*  sb = (struct reiserfs_super_block *)g_cp_super_block;*/
+  sb = (struct reiserfs_super_block *)g_sb_bh->b_data;
+  sb->s_blocksize = g_block_size;   		/* block size in bytes */
+  sb->s_block_count = g_block_number;	/* how many block reiserfs must occupy */
+  sb->s_state = REISERFS_VALID_FS;
+  sb->s_tree_height = 2;
+  sb->s_journal_dev = 0 ;
+  sb->s_orig_journal_size = JOURNAL_BLOCK_COUNT ;
+  sb->s_journal_trans_max = 0 ;
+  sb->s_journal_block_count = 0 ;
+  sb->s_journal_max_batch = 0 ;
+  sb->s_journal_max_commit_age = 0 ;
+  sb->s_journal_max_trans_age = 0 ;
+
+  sb->s_bmap_nr = g_block_number / (g_block_size * 8) + ((g_block_number % (g_block_size * 8)) ? 1 : 0);
+  memcpy (sb->s_magic, REISERFS_SUPER_MAGIC_STRING, sizeof (REISERFS_SUPER_MAGIC_STRING));
+  
+
+  /* initialize object map */
+  oids = (unsigned long *)(sb + 1);
+  oids[0] = 1;
+  oids[1] = REISERFS_ROOT_OBJECTID + 1;	/* objectids > REISERFS_ROOT_OBJECTID are free */
+  sb->s_oid_cursize = 2;
+
+  /* max size must be even */
+  sb->s_oid_maxsize = (g_block_size - SB_SIZE) / sizeof(unsigned long) / 2 * 2;
+
+
+  mark_buffer_dirty (g_sb_bh, 0);
+  mark_buffer_uptodate (g_sb_bh, 0);
+  return;
+
+}
+
+
+void zero_journal_blocks(int dev, int start, int len) {
+  int i ;
+  struct buffer_head *bh ;
+  int done = 0;
+
+  printf ("Initializing journal - "); fflush (stdout);
+
+  for (i = 0 ; i < len ; i++) {
+    print_how_far (&done, len);
+    bh = getblk (dev, start + i, g_block_size) ;
+    memset(bh->b_data, 0, g_block_size) ;
+    mark_buffer_dirty(bh,0) ;
+    mark_buffer_uptodate(bh,0) ;
+    bwrite (bh);
+    brelse(bh) ;
+  }
+  printf ("\n"); fflush (stdout);
+}
+
+
+/* this only sets few first bits in bitmap block. Fills not initialized
+   fields of super block (root block and bitmap block numbers)
+   */
+void make_bitmap ()
+{
+  struct reiserfs_super_block * sb = (struct reiserfs_super_block *)g_sb_bh->b_data;
+  int i, j;
+  
+  /* get buffer for bitmap block */
+  g_bitmap_bh = getblk (g_sb_bh->b_dev, g_sb_bh->b_blocknr + 1, g_sb_bh->b_size);
+  
+  /* mark, that first 8K of device is busy */
+  for (i = 0; i < REISERFS_DISK_OFFSET_IN_BYTES / g_block_size; i ++)
+    set_bit (i, g_bitmap_bh->b_data);
+
+  /* mark that super block is busy */
+  set_bit (i++, g_bitmap_bh->b_data);
+
+  /* mark first bitmap block as busy */
+  set_bit (i ++, g_bitmap_bh->b_data);
+  
+  /* sb->s_journal_block = g_block_number - JOURNAL_BLOCK_COUNT ; */ /* journal goes at end of disk */
+  sb->s_journal_block = i;
+
+  /* mark journal blocks as busy  BUG! we need to check to make sure journal will fit in the first bitmap block */
+  for (j = 0 ; j < (JOURNAL_BLOCK_COUNT + 1); j++) /* the descriptor block goes after the journal */
+    set_bit (i ++, g_bitmap_bh->b_data);
+
+  /* and tree root is busy */
+  set_bit (i, g_bitmap_bh->b_data);
+  sb->s_root_block = i;
+  sb->s_free_blocks = sb->s_block_count - i - 1 ;
+
+  /* count bitmap blocks not resides in first s_blocksize blocks */
+  sb->s_free_blocks -= sb->s_bmap_nr - 1;
+
+  mark_buffer_dirty (g_bitmap_bh, 0);
+  mark_buffer_uptodate (g_bitmap_bh, 0);
+
+  mark_buffer_dirty (g_sb_bh, 0);
+  return;
+}
+
+
+/* form the root block of the tree (the block head, the item head, the
+   root directory) */
+void make_root_block ()
+{
+  struct reiserfs_super_block * sb = (struct reiserfs_super_block *)g_sb_bh->b_data;
+  char * rb;
+  struct block_head * blkh;
+  struct item_head * ih;
+
+  struct stat_data * sd;
+  struct reiserfs_de_head * deh;
+  struct key maxkey = {0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff};
+
+  /* get memory for root block */
+/*  g_cp_root_block = getmem (g_block_size);*/
+  /* no more cautious bitmap, kill the *2 */
+  /* g_rb_bh = getblk (g_sb_bh->b_dev, g_sb_bh->b_blocknr + sb->s_bmap_nr * 2 + 1, g_sb_bh->b_size); */
+  g_rb_bh = getblk (g_sb_bh->b_dev, sb->s_root_block, sb->s_blocksize);
+  rb = g_rb_bh->b_data;
+
+  /* block head */
+  blkh = (struct block_head *)rb;
+  blkh->blk_level = DISK_LEAF_NODE_LEVEL;
+  blkh->blk_nr_item = 0;
+  blkh->blk_free_space = sb->s_blocksize - BLKH_SIZE;
+  memcpy (&blkh->blk_right_delim_key, &maxkey, KEY_SIZE);
+
+  /* first item is stat data item of root directory */
+  ih = (struct item_head *)(blkh + 1);
+  ih->ih_key.k_dir_id = REISERFS_ROOT_PARENT_OBJECTID;
+  ih->ih_key.k_objectid = REISERFS_ROOT_OBJECTID;
+  ih->ih_key.k_offset = SD_OFFSET;
+  ih->ih_key.k_uniqueness = TYPE_STAT_DATA;
+  ih->ih_item_len = SD_SIZE;
+  ih->ih_item_location = sb->s_blocksize - ih->ih_item_len;
+  ih->u.ih_free_space = MAX_US_INT;
+  ih->ih_reserved = 0;
+
+  /* fill stat data */
+  sd = (struct stat_data *)(rb + ih->ih_item_location);
+  sd->sd_mode = S_IFDIR + 0755;
+  sd->sd_nlink = 3;
+  sd->sd_uid = 0;	/*??*/
+  sd->sd_gid = 0;	/*??*/
+  sd->sd_size = EMPTY_DIR_SIZE;
+  sd->sd_atime = sd->sd_ctime = sd->sd_mtime = time (NULL);
+  sd->u.sd_blocks = 0;	/*??*/
+  sd->sd_first_direct_byte = MAX_UL_INT;	/*??*/
+
+
+  blkh->blk_nr_item ++;
+  blkh->blk_free_space -= (IH_SIZE + ih->ih_item_len);
+
+  
+  /* second item is root directory item, containing "." and ".." */
+  ih ++;
+  ih->ih_key.k_dir_id = REISERFS_ROOT_PARENT_OBJECTID;
+  ih->ih_key.k_objectid = REISERFS_ROOT_OBJECTID;
+  ih->ih_key.k_offset = DOT_OFFSET;
+  ih->ih_key.k_uniqueness = DIRENTRY_UNIQUENESS/*DOT_UNIQUENESS*/;
+#ifdef REISERFS_ALIGNED
+  ih->ih_item_len = DEH_SIZE * 2 + 4 + 4;
+#else
+  ih->ih_item_len = DEH_SIZE * 2 + strlen (".") + strlen ("..")/* + sizeof (unsigned long)*/;
+#endif
+  ih->ih_item_location = (ih-1)->ih_item_location - ih->ih_item_len;
+  ih->u.ih_entry_count = 2;
+  ih->ih_reserved = 0;
+  
+
+  deh = (struct reiserfs_de_head *)(rb + ih->ih_item_location);
+
+  /* "." */
+  deh[0].deh_offset = DOT_OFFSET;
+  /*  deh[0].deh_uniqueness = DOT_UNIQUENESS;*/
+  deh[0].deh_dir_id = ih->ih_key.k_dir_id;
+  deh[0].deh_objectid = ih->ih_key.k_objectid;
+#ifdef REISERFS_ALIGNED
+  deh[0].deh_location = ih->ih_item_len - 4;
+#else
+  deh[0].deh_location = ih->ih_item_len - strlen (".");
+#endif
+  /*mark_de_without_sd (&(deh[0]));*/
+  clear_bit (DEH_Statdata, &(deh[0].deh_state));
+
+  /*mark_de_with_directory_id (&(deh[0]));*/
+/*  clear_bit (DEH_AdditionalKeyComponent, &(deh[0].deh_state));*/
+
+  /*mark_de_visible (&(deh[0]));*/
+  set_bit (DEH_Visible, &(deh[0].deh_state));
+
+  /* ".." */
+  deh[1].deh_offset = DOT_DOT_OFFSET;
+  /*  deh[1].deh_uniqueness = DOT_DOT_UNIQUENESS;*/
+  deh[1].deh_dir_id = 0;
+  deh[1].deh_objectid = REISERFS_ROOT_PARENT_OBJECTID;	/* as key of root directory is [REISERFS_ROOT_PARENT_OBJECTID, 
+							                                REISERFS_ROOT_OBJECTID],
+							   so objectid of root directory
+							   parent direcotry is REISERFS_ROOT_PARENT_OBJECTID */
+#ifdef REISERFS_ALIGNED
+  deh[1].deh_location = deh[0].deh_location - 4;
+#else
+  deh[1].deh_location = deh[0].deh_location - strlen ("..");
+#endif
+
+  /*mark_de_without_sd (&(deh[1]));*/
+  clear_bit (DEH_Statdata, &(deh[1].deh_state));
+  
+  /*mark_de_with_directory_id (&(deh[1]));*/
+  /*set_bit (DEH_AdditionalKeyComponent, &(deh[1].deh_state));*/
+
+  /*mark_de_visible (&(deh[1]));*/
+  set_bit (DEH_Visible, &(deh[1].deh_state));
+
+#ifdef REISERFS_ALIGNED
+  strncpy(rb + ih->ih_item_location + deh[0].deh_location, ".", 4);
+  strncpy(rb + ih->ih_item_location + deh[1].deh_location, "..", 4);
+#else
+  memcpy (rb + ih->ih_item_location + deh[0].deh_location, ".", strlen ("."));
+  memcpy (rb + ih->ih_item_location + deh[1].deh_location, "..", strlen (".."));
+#endif
+  /* objectid of parent directory of object pointed by ".." */
+  /**(unsigned long *)(rb + ih->ih_item_location + deh[1].deh_location + strlen ("..")) = 0;*/
+  
+
+  blkh->blk_nr_item ++;
+  blkh->blk_free_space -= (IH_SIZE + ih->ih_item_len);
+  
+  mark_buffer_dirty (g_rb_bh, 0);
+  mark_buffer_uptodate (g_rb_bh, 0);
+  return;
+}
+
+
+/*
+ *  write the super block, the bitmap blocks and the root of the tree
+ */
+void write_super_and_root_blocks ()
+{
+  struct reiserfs_super_block * sb = (struct reiserfs_super_block *)g_sb_bh->b_data;
+  int i;
+
+  zero_journal_blocks(g_sb_bh->b_dev, sb->s_journal_block, JOURNAL_BLOCK_COUNT + 1) ;
+
+  /* super block */
+  bwrite (g_sb_bh);
+
+  /* bitmap blocks */
+  for (i = 0; i < sb->s_bmap_nr; i ++) {
+    if (i != 0) {
+      g_bitmap_bh->b_blocknr = i * sb->s_blocksize * 8;
+      memset (g_bitmap_bh->b_data, 0, g_bitmap_bh->b_size);
+      set_bit (0,g_bitmap_bh->b_data);
+    }
+    if (i == sb->s_bmap_nr - 1) {
+      int j;
+
+      /* fill unused part of last bitmap block with 1s */
+      if (sb->s_block_count % (sb->s_blocksize * 8))
+	for (j = sb->s_block_count % (sb->s_blocksize * 8); j < sb->s_blocksize * 8; j ++) {
+	  set_bit (j, g_bitmap_bh->b_data);
+      }
+    }
+    /* write true bitmap */
+    mark_buffer_dirty (g_bitmap_bh, 0);
+    bwrite (g_bitmap_bh);
+
+#if 0
+    /* write cautious bitmap */
+    g_bitmap_bh->b_blocknr += sb->s_bmap_nr;
+    mark_buffer_dirty (g_bitmap_bh, 0);
+    bwrite (g_bitmap_bh);
+    g_bitmap_bh->b_blocknr -= sb->s_bmap_nr;    
+#endif
+  }
+
+  /* root block */
+  bwrite (g_rb_bh);
+  brelse (g_rb_bh);
+  brelse (g_bitmap_bh);
+  brelse (g_sb_bh);
+}
+
+
+char buf[20];
+
+#include <linux/kdev_t.h>
+
+char * devname (int dev)
+{
+  struct stat st;
+
+  if (fstat (dev, &st) != 0)
+    die ("stat failed");
+  sprintf (buf, "0x%x:0x%x", MAJOR((int)st.st_rdev), MINOR((int)st.st_rdev));
+  return buf;
+}
+
+
+void report (void)
+{
+    struct reiserfs_super_block * sb = (struct reiserfs_super_block *)g_sb_bh->b_data;
+    unsigned int i;
+
+    printf ("Block size %d bytes\n", sb->s_blocksize);
+    printf ("Block count %d\n", sb->s_block_count);
+    printf ("First %ld blocks skipped\n", g_sb_bh->b_blocknr);
+    printf ("Super block is in %ld\n", g_sb_bh->b_blocknr);
+    printf ("Bitmap blocks are : \n\t%ld", g_bitmap_bh->b_blocknr);
+    for (i = 1; i < sb->s_bmap_nr; i ++) {
+	printf (", %d", i * sb->s_blocksize * 8);
+    }
+    printf ("\nJournal size %d (blocks %d-%d of device %s)\n",
+	    JOURNAL_BLOCK_COUNT, sb->s_journal_block, 
+	    sb->s_journal_block + JOURNAL_BLOCK_COUNT, devname (g_sb_bh->b_dev));
+    printf ("Root block %u\n", sb->s_root_block);
+    printf ("Used %d blocks\n", sb->s_block_count - sb->s_free_blocks);
+    fflush (stdout);
+}
+
+
+/* discard 1st 2k block partition. This should be enough to make
+   mount not see ext2 (and others) on mkreiserfs'd partition;
+   NOW it clear the first 2k block to avoid wrong vfat mounting 
+   (it search its "super block" in 1st 512 bytes) 
+
+   We also clear the original old journaled superblock (8k offset).
+   
+*/
+void invalidate_other_formats (int dev)
+{
+  struct buffer_head * bh;
+
+  bh = getblk (dev, 0, 2048);
+  mark_buffer_uptodate (bh, 1);
+  mark_buffer_dirty (bh, 1);
+  bwrite (bh);
+  brelse (bh);
+  bh = getblk(dev, REISERFS_OLD_DISK_OFFSET_IN_BYTES  / 1024, 1024) ;
+  if (!bh) {
+    printf("Unable to get block to clear the old reiserfs superblock\n") ;
+    return ;
+  }
+  mark_buffer_uptodate (bh, 1);
+  mark_buffer_dirty (bh, 1);
+  bwrite (bh);
+  brelse (bh);
+}
+
+
+int main (int argc, char **argv)
+{
+  char *tmp;
+  int dev;
+  int force = 0;
+  struct stat statbuf;
+  char * device_name;
+  char c;
+
+  printf ("\n\n<-----------MKREISERFS, 1999----------->\n%s\n", 
+           reiserfs_get_version_string());
+  
+
+#if 1
+  if (0) {
+    /* ???? */
+    getblk (0,0,0);
+    iput (0);
+  }
+#endif
+
+  if (argc < 2)
+    print_usage_and_exit ();
+
+/*  init_buffer_mem ();*/
+
+  while ( ( c = getopt( argc, argv, "f" ) ) != EOF )
+    switch( c )
+      {
+      case 'f' :                 /* force if file is not a block device */
+	force = 1;
+	break;
+#if 0 /* -b is not supported with the journal code */
+      case 'b' :                  /* -k n - where n is 1,2 or 4 */
+	g_block_size = (int) strtol (optarg, &tmp, 0);
+	if ( *tmp || ( g_block_size != 1 && g_block_size != 2 && g_block_size != 4 ))
+	  die ("mkreiserfs: bad block size : %s\n", optarg);
+	g_block_size *= 1024;
+	break;
+#endif /* -b */
+      default :
+	print_usage_and_exit ();
+      }
+  device_name = argv [optind];
+  
+
+  /* get block number for file system */
+  if (optind == argc - 2) {
+    g_block_number = strtol (argv[optind + 1], &tmp, 0);
+    if (*tmp == 0) {    /* The string is integer */
+      if (g_block_number > count_blocks (device_name, g_block_size))
+	die ("mkreiserfs: specified block number (%d) is too high", g_block_number);
+/*      else if (g_block_number < MIN_BLOCK_AMOUNT)
+        die ("mkreiserfs: specified block number (%d) is too low", g_block_number); 
+*/
+    } else {
+	    die ("mkreiserfs: bad block count : %s\n", argv[optind + 1]);
+	}	
+  } else 
+    if (optind == argc - 1) {
+      /* number of blocks is not specified */
+      g_block_number = count_blocks (device_name, g_block_size);
+      tmp = "";
+    } else
+      print_usage_and_exit ();
+
+
+  g_block_number = g_block_number / 8 * 8;
+
+/*  if (*tmp || g_block_number % 8 || (g_block_number == 0))
+    / * block amount specified is not a valid integer * /
+    die ("mkreiserfs: bad block count : %s\n", argv[optind + 1]);
+*/	
+  if (g_block_number < MIN_BLOCK_AMOUNT)
+	die ("mkreiserfs: block number %d (truncated to n*8) is too low", 
+		g_block_number);
+
+  if (is_mounted (device_name))
+    die ("mkreiserfs: '%s' contains a mounted file system\n", device_name);
+
+  /* open_device will die if it could not open device */
+  dev = open (device_name, O_RDWR);
+  if (dev == -1)
+    die ("mkreiserfs: can not open '%s': %s", device_name, strerror (errno));
+  
+  if (fstat (dev, &statbuf) < 0)
+    die ("mkreiserfs: unable to stat %s", device_name);
+  
+  if (!S_ISBLK (statbuf.st_mode) && ( force == 1 ))
+    die ("mkreiserfs: '%s (%o)' is not a block device", device_name, statbuf.st_mode);
+  else        /* Ignore any 'full' fixed disk devices */
+    if ( statbuf.st_rdev == 0x0300 || statbuf.st_rdev == 0x0340 
+	 || statbuf.st_rdev == 0x0400 || statbuf.st_rdev == 0x0410
+	 || statbuf.st_rdev == 0x0420 || statbuf.st_rdev == 0x0430
+	 || statbuf.st_rdev == 0x0d00 || statbuf.st_rdev == 0x0d40 )
+      /* ???? */
+      die ("mkreiserfs: will not try to make filesystem on '%s'", device_name);
+
+  
+  /* these fill buffers (super block, first bitmap, root block) with
+     reiserfs structures */
+  make_super_block (dev);
+  make_bitmap ();
+  make_root_block ();
+  
+  report ();
+
+  printf ("ATTENTION: ALL DATA WILL BE LOST ON '%s'! (y/n)", device_name);
+  c = getchar ();
+  if (c != 'y' && c != 'Y')
+    die ("mkreiserfs: Disk was not formatted");
+
+  invalidate_other_formats (dev);
+  write_super_and_root_blocks ();
+
+  check_and_free_mem ();
+
+  printf ("Syncing.."); fflush (stdout);
+
+  close(dev) ;
+  sync ();
+ 
+  printf ("\n\nReiserFS core development sponsored by SuSE Labs (suse.com)\n\nJournaling sponsored by MP3.com.\n\nItem handlers sponsored by Ecila.com\n\nTo learn about the programmers and ReiserFS, please go to\nhttp://www.devlinux.com/namesys\n\nHave fun.\n\n"); fflush (stdout);
+  return 0;
+
+}
Index: empeg/kernel/fs/reiserfs/utils/obj/makefile
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/obj/makefile:1.2
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/obj/makefile	Fri Oct 20 16:48:40 2000
@@ -0,0 +1,44 @@
+vpath %.c ../..
+
+OBJS1 = prints.o stree.o  buffer.o dir.o file.o inode.o namei.o objectid.o \
+        version.o
+#journal.o
+#bitmap.o
+
+
+OBJS = do_balan.o fix_node.o ibalance.o lbalance.o teahash3.o prints.o super.o stree.o  buffer.o dir.o file.o inode.o namei.o objectid.o  version.o
+#journal.o 
+BITMAPOBJ = bitmap.o
+
+REISERFS1 = $(TMPBINDIR)/libreiserfs1.a 
+REISERFS2 = $(TMPBINDIR)/libreiserfs2.a
+REISERFS = $(TMPBINDIR)/libreiserfs.a
+BITMAP = $(TMPBINDIR)/libbitmap.a
+
+all: $(REISERFS1) $(REISERFS2) $(REISERFS) $(BITMAP)
+
+.c.o:
+	$(CC) $(CFLAGS) $<
+
+$(REISERFS1): $(OBJS1)
+	$(AR) -r $(REISERFS1)  $(OBJS1)
+$(REISERFS2): $(OBJS2)
+	$(AR) -r $(REISERFS2)  $(OBJS2)
+
+$(REISERFS): $(OBJS)
+	$(AR) -r $(REISERFS)  $(OBJS)
+
+$(BITMAP): $(BITMAPOBJ)
+	$(AR) -r $(BITMAP)  $(BITMAPOBJ)
+
+clean:
+	rm -f *.o $(REISERFS1) $(REISERFS2) *~ TAGS .depend $(REISERFS) $(BITMAP)
+
+dep:
+	gcc -MM $(IDIRS) ../../*.c > .depend
+
+
+ifeq (.depend,$(wildcard .depend))
+include .depend
+endif
+
Index: empeg/kernel/fs/reiserfs/utils/resize_reiserfs/Makefile
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/resize_reiserfs/Makefile:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/resize_reiserfs/Makefile	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,40 @@
+
+VPATH = ../bin
+
+OBJS = resize_reiserfs.o fe.o do_shrink.o bitmap.o
+
+RESIZER = $(TMPBINDIR)/resize_reiserfs
+
+all: $(RESIZER)
+
+.c.o:
+	$(CC) $(CFLAGS) -Wall -g $<
+
+$(RESIZER): $(OBJS) libmisc.a libreiserfs.a
+	$(CC) $(LFLAGS) -o $(RESIZER) $(OBJS) -lmisc
+
+clean:
+	rm -f *.o $(RESIZER) *~
+
+dep:
+	gcc -MM $(IDIRS) *.c > .depend
+
+install: all
+	cp -f $(RESIZER) $(SBIN)
+
+uninstall:
+	rm -f $(SBIN)/resize_reiserfs
+
+
+ifeq (.depend,$(wildcard .depend))
+include .depend
+endif
+
+
+
+
+
+
+
+
+
Index: empeg/kernel/fs/reiserfs/utils/resize_reiserfs/bitmap.c
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/resize_reiserfs/bitmap.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/resize_reiserfs/bitmap.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,179 @@
+/*
+ * Copyright 1999,2000 Hans Reiser, see README file for licensing details.
+ * written by Alexander Zarochentcev <zam@programbank.ru>
+ * 
+ * This file contains small functons which operate with bitmaps:
+ * create, delete, copy, bit operations, etc.
+ * There are two bitmap types: general bitmap and bitmap with associated
+ * disk blocks from a reiserfs.
+ *
+ */
+
+#include <sys/vfs.h>
+#include <sys/types.h>
+#include <asm/types.h>
+ 
+#include "inode.h"
+#include "io.h"
+#include "sb.h"
+#include "misc.h"
+#include "reiserfs_fs.h"
+
+#include "resize.h"
+
+/* sorry, I can't reuse code from fsck/ubitmap.c */
+
+struct bitmap_head * create_bitmap (unsigned long size, int blocksize) 
+{
+	struct bitmap_head * bmp;
+	int i, bmap_nr;
+	bmp = getmem(sizeof(struct bitmap_head));
+	bmp->bm_block_count = size;
+	bmp->bm_blocksize = blocksize;
+	bmp->bm_bh_table = NULL;
+	bmp->bm_nr = (size - 1) / blocksize + 1;
+	for (i = 0; i < bmp->bm_nr; i++)
+		bmp->bm_bmap [i] = getmem(blocksize);
+	return bmp;				
+}
+
+struct bitmap_head * create_bitmap_from_sb (struct buffer_head * sb_bh)
+{
+	struct bitmap_head * bmp;
+	struct reiserfs_super_block * sb;
+	int i;
+
+	sb = (struct reiserfs_super_block *) sb_bh->b_data;
+	
+	bmp = getmem(sizeof(struct bitmap_head));
+	bmp->bm_blocksize = sb->s_blocksize;
+	bmp->bm_block_count = sb->s_block_count;
+	bmp->bm_bh_table = NULL;
+	bmp->bm_nr = 0;
+
+	bmp->bm_bh_table = getmem(sizeof(struct buffer_head *) * sb->s_bmap_nr);
+	bmp->bm_bmap = getmem(sizeof(char *) * sb->s_bmap_nr);
+	
+	/* read first bitmap block */
+	bmp->bm_bh_table [0] = bread(sb_bh->b_dev,
+	 		   REISERFS_DISK_OFFSET_IN_BYTES / sb->s_blocksize + 1,
+			   sb->s_blocksize);
+	if (!bmp->bm_bh_table [0]) {
+		free_bitmap(bmp);
+		return NULL;
+	}
+	bmp->bm_bmap [0] = bmp->bm_bh_table [0] -> b_data;
+	bmp->bm_nr++;
+		
+	/* read others bitmap blocks */	
+	for (i=1; i < sb->s_bmap_nr; i++) {
+		bmp->bm_bh_table [i] = bread(sb_bh->b_dev, i * sb->s_blocksize * 8, sb->s_blocksize);
+		if (!bmp->bm_bh_table [i]) {
+			free_bitmap(bmp);
+			return NULL;
+		}
+		bmp->bm_bmap [i] = bmp->bm_bh_table [i] -> b_data;
+		bmp->bm_nr++;
+	}	
+	return bmp;	
+}
+
+void free_bitmap (struct bitmap_head * bmp)
+{
+	int i;
+	
+	if (bmp->bm_bh_table) {
+		for (i = 0; i < bmp->bm_nr; i++ )
+			brelse(bmp->bm_bh_table [i]);
+		freemem(bmp->bm_bh_table);
+	} else {
+		if(bmp->bm_bmap)
+			for (i = 0; i < bmp->bm_nr; i++)
+				freemem(bmp->bm_bmap [i]);
+	}
+	if(bmp->bm_bmap)
+		freemem(bmp->bm_bmap);
+	freemem(bmp);
+}
+
+int sync_bitmap (struct bitmap_head * bmp)
+{
+	int i;
+	if (bmp->bm_bh_table)
+		for (i = 0; i < bmp->bm_nr; i++) {
+			bwrite(bmp->bm_bh_table [i]); 
+		}	
+	return 0;
+}
+
+void truncate_bitmap (struct bitmap_head * bmp, unsigned long block)
+{
+	int i,j;
+
+	i = (block - 1) / (8 * bmp->bm_blocksize);
+	j = block - i * 8 * bmp->bm_blocksize;
+
+	while (j < (8 * bmp->bm_blocksize))
+		set_bit(j++, bmp->bm_bh_table [i] -> b_data);
+	mark_buffer_dirty(bmp->bm_bh_table [i], 1);	
+	
+	for (j = i + 1; j < bmp->bm_nr; j++)
+		brelse(bmp->bm_bh_table [j]);
+
+	bmp->bm_nr = i + 1;
+	bmp->bm_block_count = block;
+}
+
+
+int is_block_used (struct bitmap_head * bmp, unsigned long block)
+{
+	int i,j;
+
+	i = block / (8 * bmp->bm_blocksize);
+	j = block % (8 * bmp->bm_blocksize);
+
+	return test_bit(j, bmp->bm_bmap [i]);
+}
+
+void mark_block_free (struct bitmap_head * bmp, unsigned long block)
+{
+	int i,j;
+
+    i = block / (8 * bmp->bm_blocksize);
+    j = block % (8 * bmp->bm_blocksize);
+	
+	clear_bit(j, bmp->bm_bmap [i]);
+	if (bmp->bm_bh_table) 
+		mark_buffer_dirty(bmp->bm_bh_table [i], 1);
+}
+
+void mark_block_used (struct bitmap_head * bmp, unsigned long block)
+{
+	int i,j;
+	
+	i = block / (8 * bmp->bm_blocksize);
+	j = block % (8 * bmp->bm_blocksize);
+
+	set_bit(j, bmp->bm_bmap [i]);
+	if (bmp->bm_bh_table) 
+		mark_buffer_dirty(bmp->bm_bh_table [i], 1);
+}
+
+unsigned long find_1st_unused_block_right (struct bitmap_head * bmp,
+					 							  unsigned long start)
+{
+	for(;start < bmp->bm_block_count; start++)
+		if (is_block_free(bmp, start))
+			return start;
+	return 0;		
+}
+
+unsigned long find_1st_unused_block_left (struct bitmap_head * bmp,
+					 							  unsigned long start)
+{
+	while (--start)
+		if (is_block_free(bmp, start))
+			return start;
+	return 0;		
+}
+
Index: empeg/kernel/fs/reiserfs/utils/resize_reiserfs/do_shrink.c
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/resize_reiserfs/do_shrink.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/resize_reiserfs/do_shrink.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,273 @@
+/*
+ * Copyright 2000 Hans Reiser, see README file for licensing details.
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <asm/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/vfs.h>
+#include <time.h>
+#include <sys/ioctl.h>
+#include <sys/mount.h>
+
+#include "inode.h"
+#include "io.h"
+#include "sb.h"
+#include "misc.h"
+#include "reiserfs_fs.h"
+#include "resize.h"
+
+static long int_node_cnt   = 0, int_moved_cnt   = 0;
+static long	leaf_node_cnt  = 0, leaf_moved_cnt  = 0;
+static long	unfm_node_cnt  = 0, unfm_moved_cnt  = 0;
+static long	total_node_cnt = 0, total_moved_cnt = 0;
+
+static unsigned long unused_block;
+static unsigned long blocks_used;
+static struct bitmap_head * bmp;
+
+/* abnornal exit from block reallocation process */
+static void quit_resizer()
+{
+	/* save changes to bitmap blocks */
+	sync_bitmap (bmp);
+	free_bitmap (bmp);
+	/* leave fs in ERROR state */
+	brelse(g_sb_bh);
+	die ("resize_reiserfs: fs shrinking was not completed successfully, run reiserfsck.\n");
+}
+
+/* block moving */
+static unsigned long move_generic_block(unsigned long block,
+										unsigned long bnd, int h)
+{
+	struct buffer_head * bh, * bh2;
+
+	/* primitive fsck */
+	if (block > ((struct reiserfs_super_block *)(g_sb_bh->b_data))->s_block_count) {
+		fprintf(stderr, "resize_reiserfs: invalid block number (%lu) found.\n", block);
+		quit_resizer();
+	}
+	/* progress bar, 3D style :) */
+	if (opt_verbose)	
+		print_how_far((__u32 *)&total_node_cnt, blocks_used);
+	else
+		total_node_cnt ++;
+	/* infinite loop check */
+	if( total_node_cnt > blocks_used) {
+		fputs("resize_reiserfs: block count exeeded\n",stderr);
+		quit_resizer();
+	}
+
+	if (block < bnd) /* block will not be moved */
+		return 0;
+	
+	/* move wrong block */ 
+	bh = bread(g_sb_bh->b_dev, block, g_sb_bh->b_size);
+
+	unused_block = find_1st_unused_block_right(bmp, unused_block);
+	if (unused_block == 0 || unused_block >= bnd) {
+		fputs ("resize_reiserfs: can\'t find free block\n", stderr);
+		quit_resizer();
+	}
+
+	/* blocknr changing */
+	bh2 = getblk(g_sb_bh->b_dev, unused_block, g_sb_bh->b_size);
+	memcpy(bh2->b_data, bh->b_data, bh2->b_size);
+	mark_block_free(bmp, block);
+	mark_block_used(bmp, unused_block);
+
+	brelse(bh);
+	mark_buffer_dirty(bh2,0);
+	mark_buffer_uptodate(bh2,0);
+	bwrite(bh2);
+	brelse(bh2);
+
+	total_moved_cnt++;
+	return unused_block;
+}
+
+static unsigned long move_unformatted_block(unsigned long block,
+											unsigned long bnd, int h)
+{
+	unsigned long b;
+	unfm_node_cnt++;
+	b = move_generic_block(block, bnd, h);
+	if (b)
+		unfm_moved_cnt++;
+	return b;		
+}
+
+
+/* recursive function processing all tree nodes */
+static unsigned long move_formatted_block(unsigned long block,
+										  unsigned long bnd, int h)
+{
+	struct buffer_head * bh;
+	struct item_head *ih;
+	unsigned long new_blocknr = 0;
+	int dev;
+	int i, j;
+	
+	dev = g_sb_bh -> b_dev;
+	
+	bh = bread(dev, block, g_sb_bh->b_size);
+
+	if (B_IS_ITEMS_LEVEL(bh)) { /* leaf node*/
+
+		leaf_node_cnt++;
+
+		for (i=0; i < B_NR_ITEMS(bh); i++) {
+			ih = B_N_PITEM_HEAD(bh, i);
+			if (I_IS_INDIRECT_ITEM(ih)) {
+				for (j = 0; j < I_UNFM_NUM(ih); j++) {
+					unsigned long  unfm_block;
+					/* unfm_block_ptr = (unsigned long *)() + j; */
+					unfm_block = move_unformatted_block(
+									B_I_POS_UNFM_POINTER(bh, ih, j),
+									bnd, h + 1);
+					if (unfm_block) {
+						B_I_POS_UNFM_POINTER(bh,ih,j) = unfm_block;
+						mark_buffer_dirty(bh,0);
+					}
+				}
+			}	
+		}
+		mark_buffer_uptodate(bh,0);
+		bwrite(bh);
+		brelse(bh);
+		new_blocknr = move_generic_block(block, bnd, h);
+		if (new_blocknr)
+			leaf_moved_cnt++;
+	} else if (B_IS_KEYS_LEVEL(bh)) { /* internal node */
+
+		int_node_cnt++;
+
+		for (i=0; i <= B_NR_ITEMS(bh); i++) {
+			unsigned long moved_block;
+			moved_block = move_formatted_block(B_N_CHILD_NUM(bh, i), bnd, h+1);
+			if (moved_block) {
+				B_N_CHILD_NUM(bh, i) = moved_block;
+				mark_buffer_dirty(bh,0);
+			}
+		}	
+		mark_buffer_uptodate(bh,0);
+		bwrite(bh);
+		brelse(bh);	
+		new_blocknr = move_generic_block(block, bnd, h);
+		if (new_blocknr)
+			int_moved_cnt++;
+	} else {
+		die ("resize_reiserfs: block (%lu) have invalid format\n", block);
+	}
+
+	return new_blocknr;
+}
+
+static void sync_super_block()
+{
+	mark_buffer_dirty(g_sb_bh,0);
+	mark_buffer_uptodate(g_sb_bh,0);
+	bwrite(g_sb_bh);
+}
+
+int shrink_fs(unsigned long blocks)
+{
+	struct reiserfs_super_block *  sb;
+	unsigned long n_root_block;
+	int bmap_nr_new;
+
+	/* warn about alpha version */
+	{
+		int c;
+
+		printf(
+			"You are running ALPHA version of reiserfs shrinker.\n"
+			"This version is only for testing or VERY CAREFUL use.\n"
+			"Backup of you data is recommended.\n\n"
+			"Do you want to continue? [y/N]:"
+			);
+		c = getchar();
+		if (c != 'y' && c != 'Y')
+			exit(1);
+	}
+	sb = (struct reiserfs_super_block *) g_sb_bh->b_data;
+	bmap_nr_new = (blocks - 1) / (8 * sb->s_blocksize) + 1;
+	
+	/* is shrinking possible ? */
+	if (sb->s_block_count - blocks > 
+		sb->s_free_blocks + sb->s_bmap_nr - bmap_nr_new)
+		die ("resize_reiserfs: can\'t shrink fs; too many blocks already allocated\n"); 
+	/* calculate number of data blocks */		
+	blocks_used = 
+		sb->s_block_count
+		- sb->s_free_blocks
+		- sb->s_bmap_nr 
+		- sb->s_orig_journal_size
+		- REISERFS_DISK_OFFSET_IN_BYTES / sb->s_blocksize
+		- 2; /* superblock itself and 1 descriptor after the journal */
+
+	bmp = create_bitmap_from_sb(g_sb_bh);
+	if (!bmp) 
+		die ("resize_reiserfs: read bitmap failed\n");
+	unused_block = 1;
+
+	/* change fs state before shrinking */
+	sb->s_state = REISERFS_ERROR_FS;
+	sync_super_block();
+
+	if (opt_verbose) {
+		printf("Processing the tree: ");
+		fflush(stdout);
+	}
+
+	n_root_block = move_formatted_block(sb->s_root_block, blocks, 0);
+	if (n_root_block) {
+		sb->s_root_block = n_root_block;
+	}
+
+	if (opt_verbose)
+		printf ("\n\nnodes processed (moved):\n"
+				"int        %lu (%lu),\n"
+				"leaves     %lu (%lu),\n" 
+				"unfm       %lu (%lu),\n"
+				"total      %lu (%lu).\n\n",
+				int_node_cnt, int_moved_cnt,
+				leaf_node_cnt, leaf_moved_cnt, 
+				unfm_node_cnt, unfm_moved_cnt,
+				total_node_cnt, total_moved_cnt);
+	
+#if 0
+	printf("check for used blocks in truncated region\n");
+	{
+		long l;
+		for (l = blocks; l < sb->s_block_count; l++)
+			if (is_block_used(bmp,l))
+				printf("<%lu>", l);
+		printf("\n");
+	}
+#endif
+		
+	sb->s_free_blocks -= (sb->s_block_count - blocks) 
+							- (sb->s_bmap_nr - bmap_nr_new);
+	sb->s_block_count = blocks;
+	sb->s_bmap_nr = bmap_nr_new;
+	
+	truncate_bitmap(bmp, blocks);
+	sync_bitmap(bmp);
+	free_bitmap(bmp);
+
+	/* change fs state after shrinking */
+	sb->s_state = REISERFS_VALID_FS;
+
+	sync_super_block();
+
+	brelse(g_sb_bh);
+	return 0;
+}
Index: empeg/kernel/fs/reiserfs/utils/resize_reiserfs/fe.c
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/resize_reiserfs/fe.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/resize_reiserfs/fe.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,44 @@
+/*
+ * Copyright 1999 Hans Reiser, see README file for licensing details.
+ */
+
+#include <sys/mount.h>
+#include <sys/types.h>
+#include <asm/types.h>
+#include <errno.h>
+#include <stdio.h>
+#include <mntent.h>
+#include <string.h>
+#include "misc.h"
+#include "resize.h"
+
+/* the front-end for kernel on-line resizer */
+int resize_fs_online(char * devname, unsigned long blocks)
+{
+	static char buf[40];
+	FILE * f;
+	struct mntent * mnt;
+	
+	if ((f = setmntent (MOUNTED, "r")) == NULL)
+		goto fail;
+
+    while ((mnt = getmntent (f)) != NULL)
+        if(strcmp(devname, mnt->mnt_fsname) == 0) {
+
+			if (strcmp(mnt->mnt_type,"reiserfs")) 			
+				die ("resize_reiserfs: can\'t resize fs other than reiserfs\n");
+				
+			sprintf(buf,"resize=%lu", blocks);
+
+			if (mount(mnt->mnt_fsname, mnt->mnt_dir, mnt->mnt_type,
+          			  (unsigned long)(MS_MGC_VAL | MS_REMOUNT), buf)) 
+				die ("resize_reiserfs: remount failed: %s\n", strerror(errno));
+			
+			endmntent(f);
+			return 0;
+		}
+fail:
+   die ("resize_reiserfs: can\t find mount entry\n");
+   return 1;
+}
+
Index: empeg/kernel/fs/reiserfs/utils/resize_reiserfs/resize_reiserfs.c
diff -u /dev/null empeg/kernel/fs/reiserfs/utils/resize_reiserfs/resize_reiserfs.c:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/fs/reiserfs/utils/resize_reiserfs/resize_reiserfs.c	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,311 @@
+/* Copyright 1999 Hans Reiser, see README file for licensing details.
+ * 
+ * Written by Alexander Zarochentcev.
+ * 
+ * FS resize utility 
+ *
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <asm/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/vfs.h>
+#include <time.h>
+#include <sys/ioctl.h>
+#include <sys/mount.h>
+
+
+#include "inode.h"
+#include "io.h"
+#include "sb.h"
+#include "misc.h"
+#include "reiserfs_fs.h"
+#include "resize.h"
+
+struct buffer_head * g_sb_bh;
+				/* use of a long is a 2.2 Linux VFS
+                                   limitation, review this decision for
+                                   2.3 and/or LFS patch. -Hans */
+unsigned long g_block_count_new;
+int g_bmap_nr_new;
+
+int opt_force = 0;
+int opt_verbose = 1;			/* now "verbose" option is default */
+int opt_nowrite = 0;
+int opt_safe = 0;
+
+/* Given a file descriptor and an offset, check whether the offset is
+   a valid offset for the file - return 0 if it isn't valid or 1 if it
+   is */
+int valid_offset( int fd, loff_t offset )
+{
+  char ch;
+
+  if (reiserfs_llseek (fd, offset, 0) < 0)
+    return 0;
+
+  if (read (fd, &ch, 1) < 1)
+    return 0;
+
+  return 1;
+}
+
+				/* A bunch of these functions look like
+                                   they could be shared with those in
+                                   super.c or the utils, can they?
+                                   If so, then do so.  -Hans */
+static void read_superblock(int dev) {
+	int bs;
+	struct reiserfs_super_block * sb;
+		
+	g_sb_bh = bread(dev, (REISERFS_DISK_OFFSET_IN_BYTES / 1024), 1024);
+	if (!g_sb_bh)
+		die ("resize_reiserfs: can\'t read superblock\n");
+	sb = (struct reiserfs_super_block *)g_sb_bh->b_data;
+
+	if(strncmp(sb->s_magic, REISERFS_SUPER_MAGIC_STRING, sizeof(REISERFS_SUPER_MAGIC_STRING) - 1) ) 
+        die ("resize_reiserfs: device doesn\'t contain valid reiserfs\n");
+							
+	bs = sb->s_blocksize;	
+	brelse(g_sb_bh);
+	
+	g_sb_bh = bread(dev, REISERFS_DISK_OFFSET_IN_BYTES / bs, bs);
+	if (!g_sb_bh)
+		die ("resize_reiserfs: can\'t read superblock\n");
+	if (g_sb_bh->b_blocknr >= sb->s_journal_block)
+		die ("resize_reiserfs: can\'t read superblock\n");
+}
+
+/* calculate the new fs size (in blocks) from old fs size and the string
+   representation of new size */
+static unsigned long calc_new_fs_size(unsigned long count, 
+								      int bs, char *bytes_str) {
+	long long int bytes;
+	unsigned long blocks;
+	int c;
+	
+	bytes = atoll(bytes_str);
+	c = bytes_str[strlen(bytes_str) - 1];
+
+	switch (c) {
+	case 'M':
+	case 'm':
+		bytes *= 1024;
+	case 'K':
+	case 'k':
+		bytes *= 1024;
+	}
+	
+	blocks = bytes / bs;
+
+	if (bytes_str[0] == '+' || bytes_str[0] == '-')
+		return (count + blocks);
+
+	return blocks;
+}
+
+/* print some fs parameters */
+static void sb_report(struct reiserfs_super_block * sb1,
+       			      struct reiserfs_super_block * sb2){
+	printf(
+		"ReiserFS report:\n"
+		"blocksize             %d\n"
+		"block count           %d (%d)\n"
+		"free blocks           %d (%d)\n"
+		"bitmap block count    %d (%d)\n", 
+		sb1->s_blocksize,
+		sb1->s_block_count, sb2->s_block_count,
+		sb1->s_free_blocks, sb2->s_free_blocks,
+		sb1->s_bmap_nr, sb2->s_bmap_nr);
+};
+
+/* read i-th bitmap block */
+static struct buffer_head * get_bm_blk (int dev, int ind, int bs) {
+	if (ind == 0) 
+		return bread(g_sb_bh->b_dev, REISERFS_DISK_OFFSET_IN_BYTES / bs + 1 ,bs);
+	return bread(dev, ind * bs * 8, bs);
+}
+
+/* conditional bwrite */
+static int bwrite_cond (struct buffer_head * bh) {
+	if(!opt_nowrite) { 
+		mark_buffer_uptodate(bh,0);
+		mark_buffer_dirty(bh,0);
+		return bwrite(bh);
+	}
+	return 0;
+}
+
+
+/* the first one of the mainest functions */
+int expand_fs(void) {
+	struct reiserfs_super_block *  sb;
+	struct buffer_head * bm_bh;
+	int block_r, block_r_new;
+	int i;
+	
+	sb = (struct reiserfs_super_block *) g_sb_bh->b_data;
+
+	/* count used bits in last bitmap block */
+	block_r = sb->s_block_count -
+		((sb->s_bmap_nr - 1) * sb->s_blocksize * 8);
+	
+	/* count bitmap blocks in new fs */
+	g_bmap_nr_new = g_block_count_new / (sb->s_blocksize * 8);
+	block_r_new = g_block_count_new -
+		g_bmap_nr_new * sb->s_blocksize	* 8;
+	if(block_r_new)
+		g_bmap_nr_new++;
+	else 
+		block_r_new = sb->s_blocksize * 8;
+
+	/* clear bits in last bitmap block (old layout) */
+	bm_bh = get_bm_blk(g_sb_bh->b_dev, sb->s_bmap_nr - 1, sb->s_blocksize);
+	for (i = block_r; i < sb->s_blocksize * 8; i++)
+		clear_bit(i, bm_bh->b_data);
+	bwrite_cond(bm_bh);
+	
+	/* add new bitmap blocks */
+	for (i = sb->s_bmap_nr; i < g_bmap_nr_new; i++) {
+		memset(bm_bh->b_data, 0, bm_bh->b_size);
+		set_bit(0, bm_bh->b_data);
+		bm_bh->b_blocknr =  			/* It is not a first BM block */
+			i * sb->s_blocksize * 8;	/* with special location */
+		bwrite_cond(bm_bh);
+	}
+	
+	/* set unused bits in last bitmap block (new layout) */
+	for (i = block_r_new; i < sb->s_blocksize * 8; i++)
+		set_bit(i, bm_bh->b_data);
+	bwrite_cond(bm_bh);
+
+	/* update super block buffer*/
+	sb->s_free_blocks += g_block_count_new - sb->s_block_count
+		- (g_bmap_nr_new - sb->s_bmap_nr);
+	sb->s_block_count = g_block_count_new;
+	sb->s_bmap_nr = g_bmap_nr_new;
+
+	/* commit changes */
+	bwrite_cond(g_sb_bh);
+
+	brelse(g_sb_bh);
+	brelse(bm_bh);
+	
+	return 0;
+}
+
+int main(int argc, char *argv[]) {
+	char * bytes_count_str = NULL;
+	char * devname;
+	struct stat statbuf;
+	int c;
+
+	int dev;
+	struct reiserfs_super_block *sb, *sb_old;
+	
+	while ((c = getopt(argc, argv, "fvcqs:")) != EOF) {
+		switch (c) {
+		case 's' :
+			  if (!optarg) 
+				  die("%s: Missing argument to -s option", argv[0]);		
+			  bytes_count_str = optarg;
+			  break;
+		case 'f':
+		    opt_force = 1;
+		    break;		 
+		case 'v':
+			opt_verbose++; 
+			break;
+		case 'n':
+			/* no nowrite option at this moment */
+			/* opt_nowrite = 1; */
+			break;
+		case 'c':
+			opt_safe = 1;
+			break;
+		case 'q':
+			opt_verbose = 0;
+			break;
+		default:
+			print_usage_and_exit ();
+		}
+	}
+
+	if (optind == argc || (!bytes_count_str))
+		print_usage_and_exit();
+	devname = argv[optind];
+
+	/* open_device will die if it could not open device */
+	dev = open (devname, O_RDWR);
+	if (dev == -1)
+		die ("%s: can not open '%s': %s", argv[0], devname, strerror (errno));
+
+	if (fstat (dev, &statbuf) < 0)
+		die ("%s: unable to stat %s", argv[0], devname);
+  
+	if (!S_ISBLK (statbuf.st_mode) && opt_force )
+		die ("%s: '%s (%o)' is not a block device", 
+			 argv[0], devname, statbuf.st_mode);
+
+	read_superblock(dev);
+	
+	sb = (struct reiserfs_super_block *) g_sb_bh->b_data;
+	g_block_count_new = calc_new_fs_size(sb->s_block_count,
+					     sb->s_blocksize, bytes_count_str);
+	if (is_mounted (devname)) {
+		close(dev);
+		if (!opt_force) 
+	    	die ("%s: '%s' contains a mounted file system,\n"
+			     "\tspecify -f option to resize the fs online\n", 
+				 argv[0], devname);
+		resize_fs_online(devname, g_block_count_new);
+		return 0;
+	}	
+
+	if (sb->s_state != REISERFS_VALID_FS) 
+		die ("%s: the file system isn't in valid state\n", argv[0]);
+		
+	if(!valid_offset(dev, (loff_t) g_block_count_new * sb->s_blocksize - 1))
+		die ("%s: %s too small", argv[0], devname);
+
+	sb_old = 0;		/* Needed to keep idiot compiler from issuing false warning */
+	/* save SB for reporting */
+	if(opt_verbose) {
+		sb_old = getmem(sizeof(struct reiserfs_super_block));
+		memcpy(sb_old, sb, sizeof(struct reiserfs_super_block));
+    }
+
+	if (g_block_count_new == sb->s_block_count) 
+		die ("%s: Calculated fs size is the same as the previous one.",
+			 argv[0]);
+	if (g_block_count_new > sb->s_block_count) 
+		expand_fs();
+	else
+		shrink_fs(g_block_count_new);
+
+	if(opt_verbose) {
+		sb_report(sb, sb_old);
+		freemem(sb_old);
+	}
+
+	check_and_free_mem ();		
+	
+	if (opt_verbose) {
+		printf("\nSyncing..");
+		fflush(stdout);
+	}
+	fsync (dev);
+	if (opt_verbose)
+		printf("done\n");
+	
+
+	close(dev);
+	
+	return 0;
+}
Index: empeg/kernel/include/asm-arm/errno.h
diff -u empeg/kernel/include/asm-arm/errno.h:1.1.1.1 empeg/kernel/include/asm-arm/errno.h:1.2
--- empeg/kernel/include/asm-arm/errno.h:1.1.1.1	Wed Jun  9 13:09:16 1999
+++ empeg/kernel/include/asm-arm/errno.h	Fri Oct 20 16:48:40 2000
@@ -128,5 +128,6 @@
 
 #define	ENOMEDIUM	123	/* No medium found */
 #define	EMEDIUMTYPE	124	/* Wrong medium type */
+#define EHASHCOLLISION  125     /* ReiserFS too many hash collisions */
 
 #endif
Index: empeg/kernel/include/asm-arm/arch-sa1100/cmptblty.h
diff -u empeg/kernel/include/asm-arm/arch-sa1100/cmptblty.h:1.1.1.1 empeg/kernel/include/asm-arm/arch-sa1100/cmptblty.h:1.3
--- empeg/kernel/include/asm-arm/arch-sa1100/cmptblty.h:1.1.1.1	Wed Jun  9 13:09:17 1999
+++ empeg/kernel/include/asm-arm/arch-sa1100/cmptblty.h	Mon Sep 18 17:14:24 2000
@@ -33,17 +33,21 @@
 
 #undef FALSE
 #undef TRUE
-#undef NULL
 #if LANGUAGE == C
 #define FALSE   	0
 #define TRUE    	(!FALSE)
-#define NULL    	((void *) 0)
 #elif LANGUAGE == Assembly
 #define FALSE   	0
 #define TRUE    	1
-#define NULL    	0
 #endif /* LANGUAGE == C || LANGUAGE == Assembly */
 
+#ifndef NULL
+#if LANGUAGE == C && !defined(__cplusplus)
+#define NULL    	((void *) 0)
+#else
+#define NULL    	0
+#endif
+#endif
 
 /*
  * MACROS: BAnd, BOr, BXor, Modulo
Index: empeg/kernel/include/asm-arm/arch-sa1100/empeg.h
diff -u empeg/kernel/include/asm-arm/arch-sa1100/empeg.h:1.37.4.3 empeg/kernel/include/asm-arm/arch-sa1100/empeg.h:1.51
--- empeg/kernel/include/asm-arm/arch-sa1100/empeg.h:1.37.4.3	Thu May 31 15:56:47 2001
+++ empeg/kernel/include/asm-arm/arch-sa1100/empeg.h	Thu Aug 23 16:29:06 2001
@@ -7,130 +7,54 @@
  *   Hugo Fiennes, <hugo@empeg.com>
  *   Mike Crowe, <mac@empeg.com>
  *
+ * This is the kernel/userspace interaction interface. This header
+ * file should not be included from any kernel header files, if it is
+ * then there is a great risk that the wrong version of this file
+ * could be used sometimes.
+ *
+ * Only userspace code and kernel driver implementation (i.e. *.c)
+ * files should include this file.
+ *
  */
 
-#ifndef __ASM_ARCH_EMPEG_H
-#define __ASM_ARCH_EMPEG_H
+#ifndef _INCLUDE_EMPEG_H
+#define _INCLUDE_EMPEG_H 1
 
-/* Revision 3 (Sonja) IO definitions */
-#define EMPEG_POWERFAIL      (GPIO_GPIO0)  /* IN  Power fail sense           */
-#define EMPEG_USBIRQ         (GPIO_GPIO1)  /* IN  USB IRQ                    */
-#define EMPEG_USBDRQ         (GPIO_GPIO2)  /* IN  USB DRQ                    */
-#define EMPEG_CRYSTALDRQ     (GPIO_GPIO2)  /* IN  Mk2 CS4231 audio in DRQ    */
-#define EMPEG_RDSCLOCK       (GPIO_GPIO3)  /* IN  RDS clock                  */
-#define EMPEG_IRINPUT_BIT    4
-#define EMPEG_IRINPUT        GPIO_GPIO(EMPEG_IRINPUT_BIT)  /* IN  Frontboard consumer IR     */
-#define EMPEG_DSP2OUT        (GPIO_GPIO5)  /* IN  7705's DSP_OUT2 pin        */
-#define EMPEG_IDE1IRQ        (GPIO_GPIO6)  /* IN  IDE channel 1 irq (actL)   */
-#define EMPEG_IDE2IRQ        (GPIO_GPIO7)  /* IN  IDE channel 2 irq (actL)   */
-#define EMPEG_ETHERNETIRQ    (GPIO_GPIO7)  /* IN  Mk2 Ethernet               */
-#define EMPEG_I2CCLOCK       (GPIO_GPIO8)  /* OUT I2C clock                  */
-#define EMPEG_I2CDATA        (GPIO_GPIO9)  /* OUT I2C data (when high pulls  */
-                                           /*     data line low)             */
-#define EMPEG_RADIODATA      (GPIO_GPIO10) /* OUT Radio data (when high it   */
-					   /*     pulls data line low)       */
-#define EMPEG_DISPLAYCONTROL (GPIO_GPIO10) /* OUT Mk2 display control line   */
-#define EMPEG_I2CDATAIN      (GPIO_GPIO11) /* IN  I2C data input             */
-#define EMPEG_RADIOCLOCK     (GPIO_GPIO12) /* OUT Radio clock                */
-#define EMPEG_SIRSPEED0      (GPIO_GPIO12) /* OUT Mk2 SIR endec speed sel 0  */
-#define EMPEG_RADIOWR        (GPIO_GPIO13) /* OUT Radio write enable         */
-#define EMPEG_ACCSENSE       (GPIO_GPIO13) /* IN  Mk2 Car accessory sense    */
-#define EMPEG_RADIODATAIN    (GPIO_GPIO14) /* IN  Radio data input           */
-#define EMPEG_POWERCONTROL   (GPIO_GPIO14) /* OUT Mk2 Control for power PIC  */
-#define EMPEG_DSPPOM         (GPIO_GPIO15) /* OUT DSP power-on-mute          */
-#define EMPEG_IDERESET       (GPIO_GPIO16) /* OUT IDE hard reset (actL)      */
-#define EMPEG_RDSDATA        (GPIO_GPIO17) /* IN  RDS datastream             */
-#define EMPEG_DISPLAYPOWER   (GPIO_GPIO18) /* OUT Frontboard power           */
-#define EMPEG_I2SCLOCK       (GPIO_GPIO19) /* IN  I2S clock (2.8224Mhz)      */
-#define EMPEG_FLASHWE        (GPIO_GPIO20) /* OUT Flash write enable (actL)  */
-#define EMPEG_SERIALDSR      (GPIO_GPIO21) /* IN  Serial DSR                 */
-#define EMPEG_SERIALCTS      (GPIO_GPIO22) /* IN  Serial CTS                 */
-#define EMPEG_SERIALDTR      (GPIO_GPIO23) /* OUT Serial DTS (also LED)      */
-#define EMPEG_SIRSPEED1      (GPIO_GPIO23) /* OUT Mk2 SIR endec speed sel 1  */
-#define EMPEG_SERIALRTS      (GPIO_GPIO24) /* OUT Serial RTS                 */
-#define EMPEG_SIRSPEED2      (GPIO_GPIO24) /* OUT Mk2 SIR endec speed sel 2  */
-#define EMPEG_EXTPOWER       (GPIO_GPIO25) /* IN  External power sense (0=   */
-                                           /*     unit is in-car)            */
-#define EMPEG_DS1821         (GPIO_GPIO26) /* I/O DS1821 data line           */
-#define EMPEG_SERIALDCD      (GPIO_GPIO27) /* IN  Serial DCD                 */
-
-/* ... and IRQ defintions */
-#define EMPEG_IRQ_IR         4
-#define EMPEG_IRQ_USBIRQ     1
-#define EMPEG_IRQ_IDE1       6
-#define EMPEG_IRQ_IDE2       7
-#define EMPEG_IRQ_POWERFAIL  0
-
-#define EMPEG_IR_MAJOR 	     (242)
-#define EMPEG_USB_MAJOR      (243)
-#define EMPEG_DISPLAY_MAJOR  (244)
-#define EMPEG_AUDIO_MAJOR    (245)
-#define EMPEG_STATE_MAJOR    (246)
-#define EMPEG_RDS_MAJOR      (248)
-#define EMPEG_AUDIOIN_MAJOR  (249)
-#define EMPEG_POWER_MAJOR    (250)
-
 /* Empeg IR ioctl values */
-#define EMPEG_IR_MAGIC 'i'
+#define EMPEG_IR_MAGIC			'i'
 
 /* Set/get the remote control type */
-#define EMPEG_IR_WRITE_TYPE _IOW(EMPEG_IR_MAGIC, 1, int)
-#define EMPEG_IR_READ_TYPE _IOR(EMPEG_IR_MAGIC, 2, int)
-
-/* Set/get the delay before repeats are honoured (in microseconds)
- * Cannot be greater than one second. */
-#define EMPEG_IR_WRITE_RPTDELAY _IOW(EMPEG_IR_MAGIC, 3, unsigned long)
-#define EMPEG_IR_READ_RPTDELAY _IOR(EMPEG_IR_MAGIC, 4, unsigned long)
-
-/* Set/get the interval between repeats (in microseconds)
- * Cannot be greater than one second. */
-#define EMPEG_IR_WRITE_RPTINT _IOW(EMPEG_IR_MAGIC, 4, unsigned long)
-#define EMPEG_IR_READ_RPTINT _IOR(EMPEG_IR_MAGIC, 5, unsigned long)
-
-/* Set/get the timeout for a repeat occuring. If a repeat code happens
- * after this amount of time without one then it will be ignored. */
-#define EMPEG_IR_WRITE_RPTTMOUT _IOW(EMPEG_IR_MAGIC, 6, unsigned long)
-#define EMPEG_IR_READ_RPTTMOUT _IOR(EMPEG_IR_MAGIC, 7, unsigned long)
-
-/* Deprecated ioctl values */
-#define IR_IOCSTYPE _IOW(EMPEG_IR_MAGIC, 1, int)
-#define IR_IOCGTYPE _IOR(EMPEG_IR_MAGIC, 2, int)
-#define IR_IOCTTYPE IR_IOCGTYPE /*deprecated*/
-#define IR_IOCSRPTDELAY _IOW(EMPEG_IR_MAGIC, 3, unsigned long)
-#define IR_IOCGRPTDELAY _IOR(EMPEG_IR_MAGIC, 4, unsigned long)
-#define IR_IOCSRPTINT _IOW(EMPEG_IR_MAGIC, 4, unsigned long)
-#define IR_IOCGRPTINT _IOR(EMPEG_IR_MAGIC, 5, unsigned long)
-#define IR_IOCSRPTTMOUT _IOW(EMPEG_IR_MAGIC, 6, unsigned long)
-#define IR_IOCGRPTTMOUT _IOR(EMPEG_IR_MAGIC, 7, unsigned long)
+#define EMPEG_IR_WRITE_TYPE		_IOW(EMPEG_IR_MAGIC, 1, int)
+#define EMPEG_IR_READ_TYPE		_IOR(EMPEG_IR_MAGIC, 2, int)
 
-#define IR_TYPE_COUNT 1
+#define IR_TYPE_COUNT			1
 
-#define IR_TYPE_CAPTURE 0
-#define IR_TYPE_KENWOOD 1
+#define IR_TYPE_CAPTURE			0
+#define IR_TYPE_KENWOOD			1
 
 /* Empeg Display ioctl values */
-#define EMPEG_DISPLAY_MAGIC 'd'
+#define EMPEG_DISPLAY_MAGIC		'd'
 
 /* Deprecated ioctl codes */
-#define DIS_IOCREFRESH _IO(EMPEG_DISPLAY_MAGIC, 0)
-#define DIS_IOCSPOWER _IOW(EMPEG_DISPLAY_MAGIC, 1, int)
-#define DIS_IOCSPALETTE _IOW(EMPEG_DISPLAY_MAGIC, 4, int)
-#define DIS_IOCCLEAR _IO(EMPEG_DISPLAY_MAGIC, 5)
-#define DIS_IOCENQUEUE _IO(EMPEG_DISPLAY_MAGIC, 6)
-#define DIS_IOCPOPQUEUE _IO(EMPEG_DISPLAY_MAGIC, 7)
-#define DIS_IOCFLUSHQUEUE _IO(EMPEG_DISPLAY_MAGIC, 8)
+#define DIS_IOCREFRESH			_IO(EMPEG_DISPLAY_MAGIC, 0)
+#define DIS_IOCSPOWER			_IOW(EMPEG_DISPLAY_MAGIC, 1, int)
+#define DIS_IOCSPALETTE			_IOW(EMPEG_DISPLAY_MAGIC, 4, int)
+#define DIS_IOCCLEAR			_IO(EMPEG_DISPLAY_MAGIC, 5)
+#define DIS_IOCENQUEUE			_IO(EMPEG_DISPLAY_MAGIC, 6)
+#define DIS_IOCPOPQUEUE			_IO(EMPEG_DISPLAY_MAGIC, 7)
+#define DIS_IOCFLUSHQUEUE		_IO(EMPEG_DISPLAY_MAGIC, 8)
 
 /* Should use these ioctl codes instead */
-#define EMPEG_DISPLAY_REFRESH _IO(EMPEG_DISPLAY_MAGIC, 0)
-#define EMPEG_DISPLAY_POWER _IOW(EMPEG_DISPLAY_MAGIC, 1, int)
-#define EMPEG_DISPLAY_WRITE_PALETTE _IOW(EMPEG_DISPLAY_MAGIC, 4, int)
-#define EMPEG_DISPLAY_CLEAR _IO(EMPEG_DISPLAY_MAGIC, 5)
-#define EMPEG_DISPLAY_ENQUEUE _IO(EMPEG_DISPLAY_MAGIC, 6)
-#define EMPEG_DISPLAY_POPQUEUE _IO(EMPEG_DISPLAY_MAGIC, 7)
-#define EMPEG_DISPLAY_FLUSHQUEUE _IO(EMPEG_DISPLAY_MAGIC, 8)
-#define EMPEG_DISPLAY_QUERYQUEUEFREE _IOR(EMPEG_DISPLAY_MAGIC, 9, int)
-#define EMPEG_DISPLAY_SENDCONTROL _IOW(EMPEG_DISPLAY_MAGIC, 10, int)
-#define EMPEG_DISPLAY_SETBRIGHTNESS _IOW(EMPEG_DISPLAY_MAGIC, 11, int)
+#define EMPEG_DISPLAY_REFRESH		_IO(EMPEG_DISPLAY_MAGIC, 0)
+#define EMPEG_DISPLAY_POWER		_IOW(EMPEG_DISPLAY_MAGIC, 1, int)
+#define EMPEG_DISPLAY_WRITE_PALETTE	_IOW(EMPEG_DISPLAY_MAGIC, 4, int)
+#define EMPEG_DISPLAY_CLEAR		_IO(EMPEG_DISPLAY_MAGIC, 5)
+#define EMPEG_DISPLAY_ENQUEUE		_IO(EMPEG_DISPLAY_MAGIC, 6)
+#define EMPEG_DISPLAY_POPQUEUE		_IO(EMPEG_DISPLAY_MAGIC, 7)
+#define EMPEG_DISPLAY_FLUSHQUEUE	_IO(EMPEG_DISPLAY_MAGIC, 8)
+#define EMPEG_DISPLAY_QUERYQUEUEFREE	_IOR(EMPEG_DISPLAY_MAGIC, 9, int)
+#define EMPEG_DISPLAY_SENDCONTROL	_IOW(EMPEG_DISPLAY_MAGIC, 10, int)
+#define EMPEG_DISPLAY_SETBRIGHTNESS	_IOW(EMPEG_DISPLAY_MAGIC, 11, int)
 
 /* Sound IOCTLs */
 /* Make use of the bitmasks in soundcard.h, we only support.
@@ -139,27 +63,27 @@
 #define EMPEG_MIXER_MAGIC 'm'
 #define EMPEG_DSP_MAGIC 'a'
 
-#define EMPEG_MIXER_READ_SOURCE _IOR(EMPEG_MIXER_MAGIC, 0, int)
-#define EMPEG_MIXER_WRITE_SOURCE _IOW(EMPEG_MIXER_MAGIC, 0, int)
-#define EMPEG_MIXER_READ_FLAGS _IOR(EMPEG_MIXER_MAGIC, 1, int)
-#define EMPEG_MIXER_WRITE_FLAGS _IOW(EMPEG_MIXER_MAGIC, 1, int)
-#define EMPEG_MIXER_READ_DB _IOR(EMPEG_MIXER_MAGIC, 2, int)
-#define EMPEG_MIXER_WRITE_LOUDNESS _IOW(EMPEG_MIXER_MAGIC, 4, int)
-#define EMPEG_MIXER_READ_LOUDNESS _IOR(EMPEG_MIXER_MAGIC, 4, int)
-#define EMPEG_MIXER_READ_LOUDNESS_DB _IOR(EMPEG_MIXER_MAGIC, 5, int)
-#define EMPEG_MIXER_WRITE_BALANCE _IOW(EMPEG_MIXER_MAGIC, 6, int)
-#define EMPEG_MIXER_READ_BALANCE _IOR(EMPEG_MIXER_MAGIC, 6, int)
-#define EMPEG_MIXER_READ_BALANCE_DB _IOR(EMPEG_MIXER_MAGIC, 7, int)
-#define EMPEG_MIXER_WRITE_FADE _IOW(EMPEG_MIXER_MAGIC, 8, int)
-#define EMPEG_MIXER_READ_FADE _IOR(EMPEG_MIXER_MAGIC, 8, int)
-#define EMPEG_MIXER_READ_FADE_DB _IOR(EMPEG_MIXER_MAGIC, 9, int)
-#define EMPEG_MIXER_SET_EQ _IOW(EMPEG_MIXER_MAGIC, 10, int)
-#define EMPEG_MIXER_GET_EQ _IOR(EMPEG_MIXER_MAGIC, 11, int)
-#define EMPEG_MIXER_SET_EQ_FOUR_CHANNEL _IOW(EMPEG_MIXER_MAGIC, 12, int)
-#define EMPEG_MIXER_GET_EQ_FOUR_CHANNEL _IOR(EMPEG_MIXER_MAGIC, 13, int)
-#define EMPEG_MIXER_GET_COMPRESSION _IOR(EMPEG_MIXER_MAGIC, 14, int)
-#define EMPEG_MIXER_SET_COMPRESSION _IOW(EMPEG_MIXER_MAGIC, 14, int)
-#define EMPEG_MIXER_SET_SAM _IOW(EMPEG_MIXER_MAGIC, 15, int)
+#define EMPEG_MIXER_READ_SOURCE		_IOR(EMPEG_MIXER_MAGIC, 0, int)
+#define EMPEG_MIXER_WRITE_SOURCE	_IOW(EMPEG_MIXER_MAGIC, 0, int)
+#define EMPEG_MIXER_READ_FLAGS		_IOR(EMPEG_MIXER_MAGIC, 1, int)
+#define EMPEG_MIXER_WRITE_FLAGS		_IOW(EMPEG_MIXER_MAGIC, 1, int)
+#define EMPEG_MIXER_READ_DB		_IOR(EMPEG_MIXER_MAGIC, 2, int)
+#define EMPEG_MIXER_WRITE_LOUDNESS	_IOW(EMPEG_MIXER_MAGIC, 4, int)
+#define EMPEG_MIXER_READ_LOUDNESS	_IOR(EMPEG_MIXER_MAGIC, 4, int)
+#define EMPEG_MIXER_READ_LOUDNESS_DB	_IOR(EMPEG_MIXER_MAGIC, 5, int)
+#define EMPEG_MIXER_WRITE_BALANCE	_IOW(EMPEG_MIXER_MAGIC, 6, int)
+#define EMPEG_MIXER_READ_BALANCE	_IOR(EMPEG_MIXER_MAGIC, 6, int)
+#define EMPEG_MIXER_READ_BALANCE_DB	_IOR(EMPEG_MIXER_MAGIC, 7, int)
+#define EMPEG_MIXER_WRITE_FADE		_IOW(EMPEG_MIXER_MAGIC, 8, int)
+#define EMPEG_MIXER_READ_FADE		_IOR(EMPEG_MIXER_MAGIC, 8, int)
+#define EMPEG_MIXER_READ_FADE_DB	_IOR(EMPEG_MIXER_MAGIC, 9, int)
+#define EMPEG_MIXER_SET_EQ		_IOW(EMPEG_MIXER_MAGIC, 10, int)
+#define EMPEG_MIXER_GET_EQ		_IOR(EMPEG_MIXER_MAGIC, 11, int)
+#define EMPEG_MIXER_SET_EQ_FOUR_CHANNEL	_IOW(EMPEG_MIXER_MAGIC, 12, int)
+#define EMPEG_MIXER_GET_EQ_FOUR_CHANNEL	_IOR(EMPEG_MIXER_MAGIC, 13, int)
+#define EMPEG_MIXER_GET_COMPRESSION	_IOR(EMPEG_MIXER_MAGIC, 14, int)
+#define EMPEG_MIXER_SET_COMPRESSION	_IOW(EMPEG_MIXER_MAGIC, 14, int)
+#define EMPEG_MIXER_SET_SAM		_IOW(EMPEG_MIXER_MAGIC, 15, int)
 #define EMPEG_MIXER_RAW_I2C_READ	_IOR(EMPEG_MIXER_MAGIC, 16, int)
 #define EMPEG_MIXER_RAW_I2C_WRITE	_IOW(EMPEG_MIXER_MAGIC, 16, int)
 #define EMPEG_MIXER_WRITE_SENSITIVITY	_IOW(EMPEG_MIXER_MAGIC, 17, int)
@@ -180,49 +104,47 @@
 #define EMPEG_MIXER_SELECT_FM		0
 #define EMPEG_MIXER_SELECT_AM		1
 
-#define EMPEG_MIXER_FLAG_MUTE (1<<0)
+#define EMPEG_MIXER_FLAG_MUTE		(1<<0)
 /*#define EMPEG_MIXER_FLAG_LOUDNESS (1<<1)*/
 
 /* Radio IOCTLs */
 /* These are in addition to those provided by the Video4Linux API */
-#define EMPEG_RADIO_MAGIC 'r'
-#define EMPEG_RADIO_READ_MONO _IOR(EMPEG_RADIO_MAGIC, 73, int)
-#define EMPEG_RADIO_WRITE_MONO _IOW(EMPEG_RADIO_MAGIC, 73, int)
-#define EMPEG_RADIO_READ_DX _IOR(EMPEG_RADIO_MAGIC, 74, int)
-#define EMPEG_RADIO_WRITE_DX _IOW(EMPEG_RADIO_MAGIC, 74, int)
-#define EMPEG_RADIO_READ_SENSITIVITY _IOR(EMPEG_RADIO_MAGIC, 75, int)
-#define EMPEG_RADIO_WRITE_SENSITIVITY _IOW(EMPEG_RADIO_MAGIC, 75, int)
-#define EMPEG_RADIO_SEARCH _IO(EMPEG_RADIO_MAGIC, 76) /* Pass in direction in *arg */
-#define EMPEG_RADIO_GET_MULTIPATH _IOR(EMPEG_RADIO_MAGIC, 77, int)
-#define EMPEG_RADIO_SET_STEREO _IOW(EMPEG_RADIO_MAGIC, 78, int)
+/* Hmm, not sure why we started at 73 but might as well stick to it */
+#define EMPEG_RADIO_MAGIC		'r'
+#define EMPEG_RADIO_READ_MONO		_IOR(EMPEG_RADIO_MAGIC, 73, int)
+#define EMPEG_RADIO_WRITE_MONO		_IOW(EMPEG_RADIO_MAGIC, 73, int)
+#define EMPEG_RADIO_READ_DX		_IOR(EMPEG_RADIO_MAGIC, 74, int)
+#define EMPEG_RADIO_WRITE_DX		_IOW(EMPEG_RADIO_MAGIC, 74, int)
+#define EMPEG_RADIO_READ_SENSITIVITY	_IOR(EMPEG_RADIO_MAGIC, 75, int)
+#define EMPEG_RADIO_WRITE_SENSITIVITY	_IOW(EMPEG_RADIO_MAGIC, 75, int)
+#define EMPEG_RADIO_SEARCH		_IO(EMPEG_RADIO_MAGIC, 76) /* Pass in direction in *arg */
+#define EMPEG_RADIO_GET_MULTIPATH	_IOR(EMPEG_RADIO_MAGIC, 77, int)
+#define EMPEG_RADIO_SET_STEREO		_IOW(EMPEG_RADIO_MAGIC, 78, int)
 #define EMPEG_RADIO_READ_RAW		_IOR(EMPEG_RADIO_MAGIC, 79, int)
 
-#define EMPEG_DSP_BEEP _IOW(EMPEG_DSP_MAGIC, 0, int)
-#define EMPEG_DSP_PURGE _IOR(EMPEG_DSP_MAGIC, 1, int)
-#define EMPEG_DSP_GRAB_OUTPUT _IOR(EMPEG_DSP_MAGIC, 2, int)
+#define EMPEG_DSP_BEEP			_IOW(EMPEG_DSP_MAGIC, 0, int)
+#define EMPEG_DSP_PURGE			_IOR(EMPEG_DSP_MAGIC, 1, int)
+#define EMPEG_DSP_GRAB_OUTPUT		_IOR(EMPEG_DSP_MAGIC, 3, int) /* must be the same in 2.4 */
 
 /* Audio input IOCTLs */
-#define EMPEG_AUDIOIN_MAGIC 'c'
-#define EMPEG_AUDIOIN_READ_SAMPLERATE _IOR(EMPEG_AUDIOIN_MAGIC, 0, int)
-#define EMPEG_AUDIOIN_WRITE_SAMPLERATE _IOW(EMPEG_AUDIOIN_MAGIC, 1, int)
-#define EMPEG_AUDIOIN_READ_CHANNEL _IOR(EMPEG_AUDIOIN_MAGIC, 2, int)
-#define EMPEG_AUDIOIN_WRITE_CHANNEL _IOW(EMPEG_AUDIOIN_MAGIC, 3, int)
-#define EMPEG_AUDIOIN_READ_STEREO _IOR(EMPEG_AUDIOIN_MAGIC, 4, int)
-#define EMPEG_AUDIOIN_WRITE_STEREO _IOW(EMPEG_AUDIOIN_MAGIC, 5, int)
-#define EMPEG_AUDIOIN_READ_GAIN _IOR(EMPEG_AUDIOIN_MAGIC, 6, int)
-#define EMPEG_AUDIOIN_WRITE_GAIN _IOW(EMPEG_AUDIOIN_MAGIC, 7, int)
-#define EMPEG_AUDIOIN_CHANNEL_DSPOUT 0
-#define EMPEG_AUDIOIN_CHANNEL_AUXIN  1
-#define EMPEG_AUDIOIN_CHANNEL_MIC    2
-
-/* Where flash is mapped in the empeg's kernel memory map */
-#define EMPEG_FLASHBASE		0xd0000000
+#define EMPEG_AUDIOIN_MAGIC		'c'
+#define EMPEG_AUDIOIN_READ_SAMPLERATE	_IOR(EMPEG_AUDIOIN_MAGIC, 0, int)
+#define EMPEG_AUDIOIN_WRITE_SAMPLERATE	_IOW(EMPEG_AUDIOIN_MAGIC, 1, int)
+#define EMPEG_AUDIOIN_READ_CHANNEL	_IOR(EMPEG_AUDIOIN_MAGIC, 2, int)
+#define EMPEG_AUDIOIN_WRITE_CHANNEL	_IOW(EMPEG_AUDIOIN_MAGIC, 3, int)
+#define EMPEG_AUDIOIN_READ_STEREO	_IOR(EMPEG_AUDIOIN_MAGIC, 4, int)
+#define EMPEG_AUDIOIN_WRITE_STEREO	_IOW(EMPEG_AUDIOIN_MAGIC, 5, int)
+#define EMPEG_AUDIOIN_READ_GAIN		_IOR(EMPEG_AUDIOIN_MAGIC, 6, int)
+#define EMPEG_AUDIOIN_WRITE_GAIN	_IOW(EMPEG_AUDIOIN_MAGIC, 7, int)
+#define EMPEG_AUDIOIN_CHANNEL_DSPOUT	0
+#define EMPEG_AUDIOIN_CHANNEL_AUXIN	1
+#define EMPEG_AUDIOIN_CHANNEL_MIC	2
 
 /* Power control IOCTLs */
-#define EMPEG_POWER_MAGIC 'p'
-#define EMPEG_POWER_TURNOFF _IO(EMPEG_POWER_MAGIC, 0)
-#define EMPEG_POWER_WAKETIME _IOW(EMPEG_POWER_MAGIC, 1, int)
-#define EMPEG_POWER_READSTATE _IOR(EMPEG_POWER_MAGIC, 2, int)
+#define EMPEG_POWER_MAGIC		'p'
+#define EMPEG_POWER_TURNOFF		_IO(EMPEG_POWER_MAGIC, 0)
+#define EMPEG_POWER_WAKETIME		_IOW(EMPEG_POWER_MAGIC, 1, int)
+#define EMPEG_POWER_READSTATE		_IOR(EMPEG_POWER_MAGIC, 2, int)
 
 #define EMPEG_POWER_FLAG_DC 		0x01
 #define EMPEG_POWER_FLAG_FAILENABLED	0x02
@@ -234,61 +156,34 @@
 
 /* State storage ioctls */
 /* Shouldn't need either of these in normal use. */
-#define EMPEG_STATE_MAGIC 's'
-#define EMPEG_STATE_FORCESTORE _IO(EMPEG_STATE_MAGIC, 74)
-#define EMPEG_STATE_FAKEPOWERFAIL _IO(EMPEG_STATE_MAGIC, 75)
+#define EMPEG_STATE_MAGIC		's'
+#define EMPEG_STATE_FORCESTORE		_IO(EMPEG_STATE_MAGIC, 74)
+#define EMPEG_STATE_FAKEPOWERFAIL	_IO(EMPEG_STATE_MAGIC, 75)
+
+/* RDS ioctls */
+#define EMPEG_RDS_MAGIC			'R'
+#define EMPEG_RDS_GET_INTERFACE		_IOR(EMPEG_RDS_MAGIC, 0, int)
+#define EMPEG_RDS_SET_INTERFACE		_IOW(EMPEG_RDS_MAGIC, 0, int)
+
+#define EMPEG_RDS_INTERFACE_OFF		0
+#define EMPEG_RDS_INTERFACE_COOKED	1
+#define EMPEG_RDS_INTERFACE_RAW		2
 
+#define EMPEG_RAMTEST_MAGIC		'T'
+#define EMPEG_RAMTEST_TEST_PAGE		_IOW(EMPEG_RAMTEST_MAGIC, 0, unsigned long)
+
 #ifndef __ASSEMBLY__
 struct empeg_eq_section_t
 {
 	unsigned int word1;
 	unsigned int word2;
 };
-
-#ifdef __KERNEL__
-extern void audio_emitted_action(void);
-extern int audio_get_fm_level(void);
-extern int audio_get_stereo(void);
-extern int audio_get_multipath(void);
-#ifdef CONFIG_EMPEG_STATE
-extern void enable_powerfail(int enable);
-extern int powerfail_enabled(void);
-#else
-static inline void enable_powerfail(int enable)
-{
-	enable = enable;
-}
-#endif /* CONFIG_EMPEG_STATE */
-
-#ifdef CONFIG_EMPEG_DISPLAY
-void empeg_displaypower(int on);
-static inline void display_powerfail_action(void)
-{
-	/* Mute audio & turn off display */
-/*	GPCR=EMPEG_DSPPOM | EMPEG_DISPLAYPOWER; */
-	empeg_displaypower(0);
-
-	/* Turn off scan */
-	LCCR0=0;
-}
-extern void display_powerreturn_action(void);
-#endif
-
-static inline int empeg_hardwarerevision(void)
-{
-	/* Return hardware revision */
-	unsigned int *id=(unsigned int*)(EMPEG_FLASHBASE+0x2000);
 
-	return(id[0]);
-}
-
-static inline unsigned int get_empeg_id(void)
+struct empeg_ramtest_args_t
 {
-	unsigned int *flash=(unsigned int*)(EMPEG_FLASHBASE+0x2000);
-	return flash[1];
-}
-
-#endif /* __KERNEL__ */
-#endif /* __ASSEMBLY__ */
+	unsigned long addr;
+	unsigned long ret;
+};
+#endif /* !defined(__ASSEMBLY__) */
 
-#endif /* __ASM_ARCH_EMPEG_H */
+#endif /* _INCLUDE_EMPEG_H */
Index: empeg/kernel/include/asm-arm/arch-sa1100/empegcar.h
diff -u /dev/null empeg/kernel/include/asm-arm/arch-sa1100/empegcar.h:1.1
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/include/asm-arm/arch-sa1100/empegcar.h	Thu Aug 23 16:29:06 2001
@@ -0,0 +1,110 @@
+#ifndef _INCLUDE_EMPEGCAR_H
+#define _INCLUDE_EMPEGCAR_H 1
+
+/* Where flash is mapped in the empeg's kernel memory map */
+#define EMPEG_FLASHBASE			0xd0000000
+
+/* Revision 3 (Sonja) IO definitions */
+#define EMPEG_POWERFAIL      (GPIO_GPIO0)  /* IN  Power fail sense           */
+#define EMPEG_USBIRQ         (GPIO_GPIO1)  /* IN  USB IRQ                    */
+#define EMPEG_USBDRQ         (GPIO_GPIO2)  /* IN  USB DRQ                    */
+#define EMPEG_CRYSTALDRQ     (GPIO_GPIO2)  /* IN  Mk2 CS4231 audio in DRQ    */
+#define EMPEG_RDSCLOCK       (GPIO_GPIO3)  /* IN  RDS clock                  */
+#define EMPEG_IRINPUT_BIT    4
+#define EMPEG_IRINPUT        GPIO_GPIO(EMPEG_IRINPUT_BIT)  /* IN  Frontboard consumer IR     */
+#define EMPEG_DSP2OUT        (GPIO_GPIO5)  /* IN  7705's DSP_OUT2 pin        */
+#define EMPEG_IDE1IRQ        (GPIO_GPIO6)  /* IN  IDE channel 1 irq (actL)   */
+#define EMPEG_IDE2IRQ        (GPIO_GPIO7)  /* IN  IDE channel 2 irq (actL)   */
+#define EMPEG_ETHERNETIRQ    (GPIO_GPIO7)  /* IN  Mk2 Ethernet               */
+#define EMPEG_I2CCLOCK       (GPIO_GPIO8)  /* OUT I2C clock                  */
+#define EMPEG_I2CDATA        (GPIO_GPIO9)  /* OUT I2C data (when high pulls  */
+                                           /*     data line low)             */
+#define EMPEG_RADIODATA      (GPIO_GPIO10) /* OUT Radio data (when high it   */
+					   /*     pulls data line low)       */
+#define EMPEG_DISPLAYCONTROL (GPIO_GPIO10) /* OUT Mk2 display control line   */
+#define EMPEG_I2CDATAIN      (GPIO_GPIO11) /* IN  I2C data input             */
+#define EMPEG_RADIOCLOCK     (GPIO_GPIO12) /* OUT Radio clock                */
+#define EMPEG_SIRSPEED0      (GPIO_GPIO12) /* OUT Mk2 SIR endec speed sel 0  */
+#define EMPEG_RADIOWR        (GPIO_GPIO13) /* OUT Radio write enable         */
+#define EMPEG_ACCSENSE       (GPIO_GPIO13) /* IN  Mk2 Car accessory sense    */
+#define EMPEG_RADIODATAIN    (GPIO_GPIO14) /* IN  Radio data input           */
+#define EMPEG_POWERCONTROL   (GPIO_GPIO14) /* OUT Mk2 Control for power PIC  */
+#define EMPEG_DSPPOM         (GPIO_GPIO15) /* OUT DSP power-on-mute          */
+#define EMPEG_IDERESET       (GPIO_GPIO16) /* OUT IDE hard reset (actL)      */
+#define EMPEG_RDSDATA        (GPIO_GPIO17) /* IN  RDS datastream             */
+#define EMPEG_DISPLAYPOWER   (GPIO_GPIO18) /* OUT Frontboard power           */
+#define EMPEG_I2SCLOCK       (GPIO_GPIO19) /* IN  I2S clock (2.8224Mhz)      */
+#define EMPEG_FLASHWE        (GPIO_GPIO20) /* OUT Flash write enable (actL)  */
+#define EMPEG_SERIALDSR      (GPIO_GPIO21) /* IN  Serial DSR                 */
+#define EMPEG_SERIALCTS      (GPIO_GPIO22) /* IN  Serial CTS                 */
+#define EMPEG_SERIALDTR      (GPIO_GPIO23) /* OUT Serial DTS (also LED)      */
+#define EMPEG_SIRSPEED1      (GPIO_GPIO23) /* OUT Mk2 SIR endec speed sel 1  */
+#define EMPEG_SERIALRTS      (GPIO_GPIO24) /* OUT Serial RTS                 */
+#define EMPEG_SIRSPEED2      (GPIO_GPIO24) /* OUT Mk2 SIR endec speed sel 2  */
+#define EMPEG_EXTPOWER       (GPIO_GPIO25) /* IN  External power sense (0=   */
+                                           /*     unit is in-car)            */
+#define EMPEG_DS1821         (GPIO_GPIO26) /* I/O DS1821 data line           */
+#define EMPEG_SERIALDCD      (GPIO_GPIO27) /* IN  Serial DCD                 */
+
+/* ... and IRQ defintions */
+#define EMPEG_IRQ_IR         4
+#define EMPEG_IRQ_USBIRQ     1
+#define EMPEG_IRQ_IDE1       6
+#define EMPEG_IRQ_IDE2       7
+#define EMPEG_IRQ_POWERFAIL  0
+
+#define EMPEG_IR_MAJOR 	     (242)
+#define EMPEG_USB_MAJOR      (243)
+#define EMPEG_DISPLAY_MAJOR  (244)
+#define EMPEG_AUDIO_MAJOR    (245)
+#define EMPEG_STATE_MAJOR    (246)
+#define EMPEG_RDS_MAJOR      (248)
+#define EMPEG_AUDIOIN_MAJOR  (249)
+#define EMPEG_POWER_MAJOR    (250)
+
+#if !defined(__ASSEMBLY__)
+extern void audio_emitted_action(void);
+extern int audio_get_fm_level(void);
+extern int audio_get_stereo(void);
+extern int audio_get_multipath(void);
+#ifdef CONFIG_EMPEG_STATE
+extern void enable_powerfail(int enable);
+extern int powerfail_enabled(void);
+#else
+static inline void enable_powerfail(int enable)
+{
+	/* It's unused */
+	enable = enable;
+}
+#endif /* CONFIG_EMPEG_STATE */
+
+#ifdef CONFIG_EMPEG_DISPLAY
+void empeg_displaypower(int on);
+static inline void display_powerfail_action(void)
+{
+	/* Turn off display */
+	empeg_displaypower(0);
+
+	/* Turn off scan */
+	LCCR0=0;
+}
+extern void display_powerreturn_action(void);
+#endif
+
+static inline int empeg_hardwarerevision(void)
+{
+	/* Return hardware revision */
+	unsigned int *id=(unsigned int*)(EMPEG_FLASHBASE+0x2000);
+
+	return(id[0]);
+}
+
+static inline unsigned int get_empeg_id(void)
+{
+	unsigned int *flash=(unsigned int*)(EMPEG_FLASHBASE+0x2000);
+	return flash[1];
+}
+#endif /* !defined(__ASSEMBLY) */
+
+#endif /* _INCLUDE_EMPEGCAR_H */
+
Index: empeg/kernel/include/asm-arm/arch-sa1100/hardware.h
diff -u empeg/kernel/include/asm-arm/arch-sa1100/hardware.h:1.5 empeg/kernel/include/asm-arm/arch-sa1100/hardware.h:1.6
--- empeg/kernel/include/asm-arm/arch-sa1100/hardware.h:1.5	Sat Mar 18 16:00:36 2000
+++ empeg/kernel/include/asm-arm/arch-sa1100/hardware.h	Thu Aug 23 16:29:06 2001
@@ -96,8 +96,7 @@
 
 /* Include specific empeg hardware definitions */
 #ifdef CONFIG_SA1100_EMPEG
-#include "empeg.h"
+#include "empegcar.h"
 #endif
-
 
 #endif
Index: empeg/kernel/include/asm-i386/errno.h
diff -u empeg/kernel/include/asm-i386/errno.h:1.1.1.1 empeg/kernel/include/asm-i386/errno.h:1.2
--- empeg/kernel/include/asm-i386/errno.h:1.1.1.1	Wed Jun  9 13:09:04 1999
+++ empeg/kernel/include/asm-i386/errno.h	Fri Oct 20 15:54:49 2000
@@ -128,5 +128,6 @@
 
 #define	ENOMEDIUM	123	/* No medium found */
 #define	EMEDIUMTYPE	124	/* Wrong medium type */
+#define	EHASHCOLLISION	125	/* Number of hash collisons exceeds maximum generation counter value.  */
 
 #endif
Index: empeg/kernel/include/linux/fs.h
diff -u empeg/kernel/include/linux/fs.h:1.1.1.3 empeg/kernel/include/linux/fs.h:1.2
--- empeg/kernel/include/linux/fs.h:1.1.1.3	Sat Mar 18 15:23:20 2000
+++ empeg/kernel/include/linux/fs.h	Fri Oct 20 15:54:49 2000
@@ -275,6 +275,7 @@
 #include <linux/hfs_fs_i.h>
 #include <linux/adfs_fs_i.h>
 #include <linux/qnx4_fs_i.h>
+#include <linux/reiserfs_fs_i.h>
 
 /*
  * Attribute flags.  These should be or-ed together to figure out what
@@ -387,7 +388,8 @@
 		struct smb_inode_info		smbfs_i;
 		struct hfs_inode_info		hfs_i;
 		struct adfs_inode_info		adfs_i;
-		struct qnx4_inode_info		qnx4_i;
+		struct qnx4_inode_info		qnx4_i;	   
+		struct reiserfs_inode_info	reiserfs_i;
 		struct socket			socket_i;
 		void				*generic_ip;
 	} u;
@@ -510,6 +512,7 @@
 #include <linux/hfs_fs_sb.h>
 #include <linux/adfs_fs_sb.h>
 #include <linux/qnx4_fs_sb.h>
+#include <linux/reiserfs_fs_sb.h>
 
 extern struct list_head super_blocks;
 
@@ -552,7 +555,8 @@
 		struct smb_sb_info	smbfs_sb;
 		struct hfs_sb_info	hfs_sb;
 		struct adfs_sb_info	adfs_sb;
-		struct qnx4_sb_info	qnx4_sb;	
+		struct qnx4_sb_info	qnx4_sb;
+	        struct reiserfs_sb_info reiserfs_sb;
 		void			*generic_sbp;
 	} u;
 	/*
Index: empeg/kernel/include/linux/reiserfs_fs.h
diff -u /dev/null empeg/kernel/include/linux/reiserfs_fs.h:1.2
--- /dev/null	Wed Oct 17 16:36:06 2001
+++ empeg/kernel/include/linux/reiserfs_fs.h	Fri Oct 20 16:48:40 2000
@@ -0,0 +1,1482 @@
+/*
+ * Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
+ */
+#ifndef _LINUX_REISER_FS_H
+#define _LINUX_REISER_FS_H
+
+
+#include <linux/types.h>
+#ifdef __KERNEL__
+#include <linux/malloc.h>
+#include <linux/tqueue.h>
+#endif
+
+/*
+ *  include/linux/reiser_fs.h
+ *
+ *  Reiser File System constants and structures
+ *
+ */
+
+/* in reading the #defines, it may help to understand that they employ
+ the following abbreviations:
+
+B = Buffer
+I = Item header
+H = Height within the tree (should be changed to LEV)
+N = Number of the item in the node
+DNM = DyNaMic data
+STAT = stat data
+DEH = Directory Entry Header
+EC = Entry Count
+E = Entry number
+UL = Unsigned Long
+BLKH = BLocK Header
+UNFM = UNForMatted node
+DC = Disk Child
+P = Path
+
+These #defines are named by concatenating these abbreviations, where
+first comes the arguments, and last comes the return value, of the
+macro.
+
+*/
+
+#define REISERFS_CHECK
+
+#ifdef __arm
+/* ARM can't load ints or u32s from unaligned addresses (it silently gives the
+ * wrong answer). So we must u32-align all structures in directory blocks :-(
+ */
+#define REISERFS_ALIGNED
+#endif
+
+/* NEW_GET_NEW_BUFFER will try to allocate new blocks better */
+/*#define NEW_GET_NEW_BUFFER*/
+#define OLD_GET_NEW_BUFFER
+
+/* if this is undefined, all inode changes get into stat data immediately, if it can be found in RAM */
+#define DIRTY_LATER
+
+
+/* these are used by reiserfs_file_read when no genericread mount option specified */
+#define REISERFS_NBUF 32
+
+#define REISERFS_OBJECT_READ_AHEAD
+
+#define PACKING_LOCALITY_READ_AHEAD
+
+/* Should be used for single disk file systems. */
+/* #define READ_LOCK_REISERFS */
+
+
+
+/* obsolete defines */
+/*#define REISERFS_CHECK_ONE_PROCESS*/
+/*#define REISERFS_INFO*/
+
+
+
+
+
+/*
+ * Disk Data Structures
+ */
+
+/***************************************************************************/
+/*                             SUPER BLOCK                                 */
+/***************************************************************************/
+
+/*
+ * Structure of super block on disk, a version of which in RAM is often accessed as s->u.reiserfs_sb.s_rs
+ * the version in RAM is part of a larger structure containing fields never written to disk.
+ */
+
+				/* used by gcc */
+#define REISERFS_SUPER_MAGIC 0x52654973
+				/* used by file system utilities that
+                                   look at the superblock, etc. */
+#define REISERFS_SUPER_MAGIC_STRING "ReIsErFs"
+
+				/* ReiserFS leaves the first 64k unused,
+                                   so that partition labels have enough
+                                   space.  If someone wants to write a
+                                   fancy bootloader that needs more than
+                                   64k, let us know, and this will be
+                                   increased in size.  This number must
+                                   be larger than than the largest block
+                                   size on any platform, or code will
+                                   break.  -Hans */
+#define REISERFS_DISK_OFFSET_IN_BYTES (64 * 1024)
+#define REISERFS_FIRST_BLOCK unused_define
+
+/* the spot for the super in versions 3.5 - 3.5.11 (inclusive) */
+#define REISERFS_OLD_DISK_OFFSET_IN_BYTES (8 * 1024)
+
+#define READ_BLOCKS  1
+#define DONT_READ_BLOCKS 2
+
+#define CARRY_ON          	0
+#define SCHEDULE_OCCURRED  	1
+#define PATH_INCORRECT    	2
+#define IO_ERROR		3
+
+#define NO_DISK_SPACE        (-1)
+#define NO_BALANCING_NEEDED  (-2)
+
+
+struct buffer_and_id {
+  struct buffer_head  * bi_buf;
+  unsigned long  bi_id;
+};
+
+typedef unsigned long b_blocknr_t;
+typedef __u32 unp_t;
+
+struct unfm_nodeinfo {
+  unsigned long	 unfm_nodenum;
+  unsigned short unfm_freespace;
+};
+
+/* when reiserfs_file_write is called with a byte count >= MIN_PACK_ON_CLOSE,
+** it sets the inode to pack on close, and when extending the file, will only
+** use unformatted nodes.
+**
+** This is a big speed up for the journal, which is badly hurt by direct->indirect
+** conversions (they must be logged).
+*/
+#define MIN_PACK_ON_CLOSE		512
+
+/* the defines below say, that if file size is >=
+   DIRECT_TAIL_SUPPRESSION_SIZE * blocksize, then if tail is longer
+   than MAX_BYTES_SUPPRESS_DIRECT_TAIL, it will be stored in
+   unformatted node */
+#define DIRECT_TAIL_SUPPRESSION_SIZE      1024
+#define MAX_BYTES_SUPPRESS_DIRECT_TAIL    1024
+
+/* Check whether byte is placed in a direct item. */
+#define INODE_OFFSET_IN_DIRECT(p_s_inode, n_offset) \
+( (n_offset) >= (p_s_inode)->u.reiserfs_i.i_first_direct_byte )
+
+/* this is used for i_first_direct_byte field of inode */
+#define NO_BYTES_IN_DIRECT_ITEM MAX_KEY_OFFSET
+
+/* We store tail in unformatted node if it is too big to fit into a
+   formatted node or if DIRECT_TAIL_SUPPRESSION_SIZE,
+   MAX_BYTES_SUPPRESS_DIRECT_TAIL and file size say that. */
+/* #define STORE_TAIL_IN_UNFM(n_file_size,n_tail_size,n_block_size) \ */
+/* ( ((n_tail_size) > MAX_DIRECT_ITEM_LEN(n_block_size)) || \ */
+/*   ( ( (n_file_size) >= (n_block_size) * DIRECT_TAIL_SUPPRESSION_SIZE ) && \ */
+/*    ( (n_tail_size) >= MAX_BYTES_SUPPRESS_DIRECT_TAIL ) ) ) */
+
+  /* This is an aggressive tail suppression policy, I am hoping it
+     improves our benchmarks. The principle behind it is that
+     percentage space saving is what matters, not absolute space
+     saving.  This is non-intuitive, but it helps to understand it if
+     you consider that the cost to access 4 blocks is not much more
+     than the cost to access 1 block, if you have to do a seek and
+     rotate.  A tail risks a non-linear disk access that is
+     significant as a percentage of total time cost for a 4 block file
+     and saves an amount of space that is less significant as a
+     percentage of space, or so goes the hypothesis.  -Hans */
+#define STORE_TAIL_IN_UNFM(n_file_size,n_tail_size,n_block_size) \
+\
+( ((n_tail_size) > MAX_DIRECT_ITEM_LEN(n_block_size)) || \
+  ( (n_file_size) >= (n_block_size) * 4 ) || \
+   ( ( (n_file_size) >= (n_block_size) * 3 ) && \
+   ( (n_tail_size) >=   (MAX_DIRECT_ITEM_LEN(n_block_size))/4) ) || \
+   ( ( (n_file_size) >= (n_block_size) * 2 ) && \
+   ( (n_tail_size) >=   (MAX_DIRECT_ITEM_LEN(n_block_size))/2) ) || \
+   ( ( (n_file_size) >= (n_block_size) ) && \
+   ( (n_tail_size) >=   (MAX_DIRECT_ITEM_LEN(n_block_size) * 3)/4) ) )
+
+
+/*
+ * values for s_state field
+ */
+#define REISERFS_VALID_FS    1
+#define REISERFS_ERROR_FS    2
+
+
+
+/***************************************************************************/
+/*                       KEY & ITEM HEAD                                   */
+/***************************************************************************/
+typedef __u32 objectid_t;
+
+/* Key of the object drop determines its location in the S+tree, and is composed of 4 components */
+struct key {
+  __u32 k_dir_id;   	    /* packing locality: by default parent directory object id */
+  __u32 k_objectid;          /* object identifier */
+  __u32 k_offset;	    /* for regular files this is the offset to the first byte of the body, */
+	                            /* contained in the object-item, */
+       		                    /* as measured from the start of the entire body of the object. */
+
+				       /* for directory entries, k_offset consists of hash derived from
+					  hashing the name and using few bits (23 or more) of the resulting
+					  hash, and generation number that allows distinguishing names with
+					  hash collisions. If number of collisions overflows generation number, we return EEXIST. 
+					  High order bit is 0 always */
+  __u32 k_uniqueness;	       /* uniqueness field used for storing flags about the item's type and
+					  mergeability.  Key size is performance critical.  These flags should
+					  not be stored here in the key, and the key could be reduced to three
+					  components by pushing the uniqueness field into the offset for
+					  directories.  Grrr. -Hans */
+};
+
+ /* Our function for comparing keys can compare keys of different
+    lengths.  It takes as a parameter the length of the keys it is to
+    compare.  These defines are used in determining what is to be
+    passed to it as that parameter. */
+#define REISERFS_FULL_KEY_LEN     4
+
+#define REISERFS_SHORT_KEY_LEN    2
+
+/* The result of the key compare */
+#define FIRST_GREATER 1
+#define SECOND_GREATER -1
+#define KEYS_IDENTICAL 0
+#define KEY_FOUND 1
+#define KEY_NOT_FOUND 0
+
+
+#define KEY_SIZE (sizeof(struct key))
+#define SHORT_KEY_SIZE (sizeof (unsigned long) + sizeof (unsigned long))
+
+/* return values for search_by_key and clones */
+#define ITEM_FOUND 1
+#define ITEM_NOT_FOUND 0
+#define ENTRY_FOUND 1
+#define ENTRY_NOT_FOUND 0
+#define DIRECTORY_NOT_FOUND -1
+#define REGULAR_FILE_FOUND -2
+#define DIRECTORY_FOUND -3
+#define BYTE_FOUND 1
+#define BYTE_NOT_FOUND 0
+#define FILE_NOT_FOUND -1
+
+#define POSITION_FOUND 1
+#define POSITION_NOT_FOUND 0
+#define GOTO_PREVIOUS_ITEM 2
+#define POSITION_FOUND_INVISIBLE 3
+
+
+/*  Everything in the filesystem is stored as a set of items.  The item head contains the key of the item, its
+   free space (for indirect items) and specifies the location of the item itself within the block.  */
+
+struct item_head
+{
+  struct key ih_key; 	/* Everything in the tree is found by searching for it based on its key.*/
+
+  union {
+    __u16 ih_free_space; /* The free space in the last unformatted node of an indirect item if this
+				     is an indirect item.  This equals 0xFFFF iff this is a direct item or
+				     stat data item. Note that the key, not this field, is used to determine
+				     the item type, and thus which field this union contains. */
+    __u16 ih_entry_count; /* Iff this is a directory item, this field equals the number of directory
+				      entries in the directory item. */
+  } u;
+  __u16 ih_item_len;           /* total size of the item body                  */
+  __u16 ih_item_location;      /* an offset to the item body within the block  */
+  __u16 ih_reserved;		/* used by reiserfsck */
+};
+/* size of item header     */
+#define IH_SIZE (sizeof(struct item_head))
+
+
+#define I_K_KEY_IN_ITEM(p_s_ih, p_s_key, n_blocksize) \
+    ( ! COMP_SHORT_KEYS(p_s_ih, p_s_key) && \
+          I_OFF_BYTE_IN_ITEM(p_s_ih, (p_s_key)->k_offset, n_blocksize) )
+
+/* maximal length of item */ 
+#define MAX_ITEM_LEN(block_size) (block_size - BLKH_SIZE - IH_SIZE)
+#define MIN_ITEM_LEN 1
+
+
+/* object identifier for root dir */
+#define REISERFS_ROOT_OBJECTID 2
+#define REISERFS_ROOT_PARENT_OBJECTID 1
+extern struct key root_key;
+
+
+
+
+/* 
+ * Picture represents a leaf of the S+tree
+ *  ______________________________________________________
+ * |      |  Array of     |                   |           |
+ * |Block |  Object-Item  |      F r e e      |  Objects- |
+ * | head |  Headers      |     S p a c e     |   Items   |
+ * |______|_______________|___________________|___________|
+ */
+
+/* Header of a disk block.  More precisely, header of a formatted leaf
+   or internal node, and not the header of an unformatted node. */
+struct block_head {       
+  __u16 blk_level;        /* Level of a block in the tree. */
+  __u16 blk_nr_item;      /* Number of keys/items in a block. */
+  __u16 blk_free_space;   /* Block free space in bytes. */
+  struct key  blk_right_delim_key; /* Right delimiting key for this block (supported for leaf level nodes
+				      only) */
+};
+
+#define BLKH_SIZE (sizeof(struct block_head))
+
+/*
+ * values for blk_type field
+ */
+
+#define FREE_LEVEL        0 /* Node of this level is out of the tree. */
+
+#define DISK_LEAF_NODE_LEVEL  1 /* Leaf node level.                       */
+
+/* Given the buffer head of a formatted node, resolve to the block head of that node. */
+#define B_BLK_HEAD(p_s_bh)  ((struct block_head *)((p_s_bh)->b_data))
+/* Number of items that are in buffer. */
+#define B_NR_ITEMS(p_s_bh)	  	( B_BLK_HEAD(p_s_bh)->blk_nr_item )
+#define B_LEVEL(bh)			( B_BLK_HEAD(bh)->blk_level )
+#define B_FREE_SPACE(bh)		( B_BLK_HEAD(bh)->blk_free_space )
+/* Get right delimiting key. */
+#define B_PRIGHT_DELIM_KEY(p_s_bh)	( &(B_BLK_HEAD(p_s_bh)->blk_right_delim_key) )
+
+/* Does the buffer contain a disk leaf. */
+#define B_IS_ITEMS_LEVEL(p_s_bh)   	( B_BLK_HEAD(p_s_bh)->blk_level == DISK_LEAF_NODE_LEVEL )
+
+/* Does the buffer contain a disk internal node */
+#define B_IS_KEYS_LEVEL(p_s_bh) 	( B_BLK_HEAD(p_s_bh)->blk_level > DISK_LEAF_NODE_LEVEL &&\
+					  B_BLK_HEAD(p_s_bh)->blk_level <= MAX_HEIGHT )
+
+
+
+
+/***************************************************************************/
+/*                             STAT DATA                                   */
+/***************************************************************************/
+
+/* Stat Data on disk (reiserfs version of UFS disk inode minus the address blocks) */
+
+/*
+  The sense of adding union to stat data is to keep a value of real number of blocks used by file.
+  The necessity of adding such information is caused by existing of files with holes.
+  Reiserfs should keep number of used blocks for file, but not calculate it from file size
+  (that is not correct for holed files). Thus we have to add additional information to stat data.
+  When we have a device special file, there is no need to get number of used blocks for them,
+  and, accordingly, we doesn't need to keep major and minor numbers for regular files, which
+  might have holes. So this field is being overloaded.
+*/
+
+struct stat_data {
+  __u16 sd_mode;	/* file type, permissions */
+  __u16 sd_nlink;	/* number of hard links */
+  __u16 sd_uid;		/* owner */
+  __u16 sd_gid;		/* group */
+  __u32 sd_size;	/* file size */
+  __u32 sd_atime;	/* time of last access */
+  __u32 sd_mtime;	/* time file was last modified  */
+  __u32 sd_ctime;	/* time inode (stat data) was last changed (except changes to sd_atime and sd_mtime) */
+  union {
+	 __u32 sd_rdev;
+	 __u32 sd_blocks;	/* number of blocks file uses */
+  } u;
+  __u32 sd_first_direct_byte; /* first byte of file which is stored in a direct item: except that if it equals 1 it is a
+     symlink and if it equals MAX_KEY_OFFSET there is no direct item.  The existence of this
+     field really grates on me. Let's replace it with a macro based on sd_size and our tail
+     suppression policy.  Someday.  -Hans */
+};
+#define SD_SIZE (sizeof(struct stat_data))
+
+
+/***************************************************************************/
+/*                      DIRECTORY STRUCTURE                                */
+/***************************************************************************/
+/* 
+   Picture represents the structure of directory items
+   ________________________________________________
+   |  Array of     |   |     |        |       |   |
+   | directory     |N-1| N-2 | ....   |   1st |0th|
+   | entry headers |   |     |        |       |   |
+   |_______________|___|_____|________|_______|___|
+                    <----   directory entries         ------>
+
+ First directory item has k_offset component 1. We store "." and ".."
+ in one item, always, we never split "." and ".." into differing
+ items.  This makes, among other things, the code for removing
+ directories simpler. */
+#define SD_OFFSET  0
+#define SD_UNIQUENESS 0
+#define DOT_OFFSET 1
+#define DOT_DOT_OFFSET 2
+#define DIRENTRY_UNIQUENESS 500
+
+/* */
+#define FIRST_ITEM_OFFSET 1
+
+/*
+   Q: How to get key of object pointed to by entry from entry?  
+
+   A: Each directory entry has its header. This header has deh_dir_id and deh_objectid fields, those are key
+      of object, entry points to */
+
+/* NOT IMPLEMENTED:   
+   Directory will someday contain stat data of object */
+
+
+
+struct reiserfs_de_head
+{
+  __u32 deh_offset;  /* third component of the directory entry key */
+  __u32 deh_dir_id;  /* objectid of the parent directory of the
+			object, that is referenced by directory entry */
+  __u32 deh_objectid;/* objectid of the object, that is referenced by
+                        directory entry */
+  __u16 deh_location;/* offset of name in the whole item */
+  __u16 deh_state;   /* whether 1) entry contains stat data (for
+			future), and 2) whether entry is hidden
+			(unlinked) */
+};
+#define DEH_SIZE sizeof(struct reiserfs_de_head)
+
+#define deh_offset(deh) (__le32_to_cpu ((deh)->deh_offset))
+#define deh_dir_id(deh) (__le32_to_cpu ((deh)->deh_dir_id))
+#define deh_objectid(deh) (__le32_to_cpu ((deh)->deh_objectid))
+
+#define DEH_Statdata 0			/* not used now */
+#define DEH_Visible 2
+
+#define mark_de_with_sd(deh)        set_bit (DEH_Statdata, &((deh)->deh_state))
+#define mark_de_without_sd(deh)     clear_bit (DEH_Statdata, &((deh)->deh_state))
+#define mark_de_visible(deh)	    set_bit (DEH_Visible, &((deh)->deh_state))
+#define mark_de_hidden(deh)	    clear_bit (DEH_Visible, &((deh)->deh_state))
+
+#define de_with_sd(deh)		    test_bit (DEH_Statdata, &((deh)->deh_state))
+#define de_visible(deh)	    	    test_bit (DEH_Visible, &((deh)->deh_state))
+#define de_hidden(deh)	    	    !test_bit (DEH_Visible, &((deh)->deh_state))
+
+/* length of the directory entry in directory item. This define calculates length of i-th directory entry
+   using directory entry locations from dir entry head. When it calculates length of 0-th directory entry, it
+   uses length of whole item in place of entry location of the non-existent following entry in the
+   calculation.  See picture above.*/
+#define I_DEH_N_ENTRY_LENGTH(ih,deh,i) \
+((i) ? (((deh)-1)->deh_location - (deh)->deh_location) : ((ih)->ih_item_len) - (deh)->deh_location)
+
+/* empty directory contains two entries "." and ".." and their headers */
+#ifdef REISERFS_ALIGNED
+#define EMPTY_DIR_SIZE  (2 * DEH_SIZE + 4 + 4)
+#else
+#define EMPTY_DIR_SIZE  (2 * DEH_SIZE + /*sizeof (unsigned long) +*/ 3)
+#endif
+
+/* number of entries in the directory item, depends on ENTRY_COUNT being at the start of directory dynamic data. */
+#define I_ENTRY_COUNT(ih) ((ih)->u.ih_entry_count)
+
+/* array of the entry headers */
+#define B_I_DEH(bh,ih) ((struct reiserfs_de_head *)(B_I_PITEM(bh,ih)))
+
+/* name by bh, ih and entry_num */
+#define B_I_E_NAME(entry_num,bh,ih) ((char *)(bh->b_data + ih->ih_item_location + (B_I_DEH(bh,ih)+(entry_num))->deh_location))
+
+#define REISERFS_MAX_NAME_LEN(block_size) (block_size - BLKH_SIZE - IH_SIZE - DEH_SIZE)	/* -SD_SIZE when entry will contain stat data */
+
+/* this structure is used for operations on directory entries. It is not a disk structure. */
+/* When reiserfs_find_entry or search_by_entry_key find directory entry, they return filled reiserfs_dir_entry structure */
+struct reiserfs_dir_entry
+{
+  struct buffer_head * de_bh;
+  int de_item_num;
+  struct item_head * de_ih;
+  int de_entry_num;
+  struct reiserfs_de_head * de_deh;
+  int de_entrylen;
+  int de_namelen;
+  char * de_name;
+  char * de_gen_number_bit_string;
+
+  __u32 de_dir_id;
+  __u32 de_objectid;
+
+  struct key de_entry_key;
+};
+   
+/* these defines are useful when a particular member of a reiserfs_dir_entry is needed */
+
+/* pointer to file name, stored in entry */
+#define B_I_DEH_ENTRY_FILE_NAME(bh,ih,deh) (B_I_PITEM (bh, ih) + (deh)->deh_location)
+
+/* length of name */
+#define I_DEH_N_ENTRY_FILE_NAME_LENGTH(ih,deh,entry_num) \
+(I_DEH_N_ENTRY_LENGTH (ih, deh, entry_num) - (de_with_sd (deh) ? SD_SIZE : 0))
+
+#define DEH_OBJECTID(deh) ((deh)->deh_objectid)
+
+/* hash value occupies 24 bits starting from 7 up to 30 */
+#define GET_HASH_VALUE(offset) ((offset) & 0x7fffff80)
+/* generation number occupies 7 bits starting from 0 up to 6 */
+#define GET_GENERATION_NUMBER(offset) ((offset) & 0x0000007f)
+
+
+/*
+ * Picture represents an internal node of the reiserfs tree
+ *  ______________________________________________________
+ * |      |  Array of     |  Array of         |  Free     |
+ * |block |    keys       |  pointers         | space     |
+ * | head |      N        |      N+1          |           |
+ * |______|_______________|___________________|___________|
+ */
+
+/***************************************************************************/
+/*                      DISK CHILD                                         */
+/***************************************************************************/
+/* Disk child pointer: The pointer from an internal node of the tree
+   to a node that is on disk. */
+struct disk_child {
+  unsigned long       dc_block_number;              /* Disk child's block number. */
+  unsigned short      dc_size;		            /* Disk child's used space.   */
+};
+
+#define DC_SIZE (sizeof(struct disk_child))
+
+/* Get disk child by buffer header and position in the tree node. */
+#define B_N_CHILD(p_s_bh,n_pos)  ((struct disk_child *)\
+((p_s_bh)->b_data+BLKH_SIZE+B_NR_ITEMS(p_s_bh)*KEY_SIZE+DC_SIZE*(n_pos)))
+
+/* Get disk child number by buffer header and position in the tree node. */
+#define B_N_CHILD_NUM(p_s_bh,n_pos) (B_N_CHILD(p_s_bh,n_pos)->dc_block_number)
+
+ /* maximal value of field child_size in structure disk_child */ 
+ /* child size is the combined size of all items and their headers */
+#define MAX_CHILD_SIZE(bh) ((int)( (bh)->b_size - BLKH_SIZE ))
+
+/* amount of used space in buffer (not including block head) */
+#define B_CHILD_SIZE(cur) (MAX_CHILD_SIZE(cur)-(B_FREE_SPACE(cur)))
+
+/* max and min number of keys in internal node */
+#define MAX_NR_KEY(bh) ( (MAX_CHILD_SIZE(bh)-DC_SIZE)/(KEY_SIZE+DC_SIZE) )
+#define MIN_NR_KEY(bh)    (MAX_NR_KEY(bh)/2)
+
+/***************************************************************************/
+/*                      PATH STRUCTURES AND DEFINES                        */
+/***************************************************************************/
+
+
+/* Search_by_key fills up the path from the root to the leaf as it descends the tree looking for the
+   key.  It uses reiserfs_bread to try to find buffers in the cache given their block number.  If it
+   does not find them in the cache it reads them from disk.  For each node search_by_key finds using
+   reiserfs_bread it then uses bin_search to look through that node.  bin_search will find the
+   position of the block_number of the next node if it is looking through an internal node.  If it
+   is looking through a leaf node bin_search will find the position of the item which has key either
+   equal to given key, or which is the maximal key less than the given key. */
+
+struct  path_element  {
+  struct buffer_head *	pe_buffer;    /* Pointer to the buffer at the path in the tree. */
+  int         		pe_position;  /* Position in the tree node which is placed in the */
+                                      /* buffer above.                                  */
+};
+
+#define MAX_HEIGHT 5 /* maximal height of a tree. don't change this without changing JOURNAL_PER_BALANCE_CNT */
+#define EXTENDED_MAX_HEIGHT         7 /* Must be equals MAX_HEIGHT + FIRST_PATH_ELEMENT_OFFSET */
+#define FIRST_PATH_ELEMENT_OFFSET   2 /* Must be equal to at least 2. */
+
+#define ILLEGAL_PATH_ELEMENT_OFFSET 1 /* Must be equal to FIRST_PATH_ELEMENT_OFFSET - 1 */
+#define MAX_FEB_SIZE 6   /* this MUST be MAX_HEIGHT + 1. See about FEB below */
+
+
+
+/* We need to keep track of who the ancestors of nodes are.  When we
+   perform a search we record which nodes were visited while
+   descending the tree looking for the node we searched for. This list
+   of nodes is called the path.  This information is used while
+   performing balancing.  Note that this path information may become
+   invalid, and this means we must check it when using it to see if it
+   is still valid. You'll need to read search_by_key and the comments
+   in it, especially about decrement_counters_in_path(), to understand
+   this structure. */
+struct  path {
+  struct  path_element  path_elements[EXTENDED_MAX_HEIGHT];	/* Array of the path elements.  */
+  int                   path_length;                      	/* Length of the array above.   */
+  int			pos_in_item;
+};
+
+/* Get path element by path and path position. */
+#define PATH_OFFSET_PELEMENT(p_s_path,n_offset)  ((p_s_path)->path_elements +(n_offset))
+
+/* Get buffer header at the path by path and path position. */
+#define PATH_OFFSET_PBUFFER(p_s_path,n_offset)   (PATH_OFFSET_PELEMENT(p_s_path,n_offset)->pe_buffer)
+
+/* Get position in the element at the path by path and path position. */
+#define PATH_OFFSET_POSITION(p_s_path,n_offset) (PATH_OFFSET_PELEMENT(p_s_path,n_offset)->pe_position)
+
+
+#define PATH_PLAST_BUFFER(p_s_path) (PATH_OFFSET_PBUFFER((p_s_path), (p_s_path)->path_length))
+#define PATH_LAST_POSITION(p_s_path) (PATH_OFFSET_POSITION((p_s_path), (p_s_path)->path_length))
+
+
+#define PATH_PITEM_HEAD(p_s_path)    B_N_PITEM_HEAD(PATH_PLAST_BUFFER(p_s_path),PATH_LAST_POSITION(p_s_path))
+
+/* in do_balance leaf has h == 0 in contrast with path structure,
+   where root has level == 0. That is why we need these defines */
+#define PATH_H_PBUFFER(p_s_path, h) PATH_OFFSET_PBUFFER (p_s_path, p_s_path->path_length - (h))	/* tb->S[h] */
+#define PATH_H_PPARENT(path, h) PATH_H_PBUFFER (path, (h) + 1)			/* tb->F[h] or tb->S[0]->b_parent */
+#define PATH_H_POSITION(path, h) PATH_OFFSET_POSITION (path, path->path_length - (h))	
+#define PATH_H_B_ITEM_ORDER(path, h) PATH_H_POSITION(path, h + 1)		/* tb->S[h]->b_item_order */
+
+#define PATH_H_PATH_OFFSET(p_s_path, n_h) ((p_s_path)->path_length - (n_h))
+
+
+/***************************************************************************/
+/*                       MISC                                              */
+/***************************************************************************/
+
+
+/* Size of pointer to the unformatted node. */
+#define UNFM_P_SIZE (sizeof(unsigned long))
+
+#define INODE_PKEY(inode) ((struct key *)((inode)->u.reiserfs_i.i_key))
+
+/* these say to reiserfs_file_read about desired kind of read ahead */
+
+#ifdef REISERFS_CHECK
+extern int g_kmalloc_count;
+#endif
+
+
+
+
+/***************************************************************************/
+/*                PRESERVE LIST STUFF                                      */
+/***************************************************************************/
+/* This flag tracks whether a buffer might contain data that has been shifted to it from another
+   node which is on disk and might be obliterated if power fails and this buffer is not written to
+   disk before that other node is. This flag is cleared in unlock buffers..  Note that this assumes
+   that write_caching is turned off for the disk.  Linux drivers turn write_caching off by default,
+   so this should be correct.  I need this flag to ensure that we don't pass a block, from which
+   items were shifted, to the scsi controller, free the preserve list, use a freed block, and then
+   have the scsi controller reorder the writes so that the supposedly preserved block is overwritten
+   before the block containing the shifted items reaches disk, and then risk the system crashing
+   before the shifted items reach disk.  See preserve.c for a discussion of the preserve list and
+   its role. -Hans */
+#define BH_Suspected_Recipient	12
+
+/* 1 if the node that this buffer has assigned to it has not been written to disk since it was
+   assigned to the buffer.  If a buffer is BH_Unwritten then there is no need to preserve the
+   contents of its block after balancing shifts data from it.  See preserve.c for a discussion of
+   the preserve list and its role. */
+#define BH_Unwritten	13
+
+/* 1 if the block that this buffer was last read from or written to has been placed on the preserved
+   list.  See preserve.c for a discussion of the preserve list and its role. */
+#define BH_Preserved	14
+
+
+/* modes of preserving */
+#define PRESERVE_DIRECT_TO_INDIRECT 1
+#define PRESERVE_INDIRECT_TO_DIRECT 2
+#define PRESERVE_RENAMING 3
+#define NOTHING_SPECIAL 4
+
+
+/* return value for get_space_from_preserve_list */
+#define PRESERVE_LIST_WAS_EMPTY 0
+#define FEW_BLOCKS_ARE_FREED 1
+
+
+#define MAX_UL_INT 0xffffffff
+#define MAX_INT    0x7ffffff
+#define MAX_US_INT 0xffff
+
+#define MAX_KEY_OFFSET		MAX_UL_INT
+#define MAX_KEY_UNIQUENESS	MAX_UL_INT
+#define MAX_KEY_OBJECTID	MAX_UL_INT
+
+#define MAX_B_NUM  MAX_UL_INT
+#define MAX_FC_NUM MAX_US_INT
+
+
+/* the purpose is to detect overflow of an unsigned short */
+#define REISERFS_LINK_MAX (MAX_US_INT - 1000)
+
+
+/* The following defines are used in reiserfs_insert_item and reiserfs_append_item  */
+#define REISERFS_KERNEL_MEM		0	/* reiserfs kernel memory mode	*/
+#define REISERFS_USER_MEM		1	/* reiserfs user memory mode		*/
+
+
+/***************************************************************************/
+/*                  FIXATE NODES                                           */
+/***************************************************************************/
+
+#define VI_TYPE_STAT_DATA 1
+#define VI_TYPE_DIRECT 2
+#define VI_TYPE_INDIRECT 4
+#define VI_TYPE_DIRECTORY 8
+#define VI_TYPE_FIRST_DIRECTORY_ITEM 16
+#define VI_TYPE_INSERTED_DIRECTORY_ITEM 32
+
+#define VI_TYPE_LEFT_MERGEABLE 64
+#define VI_TYPE_RIGHT_MERGEABLE 128
+
+/* To make any changes in the tree we always first find node, that contains item to be changed/deleted or
+   place to insert a new item. We call this node S. To do balancing we need to decide what we will shift to
+   left/right neighbor, or to a new node, where new item will be etc. To make this analysis simpler we build
+   virtual node. Virtual node is an array of items, that will replace items of node S. (For instance if we are
+   going to delete an item, virtual node does not contain it). Virtual node keeps information about item sizes
+   and types, mergeability of first and last items, sizes of all entries in directory item. We use this array
+   of items when calculating what we can shift to neighbors and how many nodes we have to have if we do not
+   any shiftings, if we shift to left/right neighbor or to both. */
+struct virtual_item
+{
+  unsigned short vi_type;		/* item type, mergeability */
+  unsigned short vi_item_len;           /* length of item that it will have after balancing */
+  
+  short vi_entry_count;			/* number of entries in directory item (including the new one if any,
+					   or excluding entry if it must be cut) */
+  unsigned short * vi_entry_sizes;	/* array of entry lengths for directory item */
+};
+
+struct virtual_node
+{
+  char * vn_free_ptr;		/* this is a pointer to the free space in the buffer */
+  unsigned short vn_nr_item;	/* number of items in virtual node */
+  short vn_size;        	/* size of node , that node would have if it has unlimited size and no balancing is performed */
+  short vn_mode;		/* mode of balancing (paste, insert, delete, cut) */
+  short vn_affected_item_num; 
+  short vn_pos_in_item;
+  struct item_head * vn_ins_ih;	/* item header of inserted item, 0 for other modes */
+  struct virtual_item * vn_vi;	/* array of items (including a new one, excluding item to be deleted) */
+};
+
+
+/***************************************************************************/
+/*                  TREE BALANCE                                           */
+/***************************************************************************/
+
+/* This temporary structure is used in tree balance algorithms, and
+   constructed as we go to the extent that its various parts are
+   needed.  It contains arrays of nodes that can potentially be
+   involved in the balancing of node S, and parameters that define how
+   each of the nodes must be balanced.  Note that in these algorithms
+   for balancing the worst case is to need to balance the current node
+   S and the left and right neighbors and all of their parents plus
+   create a new node.  We implement S1 balancing for the leaf nodes
+   and S0 balancing for the internal nodes (S1 and S0 are defined in
+   our papers.)*/
+
+#define MAX_FREE_BLOCK 7	/* size of the array of buffers to free at end of do_balance */
+
+/*#define MAX_DIRTIABLE 3*/		/* L, S, R */
+#define MAX_PRESERVE_NODES 2
+
+/* maximum number of FEB blocknrs on a single level */
+#define MAX_AMOUNT_NEEDED 2
+
+/* someday somebody will prefix every field in this struct with tb_ */
+struct tree_balance
+{
+  struct super_block * tb_sb;
+  struct path * tb_path;
+  struct buffer_head * L[MAX_HEIGHT];        /* array of left neighbors of nodes in the path */
+  struct buffer_head * R[MAX_HEIGHT];        /* array of right neighbors of nodes in the path*/
+  struct buffer_head * FL[MAX_HEIGHT];       /* array of fathers of the left  neighbors      */
+  struct buffer_head * FR[MAX_HEIGHT];       /* array of fathers of the right neighbors      */
+  struct buffer_head * CFL[MAX_HEIGHT];      /* array of common parents of center node and its left neighbor  */
+  struct buffer_head * CFR[MAX_HEIGHT];      /* array of common parents of center node and its right neighbor */
+
+  /* array of blocknr's that are free and are the nearest to the left node that are usable
+     for writing dirty formatted leaves, using the write_next_to algorithm. */
+  /*unsigned long free_and_near[MAX_DIRTIABLE];*/
+
+  /* nodes will be used in preserving */
+                                /* so we don't just get blocks, we have to get buffers which we likely won't use.  Seems
+                                   like it is not optimal. -Hans */
+  struct buffer_head * tb_nodes_for_preserving[MAX_PRESERVE_NODES];
+  struct buffer_head * preserved[MAX_PRESERVE_NODES];
+  struct buffer_head * FEB[MAX_FEB_SIZE]; /* array of empty buffers. Number of buffers in array equals
+					     cur_blknum. */
+  struct buffer_head * used[MAX_FEB_SIZE];
+  short int lnum[MAX_HEIGHT];	/* array of number of items which must be shifted to the left in
+				   order to balance the current node; for leaves includes item
+				   that will be partially shifted; for internal nodes, it is
+				   the number of child pointers rather than items. It includes
+				   the new item being created.  For preserve_shifted() purposes
+				   the code sometimes subtracts one from this number to get the
+				   number of currently existing items being shifted, and even
+				   more often for leaves it subtracts one to get the number of
+				   wholly shifted items for other purposes. */
+  short int rnum[MAX_HEIGHT];	/* substitute right for left in comment above */
+  short int lkey[MAX_HEIGHT];               /* array indexed by height h mapping the key delimiting L[h] and
+					       S[h] to its item number within the node CFL[h] */
+  short int rkey[MAX_HEIGHT];               /* substitute r for l in comment above */
+  short int insert_size[MAX_HEIGHT];        /* the number of bytes by we are trying to add or remove from
+					       S[h]. A negative value means removing.  */
+  short int blknum[MAX_HEIGHT];             /* number of nodes that will replace node S[h] after
+					       balancing on the level h of the tree.  If 0 then S is
+					       being deleted, if 1 then S is remaining and no new nodes
+					       are being created, if 2 or 3 then 1 or 2 new nodes is
+					       being created */
+
+  /* fields that are used only for balancing leaves of the tree */
+  short int cur_blknum;	/* number of empty blocks having been already allocated			*/
+  short int s0num;             /* number of items that fall into left most  node when S[0] splits	*/
+  short int s1num;             /* number of items that fall into first  new node when S[0] splits	*/
+  short int s2num;             /* number of items that fall into second new node when S[0] splits	*/
+  short int lbytes;            /* number of bytes which can flow to the left neighbor from the	left	*/
+  /* most liquid item that cannot be shifted from S[0] entirely		*/
+  /* if -1 then nothing will be partially shifted */
+  short int rbytes;            /* number of bytes which will flow to the right neighbor from the right	*/
+  /* most liquid item that cannot be shifted from S[0] entirely		*/
+  /* if -1 then nothing will be partially shifted                           */
+  short int s1bytes;		/* number of bytes which flow to the first  new node when S[0] splits	*/
+            			/* note: if S[0] splits into 3 nodes, then items do not need to be cut	*/
+  short int s2bytes;
+  struct buffer_head * buf_to_free[MAX_FREE_BLOCK]; /* buffers which are to be freed after do_balance finishes by unfix_nodes */
+  char * vn_buf;		/* kmalloced memory. Used to create
+				   virtual node and keep map of
+				   dirtied bitmap blocks */
+  int vn_buf_size;		/* size of the vn_buf */
+  struct virtual_node * tb_vn;	/* VN starts after bitmap of bitmap blocks */
+  char preserve_mode;		/* indicates that the deletion that will be done is part of a conversion of
+				   a tail to an unformatted node, and the buffer with the item should be
+				   preserve_shifted(). see preserve.c */
+} ;
+#define DIRTY_BITMAP_MAP(tb) ((tb)->vn_buf)
+
+#if 0
+				/* when balancing we potentially affect a 3 node wide column of nodes
+                                   in the tree (the top of the column may be tapered). C is the nodes
+                                   at the center of this column, and L and R are the nodes to the
+                                   left and right.  */
+  struct seal * L_path_seals[MAX_HEIGHT];
+  struct seal * C_path_seals[MAX_HEIGHT];
+  struct seal * R_path_seals[MAX_HEIGHT];
+  char L_path_lock_types[MAX_HEIGHT];   /* 'r', 'w', or 'n' for read, write, or none */
+  char C_path_lock_types[MAX_HEIGHT];
+  char R_path_lock_types[MAX_HEIGHT];
+
+
+  struct seal_list_elem * C_seal[MAX_HEIGHT];        /* array of seals on nodes in the path */
+  struct seal_list_elem * L_seal[MAX_HEIGHT];        /* array of seals on left neighbors of nodes in the path */
+  struct seal_list_elem * R_seal[MAX_HEIGHT];        /* array of seals on right neighbors of nodes in the path*/
+  struct seal_list_elem * FL_seal[MAX_HEIGHT];       /* array of seals on fathers of the left  neighbors      */
+  struct seal_list_elem * FR_seal[MAX_HEIGHT];       /* array of seals on fathers of the right neighbors      */
+  struct seal_list_elem * CFL_seal[MAX_HEIGHT];      /* array of seals on common parents of center node and its left neighbor  */
+  struct seal_list_elem * CFR_seal[MAX_HEIGHT];      /* array of seals on common parents of center node and its right neighbor */
+ 
+  struct char C_desired_lock_type[MAX_HEIGHT]; /* 'r', 'w', or 'n' for read, write, or none */
+  struct char L_desired_lock_type[MAX_HEIGHT];        
+  struct char R_desired_lock_type[MAX_HEIGHT];        
+  struct char FL_desired_lock_type[MAX_HEIGHT];       
+  struct char FR_desired_lock_type[MAX_HEIGHT];       
+  struct char CFL_desired_lock_type[MAX_HEIGHT];      
+  struct char CFR_desired_lock_type[MAX_HEIGHT];      
+#endif
+
+
+
+
+
+/* These are modes of balancing */
+
+/* When inserting an item. */
+#define M_INSERT	'i'
+/* When inserting into (directories only) or appending onto an already
+   existant item. */
+#define M_PASTE		'p'
+/* When deleting an item. */
+#define M_DELETE	'd'
+/* When truncating an item or removing an entry from a (directory) item. */
+#define M_CUT 		'c'
+
+/* used when balancing on leaf level skipped (in reiserfsck) */
+#define M_INTERNAL	'n'
+
+/* When further balancing is not needed, then do_balance does not need
+   to be called. */
+#define M_SKIP_BALANCING 		's'
+#define M_CONVERT	'v'
+
+/* modes of leaf_move_items */
+#define LEAF_FROM_S_TO_L 0
+#define LEAF_FROM_S_TO_R 1
+#define LEAF_FROM_R_TO_L 2
+#define LEAF_FROM_L_TO_R 3
+#define LEAF_FROM_S_TO_SNEW 4
+
+#define FIRST_TO_LAST 0
+#define LAST_TO_FIRST 1
+
+/* used in do_balance for passing parent of node information that has
+   been gotten from tb struct */
+struct buffer_info {
+	struct buffer_head * bi_bh;
+	struct buffer_head * bi_parent;
+	int bi_position;
+};
+
+
+/* there are 4 types of items: stat data, directory item, indirect, direct.
++-------------------+------------+--------------+------------+
+|	            |  k_offset  | k_uniqueness | mergeable? |
++-------------------+------------+--------------+------------+
+|     stat data     |	0        |      0       |   no       |
++-------------------+------------+--------------+------------+
+| 1st directory item| DOT_OFFSET |DIRENTRY_UNIQUENESS|   no       | 
+| non 1st directory | hash value |              |   yes      |
+|     item          |            |              |            |
++-------------------+------------+--------------+------------+
+| indirect item     | offset + 1 |TYPE_INDIRECT |   if this is not the first indirect item of the object
++-------------------+------------+--------------+------------+
+| direct item       | offset + 1 |TYPE_DIRECT   | if not this is not the first direct item of the object
++-------------------+------------+--------------+------------+
+*/
+#define TYPE_STAT_DATA 0x0
+#define TYPE_DIRECT 0xffffffff
+#define TYPE_INDIRECT 0xfffffffe
+#define TYPE_DIRECTORY_MAX 0xfffffffd
+
+
+#define KEY_IS_STAT_DATA_KEY(p_s_key) 	( (p_s_key)->k_uniqueness == TYPE_STAT_DATA )
+#define KEY_IS_DIRECTORY_KEY(p_s_key)	( (p_s_key)->k_uniqueness == DIRENTRY_UNIQUENESS )
+#define KEY_IS_DIRECT_KEY(p_s_key) 	( (p_s_key)->k_uniqueness == TYPE_DIRECT )
+#define KEY_IS_INDIRECT_KEY(p_s_key)	( (p_s_key)->k_uniqueness == TYPE_INDIRECT )
+
+#define I_IS_STAT_DATA_ITEM(p_s_ih) 	KEY_IS_STAT_DATA_KEY(&((p_s_ih)->ih_key))
+#define I_IS_DIRECTORY_ITEM(p_s_ih) 	KEY_IS_DIRECTORY_KEY(&((p_s_ih)->ih_key))
+#define I_IS_DIRECT_ITEM(p_s_ih) 	KEY_IS_DIRECT_KEY(&((p_s_ih)->ih_key))
+#define I_IS_INDIRECT_ITEM(p_s_ih) 	KEY_IS_INDIRECT_KEY(&((p_s_ih)->ih_key))
+
+/*
+#ifdef __KERNEL__
+
+extern inline int is_left_mergeable (struct item_head * ih, unsigned long bsize)
+{
+  if (I_IS_DIRECT_ITEM (ih))
+    return (ih->ih_key.k_offset % bsize != 1);
+
+  if (I_IS_INDIRECT_ITEM (ih))
+    return (ih->ih_key.k_offset != 1);
+
+  if (I_IS_DIRECTORY_ITEM (ih))
+   return ((ih)->ih_key.k_offset != DOT_OFFSET);
+
+#ifdef REISERFS_CHECK
+  if ( ! I_IS_STAT_DATA_ITEM (ih))
+    reiserfs_panic (0, "is_left_mergeable: 1020: item [%lu %lu %lu %lu] must be a stat data",
+		    ih->ih_key.k_dir_id, ih->ih_key.k_objectid, ih->ih_key.k_offset, ih->ih_key.k_uniqueness);
+#endif
+  return 0;
+}
+
+
+
+#endif*/	/* __KERNEL__ */
+
+#define COMP_KEYS comp_keys
+#define COMP_SHORT_KEYS comp_short_keys
+/*#define COMP_KEYS(p_s_key1, p_s_key2)		comp_keys((unsigned long *)(p_s_key1), (unsigned long *)(p_s_key2))
+#define COMP_SHORT_KEYS(p_s_key1, p_s_key2)	comp_short_keys((unsigned long *)(p_s_key1), (unsigned long *)(p_s_key2))*/
+
+
+/* number of blocks pointed to by the indirect item */
+#define I_UNFM_NUM(p_s_ih)	( (p_s_ih)->ih_item_len / UNFM_P_SIZE )
+
+/* the used space within the unformatted node corresponding to pos within the item pointed to by ih */
+#define I_POS_UNFM_SIZE(ih,pos,size) (((pos) == I_UNFM_NUM(ih) - 1 ) ? (size) - (ih)->u.ih_free_space : (size))
+
+/* number of bytes contained by the direct item or the unformatted nodes the indirect item points to */
+
+#define I_BYTES_NUMBER(ih,size) (( I_IS_INDIRECT_ITEM(ih) ) ?\
+				 I_UNFM_NUM(ih)*size - (ih)->u.ih_free_space :\
+				 (( I_IS_DIRECT_ITEM(ih) ) ? (ih)->ih_item_len : 0 /* stat data */)) 
+
+/* check whether byte number 'offset' is in this item */
+#define I_OFF_BYTE_IN_ITEM(p_s_ih, n_offset, n_blocksize) \
+                  ( (p_s_ih)->ih_key.k_offset <= (n_offset) && \
+                    (p_s_ih)->ih_key.k_offset + I_BYTES_NUMBER(p_s_ih,n_blocksize) > (n_offset) )
+
+/* get the item header */ 
+#define B_N_PITEM_HEAD(bh,item_num) ( (struct item_head * )((bh)->b_data + BLKH_SIZE) + (item_num) )
+
+/* get key */
+#define B_N_PDELIM_KEY(bh,item_num) ( (struct key * )((bh)->b_data + BLKH_SIZE) + (item_num) )
+
+/* get the key */
+#define B_N_PKEY(bh,item_num) ( &(B_N_PITEM_HEAD(bh,item_num)->ih_key) )
+
+/* get item body */
+#define B_N_PITEM(bh,item_num) ( (bh)->b_data + B_N_PITEM_HEAD((bh),(item_num))->ih_item_location)
+
+/* get the stat data by the buffer header and the item order */
+#define B_N_STAT_DATA(bh,nr) \
+( (struct stat_data *)((bh)->b_data+B_N_PITEM_HEAD((bh),(nr))->ih_item_location ) )
+
+                 /* following defines use reiserfs buffer header and item header */
+ /* get item body */
+#define B_I_PITEM(bh,ih) ( (bh)->b_data + (ih)->ih_item_location )
+
+/* get stat-data */
+#define B_I_STAT_DATA(bh, ih) ( (struct stat_data * )((bh)->b_data + (ih)->ih_item_location) )
+
+#define MAX_DIRECT_ITEM_LEN(size) ((size) - BLKH_SIZE - 2*IH_SIZE - SD_SIZE - UNFM_P_SIZE)
+
+/* indirect items consist of entries which contain blocknrs, pos
+   indicates which entry, and B_I_POS_UNFM_POINTER resolves to the
+   blocknr contained by the entry pos points to */
+#define B_I_POS_UNFM_POINTER(bh,ih,pos) (*(((unsigned long *)B_I_PITEM(bh,ih)) + (pos)))
+
+/* Reiserfs buffer cache statistics. */
+#ifdef REISERFS_CACHE_STAT
+ struct reiserfs_cache_stat
+	{
+  	int nr_reiserfs_ll_r_block; 		/* Number of block reads. */
+  	int nr_reiserfs_ll_w_block; 		/* Number of block writes. */
+	int nr_reiserfs_schedule; 		/* Number of locked buffers waits. */
+	unsigned long nr_reiserfs_bread;	/* Number of calls to reiserfs_bread function */
+	unsigned long nr_returns; /* Number of breads of buffers that were hoped to contain a key but did not after bread completed
+				     (usually due to object shifting while bread was executing.)
+				     In the code this manifests as the number
+				     of times that the repeat variable is nonzero in search_by_key.*/
+	unsigned long nr_fixed;		/* number of calls of fix_nodes function */
+	unsigned long nr_failed;	/* number of calls of fix_nodes in which schedule occurred while the function worked */
+	unsigned long nr_find1;		/* How many times we access a child buffer using its direct pointer from an internal node.*/
+	unsigned long nr_find2;	        /* Number of times there is neither a direct pointer to
+					   nor any entry in the child list pointing to the buffer. */
+	unsigned long nr_find3;	        /* When parent is locked (meaning that there are no direct pointers)
+					   or parent is leaf and buffer to be found is an unformatted node. */
+	}  cache_stat;
+#endif
+
+
+
+/***************************************************************************/
+/*                    FUNCTION DECLARATIONS                                */
+/***************************************************************************/
+
+/*#ifdef __KERNEL__*/
+
+/* journal.c see journal.c for all the comments here */
+
+#define JOURNAL_TRANS_HALF 1018   /* must be correct to keep the desc and commit structs at 4k */
+
+/* first block written in a commit.  BUG, not 64bit safe */
+struct reiserfs_journal_desc {
+  unsigned long j_trans_id ;			/* id of commit */
+  unsigned long j_len ;			/* length of commit. len +1 is the commit block */
+  unsigned long j_mount_id ;				/* mount id of this trans*/
+  unsigned long j_realblock[JOURNAL_TRANS_HALF] ; /* real locations for each block */
+  char j_magic[12] ;
+} ;
+
+/* last block written in a commit BUG, not 64bit safe */
+struct reiserfs_journal_commit {
+  unsigned long j_trans_id ;			/* must match j_trans_id from the desc block */
+  unsigned long j_len ;			/* ditto */
+  unsigned long j_realblock[JOURNAL_TRANS_HALF] ; /* real locations for each block */
+  char j_digest[16] ;			/* md5 sum of all the blocks involved, including desc and commit. not used, kill it */
+} ;
+
+/* this header block gets written whenever a transaction is considered fully flushed, and is more recent than the
+** last fully flushed transaction.  fully flushed means all the log blocks and all the real blocks are on disk,
+** and this transaction does not need to be replayed.
+*/
+struct reiserfs_journal_header {
+  unsigned long j_last_flush_trans_id ;		/* id of last fully flushed transaction */
+  unsigned long j_first_unflushed_offset ;      /* offset in the log of where to start replay after a crash */
+  unsigned long j_mount_id ;
+} ;
+
+
+/* biggest tunable defines are right here */
+#define JOURNAL_BLOCK_COUNT 8192 /* number of blocks in the journal */
+#define JOURNAL_MAX_BATCH   900 /* max blocks to batch into one transaction, don't make this any bigger than 900 */
+#define JOURNAL_MAX_COMMIT_AGE 30 
+#define JOURNAL_MAX_TRANS_AGE 30
+#define JOURNAL_PER_BALANCE_CNT 12   /* must be >= (5 + 2 * (MAX_HEIGHT-2) + 1) */
+#define JOURNAL_DEL_SIZE_LIMIT 40960 /* size in bytes of the max sized file to use cnodes while deleting */
+
+/* state bits for the per FS journal struct */
+#define JOURNAL_UNMOUNTING 1 /* tells the commit thread he's done */
+
+/* hash funcs more or less stolen from buffer cache.  t is a pointer to the hash table */
+#define JHASHDEV(d) ((unsigned int) (d))
+#define _jhashfn(dev,block)  (((unsigned)(JHASHDEV(dev)^(block))) % JOURNAL_HASH_SIZE)
+#define journal_hash(t,dev,block) ((t)[_jhashfn((dev),(block))])
+
+/* finds n'th buffer with 0 being the start of this commit.  Needs to go away, j_ap_blocks has changed
+** since I created this.  One chunk of code in journal.c needs changing before deleting it
+*/
+#define JOURNAL_BUFFER(j,n) ((j)->j_ap_blocks[((j)->j_start + (n)) % JOURNAL_BLOCK_COUNT])
+
+int journal_init(struct super_block *) ;
+int journal_release(struct reiserfs_transaction_handle*, struct super_block *) ;
+int journal_release_error(struct reiserfs_transaction_handle*, struct super_block *) ;
+int journal_end(struct reiserfs_transaction_handle *, struct super_block *, unsigned long) ;
+int journal_end_sync(struct reiserfs_transaction_handle *, struct super_block *, unsigned long) ;
+int journal_mark_dirty_nolog(struct reiserfs_transaction_handle *, struct super_block *, struct buffer_head *bh) ;
+int journal_mark_freed(struct reiserfs_transaction_handle *, struct super_block *, unsigned long blocknr) ;
+int push_journal_writer(char *w) ;
+int pop_journal_writer(int windex) ;
+int journal_lock_dobalance(struct super_block *p_s_sb) ;
+int journal_unlock_dobalance(struct super_block *p_s_sb) ;
+int journal_transaction_should_end(struct reiserfs_transaction_handle *, int) ;
+int reiserfs_in_journal(struct super_block *p_s_sb, kdev_t dev, unsigned long bl, int size, int searchall, unsigned long *next) ;
+int journal_begin(struct reiserfs_transaction_handle *, struct super_block *p_s_sb, unsigned long) ;
+int journal_join(struct reiserfs_transaction_handle *, struct super_block *p_s_sb, unsigned long) ;
+struct super_block *reiserfs_get_super(kdev_t dev) ;
+void flush_async_commits(struct super_block *p_s_sb, int *repeat) ;
+
+int remove_from_transaction(struct super_block *p_s_sb, unsigned long blocknr, int already_cleaned) ;
+int remove_from_journal_list(struct super_block *s, struct reiserfs_journal_list *jl, struct buffer_head *bh, int remove_freed) ;
+
+int buffer_journaled(struct buffer_head *bh) ;
+int mark_buffer_journal_new(struct buffer_head *bh) ;
+int reiserfs_sync_all_buffers(kdev_t dev, int wait) ;
+int reiserfs_sync_buffers(kdev_t dev, int wait) ;
+void reiserfs_file_buffer(struct buffer_head *bh, int list) ;
+void reiserfs_update_inode_transaction(struct inode *) ;
+int reiserfs_inode_in_this_transaction(struct inode *) ;
+void reiserfs_commit_for_inode(struct inode *) ;
+
+				/* Why is this kerplunked right here? -Hans */
+/* buffer was journaled, waiting to get to disk */
+static inline int buffer_journal_dirty(struct buffer_head *bh) {
+  if (bh)
+    return test_bit(BH_JDirty_wait, &bh->b_state) ;
+  else
+    return 0 ;
+}
+static inline int mark_buffer_notjournal_dirty(struct buffer_head *bh) {
+  if (bh)
+    clear_bit(BH_JDirty_wait, &bh->b_state) ;
+  return 0 ;
+}
+static inline int mark_buffer_notjournal_new(struct buffer_head *bh) {
+  if (bh) {
+    clear_bit(BH_JNew, &bh->b_state) ;
+  }
+  return 0 ;
+}
+
+
+/* objectid.c */
+unsigned long reiserfs_get_unused_objectid (struct reiserfs_transaction_handle *th, struct super_block * s);
+void reiserfs_release_objectid (struct reiserfs_transaction_handle *th, unsigned long objectid_to_release, struct super_block * s);
+
+
+/* stree.c */
+int reiserfs_file_release(struct inode *p_s_inode, struct file *p_s_filp) ;
+int B_IS_IN_TREE(struct buffer_head *);
+extern inline void copy_key (void * to, void * from);
+extern inline void copy_short_key (void * to, void * from);
+extern inline void copy_item_head(void * p_v_to, void * p_v_from);
+extern inline int comp_keys (void * p_s_key1, void * p_s_key2);
+extern inline int  comp_short_keys (void * p_s_key1, void * p_s_key2);
+int comp_items (struct item_head  * p_s_ih, struct path * p_s_path);
+struct key * get_rkey (struct path * p_s_chk_path, struct super_block  * p_s_sb);
+inline int bin_search (void * p_v_key, void * p_v_base, int p_n_num, int p_n_width, int * p_n_pos);
+int search_by_key (struct super_block *, struct key *, struct path *, int * , int, int);
+int search_by_objectid (struct super_block *, struct key *, struct path *, int * , int, int);
+int search_for_position_by_key (struct super_block * p_s_sb, struct key * p_s_key, struct path * p_s_search_path, int * p_n_pos_in_item, int * p_n_repeat);
+extern inline void decrement_bcount (struct buffer_head * p_s_bh);
+void decrement_counters_in_path (struct path * p_s_search_path);
+void pathrelse (struct path * p_s_search_path);
+int reiserfs_insert_item (struct reiserfs_transaction_handle *th, struct super_block * sb, struct path * path, 
+                          struct item_head * ih, const char * body, int memmode, int zeros_number, int preserve_mode);
+int reiserfs_paste_into_item (struct reiserfs_transaction_handle *th, struct super_block * sb, 
+                              struct path * path, int * pos_in_item, struct key * key,	
+			      const char * body, int paste_size, int memmode, int zeros_number);	/* returns -1 if failed and paste_size otherwise */
+int reiserfs_cut_from_item (struct reiserfs_transaction_handle *th, struct inode * inode, 
+			    struct super_block * sb, struct path * path, int * pos_in_item, struct key * key,
+			    unsigned long new_file_size, int preserve_mode);
+int reiserfs_delete_item (struct reiserfs_transaction_handle *th, struct inode * inode, struct path * p_s_path, 
+                          int * p_n_pos_in_item, struct key * p_s_item_key,
+			  struct buffer_head  * p_s_un_bh, int preserve_mode);
+void reiserfs_delete_object (struct reiserfs_transaction_handle *th, struct inode * p_s_inode);
+void reiserfs_truncate_file (struct  inode * p_s_inode);
+int lock_inode_to_convert (struct inode * p_s_inode);
+void unlock_inode_after_convert (struct inode * p_s_inode);
+int increment_i_read_sync_counter (struct inode * p_s_inode);
+void decrement_i_read_sync_counter (struct inode * p_s_inode);
+int get_buffer_by_range (struct super_block * p_s_sb, struct key * p_s_range_begin, struct key * p_s_range_end, 
+			 struct buffer_head ** pp_s_buf, unsigned long * p_n_objectid);
+int get_buffers_from_range (struct super_block * p_s_sb, struct key * p_s_range_start, struct key * p_s_range_end, struct buffer_head ** p_s_range_buffers,
+			    int n_max_nr_buffers_to_return);
+#ifndef REISERFS_FSCK
+
+inline int is_left_mergeable (struct item_head * ih, unsigned long bsize);
+
+#else
+
+int is_left_mergeable (struct super_block * s, struct path * path);
+int is_right_mergeable (struct super_block * s, struct path * path);
+int are_items_mergeable (struct item_head * left, struct item_head * right, int bsize);
+
+#endif
+
+/* inode.c */
+void store_key (struct super_block *s, struct key * key);
+void forget_key (struct super_block *s, struct key * key);
+struct inode * reiserfs_iget (struct super_block * s, struct key * key);
+void reiserfs_read_inode (struct inode * inode);
+void reiserfs_delete_inode (struct inode * inode);
+extern int reiserfs_notify_change(struct dentry * dentry, struct iattr * attr);
+int reiserfs_bmap (struct inode * inode, int block);
+void reiserfs_write_inode (struct inode * inode);
+struct inode * reiserfs_new_inode (struct reiserfs_transaction_handle *th, 
+			           const struct inode * dir, int mode, const char * symname,
+				   struct dentry *dentry, struct inode *inode, int * err);
+int reiserfs_sync_inode (struct reiserfs_transaction_handle *th, struct inode * inode);
+void if_in_ram_update_sd (struct reiserfs_transaction_handle *th, struct inode * inode);
+void reiserfs_inode_setattr(struct reiserfs_transaction_handle *th, struct inode * inode,  struct iattr * attr);
+void __wait_on_inode(struct inode * inode);
+
+/* namei.c */
+int bin_search_in_dir_item (struct item_head * ih, struct reiserfs_de_head * deh, struct key * key, int * pos_in_item);
+int search_by_entry_key (struct super_block * sb, struct key * key, struct path * path, int * pos_in_item, int * repeat);
+struct dentry * reiserfs_lookup (struct inode * dir, struct dentry *dentry);
+int reiserfs_create (struct inode * dir, struct dentry *dentry,	int mode);
+int reiserfs_mknod (struct inode * dir_inode, struct dentry *dentry, int mode, int rdev);
+int reiserfs_mkdir (struct inode * dir, struct dentry *dentry, int mode);
+int reiserfs_rmdir (struct inode * dir,	struct dentry *dentry);
+int reiserfs_unlink (struct inode * dir, struct dentry *dentry);
+int reiserfs_symlink (struct inode * dir, struct dentry *dentry, const char * symname);
+int reiserfs_link (struct dentry * old_dentry, struct inode * dir, struct dentry *dentry);
+int reiserfs_rename (struct inode * old_dir, struct dentry *old_dentry, struct inode * new_dir, struct dentry *new_dentry);
+
+/* super.c */
+inline void reiserfs_mark_buffer_dirty (struct buffer_head * bh, int flag);
+inline void reiserfs_mark_buffer_clean (struct buffer_head * bh);
+void reiserfs_panic (struct super_block * s, const char * fmt, ...);
+void reiserfs_write_super (struct super_block * s);
+void reiserfs_put_super (struct super_block * s);
+int reiserfs_remount (struct super_block * s, int * flags, char * data);
+/*int read_super_block (struct super_block * s, int size);
+int read_bitmaps (struct super_block * s);
+int read_old_bitmaps (struct super_block * s);
+int read_old_super_block (struct super_block * s, int size);*/
+struct super_block * reiserfs_read_super (struct super_block * s, void * data, int silent);
+int reiserfs_statfs (struct super_block * s, struct statfs * buf, int bufsiz);
+int init_reiserfs_fs (void);
+
+/* dir.c */
+extern struct inode_operations reiserfs_dir_inode_operations;
+
+/* file.c */
+extern struct inode_operations reiserfs_file_inode_operations;
+int do_direct_to_indirect (struct inode * inode);
+
+/* symlink.c */
+extern struct inode_operations reiserfs_symlink_inode_operations;
+
+/* buffer.c */
+inline int test_and_wait_on_buffer (struct buffer_head * p_s_bh);
+struct buffer_head * reiserfs_getblk (kdev_t n_dev, int n_block, int n_size, int * p_n_repeat);
+void reiserfs_rehash_buffer (struct buffer_head * bh, unsigned long block);
+void mark_suspected_recipients_dirty (struct reiserfs_transaction_handle *th, kdev_t dev);
+void fixup_reiserfs_buffers (kdev_t dev);
+
+
+
+/* buffer2.c */
+void wait_buffer_until_released (struct buffer_head * bh);
+struct buffer_head * reiserfs_bread (kdev_t n_dev, int n_block, int n_size, int * p_n_repeat);
+struct buffer_head * reiserfs_get_hash_table (kdev_t  n_dev, int n_block, int n_size, int * p_n_repeat);
+int reiserfs_sync_file (struct file * p_s_filp, struct dentry * p_s_dentry);
+void reiserfs_show_buffers (kdev_t dev);
+
+
+/*#endif  __KERNEL__ */
+
+/* fix_nodes.c */
+void * reiserfs_kmalloc (size_t size, int flags, struct super_block * s);
+void reiserfs_kfree (const void * vp, size_t size, struct super_block * s);
+int fix_nodes (struct reiserfs_transaction_handle *th, int n_op_mode, struct tree_balance * p_s_tb, 
+               int n_pos_in_item, struct item_head * p_s_ins_ih);
+void unfix_nodes (struct reiserfs_transaction_handle *th, struct tree_balance *);
+void free_buffers_in_tb (struct tree_balance * p_s_tb);
+void init_path (struct path *);
+
+/* prints.c */
+void reiserfs_panic (struct super_block * s, const char * fmt, ...);
+void reiserfs_warning (const char * fmt, ...);
+void print_virtual_node (struct virtual_node * vn);
+void print_indirect_item (struct buffer_head * bh, int item_num);
+void print_tb (int mode, int item_pos, int pos_in_item, struct tree_balance * tb, char * mes);
+void print_de (struct reiserfs_dir_entry * de);
+void print_bi (struct buffer_info * bi, char * mes);
+#define PRINT_LEAF_ITEMS 1   /* print all items */
+#define PRINT_DIRECTORY_ITEMS 2 /* print directory items */
+#define PRINT_DIRECT_ITEMS 4 /* print contents of direct items */
+void print_block (struct buffer_head * bh, ...);//int print_mode, int first, int last);
+void print_path (struct tree_balance * tb, struct path * path);
+void print_bmap (struct super_block * s, int silent);
+void print_objectid_map (struct super_block * s);
+void print_block_head (struct buffer_head * bh, char * mes);
+void check_leaf (struct buffer_head * bh);
+void print_statistics (struct super_block * s);
+
+/* lbalance.c */
+int leaf_move_items (struct reiserfs_transaction_handle *th, int shift_mode, struct tree_balance * tb, 
+                     int mov_num, int mov_bytes, struct buffer_head * Snew);
+int leaf_shift_left (struct reiserfs_transaction_handle *th, struct tree_balance * tb, int shift_num, int shift_bytes);
+int leaf_shift_right (struct reiserfs_transaction_handle *th, struct tree_balance * tb, int shift_num, int shift_bytes);
+void leaf_delete_items (struct reiserfs_transaction_handle *th, struct buffer_info * cur_bi, 
+                        int last_first, int first, int del_num, int del_bytes);
+void leaf_insert_into_buf (struct reiserfs_transaction_handle *th, struct buffer_info * bi, 
+			   int before, struct item_head * inserted_item_ih, const char * inserted_item_body, 
+			   int mem_mode, int zeros_number);
+void leaf_paste_in_buffer (struct reiserfs_transaction_handle *th, struct buffer_info * bi, int pasted_item_num, 
+			   int pos_in_item, int paste_size, const char * body, int mem_mode, int zeros_number);
+void leaf_cut_from_buffer (struct reiserfs_transaction_handle *th, struct buffer_info * bi, int cut_item_num, 
+                           int pos_in_item, int cut_size);
+void leaf_paste_entries (struct buffer_head * bh, int item_num, int before, int new_entry_count, struct reiserfs_de_head * new_dehs, const char * records,
+			 int paste_size);
+
+/*#ifdef __KERNEL__*/
+/* preserve.c */
+int ready_preserve_list (struct tree_balance *, struct buffer_head * bh);
+void preserve_shifted (struct tree_balance *, struct buffer_head **, struct buffer_head *, int, struct buffer_head *);
+void add_to_preserve (unsigned long blocknr, struct super_block * sb);
+int maybe_free_preserve_list (struct super_block * sb);
+int get_space_from_preserve_list (struct super_block * s);
+inline void unpreserve (struct super_block * s, struct buffer_head * bh);
+void preserve_invalidate (struct reiserfs_transaction_handle *,
+                          struct tree_balance * tb, struct buffer_head * bh, struct buffer_head *);
+unsigned long free_and_near_block (struct tree_balance * tb);
+inline void mark_suspected_recipient (struct super_block * sb, struct buffer_head * bh);
+inline void unmark_suspected_recipient (struct super_block * sb, struct buffer_head * bh);
+int is_buffer_unwritten (struct buffer_head * bh);
+int is_buffer_preserved (struct buffer_head * bh);
+int is_buffer_suspected_recipient (struct super_block * s, struct buffer_head * bh);
+inline void mark_buffer_unwritten (struct buffer_head * bh);
+void unpreserve (struct super_block * s, struct buffer_head * bh);
+#ifdef REISERFS_CHECK
+void preserve_trace_init_bitmap (struct super_block * s);
+void preserve_trace_release_bitmap (struct super_block * s);
+void preserve_trace_reset_suspected_recipients (struct super_block * s);
+#endif
+/*#endif*/ /* __KERNEL__ */
+
+/* ibalance.c */
+int balance_internal (struct reiserfs_transaction_handle *th, struct tree_balance * , int, int, struct item_head * , 
+                      struct buffer_head **);
+
+/* do_balance.c */
+void do_balance (struct reiserfs_transaction_handle *th, struct tree_balance * tb, int pos_in_item, 
+                 struct item_head * ih, const char * body, int flag, int mem_mode, int zeros_num);
+void reiserfs_invalidate_buffer (struct reiserfs_transaction_handle *th, struct tree_balance * tb, struct buffer_head * bh, int);
+int get_left_neighbor_position (struct tree_balance * tb, int h);
+int get_right_neighbor_position (struct tree_balance * tb, int h);
+void replace_key (struct reiserfs_transaction_handle *th, struct buffer_head *, int, struct buffer_head *, int);
+void replace_lkey (struct reiserfs_transaction_handle *th, struct tree_balance *, int, struct item_head *);
+void replace_rkey (struct reiserfs_transaction_handle *th, struct tree_balance *, int, struct item_head *);
+void make_empty_node (struct buffer_info *);
+struct buffer_head * get_FEB (struct tree_balance *);
+
+/* bitmap.c */
+int is_reusable (struct super_block * s, unsigned long block, int bit_value);
+void reiserfs_free_block (struct reiserfs_transaction_handle *th, struct super_block *, unsigned long);
+int reiserfs_new_blocknrs (struct reiserfs_transaction_handle *th, struct super_block *, unsigned long *, unsigned long, int, int);
+int reiserfs_new_unf_blocknrs (struct reiserfs_transaction_handle *th,struct super_block *,unsigned long *,unsigned long,int,int);
+
+/* reiserfs_new_blocknrs and reiserfs_free_block use
+   reiserfs_mark_buffer_dirty. To complete marking buffer dirty we use
+   brelse. But first we do b_count++ instead of getblk, as bitmaps and
+   super block were acquired once by getblk at mount time. */
+#define COMPLETE_BITMAP_DIRTING_AFTER_ALLOCATING(s,bitmapnr) \
+	SB_AP_BITMAP(s)[bitmapnr]->b_count ++;\
+	brelse (SB_AP_BITMAP(s)[bitmapnr]);\
+    	SB_BUFFER_WITH_SB (s)->b_count ++;\
+	brelse (SB_BUFFER_WITH_SB (s));\
+
+#define COMPLETE_BITMAP_DIRTING_AFTER_FREEING(s,bitmapnr) \
+	SB_AP_BITMAP(s)[bitmapnr]->b_count ++;\
+	brelse (SB_AP_BITMAP(s)[bitmapnr]);\
+    	SB_BUFFER_WITH_SB (s)->b_count ++;\
+	brelse (SB_BUFFER_WITH_SB (s));\
+
+/* teahash3.c */
+unsigned long keyed_hash (const char *msg, int len);
+
+/* version.c */
+char *reiserfs_get_version_string(void) ;
+
+/* lock.c */
+#ifdef __KERNEL__
+inline int try_ulong_lock(unsigned long * lock, unsigned short bitnumber);
+void unlock_ulong_lock(unsigned long * lock, unsigned short bitnumber, struct  wait_queue ** l_wait);
+#endif
+
+
+#ifdef __i386__
+
+extern __inline__ int 
+find_first_nonzero_bit(void * addr, unsigned size) {
+  int res;
+  int __d0;
+  void *__d1;
+
+
+  if (!size) {
+    return (0);
+  }
+  __asm__ __volatile__ (
+	  "cld\n\t"
+	  "xorl %%eax,%%eax\n\t"
+	  "repe; scasl\n\t"
+	  "je 1f\n\t"
+	  "movl -4(%%edi),%%eax\n\t"
+	  "subl $4, %%edi\n\t"
+	  "bsfl %%eax,%%eax\n\t"
+	  "1:\tsubl %%edx,%%edi\n\t"
+	  "shll $3,%%edi\n\t"
+	  "addl %%edi,%%eax"
+	  :"=a" (res),
+	  "=c"(__d0), "=D"(__d1)
+	  :"1" ((size + 31) >> 5), "d" (addr), "2" (addr));
+  return (res);
+}
+
+#else /* __i386__ */
+
+extern __inline__ int find_next_nonzero_bit(void * addr, unsigned size, unsigned offset)
+{
+	unsigned int * p = ((unsigned int *) addr) + (offset >> 5);
+	unsigned int result = offset & ~31UL;
+	unsigned int tmp;
+
+	if (offset >= size)
+		return size;
+	size -= result;
+	offset &= 31UL;
+	if (offset) {
+		tmp = *p++;
+		/* set to zero first offset bits */
+		tmp &= ~(~0UL >> (32-offset));
+		if (size < 32)
+			goto found_first;
+		if (tmp != 0U)
+			goto found_middle;
+		size -= 32;
+		result += 32;
+	}
+	while (size >= 32) {
+		if ((tmp = *p++) != 0U)
+			goto found_middle;
+		result += 32;
+		size -= 32;
+	}
+	if (!size)
+		return result;
+	tmp = *p;
+found_first:
+found_middle:
+	return result + ffs(tmp);
+}
+
+#define find_first_nonzero_bit(addr,size) find_next_nonzero_bit((addr), (size), 0)
+
+#endif /* 0 */
+
+
+#endif /* _LINUX_REISER_FS_H */
+
+
Index: empeg/kernel/include/linux/reiserfs_fs_i.h
diff -u /dev/null empeg/kernel/include/linux/reiserfs_fs_i.h:1.1
--- /dev/null	Wed Oct 17 16:36:09 2001
+++ empeg/kernel/include/linux/reiserfs_fs_i.h	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,21 @@
+#ifndef _REISER_FS_I
+#define _REISER_FS_I
+
+#define REISERFS_N_BLOCKS 10
+
+struct reiserfs_inode_info {
+  struct pipe_inode_info reserved;
+  __u32 i_key [4];
+  __u32 i_first_direct_byte;
+
+  int i_data_length;
+  __u32 i_data [REISERFS_N_BLOCKS];
+  int i_is_being_converted;
+  int i_read_sync_counter;
+  int i_pack_on_close ;
+  int i_transaction_index ;
+  int i_transaction_id ;
+};
+
+
+#endif
Index: empeg/kernel/include/linux/reiserfs_fs_sb.h
diff -u /dev/null empeg/kernel/include/linux/reiserfs_fs_sb.h:1.1
--- /dev/null	Wed Oct 17 16:36:09 2001
+++ empeg/kernel/include/linux/reiserfs_fs_sb.h	Fri Oct 20 15:54:49 2000
@@ -0,0 +1,316 @@
+/*
+ * Copyright 1996, 1997, 1998 Hans Reiser, see reiserfs/README for licensing and copyright details
+ */
+
+#ifndef _LINUX_REISER_FS_SB
+#define _LINUX_REISER_FS_SB
+
+#ifdef __KERNEL__
+#include <linux/tqueue.h>
+#endif
+                                /* this struct goes on disk */
+struct reiserfs_super_block
+{
+  __u32 s_block_count;			/* blocks count         */
+  __u32 s_free_blocks;                  /* free blocks count    */
+  __u32 s_root_block;           	/* root block number    */
+  __u32 s_journal_block;           	/* journal block number    */
+  __u32 s_journal_dev;           	/* journal device number  */
+  __u32 s_orig_journal_size; 		/* size of the journal on FS creation.  used to make sure they don't overflow it */
+  __u32 s_journal_trans_max ;           /* max number of blocks in a transaction.  */
+  __u32 s_journal_block_count ;         /* total size of the journal. can change over time  */
+  __u32 s_journal_max_batch ;           /* max number of blocks to batch into a trans */
+  __u32 s_journal_max_commit_age ;      /* in seconds, how old can an async commit be */
+  __u32 s_journal_max_trans_age ;       /* in seconds, how old can a transaction be */
+  __u16 s_blocksize;                   	/* block size           */
+  __u16 s_oid_maxsize;			/* max size of object id array, see get_objectid() commentary  */
+  __u16 s_oid_cursize;			/* current size of object id array */
+  __u16 s_state;                       	/* valid or error       */
+  char s_magic[16];                     /* reiserfs magic string indicates that file system is reiserfs */
+  __u16 s_tree_height;                  /* height of disk tree */
+  __u16 s_bmap_nr;                      /* amount of bitmap blocks needed to address each block of file system */
+  __u16 s_reserved;
+};
+
+#define SB_SIZE (sizeof(struct reiserfs_super_block))
+
+/* LOGGING -- */
+
+/* These all interelate for performance.  
+**
+** If the journal block count is smaller than n transactions, you lose speed. I don't know what n is yet, I'm guessing 8-16 
+** 
+** If your journal fills faster than dirty buffers get flushed to disk, it must flush them before allowing the journal
+** to wrap, which slows things down.  If you need high speed meta data updates, the journal should be big enough
+** to prevent wrapping before dirty meta blocks get to disk.
+**
+** If the batch max is smaller than the transaction max, you'll waste space at the end of the journal
+** because journal_end sets the next transaction to start at 0 if the next transaction has any chance of wrapping.
+**
+** The large the batch max age, the better the speed, and the more meta data changes you'll lose after a crash.
+**
+*/
+
+/* don't mess with these for a while */
+#define JOURNAL_BLOCK_SIZE  4096 /* BUG gotta get rid of this */
+#define JOURNAL_MAX_CNODE   1500 /* max cnodes to allocate. */
+#define JOURNAL_TRANS_MAX 1024   /* biggest possible single transaction, don't change for now (8/3/99) */
+#define JOURNAL_HASH_SIZE 2048   /* size of journal hash table, used to index lookups in current commit  */
+#define JOURNAL_LIST_HASH_SIZE 16384   
+#define JOURNAL_NUM_BITMAPS 3 /* number of copies of the bitmaps to have floating.  Must be >= 2 */
+#define JOURNAL_LIST_COUNT 128
+#define BH_JDirty       16      /* journal data needs to be written before buffer can be marked dirty */
+#define BH_JDirty_wait 18	/* commit is done, buffer marked dirty */
+#define BH_JNew 19		/* buffer allocated during this transaction, no need to write if freed during this trans too */
+
+/* One of these for every block in every transaction
+** Each one is in two hash tables.  First, a hash of the current transaction, and after journal_end, a
+** hash of all the in memory transactions.
+** next and prev are used by the current transaction (journal_hash).
+** hnext and hprev are used by journal_list_hash.  If a block is in more than one transaction, the journal_list_hash
+** links it in multiple times.  This allows the end_io handler, and flush_journal_list to remove just the cnode belonging
+** to a given transaction.
+*/
+struct reiserfs_journal_cnode {
+  struct buffer_head *bh ;		 /* real buffer head */
+  kdev_t dev ;				 /* dev of real buffer head */
+  unsigned long blocknr ;		 /* block number of real buffer head, == 0 when buffer on disk */		 
+  int state ;
+  struct reiserfs_journal_list *jlist ;  /* journal list this cnode lives in */
+  struct reiserfs_journal_cnode *next ;  /* next in transaction list */
+  struct reiserfs_journal_cnode *prev ;  /* prev in transaction list */
+  struct reiserfs_journal_cnode *hprev ; /* prev in hash list */
+  struct reiserfs_journal_cnode *hnext ; /* next in hash list */
+};
+
+struct reiserfs_list_bitmap {
+  struct reiserfs_journal_list *journal_list;  /* used to flush the commit when this one needs to be reused */
+  char *bitmap ;   /* the bitmap */
+} ;
+
+/*
+** transaction handle which is passed around for all journal calls
+*/
+struct reiserfs_transaction_handle {
+  char *t_caller ;              /* debugging use */
+  int t_blocks_logged ;         /* number of blocks this writer has actually logged */
+  int t_blocks_allocated ;      /* number of blocks this writer allocated */
+  unsigned long t_trans_id ;    /* sanity check, should equal the current trans id */
+  struct super_block *t_super ; /* super for this FS when journal_begin was called. saves calls to reiserfs_get_super */
+} ;
+
+/*
+** one of these for each transaction.  The most important part here is the j_realblock.
+** this list of cnodes is used to hash all the blocks in all the commits, to mark all the
+** real buffer heads dirty once all the commits hit the disk,
+** and to make sure every real block in a transaction is on disk before allowing the log area
+** to be overwritten
+*/
+struct reiserfs_journal_list {
+  unsigned long j_start ;
+  unsigned long j_len ;
+  atomic_t j_nonzerolen ;
+  atomic_t j_commit_left ;
+  atomic_t j_flushing ;
+  atomic_t j_commit_flushing ;
+  atomic_t j_older_commits_done ;      /* all commits older than this on disk*/
+  spinlock_t j_lock ;
+  unsigned long j_trans_id ;
+  time_t j_timestamp ;
+  struct reiserfs_list_bitmap *j_list_bitmap ;
+  struct buffer_head *j_commit_bh ; /* commit buffer head */
+  struct reiserfs_journal_cnode *j_realblock  ;
+  struct reiserfs_journal_cnode *j_freedlist ; /* list of buffers that were freed during this trans.  free each of these on flush */
+  struct wait_queue *j_commit_wait ; /* wait for all the commit blocks to be flushed */
+  struct wait_queue *j_flush_wait ; /* wait for all the real blocks to be flushed */
+} ;
+
+
+struct reiserfs_journal {
+  struct buffer_head ** j_ap_blocks ; /* journal blocks on disk */
+  struct reiserfs_journal_cnode *j_last ; /* newest journal block */
+  struct reiserfs_journal_cnode *j_first ; /*  oldest journal block.  start here for traverse */
+  int j_state ;			
+  unsigned long j_trans_id ;
+  unsigned long j_mount_id ;
+  unsigned long j_start ;             /* start of current waiting commit (index into j_ap_blocks) */
+  unsigned long j_len ;               /* lenght of current waiting commit */
+  unsigned long j_len_alloc ;         /* number of buffers requested by journal_begin() */
+  atomic_t j_wcount ;            /* count of writers for current commit */
+  unsigned long j_bcount ;            /* batch count. allows turning X transactions into 1 */
+  unsigned long j_first_unflushed_offset ;  /* first unflushed transactions offset */
+  unsigned long j_last_flush_trans_id ;    /* last fully flushed journal timestamp */
+  struct buffer_head *j_header_bh ;   
+  time_t j_trans_start_time ;         /* time this transaction started */
+  struct wait_queue *j_wait ;         /* wait  journal_end to finish I/O */
+  atomic_t j_wlock ;                       /* lock for j_wait */
+  struct wait_queue *j_join_wait ;    /* wait for current transaction to finish before starting new one */
+  atomic_t j_jlock ;                       /* lock for j_join_wait */
+  struct wait_queue *j_dobalance_wait ; /* call this before going into do_balance */
+  struct wait_queue *j_commit_thread_wait ; /* commit thread waits on this between commits */
+  struct wait_queue *j_commit_thread_done ; /* commit thread wakes this up when it has run its task queue */
+  task_queue j_commit_thread_tq ;        /* task queue for this FS's commit thread */
+  int j_dobalance_lock ;		/* lock for the above */
+  int j_journal_list_index ;	      /* journal list number of the current trans */
+  int j_list_bitmap_index ;	      /* number of next list bitmap to use */
+  int j_must_wait ;		       /* no more journal begins allowed. MUST sleep on j_join_wait */
+  int j_next_full_flush ;             /* next journal_end will flush all journal list */
+  int j_next_async_flush ;             /* next journal_end will flush all async commits */
+
+  int j_cnode_used ;	      /* number of cnodes on the used list */
+  int j_cnode_free ;          /* number of cnodes on the free list */
+
+  spinlock_t j_cnode_lock ; /* lock inside of get/free cnode */
+  rwlock_t j_hash_lock ; /* lock before using the j_hash_table */
+  rwlock_t j_list_hash_lock ; /* lock before using the j_list_hash_table */
+  struct reiserfs_journal_cnode *j_cnode_free_list ;
+  struct reiserfs_journal_cnode *j_cnode_free_orig ; /* orig pointer returned from vmalloc */
+
+  struct reiserfs_list_bitmap j_list_bitmap[JOURNAL_NUM_BITMAPS] ;	/* array of bitmaps to record the deleted blocks */
+  struct reiserfs_journal_list j_journal_list[JOURNAL_LIST_COUNT] ;	    /* array of all the journal lists */
+  struct reiserfs_journal_cnode *j_hash_table[JOURNAL_HASH_SIZE] ; 	    /* hash table for real buffer heads in current trans */ 
+  struct reiserfs_journal_cnode *j_list_hash_table[JOURNAL_LIST_HASH_SIZE] ; /* hash table for all the real buffer heads in all 
+  										the transactions */
+};
+
+#define JOURNAL_DESC_MAGIC "ReIsErLB" /* ick.  magic string to find desc blocks in the journal */
+
+
+
+/*#ifdef __KERNEL__*/
+
+/*
+ * reiserfs super block data in memory
+ */
+
+
+/* The preserve list stores blocknr's of blocks whose contents have in at least part been shifted by balancing to
+   another node in RAM but perhaps not yet written to disk.  We do not attempt to track more than that a block has had
+   its contents shifted since the last time that there were no dirty buffers that were suspected recipients (see
+   mark_suspected_recipients).  The preserve list is constructed by kmalloc'ing a page at a time whenever the
+   preserve_offset reaches near the end of a page.  Scheduling issues need to be remembered when growing the list. This
+   list is append to the end and read from the beginning in its access.  This motivates the jar containing pointers to
+   the end and the start. */
+
+/* a jar holds a preserve list */
+struct jar
+{
+    char * plist_first_page;	/* points to first memory block in a chain */
+    char * plist_current_page;	/* points to memory block that contains pointer to free entry */
+    unsigned long * plist_end;	/* points to free entry at end of preserve list */
+};
+
+
+struct reiserfs_sb_info
+{
+  struct buffer_head * s_sbh;                   /* Buffer containing the super block */
+  struct reiserfs_super_block * s_rs;           /* Pointer to the super block in the buffer */
+  struct buffer_head ** s_ap_true_bitmap;       /* array of buffers, holding block bitmap */
+#if 0 /* journal victim */
+  struct buffer_head ** s_ap_cautious_bitmap;   /* the same as the above, but we do not set bit until new allocated
+                                                   block reached disk, or more precisely, until the preserve list is
+                                                   freed */
+#endif /* journal victim */
+  struct reiserfs_journal *s_journal ;		/* pointer to journal information */
+  unsigned short s_mount_state;                 /* reiserfs state (valid, invalid) */
+  
+  struct jar s_jam;                             /* holds the preserve list, see preserve.c */
+  unsigned long read_lock;              /* locks fs for reads, which makes multiprocess large reads more efficient. We
+                                           use bit 0 for the read lock.  This should be merged into the s_state field.
+                                           Yura, if this read_locking code works well, when you find time, please do so.  */
+  struct wait_queue * read_wait;                /* wait queue for reiserfs read lock */
+  unsigned long s_suspected_recipient_count;    /* To support preserve lists we need to be able to
+                                                   efficiently determine if there are any dirty
+                                                   blocks that have not reached disk. This counter
+                                                   serves that purpose.  It is incremented with
+                                                   every dirtying of a block that might possibly
+                                                   receive a shifted item from another buffer, and
+                                                   decremented in unpreserve() which is called
+                                                   whenever a buffer is written or freed.  See
+                                                   unpreserve() and mark_buffer_dirty().  */
+  unsigned long s_preserved;
+  int lock_preserve;
+  void (*unpreserve)(struct super_block * s, struct buffer_head * bh); /* Vladimir, comment this.... -Hans */
+  unsigned long s_mount_opt;
+
+  /* to debug preserve list */
+  char ** s_suspected_recipient_bitmap;
+  char ** s_preserved_block_bitmap;
+  int s_set_pb_bits;
+  int s_set_sr_bits;
+
+  /* session statistics */
+  int s_kmallocs;
+  int s_disk_reads;
+  int s_disk_writes;
+  int s_fix_nodes;
+  int s_do_balance;
+  int s_preserve_list_freeings;
+  int s_unneeded_left_neighbor;
+  int s_good_search_by_key_reada;
+  int s_bmaps;
+  int s_bmaps_without_search;
+  int s_direct2indirect;
+  int s_indirect2direct;
+
+};
+
+#define NOTAIL 0  /* mount option -o notail */
+#define NOPRESERVE 1 /*           -o nopreserve */ 
+#define GENERICREAD 2 /*          -o genericread */
+#define REPLAYONLY 3 /* replay journal and return 0. Use by fsck */
+
+#define dont_have_tails(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << NOTAIL))
+#define dont_preserve(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << NOPRESERVE))
+#define use_genericread(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << GENERICREAD))
+#define replay_only(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << REPLAYONLY))
+
+#define SB_PL_FIRST_PAGE(s) ((s)->u.reiserfs_sb.s_jam.plist_first_page)
+#define SB_PL_CURRENT_PAGE(s) ((s)->u.reiserfs_sb.s_jam.plist_current_page)
+/* place to preserve next block number */
+#define SB_PL_END(s) ((s)->u.reiserfs_sb.s_jam.plist_end)
+
+void __wait_on_inode (struct inode * inode);
+extern struct list_head inode_in_use;
+extern spinlock_t inode_lock;
+inline int  test_and_wait_on_buffer(struct buffer_head * p_s_bh);
+struct buffer_head * reiserfs_get_hash_table (kdev_t  n_dev, int n_block, int n_size, int * p_n_repeat);
+struct buffer_head * reiserfs_getblk (kdev_t  n_dev, int n_block, int n_size, int * p_n_repeat);
+void reiserfs_show_buffers (kdev_t dev);
+void mark_suspected_recipients_dirty (struct reiserfs_transaction_handle *th, kdev_t dev);
+void fixup_reiserfs_buffers (kdev_t dev);
+void reiserfs_refile_buffer (struct buffer_head * bh);
+void reiserfs_file_buffer (struct buffer_head * bh, int list);
+int reiserfs_is_super(struct super_block *s)  ;
+int journal_mark_dirty(struct reiserfs_transaction_handle *, struct super_block *, struct buffer_head *bh) ;
+int flush_old_commits(struct super_block *s, int) ;
+int show_reiserfs_locks(void) ;
+void reiserfs_end_buffer_io_sync (struct buffer_head *bh, int uptodate) ; 
+void reiserfs_journal_end_io(struct buffer_head *bh, int uptodate) ;
+int reiserfs_resize(struct super_block *, unsigned long) ;
+
+
+/*#endif	*//* __KERNEL__ */
+
+
+
+#define SB_BUFFER_WITH_SB(s) ((s)->u.reiserfs_sb.s_sbh)
+#define SB_DISK_SUPER_BLOCK(s) ((s)->u.reiserfs_sb.s_rs)
+#define SB_JOURNAL(s) ((s)->u.reiserfs_sb.s_journal)
+#define SB_JOURNAL_BLOCK(s) (SB_DISK_SUPER_BLOCK(s)->s_journal_block)
+#define SB_JOURNAL_LIST(s) (SB_JOURNAL(s)->j_journal_list)
+#define SB_JOURNAL_LIST_INDEX(s) (SB_JOURNAL(s)->j_journal_list_index) 
+#define SB_JOURNAL_LEN_FREE(s) (SB_JOURNAL(s)->j_journal_len_free) 
+#define SB_BLOCK_COUNT(s) (SB_DISK_SUPER_BLOCK(s)->s_block_count)
+#define RESERVED_FOR_PRESERVE_LIST 500
+#define SB_FREE_BLOCKS(s) (SB_DISK_SUPER_BLOCK(s)->s_free_blocks)
+#define SB_REISERFS_MAGIC(s) (SB_DISK_SUPER_BLOCK(s)->s_magic)
+#define SB_ROOT_BLOCK(s) (SB_DISK_SUPER_BLOCK(s)->s_root_block)
+#define SB_TREE_HEIGHT(s) (SB_DISK_SUPER_BLOCK(s)->s_tree_height)
+#define SB_REISERFS_STATE(s) (SB_DISK_SUPER_BLOCK(s)->s_state)
+#define SB_BMAP_NR(s) (SB_DISK_SUPER_BLOCK(s)->s_bmap_nr)
+#define SB_AP_BITMAP(s) ((s)->u.reiserfs_sb.s_ap_true_bitmap)
+/* #define SB_AP_CAUTIOUS_BITMAP(s) ((s)->u.reiserfs_sb.s_ap_cautious_bitmap) journal victim */
+#define SB_PRESERVED(s) ((s)->u.reiserfs_sb.s_preserved)
+
+#endif	/* _LINUX_REISER_FS_SB */
Index: empeg/kernel/kernel/ksyms.c
diff -u empeg/kernel/kernel/ksyms.c:1.1.1.3 empeg/kernel/kernel/ksyms.c:1.2
--- empeg/kernel/kernel/ksyms.c:1.1.1.3	Sat Mar 18 15:23:20 2000
+++ empeg/kernel/kernel/ksyms.c	Fri Oct 20 15:54:49 2000
@@ -196,6 +196,21 @@
 EXPORT_SYMBOL(ROOT_DEV);
 EXPORT_SYMBOL(inode_generation_count);
 
+#if !defined(CONFIG_REISERFS_FS) && defined(CONFIG_REISERFS_FS_MODULE)
+EXPORT_SYMBOL(__wait_on_inode);
+EXPORT_SYMBOL(inode_in_use);
+EXPORT_SYMBOL(inode_lock);
+EXPORT_SYMBOL(test_and_wait_on_buffer);
+EXPORT_SYMBOL(reiserfs_get_hash_table);
+EXPORT_SYMBOL(reiserfs_getblk);
+EXPORT_SYMBOL(fixup_reiserfs_buffers);
+EXPORT_SYMBOL(reiserfs_refile_buffer);
+EXPORT_SYMBOL(reiserfs_file_buffer) ;
+EXPORT_SYMBOL(reiserfs_journal_end_io) ;
+EXPORT_SYMBOL(reiserfs_end_buffer_io_sync) ;
+#endif
+
+
 #if !defined(CONFIG_NFSD) && defined(CONFIG_NFSD_MODULE)
 EXPORT_SYMBOL(do_nfsservctl);
 #endif
Index: empeg/kernel/net/ipv4/ipconfig.c
diff -u empeg/kernel/net/ipv4/ipconfig.c:1.4 empeg/kernel/net/ipv4/ipconfig.c:1.5
--- empeg/kernel/net/ipv4/ipconfig.c:1.4	Mon Jun  5 12:12:02 2000
+++ empeg/kernel/net/ipv4/ipconfig.c	Thu Sep 28 18:44:28 2000
@@ -935,6 +935,16 @@
 	retries = CONF_RETRIES;
 	get_random_bytes(&timeout, sizeof(timeout));
 	timeout = CONF_BASE_TIMEOUT + (timeout % (unsigned) CONF_TIMEOUT_RANDOM);
+
+#ifdef CONFIG_SA1100_EMPEG
+	/*
+	 * Hack - tifon driver swallows first packet if it's sent
+	 * within 1 second of initialisation.
+	 */
+
+	while(jiffies - start_jiffies < HZ);
+#endif
+
 	for(;;) {
 #ifdef CONFIG_IP_PNP_BOOTP
 		if (do_bootp)
