Index: empeg/kernel/arch/arm/def-configs/empeg
diff -u empeg/kernel/arch/arm/def-configs/empeg:1.5 empeg/kernel/arch/arm/def-configs/empeg:1.5.8.1
--- empeg/kernel/arch/arm/def-configs/empeg:1.5	Sat Mar 18 13:39:01 2000
+++ empeg/kernel/arch/arm/def-configs/empeg	Tue Jun  5 19:36:37 2001
@@ -108,7 +108,7 @@
 # CONFIG_WATCHDOG is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-CONFIG_EMPEG_IR=y
+CONFIG_EMPEG_INPUT=y
 CONFIG_EMPEG_USB9602=y
 # CONFIG_EMPEG_USBD12 is not set
 CONFIG_EMPEG_STATE=y
Index: empeg/kernel/arch/arm/def-configs/empeg-car1
diff -u empeg/kernel/arch/arm/def-configs/empeg-car1:1.1.2.1 empeg/kernel/arch/arm/def-configs/empeg-car1:1.1.2.2
--- empeg/kernel/arch/arm/def-configs/empeg-car1:1.1.2.1	Tue Oct 31 14:23:53 2000
+++ empeg/kernel/arch/arm/def-configs/empeg-car1	Tue Jun  5 19:36:37 2001
@@ -114,7 +114,7 @@
 # CONFIG_WATCHDOG is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-CONFIG_EMPEG_IR=y
+CONFIG_EMPEG_INPUT=y
 CONFIG_EMPEG_USB9602=y
 # CONFIG_EMPEG_USBD12 is not set
 CONFIG_EMPEG_STATE=y
Index: empeg/kernel/arch/arm/def-configs/empeg-car2
diff -u empeg/kernel/arch/arm/def-configs/empeg-car2:1.1.2.2 empeg/kernel/arch/arm/def-configs/empeg-car2:1.1.2.3
--- empeg/kernel/arch/arm/def-configs/empeg-car2:1.1.2.2	Thu May  3 18:06:37 2001
+++ empeg/kernel/arch/arm/def-configs/empeg-car2	Tue Jun  5 19:36:37 2001
@@ -115,7 +115,7 @@
 # CONFIG_WATCHDOG is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-CONFIG_EMPEG_IR=y
+CONFIG_EMPEG_INPUT=y
 # CONFIG_EMPEG_USB9602 is not set
 CONFIG_EMPEG_USBD12=y
 CONFIG_EMPEG_STATE=y
Index: empeg/kernel/arch/arm/special/Makefile
diff -u empeg/kernel/arch/arm/special/Makefile:1.18.8.1 empeg/kernel/arch/arm/special/Makefile:1.18.8.2
--- empeg/kernel/arch/arm/special/Makefile:1.18.8.1	Thu May  3 11:54:49 2001
+++ empeg/kernel/arch/arm/special/Makefile	Tue Jun  5 19:35:38 2001
@@ -77,6 +77,10 @@
   endif
 endif
 
+ifdef CONFIG_EMPEG_INPUT
+  L_OBJS += empeg_input.o empeg_input_fiq.o
+endif
+
 ifdef CONFIG_EMPEG_STATE
   L_OBJS	+= empeg_state.o
 endif
Index: empeg/kernel/arch/arm/special/empeg_dsp_i2c.h
diff -u empeg/kernel/arch/arm/special/empeg_dsp_i2c.h:1.3.2.2 empeg/kernel/arch/arm/special/empeg_dsp_i2c.h:1.3.2.3
--- empeg/kernel/arch/arm/special/empeg_dsp_i2c.h:1.3.2.2	Thu May 31 15:57:27 2001
+++ empeg/kernel/arch/arm/special/empeg_dsp_i2c.h	Mon Jun  4 19:03:29 2001
@@ -40,6 +40,8 @@
 #define Y_E_strnf_rsp	0x872
 #define Y_E_mltp_rsp	0x873
 #define Y_sdr_d_c	0x874
+#define Y_p6		0x876
+#define Y_q6		0x877
 #define Y_c91		0x87b
 #define Y_c61		0x87d
 #define Y_EMute		0x887
Index: empeg/kernel/arch/arm/special/empeg_input.c
diff -u /dev/null empeg/kernel/arch/arm/special/empeg_input.c:1.2.2.1
--- /dev/null	Tue Jun  5 20:24:05 2001
+++ empeg/kernel/arch/arm/special/empeg_input.c	Tue Jun  5 19:35:13 2001
@@ -0,0 +1,1123 @@
+/*
+ * empeg-car Infrared 205/70VR15 support
+ *
+ * (C) 1999-2000 empeg ltd
+ *
+ * Authors:
+ *   Mike Crowe <mac@empeg.com>
+ *
+ * This driver supports infrared remote control devices on the
+ * empegCar. It currently has support only for the Kenwood credit card
+ * remote control (and presumably other Kenwood remotes) and a capture
+ * mode to decipher the format of other remote controls.
+ *
+ * The repeat handling code is biased towards the Kenwood remote and
+ * other controls may need a different approach.
+ *
+ * 1999/02/11 MAC Code tidied up and symbols made static.
+ *
+ * 1999/02/11 MAC Comments added. Now limitted to only one open.
+ *
+ * 1999/02/12 MAC Magic sequence support added. It doesn't actually
+ *                work yet so it's disabled by default.
+ *
+ * 1999/03/01 MAC Added support for a repeat timeout. If a repeat code
+ *                is received a long time after the previous repeat
+ *                code/button code then it is ignored. The actual
+ *                data for the repeat is now stored inside the remote
+ *                specific function so that the repeat is for the
+ *                correct control.
+ *
+ * 1999/06/02 MAC Generation of repeats are no longer cancelled in
+ *                Kenwood handler if dodgy data is received. So we
+ *                are relying on the timeout to stop the wrong code
+ *                being repeated.
+ *
+ * 1999/07/03 MAC Various fixes in the IR handlers to reduce the
+ *                chances of missed messages. Widened the
+ *                acceptable values for the start sequence on
+ *                button presses.
+ *
+ * 1999/07/04 MAC Added bounds checking on kenwood handler so that
+ *                repeat codes are now much less likely to come
+ *                from the sky.
+ *
+ * 2000/04/04 MAC Changed to use timing queue, FIQ option.
+ *
+ * 2000/09/19 MAC Complete overhaul to send button up and button down
+ *                codes rather that doing all the repeat stuff here.
+ *
+ * */
+
+/* Output format.
+ *
+ * Codes are put into the buffer as 32 bit quantities.
+ *
+ * Infra-red remote controls always generate 24 bits of data ( 16 bits
+ * of manufacturer code and 8 bits of error checked button code)
+ * therefore the 32 bit quantity always has the top  bits set to
+ * zero for button presses. The top bit is set for button up codes.
+ *
+ * So, in summary:
+ *
+ *   0000 0000 mmmm mmmm  mmmm mmmm xxxx xxxx = Button down
+ *   1000 0000 mmmm mmmm  mmmm mmmm xxxx xxxx = Button up */
+
+/* Since we now use jiffies for the repeat handling we're assuming
+   that the device won't be up for 497 days :-) */
+
+#include <linux/sched.h>
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <asm/ptrace.h>
+#include <asm/fiq.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/time.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/vmalloc.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <asm/system.h>
+#include <asm/arch/hardware.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <asm/arch/empeg.h>
+#include <asm/uaccess.h>
+#include <linux/proc_fs.h>
+#include <linux/poll.h>
+#include "empeg_input.h"
+
+#define MS_TO_JIFFIES(MS) ((MS)/(1000/HZ))
+#define JIFFIES_TO_MS(J) (((J)*1000)/HZ)
+#define US_TO_TICKS(US) ((368 * (US))/100)
+#define TICKS_TO_US(T) ((100 * (T))/368)
+
+#define IR_DEBUG 0
+
+#define USE_TIMING_QUEUE 1
+
+/* The CS4231 in the Mk2 uses FIQs */
+#ifndef CONFIG_EMPEG_CS4231
+#define USE_TIMING_QUEUE_FIQS 1
+#else
+#define USE_TIMING_QUEUE_FIQS 0
+#endif
+
+#ifndef USE_TIMING_QUEUE
+#error Non timing queue is no longer supported
+#endif
+
+#define IR_TYPE_DEFAULT IR_TYPE_KENWOOD
+
+/* Delay before repeating default */
+//#define IR_RPTDELAY_DEFAULT MS_TO_JIFFIES(300) /* .3 seconds */
+
+/* Delay between repeats default */
+//#define IR_RPTINT_DEFAULT MS_TO_JIFFIES(100) /*.1 seconds */
+
+/* Timeout for getting a repeat code and still repeating */
+#define IR_REPEAT_TIMEOUT MS_TO_JIFFIES(500) /* 0.5 seconds */
+
+/* Freeing up the IRQ breaks on Henry due to the IRQ hack. This means
+ * that we can't request and free on open and close. Ultimately we
+ * should probably do so but it needs testing on Sonja first.
+ */   
+//#define REQUEST_IRQ_ON_OPEN 0
+
+#define REMOTE_BUTTON_UP_TIMEOUT MS_TO_JIFFIES(100) /* .1 seconds */
+
+/* Each button press when in one of the control specific modes
+ * generates a 4 byte code. When in capture mode each transition
+ * received generates a 4 byte code.
+ *
+ * Therefore, this buffer has room for 256 keypresses or
+ * transitions. This should be enough since capturing is only meant as
+ * a diagnostic and development feature and therefore should not be
+ * attempted if you can't guarantee reading it often enough.
+ */
+#define IR_BUFFER_SIZE 256
+
+/* The type used for IR codes returned to the user process. */
+typedef __u32 input_code;
+
+/* We only support one device */
+struct input_dev
+{
+#if USE_TIMING_QUEUE
+	volatile int timings_used;	/* Do not move */
+        volatile int timings_free;	/* Do not move */
+        volatile int timings_head;      /* Do not move */
+	volatile int timings_tail;      /* Do not move */
+	volatile unsigned long *timings_buffer;     /* Do not move */
+#endif
+	
+	input_code *buf_start;
+	input_code *buf_end;
+	input_code *buf_wp;
+	input_code *buf_rp;
+
+	struct wait_queue *wq;          /* Blocking queue */
+	struct tq_struct timer;         /* Timer queue */
+	
+	int remote_type;
+
+	/* Repeat support */
+	unsigned long last_ir_jiffies;
+	unsigned long current_button_down;
+	unsigned long last_code_received;
+
+	/* Statistics */
+	unsigned long count_valid;
+	unsigned long count_repeat;
+	unsigned long count_badrepeat;
+	unsigned long count_spurious;
+	unsigned long count_malformed;
+	unsigned long count_missed;
+#if USE_TIMING_QUEUE
+	unsigned long timings_hwm;
+#endif
+};
+
+static struct input_dev input_devices[1];
+
+/* Used to disallow multiple opens. */
+static int users = 0;
+#if USE_TIMING_QUEUE_FIQS
+static struct fiq_handler fh = { NULL, "empeg_input", NULL, NULL };
+#endif
+
+/* Bottom bit must be clear for switch statement */
+#define IR_STATE_IDLE 0x00
+#define IR_STATE_START1 0x02
+#define IR_STATE_START2 0x04
+#define IR_STATE_START3 0x06
+#define IR_STATE_DATA1  0x08
+#define IR_STATE_DATA2 0x0a
+
+/* Work out how many jiffies have passed since the parameter. This
+ * means that if past_jiffies is actually in the future it will appear
+ * to be hugely in the past. */
+static inline unsigned long jiffies_since(unsigned long past_jiffies)
+{
+	/* Since jiffies is volatile we need to make sure we are using
+         * a consistent value for it for the whole function. */
+	const unsigned long now_jiffies = jiffies;
+	if (past_jiffies <= now_jiffies) {
+		/* Simple case */
+		return now_jiffies - past_jiffies;
+	} else {
+		/* Wrap around case */
+		return ULONG_MAX - past_jiffies + now_jiffies;
+	}
+}
+
+static void input_append_code(struct input_dev *dev, input_code data)
+{
+	/* Now this is called from the bottom half we need to make
+	   sure that noone else is fiddling with stuff while we
+	   do it. */
+	input_code *new_wp;
+	unsigned long flags;
+	save_flags_cli(flags);
+	
+	new_wp = dev->buf_wp + 1;
+	if (new_wp == dev->buf_end)
+		new_wp = dev->buf_start;
+	
+	if (new_wp != dev->buf_rp)
+	{
+		*dev->buf_wp = data;
+		dev->buf_wp = new_wp;
+		/* Now we've written, wake up anyone who's reading */
+		wake_up_interruptible(&dev->wq);
+	}
+#if IR_DEBUG
+	else
+		printk("Infra-red buffer is full.\n");
+#endif
+	restore_flags(flags);
+}
+
+static void input_on_remote_repeat(struct input_dev *dev)
+{
+	if (dev->current_button_down == 0) {
+		/* We got a repeat code but nothing was held, if it
+	           wasn't too long ago assume that we accidentally
+	           sent a button up and send another button down to
+	           compensate. */
+		if (jiffies_since(dev->last_ir_jiffies) < IR_REPEAT_TIMEOUT) {
+			dev->current_button_down = dev->last_code_received;
+			input_append_code(dev, dev->current_button_down);
+			dev->last_ir_jiffies = jiffies;
+		}
+	} else {
+		/* Since we've had a repeat, make sure we know when it was. */
+		dev->last_ir_jiffies = jiffies;
+	}
+}
+
+static void input_on_remote_up(struct input_dev *dev)
+{
+	if (dev->current_button_down) {
+		input_append_code(dev, (1 << 31) | dev->current_button_down);
+		dev->current_button_down = 0;
+	}
+}
+
+static void input_on_remote_code(struct input_dev *dev,
+				 input_code data)
+{
+	if (dev->current_button_down != data)
+		input_on_remote_up(dev);
+	dev->current_button_down = data;
+	dev->last_code_received = data;
+	input_append_code(dev, data);
+
+	// We've got a repeat, notify how long ago our last repeat was.
+	dev->last_ir_jiffies = jiffies;
+}
+
+#if IR_DEBUG
+struct recent_entry {
+	int state;
+	int interval;
+};
+#define ENTRY_COUNT 32
+
+static void dump_entries(struct recent_entry *e, int start, int end)
+{
+	int i = start;
+	printk("State level interval\n");
+	while (i != end)
+	{
+		printk("%5x %5d %8d\n", e[i].state & ~1, e[i].state & 1, e[i].interval);
+		++i;
+		if (i >= ENTRY_COUNT)
+			i = 0;
+	}
+}
+#endif
+
+static inline void input_buttons_interrupt(struct input_dev *dev, int level,
+					unsigned long span)
+{
+	static int state = IR_STATE_IDLE;
+	static int unit_time = 1; /* not zero in case we accidentally use it */
+	static unsigned short bit_position = 0;
+	static __u8 data = 0;
+	
+#if IR_DEBUG
+	static int entry_rp = 0, entry_wp = 0;
+	static struct recent_entry entries[ENTRY_COUNT];
+#endif
+
+	/* Check to see if the last interrupt was so long ago that
+	 * we should restart the state machine.
+	 */
+
+	if (span >= US_TO_TICKS(40000)) {
+		bit_position = 0;
+		state = IR_STATE_IDLE;
+	}
+
+#if IR_DEBUG
+	entries[entry_wp].state = state | (level ? 1 : 0);
+	entries[entry_wp].interval = span;
+
+	entry_wp++;
+	if (entry_wp >= ENTRY_COUNT)
+		entry_wp = 0;
+
+	if (entry_wp == entry_rp) {
+		entry_rp++;
+		if (entry_rp >= ENTRY_COUNT)
+			entry_rp = 0;
+	}
+#endif
+	
+#if IR_DEBUG
+#define ON_RECOVER dump_entries(entries, entry_rp, entry_wp)
+#define ON_VALID entry_rp = entry_wp = 0
+#else
+#define ON_RECOVER
+#define ON_VALID
+#endif
+	
+	//old_state = state | (level ? 1 : 0);
+	/* Now we can actually do something */
+
+#if IR_DEBUG
+	{
+		int result = (1<<31);
+		if (level)
+		    result |= (1<<30);
+		result |= ((state & 0xF) << 26);
+		result |= (span & 0x3ffff);
+		ir_append_data(dev, result);
+	}
+#endif
+
+			
+retry:
+	switch(state | (level ? 1 : 0))
+	{
+	case IR_STATE_IDLE | 1:
+		/* Going high in idle doesn't mean anything */
+		break;
+		
+	case IR_STATE_IDLE | 0:
+		/* Going low in idle is the start of a start sequence */
+		state = IR_STATE_START1;
+		break;
+
+	case IR_STATE_START1 | 1:
+		/* Going high, that should be after 4T */
+		unit_time = span / 4;
+		if (unit_time > US_TO_TICKS(50) && unit_time < US_TO_TICKS(550))
+		//if (unit_time > US_TO_TICKS(150) && unit_time < US_TO_TICKS(350)) << original
+		//if (unit_time > 225 && unit_time < 275)
+			state = IR_STATE_START2;
+		else
+			state = IR_STATE_IDLE; /* There's no point in recovering immediately
+						  since this can't be the start of a new
+						  sequence. */
+		break;
+
+	case IR_STATE_START1 | 0:
+		/* Shouldn't ever go low in START1, recover */
+		/*state = IR_STATE_IDLE;*/
+		/* We jump straight back to START1 since this might still */
+		/* be the start of a sequence */
+		ON_RECOVER;
+		state = IR_STATE_IDLE;
+		++dev->count_missed;
+		goto retry;
+
+	case IR_STATE_START2 | 1:
+		/* Shouldn't ever go high in START2, recover */
+		state = IR_STATE_IDLE;
+		++dev->count_missed;
+		break;
+
+	case IR_STATE_START2 | 0:
+		/* If this forms the end of the start sequence then we
+		 * should have been high for around 8T time.
+		 */
+		if (span > 7 * unit_time && span < 9 * unit_time) {
+			/* It's the start of one of the unit button codes. */
+			data = 0;
+			bit_position = 0;
+			state = IR_STATE_DATA1;
+		} else {
+			/* We're out of bounds. Give up, but this might be the
+			   start of a valid start sequence. */
+			ON_RECOVER;
+			state = IR_STATE_IDLE;
+			goto retry; /* try again */
+		}
+		break;
+
+	case IR_STATE_DATA1 | 0:
+		/* This should never happen */
+		state = IR_STATE_IDLE;
+		++dev->count_missed;
+		break;
+		
+	case IR_STATE_DATA1 | 1:
+		data <<= 1;
+		if (span <= 3 * unit_time) {
+			/* It's a zero bit */
+			bit_position++;
+			state = IR_STATE_DATA2;
+		} else if (span > 3 * unit_time && span < 5 * unit_time) {
+			/* It's a one bit */
+			data |= 1;
+			bit_position++;
+			state = IR_STATE_DATA2;
+		} else {
+			/* This can't be the start of a start sequence since
+			   we're going high, so just give up */
+			ON_RECOVER;
+			state = IR_STATE_START1;
+			goto retry;
+		}
+
+		/* Now process the bit */
+		if (bit_position > 7) {
+			/* Does it pass the validity check */
+			if (((data>>4)^(data&0xf))==0xf)
+			{
+				/* We don't do anything with repeats so go
+				   straight to the real code */
+				input_append_code(dev, data >> 4);
+				ON_VALID;
+			        state = IR_STATE_IDLE;
+			}
+			else
+			{
+				/* Report CRC failures */
+				//ir_append_data(dev, tv_now, 0xFF00 | data);
+				ON_RECOVER;
+				state = IR_STATE_START1;
+				goto retry;
+			}
+		}
+		break;
+
+	case IR_STATE_DATA2 | 0:
+		if (span < 2 * unit_time) {
+			/* It's a correct inter-bit gap */
+			state = IR_STATE_DATA1;
+		} else {
+			ON_RECOVER;
+			/* It's out of bounds. It might be the start
+			   of another valid sequence so try again. */
+			state = IR_STATE_IDLE;
+			goto retry;
+		}
+		break;
+
+	case IR_STATE_DATA2 | 1:
+		/* Should never get here */
+		ON_RECOVER;
+		state = IR_STATE_IDLE;
+		++dev->count_missed;
+		break;
+		
+	default:
+#if IR_DEBUG
+		printk("Buttons handler got into impossible state. Recovering.\n");
+		state = IR_STATE_IDLE;
+#endif
+		break;
+	}
+}
+
+static inline void input_kenwood_interrupt(struct input_dev *dev, int level,
+					   unsigned long span)
+{
+	static int state = IR_STATE_IDLE;
+	static int unit_time = 1; /* not zero in case we accidentally use it */
+	static unsigned short bit_position = 0;
+	static __u32 data = 0;
+	static input_code decoded_data = 0;
+	static int repeat_valid = FALSE;
+	//static struct timeval tv_last_valid;
+	
+	/* Check to see if the last interrupt was so long ago that
+	 * we should restart the state machine.
+	 */
+
+	if (span >= US_TO_TICKS(40000)) {
+		bit_position = 0;
+		state = IR_STATE_IDLE;
+	}
+
+	/* Now we can actually do something */
+
+ retry:
+	switch(state | (level ? 1 : 0))
+	{
+	case IR_STATE_IDLE | 1:
+		/* Going high in idle doesn't mean anything */
+		break;
+		
+	case IR_STATE_IDLE | 0:
+		/* Going low in idle is the start of a start sequence */
+		state = IR_STATE_START1;
+		break;
+
+	case IR_STATE_START1 | 1:
+		/* Going high, that should be after 8T */
+		unit_time = span / 8;
+		/* But some bounds on it so we don't start receiving magic
+		   codes from the sky */
+		if (unit_time > US_TO_TICKS(500) && unit_time < US_TO_TICKS(1500))
+			state = IR_STATE_START2;
+		else
+			state = IR_STATE_IDLE;
+		break;
+
+	case IR_STATE_START1 | 0:
+		/* Shouldn't ever go low in START1, recover */
+		state = IR_STATE_IDLE;
+		++dev->count_missed;
+		break;
+
+	case IR_STATE_START2 | 1:
+		/* Shouldn't ever go low in START2, recover */
+		state = IR_STATE_IDLE;
+		++dev->count_missed;
+		break;
+
+	case IR_STATE_START2 | 0:
+		/* If this forms the end of the start sequence then we
+		 * should have been high for around 4T time.
+		 */
+		if ((span >= 3 * unit_time) &&
+			(span < 5 * unit_time)) {
+			state = IR_STATE_START3;
+			/*repeat_valid = FALSE;*/
+		} else if (span > unit_time && span < 3 * unit_time) {
+			/* This means that the last code is repeated - just
+			   send out the last code again with the top bit set to indicate
+			   a repeat. */
+			if (repeat_valid)
+			{
+				input_on_remote_repeat(dev);
+				++dev->count_repeat;
+			}
+			else
+			{
+				++dev->count_badrepeat;
+			}
+			state = IR_STATE_IDLE;
+		} else {
+			/* We're out of bounds. Recover */
+			state = IR_STATE_IDLE;
+			/* But it could be the start of a new sequence
+                           so try again */
+			++dev->count_spurious;
+			goto retry;
+		}
+		break;
+
+	case IR_STATE_START3 | 0:
+		/* Shouldn't happen */
+		state = IR_STATE_IDLE;
+		++dev->count_missed;
+		break;
+
+	case IR_STATE_START3 | 1:
+		/* Data will follow this */
+		if (span < unit_time) {
+			bit_position = 0;
+			data = 0;
+			state = IR_STATE_DATA1;
+		} else {
+			/* We're out of bounds. It might be the start
+			   of a new sequence so try it again. */
+			state = IR_STATE_IDLE;
+			++dev->count_spurious;
+			goto retry;
+		}
+		break;
+		
+	case IR_STATE_DATA1 | 1:
+		/* Shouldn't get this. Recover */
+		state = IR_STATE_IDLE;
+		++dev->count_missed;
+		break;
+
+	case IR_STATE_DATA1 | 0:
+		/* The actual data bit is encoded in the length of this.
+		 */
+		if (span < unit_time) {
+			/* It's a zero */
+			bit_position++;
+			state = IR_STATE_DATA2;
+		} else if (span < 2 * unit_time) {
+			/* It's a one */
+			data |= (1<<bit_position);
+			bit_position++;
+			state = IR_STATE_DATA2;
+		} else {
+			/* Not valid. It might be the start of a new
+                           sequence though. */
+			state = IR_STATE_IDLE;
+			++dev->count_spurious;
+			goto retry;
+		}
+		break;
+
+	case IR_STATE_DATA2 | 1:
+		/* This marks the end of the post-data space
+		 * It is a consistent length
+		 */
+		if (span < unit_time) {
+			/* It's a valid space */
+			if (bit_position >= 32) {
+				__u16 mfr;
+				__u8 data1, data2;
+				__u32 cpu_data = be32_to_cpu(data);
+
+				// On modern remotes the manufacturer code is not protected.
+				mfr = cpu_data >> 16;
+				data1 = (cpu_data >> 8) & 0xff;
+				data2 = cpu_data & 0xff;
+
+				/* We've finished getting data, confirm
+				   it passes the validity check */
+				if (data1 == ((__u8)(~data2))) {
+					decoded_data = ((__u32)(mfr) << 8) | data1;
+					input_on_remote_code(dev, decoded_data);
+					repeat_valid = TRUE;
+					++dev->count_valid;
+				} else {
+#if IR_DEBUG
+					printk("Got an invalid sequence %08lx (%04lx, %04lx)\n",
+					       (unsigned long)data, (unsigned long)data1,
+					       (unsigned long)data2);
+					printk("(%04lx %04lx, %04lx %04lx)\n",
+					       (unsigned long)data1, (unsigned long)~data1,
+					       (unsigned long)data2, (unsigned long)~data2);
+#endif
+					++dev->count_malformed;
+				}
+				state = IR_STATE_IDLE;
+			}
+			else
+				state = IR_STATE_DATA1;
+		} else {
+			/* It's too long to be valid. Give up and try again. */
+			state = IR_STATE_IDLE;
+			++dev->count_spurious;
+			goto retry;
+		}
+		break;
+
+	case IR_STATE_DATA2 | 0:
+		/* Shouldn't get this. Recover */
+		state = IR_STATE_IDLE;
+		++dev->count_missed;
+		break;
+
+	default:
+		state = IR_STATE_IDLE;
+		break;
+	}
+}
+
+static inline void input_capture_interrupt(struct input_dev *dev, int level,
+					unsigned long span)
+{
+	unsigned long us = TICKS_TO_US(span);
+	/* Just capture it straight to the output buffer */
+	if (level)
+		input_append_code(dev, us | (1<<30) | (1<<31));
+	else
+		input_append_code(dev, (us & ~(1<<30)) | (1<<31));
+}
+
+static inline void ir_transition(struct input_dev *dev, int level, unsigned long span)
+{
+	/* Call buttons interrupt handler */
+	if (dev->remote_type != IR_TYPE_CAPTURE)
+		input_buttons_interrupt(dev, level, span);
+	
+	/* Call remote specific interrupt handler */
+
+	switch (dev->remote_type)
+	{
+	case IR_TYPE_CAPTURE:
+		input_capture_interrupt(dev, level, span);
+		break;
+	case IR_TYPE_KENWOOD:
+		input_kenwood_interrupt(dev, level, span);
+		break;
+	default:
+		/* Hmm, I wonder what it was supposed to be */
+		dev->remote_type = IR_TYPE_KENWOOD;
+		break;
+	}
+}
+
+#if USE_TIMING_QUEUE_FIQS
+static void input_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	/* Not needed if we're running on FIQs */
+	printk("BAD!\n");
+}
+#else
+static void input_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	int level;
+	unsigned long now; 
+	unsigned long entry;
+	unsigned long flags;
+	struct input_dev *dev = input_devices;
+	
+	save_flags_cli(flags);
+
+	level = (GPLR & EMPEG_IRINPUT)?1:0;
+	now = OSCR;
+
+	entry = (now & ~1) | level;
+	
+	if (dev->timings_free) {
+		--dev->timings_free;
+		dev->timings_buffer[dev->timings_head] = entry;
+		if (++dev->timings_head >= TIMINGS_BUFFER_SIZE)
+			dev->timings_head = 0;
+		++dev->timings_used;
+	}
+
+	restore_flags(flags);
+	
+}
+#endif
+
+static void input_check_buffer(void *dev_id)
+{
+	/* This stores the time of the last actual interrupt, not the time this
+	 * routine was called
+	 */
+	static unsigned long last_interrupt;
+	
+	struct input_dev *dev = dev_id;
+
+	while (dev->timings_used) {
+		unsigned long flags;
+		unsigned long entry;
+		unsigned long span;
+		unsigned long interrupt_time;
+		int level;
+
+		/* Keep track of the hwm */
+		{
+			int used = dev->timings_used;
+			if (used > dev->timings_hwm)
+				dev->timings_hwm = used;
+		}
+
+		/* Safe to do even if an interrupt happens during it. */
+		entry = dev->timings_buffer[dev->timings_tail];
+		
+		/* Disable interrupts while we tidy up the pointers */
+		save_flags_clif(flags);
+		++dev->timings_free;
+		--dev->timings_used;
+		restore_flags(flags);
+
+		if (++dev->timings_tail >= TIMINGS_BUFFER_SIZE)
+			dev->timings_tail = 0;
+
+		/* Now, we have our entry, go and deal with it. */
+		interrupt_time = entry & ~1;
+		level = entry & 1;
+
+		span = interrupt_time - last_interrupt;
+		last_interrupt = interrupt_time;
+
+		//printk("Transition(%d): %d %5ld\n", dev->timings_tail, level, span);
+		ir_transition(dev, level, span);
+	}
+
+	/* If we haven't had a repeat code for a while send a button up. */
+	if ((dev->current_button_down != 0) && (jiffies_since(dev->last_ir_jiffies) > REMOTE_BUTTON_UP_TIMEOUT))
+		input_on_remote_up(dev);
+	
+	/* Requeue me */
+	queue_task(&dev->timer, &tq_timer);
+}
+
+static int input_open(struct inode *inode, struct file *filp)
+{
+	struct input_dev *dev = input_devices;
+
+	if (users)
+		return -EBUSY;
+
+	users++;
+	MOD_INC_USE_COUNT;
+	
+	/* This shouldn't be necessary, but there's something (IDE, audio?)
+	 * that's setting rather than or'ing these and breaking it after
+	 * initialisation.
+	 */
+	GRER|=EMPEG_IRINPUT;
+	GFER|=EMPEG_IRINPUT;
+	GEDR=EMPEG_IRINPUT;
+
+	dev->remote_type = IR_TYPE_DEFAULT;
+	filp->private_data = dev;
+	
+	return 0;
+}
+
+static int input_release(struct inode *inode, struct file *filp)
+{
+	--users;
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+/*
+ * Read some bytes from the IR buffer. The count should be a multiple
+ * of four bytes - if it isn't then it is rounded down. If the
+ * rounding means that it is zero then EINVAL will result.
+ */
+static ssize_t input_read(struct file *filp, char *dest, size_t count,
+		       loff_t *ppos)
+{
+	struct input_dev *dev = filp->private_data;
+	int n;
+
+	struct wait_queue wait = { current, NULL };
+
+	/* If we're nonblocking then return immediately if there's no data */
+	if ((filp->f_flags & O_NONBLOCK) && (dev->buf_rp == dev->buf_wp))
+		return -EAGAIN;
+
+	/* Wait for some data to turn up - this method avoids race
+           conditions see p209 of Linux device drivers. */
+	add_wait_queue(&dev->wq, &wait);
+	current->state = TASK_INTERRUPTIBLE;	
+	while ((dev->buf_rp == dev->buf_wp) && !signal_pending(current))
+		schedule();
+	current->state = TASK_RUNNING;
+	remove_wait_queue(&dev->wq, &wait);
+
+	if (signal_pending(current))
+	    return -ERESTARTSYS;
+
+	/* Only allow reads of a multiple of four bytes. Anything else
+           is meaningless and may cause us to get out of sync */
+	count >>= 2;
+
+	/* Not sure if this is a valid thing to be doing */
+	if (!count)
+		return -EINVAL;
+	
+	n = 0;
+	while (count--) {
+		input_code data;
+
+		if (dev->buf_rp == dev->buf_wp)
+			return n;
+
+		/* Need to put one byte at a time since there are no
+		   alignment requirements on parameters to read. */
+		data = *dev->buf_rp;
+		__put_user(data & 0xFF, dest++);
+		__put_user((data >> 8) & 0xFF, dest++);
+		__put_user((data >> 16) & 0xFF, dest++);
+		__put_user((data >> 24) & 0xFF, dest++);
+		dev->buf_rp++;
+		if (dev->buf_rp == dev->buf_end)
+			dev->buf_rp = dev->buf_start;
+
+		n += 4;
+	}
+
+	return n;
+}
+
+unsigned int input_poll(struct file *filp, poll_table *wait)
+{
+	struct input_dev *dev = filp->private_data;
+
+	/* Add ourselves to the wait queue */
+	poll_wait(filp, &dev->wq, wait);
+
+	/* Check if we've got data to read */
+	if (dev->buf_rp != dev->buf_wp)
+		return POLLIN | POLLRDNORM;
+	else
+		return 0;
+}
+
+int input_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,
+	     unsigned long arg)
+{
+	struct input_dev *dev = filp->private_data;
+
+	switch(cmd)
+	{
+	case EMPEG_IR_WRITE_TYPE:
+		if (arg >= IR_TYPE_COUNT)
+			return -EINVAL;
+		dev->remote_type = arg;
+		return 0;
+		
+	case EMPEG_IR_READ_TYPE:
+		return put_user(dev->remote_type, (int *)arg);
+	default:
+		return -EINVAL;
+	}
+}
+
+static struct file_operations input_fops = {
+	NULL, /* ir_lseek */
+	input_read,
+	NULL, /* ir_write */
+	NULL, /* ir_readdir */
+	input_poll, /* ir_poll */
+	input_ioctl,
+	NULL, /* ir_mmap */
+	input_open,
+	NULL, /* ir_flush */
+	input_release,
+};
+
+int input_read_procmem(char *buf, char **start, off_t offset, int len, int unused)
+{
+	struct input_dev *dev = input_devices;
+	len = 0;
+
+	len += sprintf(buf+len, "Valid sequences:      %ld\n", dev->count_valid);
+	len += sprintf(buf+len, "Repeated sequences:   %ld\n", dev->count_repeat);
+	len += sprintf(buf+len, "Unfulfilled repeats:  %ld\n", dev->count_badrepeat);
+	len += sprintf(buf+len, "Malformed sequences:  %ld\n", dev->count_malformed);
+	len += sprintf(buf+len, "Spurious transitions: %ld\n", dev->count_spurious);
+	len += sprintf(buf+len, "Missed interrupts:    %ld\n", dev->count_missed);
+	len += sprintf(buf+len, "Timings buffer hwm:   %ld\n", dev->timings_hwm);
+
+	return len;
+}
+
+struct proc_dir_entry input_proc_entry = {
+	0,			/* inode (dynamic) */
+	8, "empeg_ir",  	/* length and name */
+	S_IFREG | S_IRUGO, 	/* mode */
+	1, 0, 0, 		/* links, owner, group */
+	0, 			/* size */
+	NULL, 			/* use default operations */
+	&input_read_procmem, 	/* function used to read data */
+};
+
+void __init empeg_input_init(void)
+{
+	struct input_dev *dev = input_devices;
+	int result;
+#if USE_TIMING_QUEUE_FIQS
+	struct pt_regs regs;
+	extern char empeg_input_fiq, empeg_input_fiqend;
+#endif
+
+	result = register_chrdev(EMPEG_IR_MAJOR, "empeg_input", &input_fops);
+	if (result < 0) {
+		printk(KERN_WARNING "empeg IR: Major number %d unavailable.\n",
+			   EMPEG_IR_MAJOR);
+		return;
+	}
+
+	/* First grab the memory buffer */
+	dev->buf_start = vmalloc(IR_BUFFER_SIZE * sizeof(input_code));
+	if (!dev->buf_start) {
+		printk(KERN_WARNING "Could not allocate memory buffer for empeg IR.\n");
+		return;
+	}
+	
+	dev->buf_end = dev->buf_start + IR_BUFFER_SIZE;
+	dev->buf_rp = dev->buf_wp = dev->buf_start;
+	dev->wq = NULL;
+	dev->remote_type = IR_TYPE_DEFAULT;
+
+	dev->count_valid = 0;
+	dev->count_repeat = 0;
+	dev->count_badrepeat = 0;
+	dev->count_spurious = 0;
+	dev->count_malformed = 0;
+	dev->count_missed = 0;
+
+#if USE_TIMING_QUEUE
+	dev->timings_hwm = 0;
+
+	dev->timings_free = TIMINGS_BUFFER_SIZE;
+	dev->timings_used = 0;
+	dev->timings_head = 0;
+	dev->timings_tail = 0;
+	dev->timings_buffer = vmalloc(TIMINGS_BUFFER_SIZE * sizeof(unsigned long));
+	
+	/* Set up timer routine to check the buffer */
+	dev->timer.sync = 0;
+	dev->timer.routine = input_check_buffer;
+	dev->timer.data = dev;
+	queue_task(&dev->timer, &tq_timer);
+
+#if USE_TIMING_QUEUE_FIQS
+	/* Install FIQ handler */
+	regs.ARM_r9=(int)dev;
+	regs.ARM_r10=(int)&OSCR; 	
+	regs.ARM_fp=0; 		/* r11 */
+	regs.ARM_ip=0;	 	/* r12 */
+	regs.ARM_sp=(int)&GPLR;
+	set_fiq_regs(&regs);
+
+	set_fiq_handler(&empeg_input_fiq,(&empeg_input_fiqend-&empeg_input_fiq));
+	claim_fiq(&fh);
+#endif
+#endif
+       	/* No interrupts yet */
+	GRER&=~EMPEG_IRINPUT;
+	GFER&=~EMPEG_IRINPUT;
+	GEDR=EMPEG_IRINPUT;
+
+	/* IRQs shouldn't be reenabled, the routine is very fast */
+	result = request_irq(EMPEG_IRQ_IR, input_interrupt, SA_INTERRUPT,
+			     "empeg_input", dev);
+	
+	if (result != 0) {
+		printk(KERN_ERR "Can't get empeg IR IRQ %d.\n", EMPEG_IRQ_IR);
+		return;
+	}
+
+#if USE_TIMING_QUEUE_FIQS
+	/* It's a FIQ not an IRQ */
+	ICLR|=EMPEG_IRINPUT;
+
+	/* Enable FIQs: there should be a neater way of doing
+	   this... */
+	{
+		unsigned long flags;
+		save_flags(flags);
+		flags&=~F_BIT;
+		restore_flags(flags);
+	}
+#endif
+  
+       	/* We want interrupts on rising and falling */
+	GRER|=EMPEG_IRINPUT;
+	GFER|=EMPEG_IRINPUT;
+	
+#ifdef CONFIG_PROC_FS
+	proc_register(&proc_root, &input_proc_entry);
+#endif
+
+#if USE_TIMING_QUEUE_FIQS
+	printk("empeg remote control/panel button support initialised (Using FIQs).\n");
+#else
+	printk("empeg remote control/panel button initialised.\n");
+#endif
+}
+
+static inline void empeg_input_cleanup(void)
+{
+	int result;
+	struct input_dev *dev = input_devices;
+
+	free_irq(EMPEG_IRQ_IR, dev);
+
+	/* No longer require interrupts */
+	GRER&=~(EMPEG_IRINPUT);
+	GFER&=~(EMPEG_IRINPUT);
+
+	result = unregister_chrdev(EMPEG_IR_MAJOR, "empeg_ir");
+	if (result < 0)
+		printk(KERN_WARNING "empeg_input: Unable to unregister device.\n");
+	printk("empeg IR cleanup complete.\n");
+}
+
+#ifdef MODULE
+MODULE_AUTHOR("Mike Crowe");
+MODULE_DESCRIPTION("A driver for the empeg infrared remote control and panel buttons");
+MODULE_SUPPORTED_DEVICE("ir");
+
+EXPORT_NO_SYMBOLS
+
+int init_module(void)
+{
+	return empeg_input_init();
+}
+
+void cleanup_module(void)
+{
+	empeg_input_cleanup();
+}
+
+#endif /* MODULE */
Index: empeg/kernel/arch/arm/special/empeg_input.h
diff -u /dev/null empeg/kernel/arch/arm/special/empeg_input.h:1.1.2.1
--- /dev/null	Tue Jun  5 20:24:05 2001
+++ empeg/kernel/arch/arm/special/empeg_input.h	Tue Jun  5 19:35:13 2001
@@ -0,0 +1,12 @@
+/*
+ * Empeg Infrared 205/70VR15 support
+ *
+ * Mike Crowe, <mac@empeg.com>
+ */
+
+#ifndef EMPEG_IR_H
+#define EMPEG_IR_H 1
+
+#define TIMINGS_BUFFER_SIZE 64
+
+#endif
Index: empeg/kernel/arch/arm/special/empeg_input_fiq.S
diff -u /dev/null empeg/kernel/arch/arm/special/empeg_input_fiq.S:1.2.2.1
--- /dev/null	Tue Jun  5 20:24:05 2001
+++ empeg/kernel/arch/arm/special/empeg_input_fiq.S	Tue Jun  5 19:35:13 2001
@@ -0,0 +1,87 @@
+/*
+ * empeg IR driver FIQ section
+ *
+ * (C)2000 empeg ltd, http://www.empeg.com
+ *
+ * Authors:
+ *   Mike Crowe, <mac@empeg.com>
+ *   Hugo Fiennes, <hugo@empeg.com>
+ *
+ */
+
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+#include <asm/arch/empeg.h>
+#include "empeg_input.h"
+		.text
+	
+.set		BUFFERS_USED,		0
+.set		BUFFERS_FREE,		4
+.set		BUFFERS_HEAD,		8
+.set		BUFFERS_TAIL,		12
+.set		BUFFERS_POINTER,	16
+
+		.global	SYMBOL_NAME(empeg_input_fiqend)
+ENTRY(empeg_input_fiq)
+		#   r8  - scratch
+	        #   r9  - pointer to empeg device structure
+		#   r10 - pointer to OSCR
+		#   r11 - scratch
+		#   r12 - scratch
+		#   r13	- pointer to GPLR
+
+		# First get the value of OSCR
+		ldr	r8, [r10]
+
+		# Now get the value of the IR bit in GPLR
+		ldr	r12, [r13,#0]		@ GPLR
+
+		# Check the IR input and set the bottom bit of the timer
+		# value to indicate the state
+		tst	r12, #(1<<EMPEG_IRINPUT_BIT)
+		orrne	r8,r8,#1
+		biceq	r8,r8,#1
+
+		# Now we have our entry, we had better put it in the queue.
+		# Is there room?
+		ldr	r12, [r9, #BUFFERS_FREE]
+		cmp	r12, #0
+		beq	no_room
+
+		# First decrement the free and store it.
+		sub	r12, r12, #1
+		str	r12, [r9, #BUFFERS_FREE]
+
+		# Load up the head pointer
+		ldr	r12, [r9, #BUFFERS_HEAD]
+
+		# Load up the address of the queue and add on the head pointer
+		ldr	r11, [r9, #BUFFERS_POINTER]
+
+		# Store the value we have
+		str	r8, [r11,r12,lsl#2]
+
+		# Increment the head pointer, if we have reached the maximum
+		# then set it to zero
+		add	r12, r12, #1
+		cmp	r12, #TIMINGS_BUFFER_SIZE
+		moveq	r12, #0               @  This is wierd for a 68000 programmer like me :)
+
+		# Store the head pointer back again.
+		str	r12, [r9, #BUFFERS_HEAD]
+
+		# Increment the used pointer
+		ldr	r12, [r9, #BUFFERS_USED]
+		add	r12, r12, #1
+		str	r12, [r9, #BUFFERS_USED]
+
+no_room:
+		# Lastly, we need to clear GEDR so we get re-triggered
+		mov	r8,#(1<<EMPEG_IRINPUT_BIT)
+		str	r8,[r13,#0x18]		@ GEDR
+
+		# Return
+		subs	pc,lr,#4
+SYMBOL_NAME(empeg_input_fiqend):
+/* ENTRY(empeg_input_fiqend) */
+
Index: empeg/kernel/arch/arm/special/empeg_mixer.c
diff -u empeg/kernel/arch/arm/special/empeg_mixer.c:1.4.2.6 empeg/kernel/arch/arm/special/empeg_mixer.c:1.4.2.8
--- empeg/kernel/arch/arm/special/empeg_mixer.c:1.4.2.6	Thu May 31 15:58:04 2001
+++ empeg/kernel/arch/arm/special/empeg_mixer.c	Tue Jun  5 19:35:27 2001
@@ -122,6 +122,7 @@
 static int radio_fm_deemphasis = 50;
 /* stereo detect */
 static unsigned stereo_level = 0;
+static unsigned sampling_rate = 44100;
 
 static mixer_dev	mixer_global;
 
@@ -139,12 +140,12 @@
 static void empeg_mixer_setbalance(mixer_dev *dev, int balance);
 static void empeg_mixer_setfade(mixer_dev *dev, int fade);
 static void empeg_mixer_mute(int on);
-static void empeg_mixer_select_input(int input);
 static void empeg_mixer_eq_reset(void);
 static void empeg_mixer_eq_set(struct empeg_eq_section_t *sections);
 static void empeg_mixer_set_fm_level(unsigned int p1, unsigned int q1);
 static int empeg_mixer_get_fm_noise(void);
 static int empeg_mixer_set_fm_deemphasis(int which);
+static void empeg_mixer_set_sampling_rate(mixer_dev *dev, unsigned rate);
 
 static struct file_operations mixer_fops =
 {
@@ -739,7 +740,7 @@
 
 static void empeg_mixer_setloudness(mixer_dev *dev, int level)
 {
-	static dsp_setup dynlou_41[] = {
+	static dsp_setup dynlou_44100[] = {
 		{ Y_KLCl, 0x347 }, /* p79, 100Hz */
 		{ Y_KLCh, 0x7dc },
 		{ Y_KLBl, 0x171 },
@@ -757,21 +758,46 @@
 		{ 0,0 }
 	};
 	       
+	static dsp_setup dynlou_38000[] = {
+		{ Y_KLCl, 0x5e2 }, /* p78, 100Hz */
+		{ Y_KLCh, 0x7d6 },
+		{ Y_KLBl, 0x5b6 },
+		{ Y_KLBh, 0xc28 },
+		{ Y_KLA0l, 0x467 },
+		{ Y_KLA0h, 0x000 },
+		{ Y_KLA2l, 0x000 },
+		{ Y_KLA2h, 0x000 },
+		{ Y_KLmid,0x200 },
+		{ Y_Cllev,0x400 },
+		{ Y_Ctre, 0x000 },
+		{ Y_OFFS, 0x100 },
+		{ Y_statLou, 0x7ff }, /* p84, 10.5678dB boost */
+		{ Y_louSwi, 0x910 },
+		{ 0,0 }
+	};
+
 	static dsp_setup louoff[]= {
 		{ Y_louSwi, 0x90d },
 		{ Y_statLou, 0x7ff },
 		{ 0,0 }
 	};
 
+	dsp_setup *table;
+
+	if(sampling_rate == 38000)
+		table = dynlou_38000;
+	else
+		table = dynlou_44100;
+	       
 	if (level < 0)
 		level = 0;
 	if (level >= LOUDNESS_TABLE_SIZE)
 		level = LOUDNESS_TABLE_SIZE - 1;
 		
 	if (level) {
-		dsp_patchmulti(dynlou_41, Y_Cllev,
+		dsp_patchmulti(table, Y_Cllev,
 			       loudness_table[level].Cllev);
-		dsp_writemulti(dynlou_41);
+		dsp_writemulti(table);
 	}
 	else {
 		dsp_writemulti(louoff);
@@ -869,6 +895,8 @@
 	  { 0xff3, 0x0000 }, /*RDS_CONTROL*/
 	  { 0,0 } };
 
+	mixer_dev *dev = &mixer_global;
+
 	eq_reg_last = radio_sensitivity;
 	dsp_patchmulti(fm_setup, 0xffd, eq_reg_last);
 	dsp_patchmulti(mpeg_setup, 0xffd, eq_reg_last);
@@ -974,9 +1002,8 @@
 
 		/* set for last known de-emphasis */
 		empeg_mixer_set_fm_deemphasis(radio_fm_deemphasis);
-		
-		/* we want the 38kHz tone table */
-		empeg_audio_beep_setup(38000);
+
+		empeg_mixer_set_sampling_rate(dev, 38000);
 		break;    
 		
 	case INPUT_RADIO_AM: /* AM */
@@ -1023,8 +1050,7 @@
 		dsp_write(Y_p13, 0x7ff);
 #endif
 		
-		// we want the 38kHz tone table
-		empeg_audio_beep_setup(38000);
+		empeg_mixer_set_sampling_rate(dev, 38000);
 		break;    
 		
 	case INPUT_PCM: /* MPEG */
@@ -1048,8 +1074,7 @@
 		/* Select mode */
 		dsp_write(X_modpntr,0x0200);
 
-		// we want the 44.1kHz tone table
-		empeg_audio_beep_setup(44100);
+		empeg_mixer_set_sampling_rate(dev, 44100);
 		break;
 		
 	case INPUT_AUX:
@@ -1069,8 +1094,7 @@
 		/* Select mode */
 		dsp_write(X_modpntr,0x200);
 
-		// we want the 44.1kHz tone table
-		empeg_audio_beep_setup(44100);
+		empeg_mixer_set_sampling_rate(dev, 44100);
 		break;    
 	}
 }
@@ -1225,22 +1249,43 @@
 
 static int empeg_mixer_set_fm_deemphasis(int which)
 {
-    unsigned c61, c91;
+    unsigned p6, q6, c61, c91;
     if(which == 50) {
-	c61 = 0x4b8;
-	c91 = 0x347;
+	    p6 = 0x11e;
+	    q6 = 0x228;
+	    c61 = 0x4b8;
+	    c91 = 0x347;
     }
     else if(which == 75) {
-	c61 = 0x59e;
-	c91 = 0x260;
+	    p6 = 0x0e5;
+	    q6 = 0x17b;
+	    c61 = 0x59e;
+	    c91 = 0x260;
     }
     else
-	return -EINVAL;
-    
+	    return -EINVAL;
+
+    dsp_write(Y_p6, p6);
+    dsp_write(Y_q6, q6);
     dsp_write(Y_c61, c61);
     dsp_write(Y_c91, c91);
     radio_fm_deemphasis = which;
     return 0;
+}
+
+static void empeg_mixer_set_sampling_rate(mixer_dev *dev, unsigned rate)
+{
+	if(rate != 38000 && rate != 44100)
+	{
+		panic("Can't set sampling rate %u\n", rate);
+	}
+	sampling_rate = rate;
+
+	/* setup beep table */
+	empeg_audio_beep_setup(sampling_rate);
+
+	/* setup loudness coefficients */
+	empeg_mixer_setloudness(dev, dev->loudness);
 }
 
 static volume_entry volume_table[101] =
Index: empeg/kernel/drivers/char/Config.in
diff -u empeg/kernel/drivers/char/Config.in:1.15 empeg/kernel/drivers/char/Config.in:1.15.4.1
--- empeg/kernel/drivers/char/Config.in:1.15	Sat Jul 15 17:11:43 2000
+++ empeg/kernel/drivers/char/Config.in	Tue Jun  5 19:34:05 2001
@@ -151,7 +151,7 @@
 fi
 
 if [ "$CONFIG_SA1100_EMPEG" = "y" ]; then
-  bool 'empeg-car infrared remote control support' CONFIG_EMPEG_IR
+  bool 'empeg-car remote control/panel buttons support' CONFIG_EMPEG_INPUT
   bool 'empeg-car USB slave support (Natsemi 9602)' CONFIG_EMPEG_USB9602
   bool 'empeg-car USB slave support (Mk2 - Philips PDIUSBD12)' CONFIG_EMPEG_USBD12
   bool 'empeg-car persistent state device support' CONFIG_EMPEG_STATE
Index: empeg/kernel/drivers/char/Makefile
diff -u empeg/kernel/drivers/char/Makefile:1.5 empeg/kernel/drivers/char/Makefile:1.5.8.1
--- empeg/kernel/drivers/char/Makefile:1.5	Sat Apr 22 19:01:07 2000
+++ empeg/kernel/drivers/char/Makefile	Tue Jun  5 19:34:14 2001
@@ -334,22 +334,6 @@
   endif
 endif
 
-ifeq ($(CONFIG_EMPEG_IR),y)
-L_OBJS += empeg_ir.o empeg_ir_fiq.o
-else
-  ifeq ($(CONFIG_EMPEG_IR),m)
-  M_OBJS += empeg_ir.o empeg_ir_fiq.o
-  endif
-endif
-
-ifeq ($(CONFIG_EMPEG_IR),y)
-L_OBJS += empeg_ir.o
-else
-  ifeq ($(CONFIG_EMPEG_IR),m)
-  M_OBJS += empeg_ir.o
-  endif
-endif
-
 ifeq ($(CONFIG_AMIGAMOUSE),y)
 L_OBJS += amigamouse.o
 else
Index: empeg/kernel/drivers/char/empeg_ir.c
diff -u empeg/kernel/drivers/char/empeg_ir.c:1.30.4.4 empeg/kernel/drivers/char/empeg_ir.c:removed
--- empeg/kernel/drivers/char/empeg_ir.c:1.30.4.4	Wed May 30 17:42:29 2001
+++ empeg/kernel/drivers/char/empeg_ir.c	Tue Jun  5 20:24:05 2001
@@ -1,1165 +0,0 @@
-/*
- * empeg-car Infrared 205/70VR15 support
- *
- * (C) 1999-2000 empeg ltd
- *
- * Authors:
- *   Mike Crowe <mac@empeg.com>
- *
- * This driver supports infrared remote control devices on the
- * empegCar. It currently has support only for the Kenwood credit card
- * remote control (and presumably other Kenwood remotes) and a capture
- * mode to decipher the format of other remote controls.
- *
- * The repeat handling code is biased towards the Kenwood remote and
- * other controls may need a different approach.
- *
- * 1999/02/11 MAC Code tidied up and symbols made static.
- *
- * 1999/02/11 MAC Comments added. Now limitted to only one open.
- *
- * 1999/02/12 MAC Magic sequence support added. It doesn't actually
- *                work yet so it's disabled by default.
- *
- * 1999/03/01 MAC Added support for a repeat timeout. If a repeat code
- *                is received a long time after the previous repeat
- *                code/button code then it is ignored. The actual
- *                data for the repeat is now stored inside the remote
- *                specific function so that the repeat is for the
- *                correct control.
- *
- * 1999/06/02 MAC Generation of repeats are no longer cancelled in
- *                Kenwood handler if dodgy data is received. So we
- *                are relying on the timeout to stop the wrong code
- *                being repeated.
- *
- * 1999/07/03 MAC Various fixes in the IR handlers to reduce the
- *                chances of missed messages. Widened the
- *                acceptable values for the start sequence on
- *                button presses.
- *
- * 1999/07/04 MAC Added bounds checking on kenwood handler so that
- *                repeat codes are now much less likely to come
- *                from the sky.
- *
- * 2000/04/04 MAC Changed to use timing queue, FIQ option.
- *
- * */
-
-/* Since we now use jiffies for the repeat handling we're assuming
-   that the device won't be up for 497 days :-) */
-
-#include <linux/sched.h>
-#include <linux/config.h>
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <asm/ptrace.h>
-#include <asm/fiq.h>
-#include <linux/interrupt.h>
-#include <linux/delay.h>
-#include <linux/time.h>
-#include <linux/types.h>
-#include <linux/sched.h>
-#include <linux/vmalloc.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <asm/system.h>
-#include <asm/arch/hardware.h>
-#include <asm/irq.h>
-#include <asm/io.h>
-#include <asm/arch/empeg.h>
-#include <asm/uaccess.h>
-#include <linux/proc_fs.h>
-#include <linux/poll.h>
-#include "empeg_ir.h"
-
-#define MS_TO_JIFFIES(MS) ((MS)/(1000/HZ))
-#define JIFFIES_TO_MS(J) (((J)*1000)/HZ)
-#define US_TO_TICKS(US) ((368 * (US))/100)
-#define TICKS_TO_US(T) ((100 * (T))/368)
-
-#define IR_DEBUG 0
-
-#define USE_TIMING_QUEUE 1
-
-/* The CS4231 in the Mk2 uses FIQs */
-#ifndef CONFIG_EMPEG_CS4231
-#define USE_TIMING_QUEUE_FIQS 1
-#else
-#define USE_TIMING_QUEUE_FIQS 0
-#endif
-
-#define IR_TYPE_DEFAULT IR_TYPE_KENWOOD
-
-/* Delay before repeating default */
-#define IR_RPTDELAY_DEFAULT MS_TO_JIFFIES(200) /* .2 seconds */
-
-/* Delay between repeats default */
-#define IR_RPTINT_DEFAULT MS_TO_JIFFIES(100) /*.1 seconds */
-
-/* Timeout for getting a repeat code and still repeating */
-#define IR_RPTTMOUT_DEFAULT MS_TO_JIFFIES(500) /* 0.5 seconds */
-
-/* Freeing up the IRQ breaks on Henry due to the IRQ hack. This means
- * that we can't request and free on open and close. Ultimately we
- * should probably do so but it needs testing on Sonja first.
- */   
-#define REQUEST_IRQ_ON_OPEN 0
-
-/* Each button press when in one of the control specific modes
- * generates a 4 byte code. When in capture mode each transition
- * received generates a 4 byte code.
- *
- * Therefore, this buffer has room for 256 keypresses or
- * transitions. This should be enough since capturing is only meant as
- * a diagnostic and development feature and therefore should not be
- * attempted if you can't guarantee reading it often enough.
- */
-#define IR_BUFFER_SIZE 256
-
-/* The type used for IR codes returned to the user process. */
-typedef __u32 ir_code;
-
-/* We only support one device */
-struct ir_dev
-{
-#if USE_TIMING_QUEUE
-	volatile int timings_used;	/* Do not move */
-        volatile int timings_free;	/* Do not move */
-        volatile int timings_head;      /* Do not move */
-	volatile int timings_tail;      /* Do not move */
-	volatile unsigned long *timings_buffer;     /* Do not move */
-#endif
-	
-	ir_code *buf_start;
-	ir_code *buf_end;
-	ir_code *buf_wp;
-	ir_code *buf_rp;
-
-	struct wait_queue *wq;          /* Blocking queue */
-	struct tq_struct timer;         /* Timer queue */
-	
-	int ir_type;
-	unsigned long repeat_delay_jiffies;
-	unsigned long repeat_interval_jiffies;
-	unsigned long repeat_timeout_jiffies;
-
-	/* Repeat support */
-	unsigned long last_repeat_jiffies;
-	unsigned long last_new_data_jiffies;
-
-	/* Statistics */
-	unsigned long count_valid;
-	unsigned long count_repeat;
-	unsigned long count_badrepeat;
-	unsigned long count_spurious;
-	unsigned long count_malformed;
-	unsigned long count_missed;
-#if USE_TIMING_QUEUE
-	unsigned long timings_hwm;
-#endif
-};
-
-static struct ir_dev ir_devices[1];
-
-/* Used to disallow multiple opens. */
-static int users = 0;
-#if USE_TIMING_QUEUE_FIQS
-static struct fiq_handler fh = { NULL, "empeg_ir", NULL, NULL };
-#endif
-
-/* Bottom bit must be clear for switch statement */
-#define IR_STATE_IDLE 0x00
-/*#define IR_STATE_RECOVER 0x02*/
-#define IR_STATE_START1 0x04
-#define IR_STATE_START2 0x06
-#define IR_STATE_START3 0x08
-#define IR_STATE_DATA1  0x0a
-#define IR_STATE_DATA2 0x0c
-
-static void ir_append_data(struct ir_dev *dev, ir_code data)
-{
-	/* Now this is called from the bottom half we need to make
-	   sure that noone else is fiddling with stuff while we
-	   do it. */
-	ir_code *new_wp;
-	unsigned long flags;
-	save_flags_cli(flags);
-	
-	new_wp = dev->buf_wp + 1;
-	if (new_wp == dev->buf_end)
-		new_wp = dev->buf_start;
-	
-	if (new_wp != dev->buf_rp)
-	{
-		*dev->buf_wp = data;
-		dev->buf_wp = new_wp;
-		/* Now we've written, wake up anyone who's reading */
-		wake_up_interruptible(&dev->wq);
-	}
-#if IR_DEBUG
-	else
-		printk("Infra-red buffer is full.\n");
-#endif
-	restore_flags(flags);
-}
-
-static void ir_append_data_repeatable(struct ir_dev *dev,
-				      ir_code data)
-{
-	unsigned long now = jiffies;
-	dev->last_new_data_jiffies = now;
-	dev->last_repeat_jiffies = 0; /* Make it look like a long time ago */
-	
-	ir_append_data(dev, data);
-#ifdef SUPPORT_MAGIC
-	ir_handle_magic(data);
-#endif
-}
-
-static inline int ir_code_repeatable(ir_code data)
-{
-#if 1
-	/* Is the code a repeatable one? */
-	data &= 0x7fffffff;
-	
-	if ((data < 0x2000) || (data > 0x2017))
-		return TRUE;
-	else if (data == 0x2007)
-		return TRUE;
-	else if (data < 0x2010)
-		return FALSE;
-	else if (data == 0x2012)
-		return FALSE;
-	else if ((data >= 0x2014) && data <= 0x2016)
-		return FALSE;
-	else
-		return TRUE;
-#else
-	return TRUE;
-#endif
-}
-
-/* Append a repetition of the last data. This is only done if the
- * repetition is long enough after the initial button press and if the
- * last repetition was long enough ago.
- *
- * Also, the repeat must have been within the repeat timeout since the
- * last repeat.
- */
-   
-static void ir_append_data_repeat(struct ir_dev *dev, ir_code data)
-{
-	unsigned long now_jiffies = jiffies;
-
-	unsigned long since_new_jiffies;
-	unsigned long since_repeat_jiffies;
-
-	if (!ir_code_repeatable(data))
-		return;
-	
-	if (dev->last_repeat_jiffies)
-		since_repeat_jiffies = now_jiffies - dev->last_repeat_jiffies;
-	else
-		since_repeat_jiffies = 100000; /* A long time ago */
-
-	since_new_jiffies = now_jiffies - dev->last_new_data_jiffies;
-	
-	if ((since_repeat_jiffies < dev->repeat_timeout_jiffies
-	     || since_new_jiffies < dev->repeat_timeout_jiffies)
-	    && since_repeat_jiffies > dev->repeat_interval_jiffies) {
-		if (since_new_jiffies > dev->repeat_delay_jiffies) {
-			dev->last_repeat_jiffies = now_jiffies;
-			ir_append_data(dev, data);
-#if IR_DEBUG
-			printk("Doing repeat. timings are:\n");
-			printk("  Time of last new %ld.\n", dev->last_new_data_jiffies);
-			printk("  Time of last repeat %ld.\n", dev->last_repeat_jiffies);
-			printk("  Since new %ld.\n", since_new_jiffies);
-			printk("  Since repeat %ld.\n", since_repeat_jiffies);
-#endif
-		}
-	}
-#if IR_DEBUG
-	else
-		printk(".");
-#endif
-}
-
-struct recent_entry {
-	int state;
-	int interval;
-};
-#define ENTRY_COUNT 32
-
-#if 0
-static void dump_entries(struct recent_entry *e, int start, int end)
-{
-	int i = start;
-	printk("State level interval\n");
-	while (i != end)
-	{
-		printk("%5x %5d %8d\n", e[i].state & ~1, e[i].state & 1, e[i].interval);
-		++i;
-		if (i >= ENTRY_COUNT)
-			i = 0;
-	}
-}
-#endif
-
-static inline void ir_buttons_interrupt(struct ir_dev *dev, int level,
-					unsigned long span)
-{
-	static int state = IR_STATE_IDLE;
-	static int unit_time = 1; /* not zero in case we accidentally use it */
-	static unsigned short bit_position = 0;
-	static __u8 data = 0;
-	
-	static int entry_rp = 0, entry_wp = 0;
-	static struct recent_entry entries[ENTRY_COUNT];
-
-	/* Check to see if the last interrupt was so long ago that
-	 * we should restart the state machine.
-	 */
-
-	if (span >= US_TO_TICKS(40000)) {
-		bit_position = 0;
-		state = IR_STATE_IDLE;
-	}
-
-	entries[entry_wp].state = state | (level ? 1 : 0);
-	entries[entry_wp].interval = span;
-
-	entry_wp++;
-	if (entry_wp >= ENTRY_COUNT)
-		entry_wp = 0;
-
-	if (entry_wp == entry_rp) {
-		entry_rp++;
-		if (entry_rp >= ENTRY_COUNT)
-			entry_rp = 0;
-	}
-
-#if 0
-#define ON_RECOVER dump_entries(entries, entry_rp, entry_wp)
-#define ON_VALID entry_rp = entry_wp = 0
-#else
-#define ON_RECOVER
-#define ON_VALID
-#endif
-	
-	//old_state = state | (level ? 1 : 0);
-	/* Now we can actually do something */
-
-#ifdef DEBUG_BUTTONS
-	{
-		int result = (1<<31);
-		if (level)
-		    result |= (1<<30);
-		result |= ((state & 0xF) << 26);
-		result |= (span & 0x3ffff);
-		ir_append_data(dev, result);
-	}
-#endif
-
-			
-retry:
-	switch(state | (level ? 1 : 0))
-	{
-	case IR_STATE_IDLE | 1:
-		/* Going high in idle doesn't mean anything */
-		break;
-		
-	case IR_STATE_IDLE | 0:
-		/* Going low in idle is the start of a start sequence */
-		state = IR_STATE_START1;
-		break;
-
-	case IR_STATE_START1 | 1:
-		/* Going high, that should be after 4T */
-		unit_time = span / 4;
-		if (unit_time > US_TO_TICKS(50) && unit_time < US_TO_TICKS(550))
-		//if (unit_time > US_TO_TICKS(150) && unit_time < US_TO_TICKS(350)) << original
-		//if (unit_time > 225 && unit_time < 275)
-			state = IR_STATE_START2;
-		else
-			state = IR_STATE_IDLE; /* There's no point in recovering immediately
-						  since this can't be the start of a new
-						  sequence. */
-		break;
-
-	case IR_STATE_START1 | 0:
-		/* Shouldn't ever go low in START1, recover */
-		/*state = IR_STATE_IDLE;*/
-		/* We jump straight back to START1 since this might still */
-		/* be the start of a sequence */
-		ON_RECOVER;
-		state = IR_STATE_IDLE;
-		++dev->count_missed;
-		goto retry;
-
-	case IR_STATE_START2 | 1:
-		/* Shouldn't ever go high in START2, recover */
-		state = IR_STATE_IDLE;
-		++dev->count_missed;
-		break;
-
-	case IR_STATE_START2 | 0:
-		/* If this forms the end of the start sequence then we
-		 * should have been high for around 8T time.
-		 */
-		if (span > 7 * unit_time && span < 9 * unit_time) {
-			/* It's the start of one of the unit button codes. */
-			data = 0;
-			bit_position = 0;
-			state = IR_STATE_DATA1;
-		} else {
-			/* We're out of bounds. Give up, but this might be the
-			   start of a valid start sequence. */
-			ON_RECOVER;
-			state = IR_STATE_IDLE;
-			goto retry; /* try again */
-		}
-		break;
-
-	case IR_STATE_DATA1 | 0:
-		/* This should never happen */
-		state = IR_STATE_IDLE;
-		++dev->count_missed;
-		break;
-		
-	case IR_STATE_DATA1 | 1:
-		data <<= 1;
-		if (span <= 3 * unit_time) {
-			/* It's a zero bit */
-			bit_position++;
-			state = IR_STATE_DATA2;
-		} else if (span > 3 * unit_time && span < 5 * unit_time) {
-			/* It's a one bit */
-			data |= 1;
-			bit_position++;
-			state = IR_STATE_DATA2;
-		} else {
-			/* This can't be the start of a start sequence since
-			   we're going high, so just give up */
-			ON_RECOVER;
-			state = IR_STATE_START1;
-			goto retry;
-		}
-
-		/* Now process the bit */
-		if (bit_position > 7) {
-			/* Does it pass the validity check */
-			if (((data>>4)^(data&0xf))==0xf)
-			{
-				/* We don't do anything with repeats so go
-				   straight to the real code */
-				ir_append_data(dev, data >> 4);
-				ON_VALID;
-			        state = IR_STATE_IDLE;
-			}
-			else
-			{
-				/* Report CRC failures */
-				//ir_append_data(dev, tv_now, 0xFF00 | data);
-				ON_RECOVER;
-				state = IR_STATE_START1;
-				goto retry;
-			}
-		}
-		break;
-
-	case IR_STATE_DATA2 | 0:
-		if (span < 2 * unit_time) {
-			/* It's a correct inter-bit gap */
-			state = IR_STATE_DATA1;
-		} else {
-			ON_RECOVER;
-			/* It's out of bounds. It might be the start
-			   of another valid sequence so try again. */
-			state = IR_STATE_IDLE;
-			goto retry;
-		}
-		break;
-
-	case IR_STATE_DATA2 | 1:
-		/* Should never get here */
-		ON_RECOVER;
-		state = IR_STATE_IDLE;
-		++dev->count_missed;
-		break;
-		
-	default:
-#if IR_DEBUG
-		printk("Buttons handler got into impossible state. Recovering.\n");
-		state = IR_STATE_IDLE;
-#endif
-		break;
-	}
-}
-
-static inline void ir_kenwood_interrupt(struct ir_dev *dev, int level,
-					unsigned long span)
-{
-	static int state = IR_STATE_IDLE;
-	static int unit_time = 1; /* not zero in case we accidentally use it */
-	static unsigned short bit_position = 0;
-	static __u32 data = 0;
-	static ir_code decoded_data = 0;
-	static int repeat_valid = FALSE;
-	//static struct timeval tv_last_valid;
-	
-	/* Check to see if the last interrupt was so long ago that
-	 * we should restart the state machine.
-	 */
-
-	if (span >= US_TO_TICKS(40000)) {
-		bit_position = 0;
-		state = IR_STATE_IDLE;
-	}
-
-	/* Now we can actually do something */
-
- retry:
-	switch(state | (level ? 1 : 0))
-	{
-	case IR_STATE_IDLE | 1:
-		/* Going high in idle doesn't mean anything */
-		break;
-		
-	case IR_STATE_IDLE | 0:
-		/* Going low in idle is the start of a start sequence */
-		state = IR_STATE_START1;
-		break;
-
-	case IR_STATE_START1 | 1:
-		/* Going high, that should be after 8T */
-		unit_time = span / 8;
-		/* But some bounds on it so we don't start receiving magic
-		   codes from the sky */
-		if (unit_time > US_TO_TICKS(500) && unit_time < US_TO_TICKS(1500))
-			state = IR_STATE_START2;
-		else
-			state = IR_STATE_IDLE;
-		break;
-
-	case IR_STATE_START1 | 0:
-		/* Shouldn't ever go low in START1, recover */
-		state = IR_STATE_IDLE;
-		++dev->count_missed;
-		break;
-
-	case IR_STATE_START2 | 1:
-		/* Shouldn't ever go low in START2, recover */
-		state = IR_STATE_IDLE;
-		++dev->count_missed;
-		break;
-
-	case IR_STATE_START2 | 0:
-		/* If this forms the end of the start sequence then we
-		 * should have been high for around 4T time.
-		 */
-		if ((span >= 3 * unit_time) &&
-			(span < 5 * unit_time)) {
-			state = IR_STATE_START3;
-			/*repeat_valid = FALSE;*/
-		} else if (span > unit_time && span < 3 * unit_time) {
-			/* This means that the last code is repeated - just
-			   send out the last code again with the top bit set to indicate
-			   a repeat. */
-			if (repeat_valid)
-			{
-				ir_append_data_repeat(dev, (1<<31) | decoded_data);
-				++dev->count_repeat;
-			}
-			else
-			{
-				++dev->count_badrepeat;
-			}
-			state = IR_STATE_IDLE;
-		} else {
-			/* We're out of bounds. Recover */
-			state = IR_STATE_IDLE;
-			/* But it could be the start of a new sequence
-                           so try again */
-			++dev->count_spurious;
-			goto retry;
-		}
-		break;
-
-	case IR_STATE_START3 | 0:
-		/* Shouldn't happen */
-		state = IR_STATE_IDLE;
-		++dev->count_missed;
-		break;
-
-	case IR_STATE_START3 | 1:
-		/* Data will follow this */
-		if (span < unit_time) {
-			bit_position = 0;
-			data = 0;
-			state = IR_STATE_DATA1;
-		} else {
-			/* We're out of bounds. It might be the start
-			   of a new sequence so try it again. */
-			state = IR_STATE_IDLE;
-			++dev->count_spurious;
-			goto retry;
-		}
-		break;
-		
-	case IR_STATE_DATA1 | 1:
-		/* Shouldn't get this. Recover */
-		state = IR_STATE_IDLE;
-		++dev->count_missed;
-		break;
-
-	case IR_STATE_DATA1 | 0:
-		/* The actual data bit is encoded in the length of this.
-		 */
-		if (span < unit_time) {
-			/* It's a zero */
-			bit_position++;
-			state = IR_STATE_DATA2;
-		} else if (span < 2 * unit_time) {
-			/* It's a one */
-			data |= (1<<bit_position);
-			bit_position++;
-			state = IR_STATE_DATA2;
-		} else {
-			/* Not valid. It might be the start of a new
-                           sequence though. */
-			state = IR_STATE_IDLE;
-			++dev->count_spurious;
-			goto retry;
-		}
-		break;
-
-	case IR_STATE_DATA2 | 1:
-		/* This marks the end of the post-data space
-		 * It is a consistent length
-		 */
-		if (span < unit_time) {
-			/* It's a valid space */
-			if (bit_position >= 32) {
-				__u16 data1, data2;
-				
-				data1 = ((data >> 16) & 0xFF00) | ((data >> 8) & 0xFF);
-				data2 = ((data >> 8) & 0xFF00) | ((data & 0xFF));
-				
-				/* We've finished getting data, confirm
-				   it passes the validity check */
-				if (data1 == ((__u16)(~data2))) {
-					decoded_data = be16_to_cpu(data2);
-					ir_append_data_repeatable(dev, decoded_data);
-					repeat_valid = TRUE;
-					++dev->count_valid;
-				} else {
-#if IR_DEBUG
-					printk("Got an invalid sequence %08lx (%04lx, %04lx)\n",
-					       (unsigned long)data, (unsigned long)data1,
-					       (unsigned long)data2);
-					printk("(%04lx %04lx, %04lx %04lx)\n",
-					       (unsigned long)data1, (unsigned long)~data1,
-					       (unsigned long)data2, (unsigned long)~data2);
-#endif
-					++dev->count_malformed;
-				}
-				state = IR_STATE_IDLE;
-			}
-			else
-				state = IR_STATE_DATA1;
-		} else {
-			/* It's too long to be valid. Give up and try again. */
-			state = IR_STATE_IDLE;
-			++dev->count_spurious;
-			goto retry;
-		}
-		break;
-
-	case IR_STATE_DATA2 | 0:
-		/* Shouldn't get this. Recover */
-		state = IR_STATE_IDLE;
-		++dev->count_missed;
-		break;
-
-	default:
-		state = IR_STATE_IDLE;
-		break;
-	}
-}
-
-static inline void ir_capture_interrupt(struct ir_dev *dev, int level,
-					unsigned long span)
-{
-	unsigned long us = TICKS_TO_US(span);
-	/* Just capture it straight to the output buffer */
-	if (level)
-		ir_append_data(dev, us | (1<<30) | (1<<31));
-	else
-		ir_append_data(dev, (us & ~(1<<30)) | (1<<31));
-}
-
-static inline void ir_transition(struct ir_dev *dev, int level, unsigned long span)
-{
-	/* Call buttons interrupt handler */
-	if (dev->ir_type != IR_TYPE_CAPTURE)
-		ir_buttons_interrupt(dev, level, span);
-	
-	/* Call remote specific interrupt handler */
-
-	switch (dev->ir_type)
-	{
-	case IR_TYPE_CAPTURE:
-		ir_capture_interrupt(dev, level, span);
-		break;
-	case IR_TYPE_KENWOOD:
-		ir_kenwood_interrupt(dev, level, span);
-		break;
-	default:
-		/* Hmm, I wonder what it was supposed to be */
-		dev->ir_type = IR_TYPE_CAPTURE;
-		break;
-	}
-}
-
-#if USE_TIMING_QUEUE
-
-#if USE_TIMING_QUEUE_FIQS
-static void ir_interrupt(int irq, void *dev_id, struct pt_regs *regs)
-{
-	/* Not needed if we're running on FIQs */
-	printk("BAD!\n");
-}
-#else
-static void ir_interrupt(int irq, void *dev_id, struct pt_regs *regs)
-{
-	int level;
-	unsigned long now; 
-	unsigned long entry;
-	unsigned long flags;
-	struct ir_dev *dev = ir_devices;
-	
-	save_flags_cli(flags);
-
-	level = (GPLR & EMPEG_IRINPUT)?1:0;
-	now = OSCR;
-
-	entry = (now & ~1) | level;
-	
-	if (dev->timings_free) {
-		--dev->timings_free;
-		dev->timings_buffer[dev->timings_head] = entry;
-		if (++dev->timings_head >= TIMINGS_BUFFER_SIZE)
-			dev->timings_head = 0;
-		++dev->timings_used;
-	}
-
-	restore_flags(flags);
-	
-}
-#endif
-
-static void ir_check_buffer(void *dev_id)
-{
-	/* This stores the time of the last actual interrupt, not the time this
-	 * routine was called
-	 */
-	static unsigned long last_interrupt;
-	
-	struct ir_dev *dev = dev_id;
-
-	while (dev->timings_used) {
-		unsigned long flags;
-		unsigned long entry;
-		unsigned long span;
-		unsigned long interrupt_time;
-		int level;
-
-		/* Keep track of the hwm */
-		{
-			int used = dev->timings_used;
-			if (used > dev->timings_hwm)
-				dev->timings_hwm = used;
-		}
-
-		/* Safe to do even if an interrupt happens during it. */
-		entry = dev->timings_buffer[dev->timings_tail];
-		
-		/* Disable interrupts while we tidy up the pointers */
-		save_flags_clif(flags);
-		++dev->timings_free;
-		--dev->timings_used;
-		restore_flags(flags);
-
-		if (++dev->timings_tail >= TIMINGS_BUFFER_SIZE)
-			dev->timings_tail = 0;
-
-		/* Now, we have our entry, go and deal with it. */
-		interrupt_time = entry & ~1;
-		level = entry & 1;
-
-		span = interrupt_time - last_interrupt;
-		last_interrupt = interrupt_time;
-
-		//printk("Transition(%d): %d %5ld\n", dev->timings_tail, level, span);
-		ir_transition(dev, level, span);
-	}
-
-	/* Requeue me */
-	queue_task(&dev->timer, &tq_timer);
-}
-
-#else
-
-static inline void ir_interrupt(int irq, void *dev_id, struct pt_regs *regs)
-{
-	int level;
-	static unsigned long last_interrupt;
-	unsigned long now;
-	unsigned long span;
-	struct ir_dev *dev = dev_id;
-
-	level = (GPLR & EMPEG_IRINPUT) > 0;
-
-	now = OSCR;
-	span = now - last_interrupt;
-	last_interrupt = now;
-
-	ir_transition(dev, level, span);
-}
-#endif
-
-static int ir_open(struct inode *inode, struct file *filp)
-{
-	struct ir_dev *dev = ir_devices;
-
-	if (users)
-		return -EBUSY;
-
-	users++;
-	MOD_INC_USE_COUNT;
-	
-	/* This shouldn't be necessary, but there's something (IDE, audio?)
-	 * that's setting rather than or'ing these and breaking it after
-	 * initialisation.
-	 */
-	GRER|=EMPEG_IRINPUT;
-	GFER|=EMPEG_IRINPUT;
-	GEDR=EMPEG_IRINPUT;
-
-	dev->ir_type = IR_TYPE_DEFAULT;
-	dev->repeat_delay_jiffies = IR_RPTDELAY_DEFAULT;
-	dev->repeat_interval_jiffies = IR_RPTINT_DEFAULT;
-	dev->repeat_timeout_jiffies = IR_RPTTMOUT_DEFAULT;
-	filp->private_data = dev;
-	
-	return 0;
-}
-
-static int ir_release(struct inode *inode, struct file *filp)
-{
-	--users;
-	MOD_DEC_USE_COUNT;
-	return 0;
-}
-
-/*
- * Read some bytes from the IR buffer. The count should be a multiple
- * of four bytes - if it isn't then it is rounded down. If the
- * rounding means that it is zero then EINVAL will result.
- */
-static ssize_t ir_read(struct file *filp, char *dest, size_t count,
-		       loff_t *ppos)
-{
-	struct ir_dev *dev = filp->private_data;
-	int n;
-
-	struct wait_queue wait = { current, NULL };
-
-	/* If we're nonblocking then return immediately if there's no data */
-	if ((filp->f_flags & O_NONBLOCK) && (dev->buf_rp == dev->buf_wp))
-		return -EAGAIN;
-
-	/* Wait for some data to turn up - this method avoids race
-           conditions see p209 of Linux device drivers. */
-	add_wait_queue(&dev->wq, &wait);
-	current->state = TASK_INTERRUPTIBLE;	
-	while ((dev->buf_rp == dev->buf_wp) && !signal_pending(current))
-		schedule();
-	current->state = TASK_RUNNING;
-	remove_wait_queue(&dev->wq, &wait);
-
-	if (signal_pending(current))
-	    return -ERESTARTSYS;
-
-	/* Only allow reads of a multiple of four bytes. Anything else
-           is meaningless and may cause us to get out of sync */
-	count >>= 2;
-
-	/* Not sure if this is a valid thing to be doing */
-	if (!count)
-		return -EINVAL;
-	
-	n = 0;
-	while (count--) {
-		ir_code data;
-
-		if (dev->buf_rp == dev->buf_wp)
-			return n;
-
-		/* Need to put one byte at a time since there are no
-		   alignment requirements on parameters to read. */
-		data = *dev->buf_rp;
-		__put_user(data & 0xFF, dest++);
-		__put_user((data >> 8) & 0xFF, dest++);
-		__put_user((data >> 16) & 0xFF, dest++);
-		__put_user((data >> 24) & 0xFF, dest++);
-		dev->buf_rp++;
-		if (dev->buf_rp == dev->buf_end)
-			dev->buf_rp = dev->buf_start;
-
-		n += 4;
-	}
-
-	return n;
-}
-
-unsigned int ir_poll(struct file *filp, poll_table *wait)
-{
-	struct ir_dev *dev = filp->private_data;
-
-	/* Add ourselves to the wait queue */
-	poll_wait(filp, &dev->wq, wait);
-
-	/* Check if we've got data to read */
-	if (dev->buf_rp != dev->buf_wp)
-		return POLLIN | POLLRDNORM;
-	else
-		return 0;
-}
-
-int ir_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,
-	     unsigned long arg)
-{
-	struct ir_dev *dev = filp->private_data;
-
-	switch(cmd)
-	{
-	case EMPEG_IR_WRITE_TYPE:
-		if (arg >= IR_TYPE_COUNT)
-			return -EINVAL;
-		dev->ir_type = arg;
-		return 0;
-		
-	case EMPEG_IR_READ_TYPE:
-		return put_user(dev->ir_type, (int *)arg);
-		
-	case EMPEG_IR_WRITE_RPTDELAY:
-		dev->repeat_delay_jiffies = MS_TO_JIFFIES(arg);
-		return 0;
-
-	case EMPEG_IR_READ_RPTDELAY:
-		return put_user(JIFFIES_TO_MS(dev->repeat_delay_jiffies), (unsigned long *)arg);
-		
-	case EMPEG_IR_WRITE_RPTINT:
-		dev->repeat_interval_jiffies = MS_TO_JIFFIES(arg);
-		return 0;
-
-	case EMPEG_IR_READ_RPTINT:
-		return put_user(JIFFIES_TO_MS(dev->repeat_interval_jiffies), (unsigned long *)arg);
-		
-	case EMPEG_IR_WRITE_RPTTMOUT:
-		dev->repeat_timeout_jiffies = MS_TO_JIFFIES(arg);
-		return 0;
-
-	case EMPEG_IR_READ_RPTTMOUT:
-		return put_user(JIFFIES_TO_MS(dev->repeat_timeout_jiffies), (unsigned long *)arg);
-		
-	default:
-		return -EINVAL;
-	}
-}
-
-static struct file_operations ir_fops = {
-	NULL, /* ir_lseek */
-	ir_read,
-	NULL, /* ir_write */
-	NULL, /* ir_readdir */
-	ir_poll, /* ir_poll */
-	ir_ioctl,
-	NULL, /* ir_mmap */
-	ir_open,
-	NULL, /* ir_flush */
-	ir_release,
-};
-
-int ir_read_procmem(char *buf, char **start, off_t offset, int len, int unused)
-{
-	struct ir_dev *dev = ir_devices;
-	len = 0;
-
-	len += sprintf(buf+len, "Valid sequences:      %ld\n", dev->count_valid);
-	len += sprintf(buf+len, "Repeated sequences:   %ld\n", dev->count_repeat);
-	len += sprintf(buf+len, "Unfulfilled repeats:  %ld\n", dev->count_badrepeat);
-	len += sprintf(buf+len, "Malformed sequences:  %ld\n", dev->count_malformed);
-	len += sprintf(buf+len, "Spurious transitions: %ld\n", dev->count_spurious);
-	len += sprintf(buf+len, "Missed interrupts:    %ld\n", dev->count_missed);
-	len += sprintf(buf+len, "Timings buffer hwm:   %ld\n", dev->timings_hwm);
-
-	return len;
-}
-
-struct proc_dir_entry ir_proc_entry = {
-	0,			/* inode (dynamic) */
-	8, "empeg_ir",  	/* length and name */
-	S_IFREG | S_IRUGO, 	/* mode */
-	1, 0, 0, 		/* links, owner, group */
-	0, 			/* size */
-	NULL, 			/* use default operations */
-	&ir_read_procmem, 	/* function used to read data */
-};
-
-void __init empeg_ir_init(void)
-{
-	struct ir_dev *dev = ir_devices;
-	int result;
-#if USE_TIMING_QUEUE_FIQS
-	struct pt_regs regs;
-	extern char empeg_ir_fiq, empeg_ir_fiqend;
-#endif
-
-	result = register_chrdev(EMPEG_IR_MAJOR, "empeg_ir", &ir_fops);
-	if (result < 0) {
-		printk(KERN_WARNING "empeg IR: Major number %d unavailable.\n",
-			   EMPEG_IR_MAJOR);
-		return;
-	}
-
-	/* First grab the memory buffer */
-	dev->buf_start = vmalloc(IR_BUFFER_SIZE * sizeof(ir_code));
-	if (!dev->buf_start) {
-		printk(KERN_WARNING "Could not allocate memory buffer for empeg IR.\n");
-		return;
-	}
-	
-	dev->buf_end = dev->buf_start + IR_BUFFER_SIZE;
-	dev->buf_rp = dev->buf_wp = dev->buf_start;
-	dev->wq = NULL;
-	dev->ir_type = IR_TYPE_DEFAULT;
-
-	dev->count_valid = 0;
-	dev->count_repeat = 0;
-	dev->count_badrepeat = 0;
-	dev->count_spurious = 0;
-	dev->count_malformed = 0;
-	dev->count_missed = 0;
-
-#if USE_TIMING_QUEUE
-	dev->timings_hwm = 0;
-
-	dev->timings_free = TIMINGS_BUFFER_SIZE;
-	dev->timings_used = 0;
-	dev->timings_head = 0;
-	dev->timings_tail = 0;
-	dev->timings_buffer = vmalloc(TIMINGS_BUFFER_SIZE * sizeof(unsigned long));
-	
-	/* Set up timer routine to check the buffer */
-	dev->timer.sync = 0;
-	dev->timer.routine = ir_check_buffer;
-	dev->timer.data = dev;
-	queue_task(&dev->timer, &tq_timer);
-
-#if USE_TIMING_QUEUE_FIQS
-	/* Install FIQ handler */
-	regs.ARM_r9=(int)dev;
-	regs.ARM_r10=(int)&OSCR; 	
-	regs.ARM_fp=0; 		/* r11 */
-	regs.ARM_ip=0;	 	/* r12 */
-	regs.ARM_sp=(int)&GPLR;
-	set_fiq_regs(&regs);
-
-	set_fiq_handler(&empeg_ir_fiq,(&empeg_ir_fiqend-&empeg_ir_fiq));
-	claim_fiq(&fh);
-#endif
-#endif
-
-       	/* No interrupts yet */
-	GRER&=~EMPEG_IRINPUT;
-	GFER&=~EMPEG_IRINPUT;
-	GEDR=EMPEG_IRINPUT;
-
-	/* IRQs shouldn't be reenabled, the routine is very fast */
-	result = request_irq(EMPEG_IRQ_IR, ir_interrupt, SA_INTERRUPT,
-			     "empeg_ir", dev);
-	
-	if (result != 0) {
-		printk(KERN_ERR "Can't get empeg IR IRQ %d.\n", EMPEG_IRQ_IR);
-		return;
-	}
-
-#if USE_TIMING_QUEUE_FIQS
-	/* It's a FIQ not an IRQ */
-	ICLR|=EMPEG_IRINPUT;
-
-	/* Enable FIQs: there should be a neater way of doing
-	   this... */
-	{
-		unsigned long flags;
-		save_flags(flags);
-		flags&=~F_BIT;
-		restore_flags(flags);
-	}
-#endif
-  
-       	/* We want interrupts on rising and falling */
-	GRER|=EMPEG_IRINPUT;
-	GFER|=EMPEG_IRINPUT;
-	
-#ifdef CONFIG_PROC_FS
-	proc_register(&proc_root, &ir_proc_entry);
-#endif
-
-#if USE_TIMING_QUEUE_FIQS
-	printk("empeg infra-red support initialised (Using FIQs).\n");
-#else
-	printk("empeg infra-red support initialised.\n");
-#endif
-}
-
-static inline void empeg_ir_cleanup(void)
-{
-	int result;
-	struct ir_dev *dev = ir_devices;
-
-	free_irq(EMPEG_IRQ_IR, dev);
-
-	/* No longer require interrupts */
-	GRER&=~(EMPEG_IRINPUT);
-	GFER&=~(EMPEG_IRINPUT);
-
-	result = unregister_chrdev(EMPEG_IR_MAJOR, "empeg_ir");
-	if (result < 0)
-		printk(KERN_WARNING "empeg IR: Unable to unregister device.\n");
-	printk("empeg IR cleanup complete.\n");
-}
-
-#ifdef MODULE
-MODULE_AUTHOR("Mike Crowe");
-MODULE_DESCRIPTION("A driver for the empeg Infrared remote control");
-MODULE_SUPPORTED_DEVICE("ir");
-
-EXPORT_NO_SYMBOLS
-
-int init_module(void)
-{
-	return empeg_ir_init();
-}
-
-void cleanup_module(void)
-{
-	empeg_ir_cleanup();
-}
-
-#endif /* MODULE */
Index: empeg/kernel/drivers/char/empeg_ir.h
diff -u empeg/kernel/drivers/char/empeg_ir.h:1.3 empeg/kernel/drivers/char/empeg_ir.h:removed
--- empeg/kernel/drivers/char/empeg_ir.h:1.3	Fri May  5 12:57:43 2000
+++ empeg/kernel/drivers/char/empeg_ir.h	Tue Jun  5 20:24:05 2001
@@ -1,12 +0,0 @@
-/*
- * Empeg Infrared 205/70VR15 support
- *
- * Mike Crowe, <mac@empeg.com>
- */
-
-#ifndef EMPEG_IR_H
-#define EMPEG_IR_H 1
-
-#define TIMINGS_BUFFER_SIZE 64
-
-#endif
Index: empeg/kernel/drivers/char/empeg_ir_fiq.S
diff -u empeg/kernel/drivers/char/empeg_ir_fiq.S:1.6 empeg/kernel/drivers/char/empeg_ir_fiq.S:removed
--- empeg/kernel/drivers/char/empeg_ir_fiq.S:1.6	Fri May  5 13:00:39 2000
+++ empeg/kernel/drivers/char/empeg_ir_fiq.S	Tue Jun  5 20:24:05 2001
@@ -1,87 +0,0 @@
-/*
- * empeg IR driver FIQ section
- *
- * (C)2000 empeg ltd, http://www.empeg.com
- *
- * Authors:
- *   Mike Crowe, <mac@empeg.com>
- *   Hugo Fiennes, <hugo@empeg.com>
- *
- */
-
-#define __ASSEMBLY__
-#include <linux/linkage.h>
-#include <asm/assembler.h>
-#include <asm/arch/empeg.h>
-#include "empeg_ir.h"
-		.text
-	
-.set		BUFFERS_USED,		0
-.set		BUFFERS_FREE,		4
-.set		BUFFERS_HEAD,		8
-.set		BUFFERS_TAIL,		12
-.set		BUFFERS_POINTER,	16
-
-		.global	SYMBOL_NAME(empeg_ir_fiqend)
-		.global SYMBOL_NAME(empeg_ir_fiq)
-empeg_ir_fiq:		
-		#   r8  - scratch
-	        #   r9  - pointer to empeg device structure
-		#   r10 - pointer to OSCR
-		#   r11 - scratch
-		#   r12 - scratch
-		#   r13	- pointer to GPLR
-
-		# First get the value of OSCR
-		ldr	r8, [r10]
-
-		# Now get the value of the IR bit in GPLR
-		ldr	r12, [r13,#0]		@ GPLR
-
-		# Check the IR input and set the bottom bit of the timer
-		# value to indicate the state
-		tst	r12, #(1<<EMPEG_IRINPUT_BIT)
-		orrne	r8,r8,#1
-		biceq	r8,r8,#1
-
-		# Now we have our entry, we had better put it in the queue.
-		# Is there room?
-		ldr	r12, [r9, #BUFFERS_FREE]
-		cmp	r12, #0
-		beq	no_room
-
-		# First decrement the free and store it.
-		sub	r12, r12, #1
-		str	r12, [r9, #BUFFERS_FREE]
-
-		# Load up the head pointer
-		ldr	r12, [r9, #BUFFERS_HEAD]
-
-		# Load up the address of the queue and add on the head pointer
-		ldr	r11, [r9, #BUFFERS_POINTER]
-
-		# Store the value we have
-		str	r8, [r11,r12,lsl#2]
-
-		# Increment the head pointer, if we have reached the maximum
-		# then set it to zero
-		add	r12, r12, #1
-		cmp	r12, #TIMINGS_BUFFER_SIZE
-		moveq	r12, #0               @  This is wierd for a 68000 programmer like me :)
-
-		# Store the head pointer back again.
-		str	r12, [r9, #BUFFERS_HEAD]
-
-		# Increment the used pointer
-		ldr	r12, [r9, #BUFFERS_USED]
-		add	r12, r12, #1
-		str	r12, [r9, #BUFFERS_USED]
-
-no_room:
-		# Lastly, we need to clear GEDR so we get re-triggered
-		mov	r8,#(1<<EMPEG_IRINPUT_BIT)
-		str	r8,[r13,#0x18]		@ GEDR
-
-		# Return
-		subs	pc,lr,#4
-SYMBOL_NAME(empeg_ir_fiqend):
Index: empeg/kernel/drivers/char/mem.c
diff -u empeg/kernel/drivers/char/mem.c:1.16.6.2 empeg/kernel/drivers/char/mem.c:1.16.6.3
--- empeg/kernel/drivers/char/mem.c:1.16.6.2	Fri May  4 18:06:06 2001
+++ empeg/kernel/drivers/char/mem.c	Tue Jun  5 19:34:22 2001
@@ -689,7 +689,7 @@
 	{
 		extern int empeg_dsp_init(void);
 		extern int audio_empeg_init(void);
-		extern int empeg_ir_init(void);
+		extern int empeg_input_init(void);
 		extern int empeg_usb_init(void);
 		extern int empeg_display_init(void);
 		extern int audio_sa1100_ssp_init( void );
@@ -711,8 +711,8 @@
 #ifdef CONFIG_EMPEG_CS4231
 		empeg_cs4231_init();
 #endif
-#ifdef CONFIG_EMPEG_IR
-		empeg_ir_init();
+#ifdef CONFIG_EMPEG_INPUT
+		empeg_input_init();
 #endif
 #if defined(CONFIG_EMPEG_USB9602) || defined(CONFIG_EMPEG_USBD12)
 		empeg_usb_init();
