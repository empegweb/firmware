Index: empeg/kernel/Makefile
diff -u empeg/kernel/Makefile:1.36.2.3 empeg/kernel/Makefile:1.36.2.5
--- empeg/kernel/Makefile:1.36.2.3	Tue Sep 26 20:19:14 2000
+++ empeg/kernel/Makefile	Thu Dec 21 17:36:54 2000
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 2
 SUBLEVEL = 14
-EXTRAVERSION = -rmk5-np17-empeg38
+EXTRAVERSION = -rmk5-np17-empeg40
 
 #ARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ -e s/arm.*/arm/ -e s/sa110/arm/)
 ARCH := arm
Index: empeg/kernel/arch/arm/def-configs/empeg-car1
diff -u /dev/null empeg/kernel/arch/arm/def-configs/empeg-car1:1.1.2.1
--- /dev/null	Mon Jan  8 19:17:04 2001
+++ empeg/kernel/arch/arm/def-configs/empeg-car1	Tue Oct 31 14:23:53 2000
@@ -0,0 +1,204 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_ARM=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+
+#
+# System and processor type
+#
+# CONFIG_ARCH_ARC is not set
+# CONFIG_ARCH_A5K is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_FOOTBRIDGE is not set
+CONFIG_ARCH_SA1100=y
+CONFIG_CPU_SA1100=y
+# CONFIG_SA1100_BRUTUS is not set
+CONFIG_SA1100_EMPEG=y
+# CONFIG_SA1100_ITSY is not set
+# CONFIG_SA1100_LART is not set
+# CONFIG_SA1100_PLEB is not set
+# CONFIG_SA1100_THINCLIENT is not set
+# CONFIG_SA1100_TIFON is not set
+# CONFIG_SA1100_VICTOR is not set
+# CONFIG_ARCH_ACORN is not set
+CONFIG_CPU_32=y
+# CONFIG_CPU_26 is not set
+CONFIG_CPU_32v4=y
+CONFIG_CPU_SA110=y
+# CONFIG_ISA_DMA is not set
+# CONFIG_ALIGNMENT_TRAP is not set
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# General setup
+#
+# CONFIG_NET is not set
+# CONFIG_SYSVIPC is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+CONFIG_NWFPE=y
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_ARTHUR is not set
+# CONFIG_PARPORT is not set
+CONFIG_CMDLINE=""
+
+#
+# Plug and Play support
+#
+# CONFIG_PNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_HD_IDE is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_BLK_DEV_CMD640 is not set
+# CONFIG_IDE_CHIPSETS is not set
+
+#
+# Additional Block Devices
+#
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_MD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_BLK_DEV_XD is not set
+CONFIG_PARIDE_PARPORT=y
+# CONFIG_PARIDE is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+CONFIG_SERIAL_SA1100=y
+CONFIG_SERIAL_SA1100_CONSOLE=y
+# CONFIG_SERIAL is not set
+# CONFIG_SERIAL_EXTENDED is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_UNIX98_PTYS is not set
+
+#
+# Mice
+#
+# CONFIG_BUSMOUSE is not set
+# CONFIG_MOUSE is not set
+
+#
+# Joysticks
+#
+# CONFIG_JOYSTICK is not set
+# CONFIG_QIC02_TAPE is not set
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+CONFIG_EMPEG_IR=y
+CONFIG_EMPEG_USB9602=y
+# CONFIG_EMPEG_USBD12 is not set
+CONFIG_EMPEG_STATE=y
+CONFIG_EMPEG_RDS=y
+# CONFIG_EMPEG_DAC is not set
+CONFIG_EMPEG_DSP=y
+# CONFIG_EMPEG_CS4231 is not set
+CONFIG_EMPEG_SER2IRDA=y
+CONFIG_EMPEG_DISPLAY=y
+# CONFIG_EMPEG_DISPLAY_INVERTED is not set
+CONFIG_EMPEG_POWER=y
+
+#
+# Video For Linux
+#
+CONFIG_VIDEO_DEV=y
+# CONFIG_RADIO_RTRACK is not set
+# CONFIG_RADIO_RTRACK2 is not set
+# CONFIG_RADIO_AZTECH is not set
+# CONFIG_RADIO_CADET is not set
+# CONFIG_RADIO_MIROPCM20 is not set
+# CONFIG_RADIO_GEMTEK is not set
+CONFIG_RADIO_EMPEG=y
+# CONFIG_RADIO_TRUST is not set
+# CONFIG_VIDEO_BT848 is not set
+# CONFIG_VIDEO_PMS is not set
+# CONFIG_VIDEO_SAA5249 is not set
+# CONFIG_RADIO_SF16FMI is not set
+# CONFIG_RADIO_TYPHOON is not set
+# CONFIG_RADIO_ZOLTRIX is not set
+# CONFIG_VIDEO_ZORAN is not set
+# CONFIG_VIDEO_BUZ is not set
+# CONFIG_DTLK is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+
+#
+# SCSI support
+#
+# CONFIG_SCSI is not set
+
+#
+# Filesystems
+#
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_FAT_FS is not set
+# CONFIG_MSDOS_FS is not set
+# CONFIG_UMSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_ISO9660_FS is not set
+# CONFIG_JOLIET is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_NTFS_FS is not set
+# CONFIG_HPFS_FS is not set
+CONFIG_PROC_FS=y
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_EXT2_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_EFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_SMD_DISKLABEL is not set
+# CONFIG_SGI_DISKLABEL is not set
+# CONFIG_NLS is not set
+
+#
+# Kernel hacking
+#
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_ERRORS is not set
+CONFIG_DEBUG_USER=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_DEBUG_LL is not set
Index: empeg/kernel/arch/arm/def-configs/empeg-car2
diff -u /dev/null empeg/kernel/arch/arm/def-configs/empeg-car2:1.1.2.1
--- /dev/null	Mon Jan  8 19:17:04 2001
+++ empeg/kernel/arch/arm/def-configs/empeg-car2	Tue Oct 31 14:23:53 2000
@@ -0,0 +1,347 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_ARM=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+
+#
+# System and processor type
+#
+# CONFIG_ARCH_ARC is not set
+# CONFIG_ARCH_A5K is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_FOOTBRIDGE is not set
+CONFIG_ARCH_SA1100=y
+CONFIG_CPU_SA1100=y
+# CONFIG_SA1100_BRUTUS is not set
+CONFIG_SA1100_EMPEG=y
+# CONFIG_SA1100_ITSY is not set
+# CONFIG_SA1100_LART is not set
+# CONFIG_SA1100_PLEB is not set
+# CONFIG_SA1100_THINCLIENT is not set
+# CONFIG_SA1100_TIFON is not set
+# CONFIG_SA1100_VICTOR is not set
+# CONFIG_ARCH_ACORN is not set
+CONFIG_CPU_32=y
+# CONFIG_CPU_26 is not set
+CONFIG_CPU_32v4=y
+CONFIG_CPU_SA110=y
+# CONFIG_ISA_DMA is not set
+# CONFIG_ALIGNMENT_TRAP is not set
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# General setup
+#
+CONFIG_NET=y
+# CONFIG_SYSVIPC is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+CONFIG_NWFPE=y
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_ARTHUR is not set
+# CONFIG_PARPORT is not set
+CONFIG_CMDLINE=""
+
+#
+# Plug and Play support
+#
+# CONFIG_PNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_HD_IDE is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_BLK_DEV_CMD640 is not set
+# CONFIG_IDE_CHIPSETS is not set
+
+#
+# Additional Block Devices
+#
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_MD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_BLK_DEV_XD is not set
+CONFIG_PARIDE_PARPORT=y
+# CONFIG_PARIDE is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+CONFIG_SERIAL_SA1100=y
+CONFIG_SERIAL_SA1100_CONSOLE=y
+# CONFIG_SERIAL is not set
+# CONFIG_SERIAL_EXTENDED is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_UNIX98_PTYS is not set
+
+#
+# Mice
+#
+# CONFIG_BUSMOUSE is not set
+# CONFIG_MOUSE is not set
+
+#
+# Joysticks
+#
+# CONFIG_JOYSTICK is not set
+# CONFIG_QIC02_TAPE is not set
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+CONFIG_EMPEG_IR=y
+# CONFIG_EMPEG_USB9602 is not set
+CONFIG_EMPEG_USBD12=y
+CONFIG_EMPEG_STATE=y
+# CONFIG_EMPEG_RDS is not set
+# CONFIG_EMPEG_DAC is not set
+CONFIG_EMPEG_DSP=y
+CONFIG_EMPEG_CS4231=y
+CONFIG_EMPEG_SER2IRDA=y
+CONFIG_EMPEG_DISPLAY=y
+# CONFIG_EMPEG_DISPLAY_INVERTED is not set
+CONFIG_EMPEG_POWER=y
+
+#
+# Video For Linux
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DTLK is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_NETLINK is not set
+# CONFIG_FIREWALL is not set
+# CONFIG_FILTER is not set
+# CONFIG_UNIX is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_IP_ROUTER is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_ALIAS is not set
+# CONFIG_SYN_COOKIES is not set
+
+#
+# (it is safe to leave these untouched)
+#
+# CONFIG_INET_RARP is not set
+# CONFIG_SKB_LARGE is not set
+# CONFIG_IPV6 is not set
+
+#
+#  
+#
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_LLC is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+# CONFIG_CPU_IS_SLOW is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Amateur Radio support
+#
+# CONFIG_HAMRADIO is not set
+
+#
+# IrDA subsystem support
+#
+CONFIG_IRDA=y
+
+#
+# IrDA protocols
+#
+# CONFIG_IRLAN is not set
+CONFIG_IRCOMM=y
+# CONFIG_IRLPT is not set
+# CONFIG_IRDA_OPTIONS is not set
+# CONFIG_IRDA_COMPRESSION is not set
+
+#
+# Infrared-port device drivers
+#
+
+#
+# SIR device drivers
+#
+CONFIG_IRTTY_SIR=y
+# CONFIG_IRPORT_SIR is not set
+
+#
+# FIR device drivers
+#
+# CONFIG_NSC_FIR is not set
+# CONFIG_WINBOND_FIR is not set
+# CONFIG_SHARP_FIR is not set
+# CONFIG_TOSHIBA_FIR is not set
+# CONFIG_SMC_IRCC_FIR is not set
+
+#
+# Dongle support
+#
+# CONFIG_DONGLE is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_SB1000 is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_ARM_AM79C961A is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_LANCE is not set
+CONFIG_NET_VENDOR_SMC=y
+# CONFIG_WD80x3 is not set
+# CONFIG_ULTRA is not set
+# CONFIG_ULTRA32 is not set
+# CONFIG_SMC9194 is not set
+CONFIG_SMC9194_TIFON=y
+# CONFIG_NET_VENDOR_RACAL is not set
+# CONFIG_RTL8139 is not set
+# CONFIG_NET_ISA is not set
+# CONFIG_NET_EISA is not set
+# CONFIG_NET_POCKET is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NET_RADIO is not set
+
+#
+# Token ring devices
+#
+# CONFIG_TR is not set
+# CONFIG_NET_FC is not set
+# CONFIG_RCPCI is not set
+# CONFIG_SHAPER is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_COMX is not set
+# CONFIG_DLCI is not set
+# CONFIG_SBNI is not set
+
+#
+# SCSI support
+#
+# CONFIG_SCSI is not set
+
+#
+# Filesystems
+#
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_FAT_FS is not set
+# CONFIG_MSDOS_FS is not set
+# CONFIG_UMSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_ISO9660_FS is not set
+# CONFIG_JOLIET is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_NTFS_FS is not set
+# CONFIG_HPFS_FS is not set
+CONFIG_PROC_FS=y
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_EXT2_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_EFS_FS is not set
+
+#
+# Network File Systems
+#
+# CONFIG_CODA_FS is not set
+CONFIG_NFS_FS=y
+# CONFIG_NFSD is not set
+CONFIG_SUNRPC=y
+CONFIG_LOCKD=y
+# CONFIG_SMB_FS is not set
+# CONFIG_NCP_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_SMD_DISKLABEL is not set
+# CONFIG_SGI_DISKLABEL is not set
+# CONFIG_NLS is not set
+
+#
+# Kernel hacking
+#
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_ERRORS is not set
+CONFIG_DEBUG_USER=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_DEBUG_LL is not set
Index: empeg/kernel/arch/arm/kernel/setup.c
diff -u empeg/kernel/arch/arm/kernel/setup.c:1.11 empeg/kernel/arch/arm/kernel/setup.c:1.11.4.2
--- empeg/kernel/arch/arm/kernel/setup.c:1.11	Mon Jul  3 14:16:49 2000
+++ empeg/kernel/arch/arm/kernel/setup.c	Tue Dec 19 19:41:31 2000
@@ -491,7 +491,7 @@
 
 	if (params) {
 		mem_end	  = params->u1.s.page_size *
-			    params->u1.s.nr_pages;
+			    params->u1.s.nr_pages + PAGE_OFFSET;
 
 		ROOT_DEV	   = to_kdev_t(params->u1.s.rootdev);
 		system_rev	   = params->u1.s.system_rev;
@@ -533,7 +533,7 @@
 		from = params->commandline;
 	} else {
 #if defined(CONFIG_SA1100_EMPEG)
- 		mem_end		= 8*1024*1024;
+ 		mem_end		= PAGE_OFFSET + 8*1024*1024;
 #ifdef CONFIG_ROOT_NFS
  		ROOT_DEV        = MKDEV(UNNAMED_MAJOR, 0);
 #else
@@ -543,11 +543,15 @@
 #endif
 	}
 
-	if (!mem_end)
-		mem_end = MEM_SIZE;
+	parse_cmdline(cmdline_p, from);
 
-	mem_end += PAGE_OFFSET;
+	if (!mem_end)
+		mem_end = PAGE_OFFSET + MEM_SIZE;
 
+	/* Botch revision number */
+	/* Setup the virt/phys mapping tables */
+	empeg_setup_bank_mapping(mem_end < PAGE_OFFSET + 16*1024*1024 ? 7 : 9);
+	
 	init_task.mm->start_code = (unsigned long) &_text;
 	init_task.mm->end_code	 = (unsigned long) &_etext;
 	init_task.mm->end_data	 = (unsigned long) &_edata;
@@ -555,7 +559,6 @@
 
 	memcpy(saved_command_line, from, COMMAND_LINE_SIZE);
 	saved_command_line[COMMAND_LINE_SIZE-1] = '\0';
-	parse_cmdline(cmdline_p, from);
 	setup_bootmem();
 
 #ifdef CONFIG_NWFPE
Index: empeg/kernel/arch/arm/kernel/traps.c
diff -u empeg/kernel/arch/arm/kernel/traps.c:1.2 empeg/kernel/arch/arm/kernel/traps.c:1.2.8.1
--- empeg/kernel/arch/arm/kernel/traps.c:1.2	Tue Mar 28 14:24:23 2000
+++ empeg/kernel/arch/arm/kernel/traps.c	Mon Dec 11 12:38:03 2000
@@ -344,6 +344,7 @@
 #ifdef CONFIG_DEBUG_USER
 	printk(KERN_ERR "[%d] %s: old system call.\n", current->pid, 
 	       current->comm);
+	c_backtrace (regs->ARM_fp, processor_mode(regs));
 #endif
 	force_sig(SIGILL, current);
 }
Index: empeg/kernel/arch/arm/mm/mm-sa1100.c
diff -u empeg/kernel/arch/arm/mm/mm-sa1100.c:1.4 empeg/kernel/arch/arm/mm/mm-sa1100.c:1.4.8.2
--- empeg/kernel/arch/arm/mm/mm-sa1100.c:1.4	Sat Mar 18 15:56:30 2000
+++ empeg/kernel/arch/arm/mm/mm-sa1100.c	Tue Dec 19 19:41:46 2000
@@ -21,6 +21,22 @@
 #include <asm/io.h>
 #include <asm/proc/mm-init.h>
 
+#ifdef CONFIG_SA1100_EMPEG
+/* default mapping is 4 banks of 4MB */
+unsigned long empeg_virt_to_phys_mapping[4] = {
+	0xc0000000,
+	0xc8000000,
+	0xd0000000,
+	0xd8000000
+};
+unsigned long empeg_phys_to_virt_mapping[4] = {
+	0xc0000000,
+	0xc0400000,
+	0xc0800000,
+	0xc0c00000
+};
+#endif
+
 #ifdef CONFIG_SA1100_VICTOR
 #define FLASH_MAPPING \
 	{ 0xd0000000, 0x00000000, 0x00200000, DOMAIN_IO, 1, 1 }, /* flash */
@@ -137,4 +153,48 @@
 
 #endif  /* macros not defined */
 
+#ifdef CONFIG_SA1100_EMPEG
+void empeg_setup_bank_mapping(int hw_rev)
+{
+	unsigned long *virt_mapping, *phys_mapping;
+	
+	static const unsigned long virt_to_phys_1bank[4] = {
+		0xc0000000,
+		0xc0400000,
+		0xc0800000,
+		0xc0c00000
+	};
+	static const unsigned long phys_to_virt_1bank[4] = {
+		0xc0000000,
+		0xc0000000,
+		0xc0000000,
+		0xc0000000
+	};
+	static const unsigned long virt_to_phys_4bank[4] = {
+		0xc0000000,
+		0xc8000000,
+		0xd0000000,
+		0xd8000000
+	};
+	static const unsigned long phys_to_virt_4bank[4] = {
+		0xc0000000,
+		0xc0400000,
+		0xc0800000,
+		0xc0c00000
+	};
+	
+	if(hw_rev < 9) {
+		virt_mapping = virt_to_phys_4bank;
+		phys_mapping = phys_to_virt_4bank;
+	}
+	else {
+		virt_mapping = virt_to_phys_1bank;
+		phys_mapping = phys_to_virt_1bank;
+	}
 
+	memcpy(empeg_virt_to_phys_mapping, virt_mapping,
+	       4 * sizeof(unsigned long));
+	memcpy(empeg_phys_to_virt_mapping, phys_mapping,
+	       4 * sizeof(unsigned long));
+}
+#endif
Index: empeg/kernel/arch/arm/special/empeg_display.c
diff -u empeg/kernel/arch/arm/special/empeg_display.c:1.33 empeg/kernel/arch/arm/special/empeg_display.c:1.33.4.2
--- empeg/kernel/arch/arm/special/empeg_display.c:1.33	Sat Jul 22 16:48:04 2000
+++ empeg/kernel/arch/arm/special/empeg_display.c	Fri Jan  5 15:43:21 2001
@@ -63,6 +63,9 @@
  *                vanished because of this (probably something to do with
  *                the minimum start porch). Some tidying.
  *
+ * 2001/01/05 MAC Ported Hugo's empeg_power changes from the trunk back
+ *                so we support rev9 players.
+ *
  * This is the very basic console mapping code: we only provide a mmap()able
  * area at the moment - there is no linkup with the VT code.
  *
@@ -131,11 +134,12 @@
 #include <asm/arch/empeg.h>
 #include <asm/uaccess.h>
 
-//#define DEBUG_DISPLAY 1
-
 /* The empeg logo for the splash screen: includes tux :) */
 #include "empeg_logo.h"
 
+/* The Rio logo for the splash screen */
+#include "rio_logo.h"
+
 inline void donothing(const char *s, ...)
 {
 }
@@ -200,6 +204,9 @@
 		LCCR0_4PixMono+       /* 4-pix-per-clock mono display */   \
 		LCCR0_DMADel(0))      /* No DMA delay */
 
+/* Display power control (in empeg_power.c) */
+extern void empeg_displaypower(int);
+
 /* The display buffer */
 struct empegfb_buffer {
         short palette[EMPEG_PALETTE_SIZE];
@@ -528,10 +535,10 @@
 }
 
 /* Display splash screen */
-static void display_splash(struct display_dev *dev)
+static void display_splash(struct display_dev *dev, const unsigned char *image)
 {
 	/* Copy splash screen to the software buffer */
-	memcpy(dev->software_buffer,empeg_logo,sizeof(empeg_logo));
+	memcpy(dev->software_buffer,image,EMPEG_SCREEN_SIZE);
 
 	/* Blat it: well, add it to the refresh buffer, otherwise when the
 	   audio DMA starts it all goes blank... */
@@ -542,16 +549,71 @@
 static void display_user_splash(unsigned long screen)
 {
 	struct display_dev *dev = devices;
-	unsigned char *image=(unsigned char*)screen;
+	const unsigned char *image=(const unsigned char*)screen;
+	display_splash(dev, image);
+}
 
-	/* Copy splash screen to the software buffer */
-	memcpy(dev->software_buffer,image,EMPEG_SCREEN_SIZE);
+#define CHARS_TO_ULONG(A, B, C, D) ((A) | ((B) << 8) | ((C) << 16) | ((D) << 24))
+	
+static void handle_splash(struct display_dev *dev)
+{
+	const int LOGO_EMPEG = 0;
+	const int LOGO_RIO = 1;
+	const int LOGO_MASK = 0xf;
+	const int LOGO_CUSTOM = 0x10;	
+	int logo_type;
+	unsigned char *user_splash=(unsigned char*)(EMPEG_FLASHBASE+0xa000);
 
-	/* Blat it: well, add it to the refresh buffer, otherwise when
-	   the audio DMA starts it all goes blank... */
-	display_refresh(dev);
+	unsigned long splash_signature = *((unsigned long *)user_splash);
+
+	printk("Signature is %08x '%c%c%c%c'\n", splash_signature,
+	       user_splash[0], user_splash[1], user_splash[2], user_splash[3]);
+	
+	switch (splash_signature)
+	{
+	case CHARS_TO_ULONG('e', 'm', 'p', 'g'):
+		logo_type = LOGO_CUSTOM | LOGO_EMPEG;
+		break;
+	case CHARS_TO_ULONG('e', 'm', 'p', ' '):
+		logo_type = LOGO_EMPEG;
+		break;
+	case CHARS_TO_ULONG('r', 'i', 'o', ' '):
+		logo_type = LOGO_RIO;
+		break;
+	case CHARS_TO_ULONG('r', 'i', 'o', 'c'):
+		logo_type = LOGO_CUSTOM | LOGO_RIO;
+		break;
+	default:
+		logo_type = LOGO_EMPEG;
+	}
+	
+	printk("Logo type is %x\n", logo_type);
+	
+	/* Load splash screen image */
+	if ((logo_type & LOGO_MASK) == LOGO_RIO)
+		display_splash(dev, &rio_logo);
+	else
+		display_splash(dev, &empeg_logo);
+
+	/* Setup timer to display user's image (if present) in 3 seconds */
+	if (logo_type & LOGO_CUSTOM) {
+		printk("Scheduling custom logo.\n");
+		init_timer(&display_timer);
+		display_timer.expires=(jiffies+(HZ*3));
+
+		/* On AC or DC power? AC is first image, DC is second */
+		display_timer.data=(unsigned long)(user_splash+4);
+		if (GPLR&EMPEG_EXTPOWER) display_timer.data+=EMPEG_SCREEN_SIZE;
+
+		/* Set up function pointer & add to timer queue (it will remove
+		   itself when the timer expires) */
+		display_timer.function=display_user_splash;
+		add_timer(&display_timer);
+	}
 }
 
+
+
 /* This handles the mmap call. To be able to mmap RAM we need to swing
    through hoops a little. See p283 of Linux Device Drivers for details */
 
@@ -697,7 +759,23 @@
 	case EMPEG_DISPLAY_POWER:
 	case 1: /* Screen power control */
 		if (arg) {
-			/* LCD control register 0; flags & enable */
+			if (LCCR0&LCCR0_LEN) {
+				/* Lcd control register 0; everything off */
+				LCSR = LCSR_LDD;
+				LCCR0 = 0;
+				
+				/* Wait for controller off */
+				while((LCSR&LCSR_LDD)==0);
+			}
+			
+			/* Clear error flags */
+			LCSR = 0xfff;
+			
+			/* Set up the DMA controller's base address for the
+			   screen */
+			DBAR1 = (unsigned char*)virt_to_phys((int)dev->hardware_buffer);
+			
+			/* Now enable the screen */
 			LCCR0 = LCCR0_SETUP;
 			LCCR0 |= LCCR0_LEN;
 			
@@ -708,7 +786,7 @@
 			dev->power = TRUE;
 			
 			/* Turning display on */
-			GPSR=EMPEG_DISPLAYPOWER;
+			empeg_displaypower(1);
 
 			/* Wait for a while for it to come to life */
 			udelay(POWERFAIL_DISABLED_DELAY);
@@ -721,7 +799,7 @@
 			dev->power = FALSE;
 			
 			/* Turning display off */
-			GPCR=EMPEG_DISPLAYPOWER;
+			empeg_displaypower(0);
 			
 			/* Set standby LED mode */
 		}
@@ -827,7 +905,6 @@
 void __init empeg_display_init(void)
 {
 	struct display_dev *dev = devices;
-	unsigned char *user_splash=(unsigned char*)(EMPEG_FLASHBASE+0xa000);
 	int result,delay;
 	
 	/* Firstly, we need to locate the LCD DMA buffer to a 4k page
@@ -874,14 +951,8 @@
 	dev->queue_used = 0;
 	dev->queue_free = BUFFER_COUNT;
 
-	/* Now make it non-cacheable so the user processes and kernel
-           both see the same data. */
-//	flush_page_to_ram(MAP_NR(dev->software_buffer));
-//	uncache_page(MAP_NR(dev->software_buffer));
-
 	/* Setup normal palette */
 	display_setpalette(dev, PALETTE_STANDARD);
-/*	display_setpalette(dev, PALETTE_DIRECT);*/
 	
 	/* First ensure that LCD controller is turned off */
 	LCCR0 = 0;
@@ -938,7 +1009,7 @@
 
 	enable_powerfail(FALSE);
 	dev->power = TRUE;
-	GPSR=EMPEG_DISPLAYPOWER;
+	empeg_displaypower(1);
 	udelay(POWERFAIL_DISABLED_DELAY);
 	enable_powerfail(TRUE);
 
@@ -959,25 +1030,8 @@
 	*lcd_command1=0xaf;
 	udelay(1);
 #endif
-	
-	/* Load splash screen image */
-	display_splash(dev);	
-
-	/* Setup timer to display user's image (if present) in 3 seconds */
-	if (strncmp(user_splash,"empg",4)==0) {
-		init_timer(&display_timer);
-		display_timer.expires=(jiffies+(HZ*3));
-
-		/* On AC or DC power? AC is first image, DC is second */
-		display_timer.data=(unsigned long)(user_splash+4);
-		if (GPLR&EMPEG_EXTPOWER) display_timer.data+=EMPEG_SCREEN_SIZE;
-
-		/* Set up function pointer & add to timer queue (it will remove
-		   itself when the timer expires) */
-		display_timer.function=display_user_splash;
-		add_timer(&display_timer);
-	}
 
+	handle_splash(dev);
 	printk("empeg display initialised.\n");
 }
 
@@ -998,7 +1052,8 @@
 		LCCR0_DMADel(0);      /* No DMA delay */
 
 	/* Turn off POM */
-	GPSR=EMPEG_DSPPOM | EMPEG_DISPLAYPOWER;
+	GPSR=EMPEG_DSPPOM;
+	empeg_displaypower(1);
 #else
 	struct display_dev *dev = devices;
 
@@ -1051,7 +1106,7 @@
 	   re-enable it */
 
 	if (dev->power) {
-		GPSR=EMPEG_DISPLAYPOWER;
+		empeg_displaypower(1);
 		udelay(POWERFAIL_DISABLED_DELAY);
 	}
 	GPSR=EMPEG_DSPPOM;
Index: empeg/kernel/arch/arm/special/empeg_pdiusb12.c
diff -u empeg/kernel/arch/arm/special/empeg_pdiusb12.c:1.8.6.3 empeg/kernel/arch/arm/special/empeg_pdiusb12.c:1.8.6.5
--- empeg/kernel/arch/arm/special/empeg_pdiusb12.c:1.8.6.3	Tue Sep 26 19:22:36 2000
+++ empeg/kernel/arch/arm/special/empeg_pdiusb12.c	Tue Oct 31 14:30:04 2000
@@ -1,4 +1,5 @@
 #define DEBUG_USB
+#define DEBUG_USB_6 /* Stall checking */
 #define NO_ZERO_TERM
 
 #ifdef CONFIG_EMPEG_USB9602
@@ -431,13 +432,30 @@
 		reply[1]=0;
 		break;
 		
-	case 2:                         /* ENDPOINT */  
+	case 2: {                       /* ENDPOINT */  
 		/* reply[0] needs to be 1 if the endpoint
 		   referred to in command[3] is stalled,
 		   otherwise 0 */
-		reply[0]=0;
+		int ep=((command[3]&0x80)?1:0)+((command[3]&3)*2);
+		int stall=0;
+
+		/* Check EP */
+		usb_command(CMD_SELECTEP0+ep);
+		if (usb_cread() & SELECTEP_STALL) stall=1;
+
+		reply[0]=stall?1:0;
 		reply[1]=0;
+
+#ifdef DEBUG_USB_6
+		/* Write this packet */
+		writeendpoint(1,reply,2);
+		printk("check ep%d, stall=%d\n",ep,stall);
+
+		/* Return now - we've sent the reply */
+		return;
+#endif
 		break;
+		}
 		
 	default:                        /* UNDEFINED */   
 		/* Stall endpoints 0 & 1 */
@@ -469,9 +487,21 @@
 		usb_cwrite(0);
 		usb_command(CMD_ENDPOINTENABLE);
 		usb_cwrite(EPENABLE_GENERICISOEN);
-		
-		/* If there's anything in the tx buffer, kick tx */
-		if (dev->tx_used>0) tx_data(1);
+
+		if (usb_txidle == 0) {
+			/* If the FIFOs were full then do a little nudge so
+			   that we get the interrupts going again. This will
+			   cause a zero byte packet to be sent and some data
+			   loss but we can live with it. */
+			usb_command(CMD_SELECTEP5);
+			usb_cwrite(0);
+			usb_command(CMD_VALIDATEBUFFER);
+		} else {
+			/* Otherwise, if there is pending data and
+			   room in the FIFO then we'd better make use
+			   of it.  */
+			if (dev->tx_used>0) tx_data(1);
+		}
 	} else {
 		/* Panic! */
 		stall_ep0();
@@ -564,6 +594,31 @@
 	unsigned long flags;
 	int a,txstat,tofill=2;
 
+	if (kick == 2) {
+		usb_command(CMD_ENDPOINTENABLE);
+		usb_cwrite(0);
+
+		usb_command(CMD_ENDPOINTENABLE);
+		usb_cwrite(EPENABLE_GENERICISOEN);
+
+		dev->tx_used=0;
+		dev->tx_free=USB_TX_BUFFER_SIZE;
+		dev->tx_head=dev->tx_tail=0;
+		
+		usb_command(CMD_SELECTEP5);
+		usb_cwrite(0);
+		usb_command(CMD_VALIDATEBUFFER);
+		usb_txidle = 1;
+		return;
+	}
+
+	/* Is there any data to send? */
+	if (kick==2 && dev->tx_used==0) {
+		/* Just idle */
+		usb_txidle=1;
+		return;
+	}
+	
 	if (!kick) {
 		/* Get status/clear IRQ */
 		usb_command(CMD_LASTTRANSACTION5);
@@ -591,7 +646,7 @@
 	}
 
 	/* While we can send stuff... (this will fill both FIFOs) */
-	while(checkendpoint(CMD_SELECTEP5)==0 && tofill) {
+	while((checkendpoint(CMD_SELECTEP5)==0 || kick==2) && tofill) {
 		/* Fill local packet buffer from TX buffer: if there's nothing
 		   to send (there might be: we need to be able to send zero
 		   length packets to terminate a transfer of an exact multiple
@@ -719,17 +774,22 @@
 				/* ENDPOINT */
 				case 2: { 
 					/* Find endpoint */
-					int ep=command[4]&3;
+					int ep=((command[4]&0x80)?1:0)+((command[4]&3)*2);
 					int stall=(command[1]==SET_FEATURE)?SETEPSTATUS_STALLED:0;
-#ifdef DEBUG_USB_1
-					printk("endpoint stall(%d)\n",ep);
-#endif
-					/* Set/clear endpoint stall flag */
-					usb_command(CMD_SETEPSTATUS0+(ep*2)+1);
+					/* Set/clear stall flag */
+					usb_command(CMD_SETEPSTATUS0+ep);
 					usb_cwrite(stall);
-					usb_command(CMD_SETEPSTATUS0+(ep*2));
-					usb_cwrite(stall);
+
+					/* 0-byte ACK */
 					writeendpoint(1,0,0);
+
+#ifdef DEBUG_USB_6
+					printk("endpoint stall(%s stall on ep%d)\n",stall?"set":"clear",ep);
+#endif
+					if (!stall) {
+						/* Kick TX */
+						tx_data(2);
+					}
 					break;
 				}		
 				
@@ -881,7 +941,6 @@
 static int usb_read_procmem(char *buf, char **start, off_t offset, int len, int unused)
 {
 	struct usb_dev *dev = usb_devices;
-	int a;
 	len = 0;
 
 	len+=sprintf(buf+len,"Control endpoint 0\n");
@@ -896,15 +955,33 @@
 	len+=sprintf(buf+len,"  %9d TX bytes\n\n",dev->tx_count);
 	len+=sprintf(buf+len,"  %9d RX buffered\n",dev->rx_used);
 	len+=sprintf(buf+len,"  %9d TX buffered\n\n",dev->tx_used);
+
+	len+=sprintf(buf+len,"Endpoint\n");
+	len+=sprintf(buf+len,"  %9d RX ok\n",dev->stats_rxok[1]);
+	len+=sprintf(buf+len,"  %9d RX error\n",dev->stats_rxerr[1]);
+	len+=sprintf(buf+len,"  %9d RX nak\n",dev->stats_rxnak[1]);
+	len+=sprintf(buf+len,"  %9d RX overruns\n",dev->stats_rxoverrun[1]);
+	len+=sprintf(buf+len,"  %9d TX ok\n",dev->stats_txok[1]);
+	len+=sprintf(buf+len,"  %9d TX error\n\n",dev->stats_txerr[1]);
+
+	{
+		unsigned long flags;
 
-	len+=sprintf(buf+len,"Endpoint %d\n",a);
-	len+=sprintf(buf+len,"  %9d RX ok\n",dev->stats_rxok[a]);
-	len+=sprintf(buf+len,"  %9d RX error\n",dev->stats_rxerr[a]);
-	len+=sprintf(buf+len,"  %9d RX nak\n",dev->stats_rxnak[a]);
-	len+=sprintf(buf+len,"  %9d RX overruns\n",dev->stats_rxoverrun[a]);
-	len+=sprintf(buf+len,"  %9d TX ok\n",dev->stats_txok[a]);
-	len+=sprintf(buf+len,"  %9d TX error\n\n",dev->stats_txerr[a]);
+		save_flags_cli(flags);
+		/* Check EP */
+		usb_command(CMD_SELECTEP4);
+		if (usb_cread() & SELECTEP_STALL)
+			len += sprintf(buf+len, "Endpoint 4 is stalled.\n");
 
+		usb_command(CMD_SELECTEP5);
+		if (usb_cread() & SELECTEP_STALL)
+			len += sprintf(buf+len, "Endpoint 5 is stalled.\n");		
+		
+		restore_flags(flags);
+	}
+
+	len+=sprintf(buf+len, "txidle=%d\n", usb_txidle);
+	
 	LOG(0);
 	len+=sprintf(buf+len,"Log: %s",log);
 	log_size=0;
@@ -1131,5 +1208,51 @@
 
 static int usb_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)
 {
+	struct usb_dev *dev = filp->private_data;
+	unsigned long flags;
+	int state;
+	switch (cmd)
+	{
+	case 0: /* Get pipe status */
+	{
+		int ep;
+		int *ptr = (int *)arg;
+
+		get_user_ret(ep, ptr, -EFAULT);
+
+		/* Check EP */
+		save_flags_cli(flags);
+		usb_command(CMD_SELECTEP0+ep);
+		state = usb_cread() & SELECTEP_STALL;
+		restore_flags(flags);
+
+		if (state)
+			put_user_ret(1, ptr + 1, -EFAULT);
+		else
+			put_user_ret(0, ptr + 1, -EFAULT);
+		break;
+	}
+
+	case 1: /* Set pipe status */
+	{
+		int ep, stall;
+		int *ptr = (int *)arg;
+
+		get_user_ret(ep, ptr, -EFAULT);
+		get_user_ret(stall, ptr + 1, -EFAULT);
+
+		save_flags_cli(flags);
+		usb_command(CMD_SETEPSTATUS0+ep);
+		usb_cwrite(stall ? SETEPSTATUS_STALLED : 0);
+
+		if (!stall)
+			tx_data(2);
+
+		restore_flags(flags);
+		break;
+	}
+	default:
+	    	return -EINVAL;
+	}
 	return 0;
 }
Index: empeg/kernel/arch/arm/special/empeg_power.c
diff -u empeg/kernel/arch/arm/special/empeg_power.c:1.13.4.1 empeg/kernel/arch/arm/special/empeg_power.c:1.13.4.2
--- empeg/kernel/arch/arm/special/empeg_power.c:1.13.4.1	Mon Sep  4 14:36:21 2000
+++ empeg/kernel/arch/arm/special/empeg_power.c	Fri Jan  5 15:43:22 2001
@@ -115,8 +115,8 @@
 	int bit;
 	unsigned long flags;
 
-	/* Not really valid on Mk1's */
-	if (empeg_hardwarerevision()<6) return;
+	/* Not really valid on Mk1's or Marvin */
+	if (empeg_hardwarerevision()<7) return;
 
 	/* Need to do this with IRQs disabled to preserve timings */
 	save_flags_cli(flags);
@@ -135,8 +135,8 @@
 			/* High - 20us of low */
 			udelay(20);
 		} else {
-			/* Low - 4us of low */
-			udelay(4);
+			/* Low - 6us of low - changed for rev9, why? */
+			udelay(6);
 		}
 
 		/* Set line high */
@@ -168,7 +168,7 @@
 	static unsigned long last_lights_activity;
 	
 	
-	int bitset=0;
+	int bitset=0; // 6; // marvin hack
 	unsigned int gplr=GPLR;
 	
 	if (empeg_hardwarerevision()<6) {
@@ -427,3 +427,14 @@
 	return -EINVAL;
 }
 
+extern void empeg_displaypower(int on)
+{
+	if (empeg_hardwarerevision()<9) {
+               /* Just twiddle appropriate line */
+               if (on) GPSR=EMPEG_DISPLAYPOWER;
+               else GPCR=EMPEG_DISPLAYPOWER;
+       } else {
+               /* Send actual command */
+               powercontrol(on?3:4);
+       }
+}
Index: empeg/kernel/arch/arm/special/empeg_proc.c
diff -u empeg/kernel/arch/arm/special/empeg_proc.c:1.11 empeg/kernel/arch/arm/special/empeg_proc.c:1.11.4.1
--- empeg/kernel/arch/arm/special/empeg_proc.c:1.11	Mon Jul 17 19:35:06 2000
+++ empeg/kernel/arch/arm/special/empeg_proc.c	Tue Dec 12 16:26:20 2000
@@ -23,6 +23,7 @@
 {
 	unsigned int *permset=(unsigned int*)(EMPEG_FLASHBASE+0x2000);
 	unsigned int *modset=(unsigned int*)(EMPEG_FLASHBASE+0x2000);
+	unsigned long *user_splash=(unsigned long*)(EMPEG_FLASHBASE+0xa000);
 	len = 0;
 	len += sprintf(buf+len, "hwrev : %02d\n", permset[0]);
 	len += sprintf(buf+len, "serial: %05d\n", permset[1]);
@@ -34,6 +35,7 @@
 	len += sprintf(buf+len, "flash : %dK\n",
 		       permset[9]==0xffffffff?1024:permset[9]);
 	len += sprintf(buf+len, "drives: %d\n", modset[0]);
+	len += sprintf(buf+len, "image : %08x\n", *user_splash);
 	return len;
 }
 
Index: empeg/kernel/arch/arm/special/empeg_usb.c
diff -u empeg/kernel/arch/arm/special/empeg_usb.c:1.18 empeg/kernel/arch/arm/special/empeg_usb.c:1.18.8.2
--- empeg/kernel/arch/arm/special/empeg_usb.c:1.18	Tue Apr 25 12:21:58 2000
+++ empeg/kernel/arch/arm/special/empeg_usb.c	Mon Oct 30 19:20:22 2000
@@ -1,4 +1,5 @@
 #undef DEBUG_USB
+#define DEBUG_USB_6 /* Stall debug */
 #define NO_ZERO_TERM
 
 #ifdef CONFIG_EMPEG_USBD12
@@ -194,9 +195,6 @@
 /* These are the macros                                               */
 /**********************************************************************/
 
-/* store the status byte in FIFO0 for the chosen endpoint */
-#define EPSTATUS(ep) case ep: if (stalld[ep]) write_usb(TXD0,1); else write_usb(TXD0,0); break;
-
 /* Flush and disable the USB TXn **************************************/
 #define FLUSHTX0 write_usb(TXC0,FLUSH)
 #define FLUSHTX3 write_usb(TXC3,FLUSH)
@@ -253,7 +251,7 @@
 
 /* Bits 0-6 correspond to like-numbered endpoints and are set to indicate the
    endpoint is stalled */
-static int stalld[6];
+//static int stalld[6];
 
 /* for now the sizes and offsets below need to be hand calculated, until I can
    find a better way to do it for multiple byte values, LSB goes first */
@@ -503,6 +501,59 @@
 	}
 }
 
+static void set_endpoint_stall(int ep, int stall)
+{
+	byte bit;
+	byte state;
+
+	if (stall)
+		bit = 0x80;
+	else
+		bit = 0x00;
+
+	switch (ep)
+	{
+	case 1:
+		state = read_usb(EPC1);
+		write_usb(EPC1, (state & ~0x80) | bit);
+		break;
+	case 5:
+		state = read_usb(EPC4);
+		write_usb(EPC4, (state & ~0x80) | bit);
+		state = read_usb(EPC6);
+		write_usb(EPC6, (state & ~0x80) | bit);
+		break;
+	default:
+		printk("Warning: set of endpoint stall state on unused endpoint %d\n", ep);
+		break;
+	}
+}
+
+static int get_endpoint_stall(int ep)
+{
+	switch (ep)
+	{
+	case 1:
+		/* Endpoint 1 is just endpoint 1 */
+		if (read_usb(EPC1) & 0x80)
+			return 1;
+		else
+			return 0;
+	case 5: {
+		/* Endpoint 5 is actually 4 and 6 ping-ponged */
+		int result = 0;
+		if (read_usb(EPC4) & 0x80)
+			result |= 1;
+		if (read_usb(EPC6) & 0x80)
+			result |= 2;
+		return result;
+	}
+	default:
+		printk("Warning: query for endpoint stall state on unused endpoint %d\n", ep);
+		return 0;
+	}
+}
+
 /**********************************************************************/
 /* The CLEAR_FEATURE request is done here                             */  
 /**********************************************************************/
@@ -519,10 +570,12 @@
 	case 2:                         /* ENDPOINT */  
 		/* Clear endpoint stall flag */
 		if (usb_buf[3]<=5) {
-#ifdef DEBUG_USB_1
-			printk("clearfeature(%d)\n",usb_buf[3]);
+//			stalld[usb_buf[4] & 7]=0;
+#ifdef DEBUG_USB_6
+			printk("stall clear on ep%d, current state %d\n",
+			       usb_buf[4] & 7, get_endpoint_stall(usb_buf[4] & 7));
 #endif
-			stalld[usb_buf[3]]=0;
+			set_endpoint_stall(usb_buf[4] & 7, 0);
 		}
 		break;
 		
@@ -600,19 +653,16 @@
 		write_usb(TXD0,0);      /* first byte is reserved */   
 		break;
 		
-	case 2:                         /* ENDPOINT */  
-		switch (usb_buf[3]) {   /* find specific endpoint */
-			EPSTATUS(0);
-			EPSTATUS(1);
-			EPSTATUS(2);
-			EPSTATUS(3);  
-			EPSTATUS(4);
-			EPSTATUS(5);
-			EPSTATUS(6);  
-		default:
-			break;
-		}
+	case 2: {                       /* ENDPOINT */  
+		int ep=usb_buf[3]&7;
+		int stall=get_endpoint_stall(ep);
+//		write_usb(TXD0,(stalld[ep]?1:0));
+		write_usb(TXD0, stall);
+#ifdef DEBUG_USB_6
+		printk("status ep%d stall=%d\n",ep,stall);
+#endif
 		break;
+	}
 		
 	default:                        /* UNDEFINED */   
 		break;
@@ -641,7 +691,7 @@
 		dtapid.TGL3PID=0;
 
 		/* Nothing stalled */
-		for(a=0;a<6;a++) stalld[a]=0;
+//		for(a=0;a<6;a++) stalld[a]=0;
 
 		/* Disable unused fifos */
 		write_usb(EPC1,0);      /* disable EP1 */
@@ -688,8 +738,14 @@
 		
 	case 2:                         /* ENDPOINT */  
 		/* Mark endpoint as stalled */
-		if (usb_buf[3]<=5)
-			stalld[usb_buf[3]]=1;
+		if (usb_buf[3]<=5) {
+			set_endpoint_stall(usb_buf[4] & 7, 1);
+//			stalld[usb_buf[4] & 7]=1;
+#ifdef DEBUG_USB_6
+			printk("stall set on ep%d\n",usb_buf[3] & 7);
+#endif
+
+		}
 		break;
 		
 	default:                        /* UNDEFINED */   
@@ -1182,6 +1238,17 @@
 		len+=sprintf(buf+len,"  %9d TX error\n\n",dev->stats_txerr[a]);
 	}
 
+	{
+		unsigned long flags;
+
+		save_flags_cli(flags);
+		if (get_endpoint_stall(1))
+			len+=sprintf(buf+len, "Endpoint 1 stalled\n");
+		if (get_endpoint_stall(5))
+			len+=sprintf(buf+len, "Endpoint 5 stalled\n");
+		restore_flags(flags);
+	}
+		
 	LOG(0);
 	len+=sprintf(buf+len,"Log: %s",log);
 	log_size=0;
@@ -1395,25 +1462,45 @@
 
 static int usb_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)
 {
-#if 0
-	struct usb_dev *dev = filp->private_data;
-	if (_IOC_TYPE(cmd) != IR_IOC_MAGIC)
-		return -EINVAL;
-	
-	switch(cmd) {
-	case IR_IOCSTYPE:
-		/* arg is the type we want */
-		if (arg >= IR_TYPE_COUNT)
+	unsigned long flags;
+	switch (cmd)
+	{
+	case 0: /* Get pipe status */
+	{
+		int ep;
+		int *ptr = (int *)arg;
+
+		get_user_ret(ep, ptr, -EFAULT);
+
+		/* Check EP */
+		if (ep != 1 && ep != 5)
 			return -EINVAL;
-		dev->ir_type = arg;
-		break;
-	case IR_IOCTTYPE:
-		/* arg is the location to put the type in */
-		((int *)arg) = dev->ir_type;
-		break;
-	default:
-		return -EINVAL;
+		
+//		put_user_ret(stalld[ep], ptr + 1, -EFAULT);
+		save_flags_cli(flags);
+		put_user_ret(get_endpoint_stall(ep), ptr + 1, -EFAULT);
+		restore_flags(flags);
+		return 0;
+	}
+
+	case 1: /* Set pipe status */
+	{
+		int ep, stall;
+		int *ptr = (int *)arg;
+
+		get_user_ret(ep, ptr, -EFAULT);
+		get_user_ret(stall, ptr + 1, -EFAULT);
+
+		if (ep != 1 && ep != 5)
+			return -EINVAL;
+
+		save_flags_cli(flags);
+		set_endpoint_stall(ep, stall);
+		restore_flags(flags);
+		return 0;
 	}
-#endif
+	default:
+	    	return -EINVAL;
+	}		
 	return 0;
 }
Index: empeg/kernel/arch/arm/special/rio_logo.h
diff -u /dev/null empeg/kernel/arch/arm/special/rio_logo.h:1.1.2.2
--- /dev/null	Mon Jan  8 19:17:04 2001
+++ empeg/kernel/arch/arm/special/rio_logo.h	Tue Dec 12 16:25:43 2000
@@ -0,0 +1,252 @@
+/* This file is autogenerated by tests/xpm-to-kernel */
+/* Declare it __initdata so we can throw it away after startup */
+static unsigned char rio_logo[] __initdata={
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x31,
+	0x33,0x23,0x00,0x20,0x31,0x33,0x33,0x33,
+	0x33,0x21,0x00,0x00,0x00,0x00,0x00,0x10,
+	0x33,0x33,0x02,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x33,
+	0x33,0x33,0x22,0x31,0x33,0x33,0x33,0x33,
+	0x33,0x33,0x23,0x00,0x00,0x00,0x00,0x33,
+	0x33,0x33,0x03,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x32,0x33,
+	0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
+	0x33,0x33,0x33,0x01,0x00,0x00,0x20,0x33,
+	0x33,0x33,0x13,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x32,0x33,
+	0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
+	0x33,0x33,0x33,0x13,0x00,0x00,0x20,0x33,
+	0x33,0x33,0x13,0x00,0x00,0x00,0x00,0x20,
+	0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x33,
+	0x33,0x33,0x33,0x33,0x02,0x00,0x00,0x12,
+	0x33,0x33,0x33,0x33,0x01,0x00,0x00,0x33,
+	0x33,0x33,0x23,0x00,0x00,0x00,0x00,0x33,
+	0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x03,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x33,
+	0x33,0x33,0x33,0x01,0x00,0x00,0x00,0x00,
+	0x32,0x33,0x33,0x33,0x23,0x00,0x00,0x10,
+	0x33,0x33,0x02,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x31,
+	0x33,0x33,0x23,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x33,0x33,0x33,0x13,0x00,0x00,0x00,
+	0x22,0x02,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x31,
+	0x33,0x33,0x01,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x32,0x33,0x33,0x33,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x31,
+	0x33,0x33,0x02,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x30,0x33,0x33,0x33,0x02,0x00,0x20,
+	0x11,0x01,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x20,0x11,0x11,0x11,0x02,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x31,
+	0x33,0x33,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x10,0x33,0x33,0x33,0x01,0x00,0x31,
+	0x33,0x33,0x02,0x00,0x00,0x00,0x00,0x00,
+	0x12,0x33,0x33,0x33,0x33,0x33,0x21,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x31,
+	0x33,0x33,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x10,0x33,0x33,0x33,0x01,0x20,0x33,
+	0x33,0x33,0x23,0x00,0x00,0x00,0x00,0x32,
+	0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x23,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x31,
+	0x33,0x33,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x10,0x33,0x33,0x33,0x01,0x10,0x33,
+	0x33,0x33,0x13,0x00,0x00,0x00,0x10,0x33,
+	0x33,0x33,0x13,0x21,0x11,0x33,0x33,0x33,
+	0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x31,
+	0x33,0x33,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x10,0x33,0x33,0x33,0x01,0x20,0x33,
+	0x33,0x33,0x13,0x00,0x00,0x00,0x31,0x33,
+	0x33,0x33,0x02,0x00,0x00,0x30,0x33,0x33,
+	0x23,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x31,
+	0x33,0x33,0x02,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x30,0x33,0x33,0x33,0x02,0x00,0x33,
+	0x33,0x33,0x13,0x00,0x00,0x10,0x33,0x33,
+	0x33,0x03,0x00,0x00,0x00,0x00,0x31,0x33,
+	0x33,0x02,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x31,
+	0x33,0x33,0x03,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x31,0x33,0x33,0x33,0x00,0x00,0x30,
+	0x33,0x33,0x13,0x00,0x00,0x30,0x33,0x33,
+	0x33,0x02,0x00,0x00,0x00,0x00,0x30,0x33,
+	0x33,0x03,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x31,
+	0x33,0x33,0x13,0x00,0x00,0x00,0x00,0x00,
+	0x20,0x33,0x33,0x33,0x13,0x00,0x00,0x30,
+	0x33,0x33,0x13,0x00,0x00,0x31,0x33,0x33,
+	0x13,0x00,0x00,0x00,0x00,0x00,0x10,0x33,
+	0x33,0x23,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x31,
+	0x33,0x33,0x33,0x01,0x00,0x00,0x00,0x00,
+	0x32,0x33,0x33,0x33,0x03,0x00,0x00,0x30,
+	0x33,0x33,0x13,0x00,0x00,0x33,0x33,0x33,
+	0x23,0x00,0x00,0x00,0x00,0x00,0x00,0x33,
+	0x33,0x13,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x31,
+	0x33,0x33,0x33,0x13,0x02,0x00,0x00,0x12,
+	0x33,0x33,0x33,0x33,0x02,0x00,0x00,0x30,
+	0x33,0x33,0x13,0x00,0x20,0x33,0x33,0x33,
+	0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x33,
+	0x33,0x33,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x31,
+	0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
+	0x33,0x33,0x33,0x23,0x00,0x00,0x00,0x30,
+	0x33,0x33,0x13,0x00,0x20,0x33,0x33,0x33,
+	0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x31,
+	0x33,0x33,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x31,
+	0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
+	0x33,0x33,0x33,0x02,0x00,0x00,0x00,0x30,
+	0x33,0x33,0x13,0x00,0x20,0x33,0x33,0x33,
+	0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x31,
+	0x33,0x33,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x31,
+	0x33,0x33,0x21,0x33,0x33,0x33,0x33,0x33,
+	0x33,0x33,0x01,0x00,0x00,0x00,0x00,0x30,
+	0x33,0x33,0x13,0x00,0x20,0x33,0x33,0x33,
+	0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x31,
+	0x33,0x33,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x31,
+	0x33,0x33,0x01,0x32,0x33,0x33,0x33,0x33,
+	0x11,0x02,0x00,0x00,0x00,0x00,0x00,0x30,
+	0x33,0x33,0x13,0x00,0x20,0x33,0x33,0x33,
+	0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x33,
+	0x33,0x33,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x31,
+	0x33,0x33,0x01,0x00,0x31,0x33,0x33,0x33,
+	0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x30,
+	0x33,0x33,0x13,0x00,0x00,0x33,0x33,0x33,
+	0x23,0x00,0x00,0x00,0x00,0x00,0x00,0x33,
+	0x33,0x33,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x31,
+	0x33,0x33,0x01,0x00,0x10,0x33,0x33,0x33,
+	0x33,0x02,0x00,0x00,0x00,0x00,0x00,0x30,
+	0x33,0x33,0x13,0x00,0x00,0x33,0x33,0x33,
+	0x13,0x00,0x00,0x00,0x00,0x00,0x20,0x33,
+	0x33,0x13,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x31,
+	0x33,0x33,0x01,0x00,0x00,0x31,0x33,0x33,
+	0x33,0x23,0x00,0x00,0x00,0x00,0x00,0x30,
+	0x33,0x33,0x13,0x00,0x00,0x31,0x33,0x33,
+	0x33,0x00,0x00,0x00,0x00,0x00,0x30,0x33,
+	0x33,0x23,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x31,
+	0x33,0x33,0x01,0x00,0x00,0x20,0x33,0x33,
+	0x33,0x33,0x01,0x00,0x00,0x00,0x00,0x30,
+	0x33,0x33,0x13,0x00,0x00,0x30,0x33,0x33,
+	0x33,0x01,0x00,0x00,0x00,0x00,0x31,0x33,
+	0x33,0x01,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x31,
+	0x33,0x33,0x01,0x00,0x00,0x00,0x32,0x33,
+	0x33,0x33,0x13,0x00,0x00,0x00,0x00,0x30,
+	0x33,0x33,0x13,0x00,0x00,0x20,0x33,0x33,
+	0x33,0x13,0x00,0x00,0x00,0x10,0x33,0x33,
+	0x33,0x02,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x31,
+	0x33,0x33,0x01,0x00,0x00,0x00,0x00,0x33,
+	0x33,0x33,0x33,0x01,0x00,0x00,0x00,0x30,
+	0x33,0x33,0x13,0x00,0x00,0x00,0x31,0x33,
+	0x33,0x33,0x21,0x00,0x20,0x31,0x33,0x33,
+	0x23,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x31,
+	0x33,0x33,0x01,0x00,0x00,0x00,0x00,0x10,
+	0x33,0x33,0x33,0x33,0x00,0x00,0x00,0x30,
+	0x33,0x33,0x13,0x00,0x00,0x00,0x10,0x33,
+	0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
+	0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x31,
+	0x33,0x33,0x01,0x00,0x00,0x00,0x00,0x00,
+	0x31,0x33,0x33,0x33,0x23,0x00,0x00,0x30,
+	0x33,0x33,0x13,0x00,0x00,0x00,0x00,0x12,
+	0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x01,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x12,
+	0x11,0x11,0x02,0x00,0x00,0x00,0x00,0x00,
+	0x20,0x11,0x11,0x11,0x11,0x00,0x00,0x10,
+	0x11,0x11,0x21,0x00,0x00,0x00,0x00,0x00,
+	0x12,0x33,0x33,0x33,0x33,0x13,0x01,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+};
Index: empeg/kernel/arch/i386/boot/bbootsect
Index: empeg/kernel/arch/i386/boot/bootsect
Index: empeg/kernel/arch/i386/boot/bsetup
Index: empeg/kernel/arch/i386/boot/bzImage
Index: empeg/kernel/arch/i386/boot/setup
Index: empeg/kernel/arch/i386/boot/zImage
Index: empeg/kernel/arch/i386/boot/compressed/bvmlinux
Index: empeg/kernel/arch/i386/boot/compressed/bvmlinux.out
Index: empeg/kernel/arch/i386/boot/compressed/vmlinux.out
Index: empeg/kernel/drivers/block/ide-probe.c
diff -u empeg/kernel/drivers/block/ide-probe.c:1.15.4.1 empeg/kernel/drivers/block/ide-probe.c:1.15.4.2
--- empeg/kernel/drivers/block/ide-probe.c:1.15.4.1	Mon Sep 11 12:30:56 2000
+++ empeg/kernel/drivers/block/ide-probe.c	Tue Dec 12 16:25:08 2000
@@ -881,9 +881,9 @@
 			}
 
 			/* If we've found a drive already, give us another
-			   second to find the secondary drive */
-			if (on_if0==1 && retries<19) {
-				retries=19;
+			   second and a bit to find the secondary drive */
+			if (on_if0==1 && retries<15) {
+				retries=15;
 			}
 		} while(on_if0<2 && retries<20);
 
Index: empeg/kernel/drivers/char/empeg_ir.c
diff -u empeg/kernel/drivers/char/empeg_ir.c:1.30.4.2 empeg/kernel/drivers/char/empeg_ir.c:1.30.4.3
--- empeg/kernel/drivers/char/empeg_ir.c:1.30.4.2	Mon Aug 28 15:16:19 2000
+++ empeg/kernel/drivers/char/empeg_ir.c	Mon Dec 18 16:26:28 2000
@@ -93,7 +93,7 @@
 #define IR_TYPE_DEFAULT IR_TYPE_KENWOOD
 
 /* Delay before repeating default */
-#define IR_RPTDELAY_DEFAULT MS_TO_JIFFIES(300) /* .3 seconds */
+#define IR_RPTDELAY_DEFAULT MS_TO_JIFFIES(200) /* .2 seconds */
 
 /* Delay between repeats default */
 #define IR_RPTINT_DEFAULT MS_TO_JIFFIES(100) /*.1 seconds */
@@ -218,6 +218,23 @@
 #endif
 }
 
+static inline int ir_code_repeatable(ir_code data)
+{
+	/* Is the code a repeatable one? */
+	data &= 0x7fffffff;
+	
+	if ((data < 0x2000) || (data > 0x2017))
+		return TRUE;
+	else if (data < 0x2010)
+		return FALSE;
+	else if (data == 0x2012)
+		return FALSE;
+	else if ((data >= 0x2014) && data <= 0x2016)
+		return FALSE;
+	else
+		return TRUE;
+}
+
 /* Append a repetition of the last data. This is only done if the
  * repetition is long enough after the initial button press and if the
  * last repetition was long enough ago.
@@ -233,6 +250,9 @@
 	unsigned long since_new_jiffies;
 	unsigned long since_repeat_jiffies;
 
+	if (!ir_code_repeatable(data))
+		return;
+	
 	if (dev->last_repeat_jiffies)
 		since_repeat_jiffies = now_jiffies - dev->last_repeat_jiffies;
 	else
Index: empeg/kernel/include/asm-arm/arch-sa1100/ide.h
diff -u empeg/kernel/include/asm-arm/arch-sa1100/ide.h:1.11 empeg/kernel/include/asm-arm/arch-sa1100/ide.h:1.11.4.1
--- empeg/kernel/include/asm-arm/arch-sa1100/ide.h:1.11	Mon Jul 17 15:55:16 2000
+++ empeg/kernel/include/asm-arm/arch-sa1100/ide.h	Tue Dec 19 19:50:58 2000
@@ -58,6 +58,7 @@
 	case 5:  /* flateric has only one IDE bus */
 	case 6: /* ...and marvin */
 	case 7: /* ...and trillian */
+	case 9: /* ...and seven (of 9) */
 	case 105: /* modela has only one IDE bus too */
 		printk("empeg single channel IDE\n");
 
@@ -69,6 +70,7 @@
 
 		ide_init_hwif_ports(&hw,0x00,0x0e,EMPEG_IRQ_IDE1);
 		ide_register_hw(&hw, NULL);
+
 		break;
 
 	case 4:  /* Sonja & Kate have two IDE ports */
Index: empeg/kernel/include/asm-arm/arch-sa1100/memory.h
diff -u empeg/kernel/include/asm-arm/arch-sa1100/memory.h:1.5 empeg/kernel/include/asm-arm/arch-sa1100/memory.h:1.5.8.2
--- empeg/kernel/include/asm-arm/arch-sa1100/memory.h:1.5	Sat Mar 18 16:45:58 2000
+++ empeg/kernel/include/asm-arm/arch-sa1100/memory.h	Tue Dec 19 19:42:06 2000
@@ -8,6 +8,8 @@
 #define __ASM_ARCH_MEMORY_H
 
 
+/* We use a dynamic system */
+
 /*
  * Task size: 3GB
  */
@@ -18,9 +20,9 @@
  */
 #define PAGE_OFFSET     (0xc0000000UL)
 
-
 #include <linux/config.h>
 
+#if !defined(CONFIG_SA1100_EMPEG)
 
 /* Number of bytes per bank */
 #if defined(CONFIG_SA1100_BRUTUS)
@@ -31,15 +33,6 @@
 #define RAM_IN_BANK_2  4*1024*1024
 #define RAM_IN_BANK_3  4*1024*1024
 
-#elif defined(CONFIG_SA1100_EMPEG)
-
-/* 8Mb in 2 banks in this case */
-/* But we support up to 16Mb in four banks */
-#define RAM_IN_BANK_0  4*1024*1024
-#define RAM_IN_BANK_1  4*1024*1024
-#define RAM_IN_BANK_2  4*1024*1024
-#define RAM_IN_BANK_3  4*1024*1024
-
 #elif defined(CONFIG_SA1100_LART)
 
 /* 16 MB per bank, 2 banks, but A23 is not connected. */
@@ -118,6 +111,33 @@
 #endif
 
 
+#else
+/* defined(CONFIG_SA1100_EMPEG) */
+
+/* empeg car has 8, 12 or 16MB arrangement
+   16MB arrangement is in 1 bank. 8 and 12 are in 4 banks of 4MB */
+
+/* macros are ugly. mm-sa1100.c uses code unless this is set */
+#define __virt_to_phys__is_a_macro
+#define __phys_to_virt__is_a_macro
+
+extern unsigned long empeg_virt_to_phys_mapping[4];
+extern unsigned long empeg_phys_to_virt_mapping[4];
+/* setup the tables */
+extern void empeg_setup_bank_mapping(int hw_rev);
+
+static inline unsigned long __virt_to_phys(unsigned long x)
+{
+	return empeg_virt_to_phys_mapping[(x >> 22) & 3] | (x & 0x003fffff);
+}
+
+static inline unsigned long __phys_to_virt(unsigned long x)
+{
+	return empeg_phys_to_virt_mapping[(x >> 27) & 3] | (x & 0x07ffffff);
+}
+
+#endif
+
 /*
  * Virtual view <-> DMA view memory address translations
  * virt_to_bus: Used to translate the virtual address to an
@@ -131,6 +151,5 @@
 #define __virt_to_bus(x)        __virt_to_phys(x)
 #define __bus_to_virt__is_a_macro
 #define __bus_to_virt(x)        __phys_to_virt(x)
-
 
 #endif
